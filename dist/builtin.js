var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"C_STRING.e","content":"note\n  description: \"A low-level string class to solve some garbage %\n    %collector problems (mainly objects moving around) when %\n    %interfacing with C APIs.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-20 16:35:07 -0800 (Sun, 20 Jan 2013) $\"\n  revision: \"$Revision: 92128 $\"\n\nclass\n  C_STRING\n\ninherit\n  STRING_HANDLER\n\ncreate\n  make,\n  make_empty,\n  make_by_pointer,\n  make_by_pointer_and_count,\n  make_shared_from_pointer,\n  make_shared_from_pointer_and_count,\n  own_from_pointer,\n  own_from_pointer_and_count\n\nfeature {NONE} -- Initialization\n\n  make (a_string: READABLE_STRING_GENERAL)\n      -- Make a C string from `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      a_string_is_valid_as_string_8: a_string.is_valid_as_string_8\n    do\n      make_empty (a_string.count)\n      set_string (a_string)\n    end\n\n  make_empty (a_length: INTEGER)\n      -- Make an empty C string of `a_length' characters.\n      -- C memory area is not initialized.\n    require\n      a_length_positive: a_length >= 0\n    do\n      create managed_data.make (a_length + 1)\n      count := 0\n    end\n\n  make_by_pointer (a_ptr: POINTER)\n      -- Make a copy of string pointed by `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      make_by_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  make_by_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- Make a copy of first `a_length' byte of string pointed by `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      create managed_data.make ((a_length + 1))\n      managed_data.item.memory_copy (a_ptr, a_length)\n    end\n\n  make_shared_from_pointer (a_ptr: POINTER)\n      -- New instance sharing `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      make_shared_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  make_shared_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- New instance sharing `a_ptr' of `a_length' byte.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      create managed_data.share_from_pointer (a_ptr, a_length + 1)\n    end\n\n  own_from_pointer (a_ptr: POINTER)\n      -- New instance using `a_ptr' as memory. Current will free pointed memory\n      -- by `a_ptr' when collected.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      own_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  own_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- New instance using `a_ptr' as memory. Current will free pointed memory\n      -- by `a_ptr' when collected.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      create managed_data.own_from_pointer (a_ptr, a_length)\n    end\n\nfeature -- Initialization\n\n  set_shared_from_pointer (a_ptr: POINTER)\n      -- Share `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      set_shared_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  set_shared_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- Share `a_ptr' of `a_length' byte.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      if not managed_data.is_shared then\n        create managed_data.share_from_pointer (a_ptr, a_length + 1)\n      else\n        managed_data.set_from_pointer (a_ptr, a_length + 1)\n      end\n    end\n\n  share_from_pointer (a_ptr: POINTER)\n      -- New instance sharing `a_ptr'.\n    obsolete\n      \"Use `make_shared_from_pointer' to create object and `set_shared_from_pointer' to modify it.\"\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      set_shared_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  share_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- New instance sharing `a_ptr' of `a_length' byte.\n    obsolete\n      \"Use `make_shared_from_pointer_and_count' to create object and `set_shared_from_pointer_and_count' to modify it.\"\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      set_shared_from_pointer_and_count (a_ptr, a_length)\n    end\n\nfeature -- Access\n\n  substring (start_pos, end_pos: INTEGER): STRING\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos'.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      create Result.make (l_count)\n      Result.set_count (l_count)\n      read_substring_into (Result, start_pos, end_pos)\n    ensure\n      susbstring_not_void: Result /= Void\n    end\n\n  string: STRING\n      -- Eiffel string, ignoring `count'. Reads until a null character is being read.\n    do\n      Result := substring (1, c_strlen (item))\n    ensure\n      string_not_void: Result /= Void\n    end\n\n  copy_to_string (a_string: STRING_GENERAL; source_index, destination_index, n: INTEGER)\n      -- Copy `n' characters of `Current' from `source_index' position to `a_string' at\n      -- `destination_index'. Other characters of `a_string' remain unchanged.\n    require\n      a_string_not_void: a_string /= Void\n      source_index_positive: source_index >= 1\n      destination_index_positive: destination_index >= 1\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + (n - 1) <= capacity\n      n_is_small_enough_for_destination: destination_index + (n - 1) <= a_string.count\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := source_index - 1\n        j := destination_index\n        nb := source_index + (n - 1)\n        l_data := managed_data\n      until\n        i = nb\n      loop\n        a_string.put_code (l_data.read_natural_8 (i), j)\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  read_substring_into (a_string: STRING_GENERAL; start_pos, end_pos: INTEGER)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n      a_string_large_enough: a_string.count >= end_pos - start_pos + 1\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_pos - 1\n        nb := end_pos - start_pos\n        l_data := managed_data\n        j := 1\n      until\n        i > nb\n      loop\n        a_string.put_code (l_data.read_natural_8 (i), j)\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  read_string_into (a_string: STRING_GENERAL)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_string' replacing any\n      -- existing characters.\n    require\n      a_string_not_void: a_string /= Void\n      a_string_large_enough: a_string.count >= count\n    do\n      read_substring_into (a_string, 1, count)\n    end\n\n  read_substring_into_character_8_area (a_area: SPECIAL [CHARACTER_8]; start_pos, end_pos: INTEGER)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_area'.\n    require\n      a_area_not_void: a_area /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n      a_area_large_enough: a_area.count >= end_pos - start_pos + 1\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_pos - 1\n        nb := end_pos - start_pos\n        l_data := managed_data\n      until\n        i > nb\n      loop\n        a_area.put (l_data.read_natural_8 (i).to_character_8, j)\n        i := i + 1\n        j := j + 1\n      end\n    ensure\n      copied: -- for i in 0..end_pos - start_pos, a_area [i] = Current [i + start_pos]\n    end\n\n  read_substring_into_character_32_area (a_area: SPECIAL [CHARACTER_32]; start_pos, end_pos: INTEGER)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_area'.\n    require\n      a_area_not_void: a_area /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n      a_area_large_enough: a_area.count >= end_pos - start_pos + 1\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_pos - 1\n        nb := end_pos - start_pos\n        l_data := managed_data\n      until\n        i > nb\n      loop\n        a_area.put (l_data.read_natural_8 (i).to_character_32, j)\n        i := i + 1\n        j := j + 1\n      end\n    ensure\n      copied: -- for i in 0..end_pos - start_pos, a_area [i] = Current [i + start_pos]\n    end\n\n  item: POINTER\n      -- Get pointer to allocated area.\n    do\n      Result := managed_data.item\n    ensure\n      item_not_null: Result /= default_pointer\n    end\n\n  managed_data: MANAGED_POINTER\n      -- Hold data of Current.\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Number of characters in Current.\n    do\n      Result := managed_data.count\n    end\n\n  bytes_count: INTEGER\n      -- Number of bytes represented by the string.\n    do\n      Result := count\n    end\n\n  count: INTEGER\n      -- Number of characters in Current.\n\n  character_size: INTEGER = 1\n      -- Size of a character\n\nfeature -- Element change\n\n  set_string (a_string: READABLE_STRING_GENERAL)\n      -- Set `string' with `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      a_string_is_string_8: a_string.is_valid_as_string_8\n    do\n      set_substring (a_string, 1, a_string.count)\n    end\n\n  set_substring (a_string: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER)\n      -- Set `string' with `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= a_string.count\n    local\n      i, nb: INTEGER\n      new_size: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      count := nb\n\n      new_size := nb + 1\n\n      if managed_data.count < new_size  then\n        managed_data.resize (new_size)\n      end\n\n      from\n        i := 0\n      until\n        i = nb\n      loop\n        managed_data.put_natural_8 (a_string.code (i + start_pos).to_natural_8, i)\n        i := i +  1\n      end\n      managed_data.put_natural_8 (0, nb)\n    end\n\n  set_count (a_count: INTEGER)\n      -- Set `count' with `a_count'.\n      -- Note: Current content from index `1' to\n      -- `count.min (a_count)' is unchanged.\n    require\n      a_count_non_negative: a_count >= 0\n    local\n      new_size: INTEGER\n    do\n      new_size := a_count + 1\n      if managed_data.count < new_size then\n        managed_data.resize (new_size)\n      end\n      count := a_count\n    ensure\n      count_set: count = a_count\n    end\n\n  fill_blank\n      -- Fill Current with zeros.\n    do\n      fill_value (0)\n    ensure\n      -- all_values: For every `i' in 1..`count', `item' (`i') = `0'\n    end\n\n  fill_value (a_value: INTEGER_8)\n      -- Fill Current with `a_value'.\n    do\n      managed_data.item.memory_set (a_value, managed_data.count)\n    ensure\n      -- all_values: For every `i' in 1..`count', `item' (`i') = `a_value'\n    end\n\nfeature {NONE} -- Implementation\n\n  c_strlen (ptr: POINTER): INTEGER\n    external\n      \"C signature (char *): EIF_INTEGER use <string.h>\"\n    alias\n      \"strlen\"\n    end\n\ninvariant\n  managed_data_not_void: managed_data /= Void\n  count_not_negative: count >= 0\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"abstract_special.e","content":"note\n  description: \"Ancestor of SPECIAL to perform queries on SPECIAL without knowing its actual generic type.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-04-12 16:54:50 -0700 (Fri, 12 Apr 2013) $\"\n  revision: \"$Revision: 92440 $\"\n\ndeferred class\n  ABSTRACT_SPECIAL\n\ninherit\n  DEBUG_OUTPUT\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Count of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    deferred\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      create Result.make (12)\n      Result.append_string (\"count=\")\n      Result.append_integer (count)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"active.e","content":"note\n  description: \"[\n    ``Active'' data structures, which at every stage have\n    a possibly undefined ``current item''.\n    Basic access and modification operations apply to the current item.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: active, access\n  access: membership\n  contents: generic\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class ACTIVE [G] inherit\n\n  BAG [G]\n\nfeature -- Access\n\n  item: G\n      -- Current item\n    require\n      readable: readable\n    deferred\n    end\n\nfeature -- Status report\n\n  readable: BOOLEAN\n      -- Is there a current item that may be read?\n    deferred\n    end\n\n  writable: BOOLEAN\n      -- Is there a current item that may be modified?\n    deferred\n    end\n\n  replaceable: BOOLEAN\n      -- Can current item be replaced?\n    do\n      Result := True\n    end\n\nfeature -- Element change\n\n  replace (v: G)\n      -- Replace current item by `v'.\n    require\n      writable: writable\n      replaceable: replaceable\n    deferred\n    ensure\n      item_replaced: item = v\n    end\n\nfeature -- Removal\n\n  remove\n      -- Remove current item.\n    require\n      prunable: prunable\n      writable: writable\n    deferred\n    end\n\ninvariant\n\n  writable_constraint: writable implies readable\n  empty_constraint: is_empty implies (not readable) and (not writable)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"any.e","content":"note\n  description: \"[\n    Project-wide universal properties.\n    This class is an ancestor to all developer-written classes.\n    ANY may be customized for individual projects or teams.\n    ]\"\n\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 11:49:00 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92134 $\"\n\nclass\n  ANY\n\nfeature -- Customization\n\nfeature -- Access\n\n  generator: STRING\n      -- Name of current object's generating class\n      -- (base class of the type of which it is a direct instance)\n    external\n      \"built_in\"\n    ensure\n      generator_not_void: Result /= Void\n      generator_not_empty: not Result.is_empty\n    end\n\n  generating_type: TYPE [detachable like Current]\n      -- Type of current object\n      -- (type of which it is a direct instance)\n    do\n      Result := {detachable like Current}\n    ensure\n      generating_type_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Duplication\n\n  frozen twin: like Current\n      -- New object equal to `Current'\n      -- `twin' calls `copy'; to change copying/twinning semantics, redefine `copy'.\n    external\n      \"built_in\"\n    ensure\n      twin_not_void: Result /= Void\n      is_equal: Result ~ Current\n    end\n\n  copy (other: like Current)\n      -- Update current object using fields of object attached\n      -- to `other', so as to yield equal objects.\n    require\n      other_not_void: other /= Void\n      type_identity: same_type (other)\n    external\n      \"built_in\"\n    ensure\n      is_equal: Current ~ other\n    end\n\n  frozen standard_copy (other: like Current)\n      -- Copy every field of `other' onto corresponding field\n      -- of current object.\n    require\n      other_not_void: other /= Void\n      type_identity: same_type (other)\n    external\n      \"built_in\"\n    ensure\n      is_standard_equal: standard_is_equal (other)\n    end\n\n  frozen clone (other: detachable ANY): like other\n      -- Void if `other' is void; otherwise new object\n      -- equal to `other'\n      --\n      -- For non-void `other', `clone' calls `copy';\n      -- to change copying/cloning semantics, redefine `copy'.\n    obsolete\n      \"Use `twin' instead.\"\n    do\n      if other /= Void then\n        Result := other.twin\n      end\n    ensure\n      equal: Result ~ other\n    end\n\n  frozen standard_clone (other: detachable ANY): like other\n      -- Void if `other' is void; otherwise new object\n      -- field-by-field identical to `other'.\n      -- Always uses default copying semantics.\n    obsolete\n      \"Use `standard_twin' instead.\"\n    do\n      if other /= Void then\n        Result := other.standard_twin\n      end\n    ensure\n      equal: standard_equal (Result, other)\n    end\n\n  frozen standard_twin: like Current\n      -- New object field-by-field identical to `other'.\n      -- Always uses default copying semantics.\n    external\n      \"built_in\"\n    ensure\n      standard_twin_not_void: Result /= Void\n      equal: standard_equal (Result, Current)\n    end\n\n  frozen deep_twin: like Current\n      -- New object structure recursively duplicated from Current.\n    external\n      \"built_in\"\n    ensure\n      deep_twin_not_void: Result /= Void\n      deep_equal: deep_equal (Current, Result)\n    end\n\n  frozen deep_clone (other: detachable ANY): like other\n      -- Void if `other' is void: otherwise, new object structure\n      -- recursively duplicated from the one attached to `other'\n    obsolete\n      \"Use `deep_twin' instead.\"\n    do\n      if other /= Void then\n        Result := other.deep_twin\n      end\n    ensure\n      deep_equal: deep_equal (other, Result)\n    end\n\n  frozen deep_copy (other: like Current)\n      -- Effect equivalent to that of:\n      --    `copy' (`other' . `deep_twin')\n    require\n      other_not_void: other /= Void\n    do\n      copy (other.deep_twin)\n    ensure\n      deep_equal: deep_equal (Current, other)\n    end\n\nfeature {NONE} -- Retrieval\n\n  frozen internal_correct_mismatch\n      -- Called from runtime to perform a proper dynamic dispatch on `correct_mismatch'\n      -- from MISMATCH_CORRECTOR.\n    local\n      l_msg: STRING\n      l_exc: EXCEPTIONS\n    do\n      if attached {MISMATCH_CORRECTOR} Current as l_corrector then\n        l_corrector.correct_mismatch\n      else\n        create l_msg.make_from_string (\"Mismatch: \")\n        create l_exc\n        l_msg.append (generating_type.name)\n        l_exc.raise_retrieval_exception (l_msg)\n      end\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    once\n      create Result\n      Result.set_output_default\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature -- Platform\n\n  Operating_environment: OPERATING_ENVIRONMENT\n      -- Objects available from the operating system\n    once\n      create Result\n    ensure\n      operating_environment_not_void: Result /= Void\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n\n  default_rescue\n      -- Process exception for routines with no Rescue clause.\n      -- (Default: do nothing.)\n    do\n    end\n\n  frozen do_nothing\n      -- Execute a null action.\n    do\n    end\n\n  frozen default: detachable like Current\n      -- Default value of object's type\n    do\n    end\n\n  frozen default_pointer: POINTER\n      -- Default value of type `POINTER'\n      -- (Avoid the need to write `p'.`default' for\n      -- some `p' of type `POINTER'.)\n    do\n    ensure\n      -- Result = Result.default\n    end\n\n  frozen as_attached: attached like Current\n      -- Attached version of Current\n      -- (Can be used during transitional period to convert\n      -- non-void-safe classes to void-safe ones.)\n    do\n      Result := Current\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"array.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 14:18:20 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92138 $\"\n\nclass ARRAY [G] inherit\n\n  RESIZABLE [G]\n    redefine\n      full, copy, is_equal, resizable\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as item alias \"[]\"\n    redefine\n      copy, is_equal\n    end\n\n  TO_SPECIAL [G]\n    export\n      {ARRAY} set_area\n    redefine\n      copy, is_equal, item, put, at, valid_index\n    end\n\ncreate\n  make_empty,\n  make,\n  make_filled,\n  make_from_array,\n  make_from_special,\n  make_from_cil\n\nconvert\n  to_cil: {NATIVE_ARRAY [G]},\n  to_special: {SPECIAL [G]},\n  make_from_cil ({NATIVE_ARRAY [G]})\n\nfeature -- Initialization\n\n  make_empty\n      -- Allocate empty array starting at `1'.\n    do\n      lower := 1\n      upper := 0\n      make_empty_area (0)\n    ensure\n      lower_set: lower = 1\n      upper_set: upper = 0\n      items_set: all_default\n    end\n\n  make_filled (a_default_value: G; min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    require\n      valid_bounds: min_index <= max_index + 1\n    local\n      n: INTEGER\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        n := max_index - min_index + 1\n      end\n      make_filled_area (a_default_value, n)\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: filled_with (a_default_value)\n    end\n\n  make (min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    obsolete\n      \" `make' is not void-safe statically. Use `make_empty' or `make_filled' instead. [07-2010]\"\n    require\n      valid_bounds: min_index <= max_index + 1\n      has_default: min_index <= max_index implies ({G}).has_default\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        make_filled_area (({G}).default, max_index - min_index + 1)\n      else\n        make_empty_area (0)\n      end\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: all_default\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Initialize from the items of `a'.\n      -- (Useful in proper descendants of class `ARRAY',\n      -- to initialize an array-like object from a manifest array.)\n    require\n      array_exists: a /= Void\n    do\n      set_area (a.area)\n      lower := a.lower\n      upper := a.upper\n    ensure\n      shared: area = a.area\n      lower_set: lower = a.lower\n      upper_set: upper = a.upper\n    end\n\n  make_from_special (a: SPECIAL [G])\n      -- Initialize Current from items of `a'.\n    require\n      special_attached: a /= Void\n    do\n      set_area (a)\n      lower := 1\n      upper := a.count\n    ensure\n      shared: area = a\n      lower_set: lower = 1\n      upper_set: upper = a.count\n    end\n\n  make_from_cil (na: NATIVE_ARRAY [like item])\n      -- Initialize array from `na'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      na_not_void: na /= Void\n    do\n      create area.make_from_native_array (na)\n      lower := 1\n      upper := area.count\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): G assign put\n      -- Entry at index `i', if in index interval\n    do\n      Result := area.item (i - lower)\n    end\n\n  entry (i: INTEGER): G\n      -- Entry at index `i', if in index interval\n    require\n      valid_key: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  has (v: G): BOOLEAN\n      -- Does `v' appear in array?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      l_area := area\n      nb := upper - lower\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) ~ v\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) = v\n          i := i + 1\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER\n      -- Minimum index\n\n  upper: INTEGER\n      -- Maximum index\n\n  count, capacity: INTEGER\n      -- Number of available indices\n    do\n      Result := upper - lower + 1\n    ensure then\n      consistent_with_bounds: Result = upper - lower + 1\n    end\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n    local\n      i: INTEGER\n    do\n      if object_comparison then\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) ~ v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      else\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) = v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    ensure then\n      same_count: Result.count = count\n      same_bounds:\n        ((Result.lower = lower) and (Result.upper = upper))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif lower = other.lower and then upper = other.upper and then\n        object_comparison = other.object_comparison\n      then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := item (i) ~ other.item (i)\n            i := i + 1\n          end\n        else\n          Result := area.same_items (other.area, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    do\n      if count > 0 then\n        Result := ({G}).has_default and then area.filled_with (({G}).default, 0, upper - lower)\n      else\n        Result := True\n      end\n    ensure\n      definition: Result = (count = 0 or else\n        ((not attached item (upper) as i or else i = ({G}).default) and\n        subarray (lower, upper - 1).all_default))\n    end\n\n  filled_with (v: G): BOOLEAN\n      -- Are all items set to `v'?\n    do\n      Result := area.filled_with (v, 0, upper - lower)\n    ensure\n      definition: Result = (count = 0 or else\n        (item (upper) = v and subarray (lower, upper - 1).filled_with (v)))\n    end\n\n  full: BOOLEAN\n      -- Is structure filled to capacity? (Answer: yes)\n    do\n      Result := True\n    end\n\n  same_items (other: like Current): BOOLEAN\n      -- Do `other' and Current have same items?\n    require\n      other_not_void: other /= Void\n    do\n      if count = other.count then\n        Result := area.same_items (other.area, 0, 0, count)\n      end\n    ensure\n      definition: Result = ((count = other.count) and then\n        (count = 0 or else (item (upper) = other.item (other.upper)\n        and subarray (lower, upper - 1).same_items\n        (other.subarray (other.lower, other.upper - 1)))))\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the array?\n    do\n      Result := (lower <= i) and then (i <= upper)\n    end\n\n  extendible: BOOLEAN\n      -- May items be added?\n      -- (Answer: no, although array may be resized.)\n    do\n      Result := False\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: no.)\n    do\n      Result := False\n    end\n\n  resizable: BOOLEAN\n      -- Can array be resized automatically?\n    do\n      Result := ({G}).has_default\n    end\n\n  valid_index_set: BOOLEAN\n    do\n      Result := index_set.count = count\n    end\n\nfeature -- Element change\n\n  put (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area.put (v, i - lower)\n    end\n\n  enter (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_key: valid_index (i)\n    do\n      area.put (v, i - lower)\n    end\n\n  force (v: like item; i: INTEGER)\n      -- Assign item `v' to `i'-th entry.\n      -- Resize the array if `i' falls out of currently defined bounds; preserve existing items.\n      -- In void-safe mode, if ({G}).has_default does not hold, then you can only insert between\n      -- `lower - 1' or `upper + 1' position in the ARRAY.\n    require\n      has_default_if_too_low:\n        (i < lower - 1 and lower /= {like lower}.min_value) implies ({G}).has_default\n      has_default_if_too_high:\n        (i > upper + 1 and upper /= {like upper}.max_value) implies ({G}).has_default\n    local\n      old_size, new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      l_count, l_offset: INTEGER\n      l_increased_by_one: BOOLEAN\n    do\n      new_lower := lower.min (i)\n      new_upper := upper.max (i)\n      new_size := new_upper - new_lower + 1\n      l_increased_by_one := (i = upper + 1) or (i = lower - 1)\n      if empty_area then\n          -- List is empty. First we create an empty SPECIAL of the right capacity.\n        make_empty_area (new_size.max (additional_space))\n        if not l_increased_by_one then\n            -- We need to fill the SPECIAL for `0' to `new_size - 2' with the default value.\n          area.fill_with (({G}).default, 0, new_size - 2)\n        end\n        area.extend (v)\n      else\n        old_size := area.capacity\n        if new_size > old_size then\n          set_area (area.aliased_resized_area (new_size.max (old_size + additional_space)))\n        end\n        if new_lower < lower then\n            -- We have inserted below the previous `lower'. We need to shift entries to the right\n            -- before we can insert `v'.\n          l_offset := lower - new_lower\n          l_count := capacity\n          if not l_increased_by_one and l_offset > l_count then\n              -- With the `new_lower' given, the data has to move\n              -- beyond the `area''s count which requires us to fill\n              -- the gap between the old data's location and the new one\n              -- with the default value.\n            area.fill_with (({G}).default, l_count, l_offset - 1)\n          end\n          area.move_data (0, l_offset, l_count)\n          if not l_increased_by_one then\n              -- We start at `1' and not `0' because next instruction\n              -- will update the item at position `0'.\n            area.fill_with (({G}).default, 1, l_offset - 1)\n          end\n            -- Insert `v' at the new lower position.\n          area.put (v, 0)\n        else\n          if new_size > area.count then\n              -- We are adding to the new `upper' position. First we fill the non-initialized\n              -- elements if any up to `new_size - 2' (i.e. up the the item prior to `upper').\n            if not l_increased_by_one then\n              area.fill_with (({G}).default, area.count, new_size - 2)\n            end\n              -- Add `v' at upper position.\n            area.extend (v)\n          else\n              -- Here `lower' hasn't changed\n            area.put (v, i - lower)\n          end\n        end\n      end\n      lower := new_lower\n      upper := new_upper\n    ensure\n      inserted: item (i) = v\n      higher_count: count >= old count\n      lower_set: lower = (old lower).min (i)\n      upper_set: upper = (old upper).max (i)\n    end\n\n  fill_with (v: G)\n      -- Set items between `lower' and `upper' with `v'.\n    do\n      area.fill_with (v, 0, upper - lower)\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = old count\n      filled: filled_with (v)\n    end\n\n  subcopy (other: ARRAY [like item]; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy items of `other' within bounds `start_pos' and `end_pos'\n      -- to current array starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: start_pos >= other.lower\n      valid_end_pos: end_pos <= other.upper\n      valid_bounds: start_pos <= end_pos + 1\n      valid_index_pos: index_pos >= lower\n      enough_space: (upper - index_pos) >= (end_pos - start_pos)\n    do\n      area.copy_data (other.area, start_pos - other.lower, index_pos - lower, end_pos - start_pos + 1)\n    ensure\n      -- copied: forall `i' in 0 .. (`end_pos'-`start_pos'),\n      --     item (index_pos + i) = other.item (start_pos + i)\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    do\n      area.do_all_in_bounds (action, 0, count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    do\n      area.do_if_in_bounds (action, test, 0, count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.there_exists_in_bounds (test, 0, count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.for_all_in_bounds (test, 0, count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Removal\n\n  wipe_out\n      -- Make array empty.\n    obsolete\n      \"Not applicable since not `prunable'. Use `discard_items' instead.\"\n    do\n      discard_items\n    end\n\n  discard_items\n      -- Reset all items to default values with reallocation.\n    require\n      has_default: ({G}).has_default\n    do\n      create area.make_filled (({G}).default, capacity)\n    ensure\n      default_items: all_default\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    require\n      has_default: ({G}).has_default\n    do\n      area.fill_with (({G}).default, 0, area.count - 1)\n    ensure\n      stable_lower: lower = old lower\n      stable_upper: upper = old upper\n      default_items: all_default\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all items except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    do\n      if n < count then\n        upper := lower + n - 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_lower: lower = old lower\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all items except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        lower := upper - n + 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_upper: upper = old upper\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_upper: upper = old upper\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_head (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_lower: lower = old lower\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > capacity then\n        conservative_resize_with_default (({G}).default, lower, upper + i - capacity)\n      end\n    end\n\n  conservative_resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \" `conservative_resize' is not void-safe statically. Use `conservative_resize_with_default' instead. [07-2010]\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  conservative_resize_with_default (a_default_value: G; min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    require\n      good_indices: min_index <= max_index\n    local\n      new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      offset: INTEGER\n    do\n      if empty_area then\n        set_area (area.aliased_resized_area_with_default (a_default_value, max_index - min_index + 1))\n        lower := min_index\n        upper := max_index\n      else\n        new_lower := min_index.min (lower)\n        new_upper := max_index.max (upper)\n        new_size := new_upper - new_lower + 1\n        if new_size > area.count then\n          set_area (area.aliased_resized_area_with_default (a_default_value, new_size))\n        end\n        if new_lower < lower then\n          offset := lower - new_lower\n          area.move_data (0, offset, upper - lower + 1)\n          area.fill_with (a_default_value, 0, offset - 1)\n        end\n        lower := new_lower\n        upper := new_upper\n      end\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \"Use `conservative_resize_with_default' instead as future versions will implement `resize' as specified in ELKS.\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area.capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: same_items (old twin)\n    end\n\n  rebase (a_lower: like lower)\n      -- Without changing the actual content of `Current' we set `lower' to `a_lower'\n      -- and `upper' accordingly to `a_lower + count - 1'.\n    local\n      l_old_lower: like lower\n    do\n      l_old_lower := lower\n      lower := a_lower\n      upper := a_lower + (upper - l_old_lower)\n    ensure\n      lower_set: lower = a_lower\n      upper_set: upper = a_lower + old count - 1\n    end\n\nfeature -- Conversion\n\n  to_c: ANY\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    do\n      Result := area\n    end\n\n  to_cil: NATIVE_ARRAY [G]\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := area.native_array\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_special: SPECIAL [G]\n      -- 'area'.\n    do\n      Result := area\n    ensure\n      to_special_not_void: Result /= Void\n    end\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [G]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := lower\n      until\n        i > upper\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area.twin)\n      end\n    ensure then\n      equal_areas: area ~ other.area\n    end\n\n  subarray (start_pos, end_pos: INTEGER): ARRAY [G]\n      -- Array made of items of current array within\n      -- bounds `start_pos' and `end_pos'.\n    require\n      valid_start_pos: valid_index (start_pos)\n      valid_end_pos: end_pos <= upper\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n    do\n      if start_pos <= end_pos then\n        create Result.make_filled (item (start_pos), start_pos, end_pos)\n          -- Only copy elements if needed.\n        Result.subcopy (Current, start_pos, end_pos, start_pos)\n      else\n          -- make empty\n        create Result.make_empty\n        Result.rebase (start_pos)\n      end\n    ensure\n      lower: Result.lower = start_pos\n      upper: Result.upper = end_pos\n      -- copied: forall `i' in `start_pos' .. `end_pos',\n      --     Result.item (i) = item (i)\n    end\n\nfeature {NONE} -- Inapplicable\n\n  prune (v: G)\n      -- Remove first occurrence of `v' if any.\n      -- (Precondition is False.)\n    do\n    end\n\n  extend (v: G)\n      -- Add `v' to structure.\n      -- (Precondition is False.)\n    do\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: BOOLEAN\n      -- Is `area' empty?\n    do\n      Result := area = Void or else area.capacity = 0\n    end\n\ninvariant\n\n  area_exists: area /= Void\n  consistent_size: capacity = upper - lower + 1\n  non_negative_count: count >= 0\n  index_set_has_same_count: valid_index_set\n-- Internal discussion haven't reached an agreement on this invariant\n--  index_set_has_same_bounds: ((index_set.lower = lower) and\n--        (index_set.upper = lower + count - 1))\n\nend\n"});
__eiffel_builtin.push({"filename":"arrayed_list.e","content":"note\n  description: \"Lists implemented by resizable arrays\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: sequence;\n  representation: array;\n  access: index, cursor, membership;\n  size: fixed;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass ARRAYED_LIST [G] inherit\n\n  TO_SPECIAL [G]\n    rename\n      put as array_put,\n      at as array_at,\n      item as array_item,\n      valid_index as array_valid_index,\n      area as area_v2\n    redefine\n      is_equal, copy\n    end\n\n  RESIZABLE [G]\n    redefine\n      is_equal, copy\n    end\n\n  DYNAMIC_LIST [G]\n    undefine\n      put_i_th,\n      force, is_inserted, copy\n    redefine\n      first, last, swap, wipe_out, i_th, at,\n      go_i_th, move, prunable, start, finish,\n      count, prune, remove,\n      put_left, merge_left,\n      merge_right, duplicate, prune_all, has, search,\n      append, valid_index, is_equal, copy,\n      for_all, there_exists, do_all, do_if\n    end\n\n  MISMATCH_CORRECTOR\n    redefine\n      is_equal, copy, correct_mismatch\n    end\n\ncreate\n  make, make_filled, make_from_array\n\nfeature -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate list with `n' items.\n      -- (`n' may be zero for empty list.)\n    require\n      valid_number_of_items: n >= 0\n    do\n      index := 0\n      create area_v2.make_empty (n)\n    ensure\n      correct_position: before\n      is_empty: is_empty\n    end\n\n  make_filled (n: INTEGER)\n      -- Allocate list with `n' items.\n      -- (`n' may be zero for empty list.)\n      -- This list will be full.\n    require\n      valid_number_of_items: n >= 0\n      has_default: ({G}).has_default\n    do\n      index := 0\n      make_filled_area (({G}).default, n)\n    ensure\n      correct_position: before\n      filled: full\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Create list from array `a'.\n    require\n      array_exists: a /= Void\n    do\n      index := 0\n      area_v2 := a.area\n    ensure\n      shared: area = a.area\n      correct_position: before\n      filled: count = a.count\n    end\n\nfeature -- Access\n\n  area: SPECIAL [G]\n      -- Access to internal storage of ARRAYED_LIST\n    do\n        -- Internal storage is called `area_v2' so that it triggers\n        -- a mismatch during retrieval.\n      Result := area_v2\n    end\n\n  item: G\n      -- Current item\n    require else\n      index_is_valid: valid_index (index)\n    do\n      Result := area_v2.item (index - 1)\n    end\n\n  i_th alias \"[]\", at alias \"@\" (i: INTEGER): like item assign put_i_th\n      -- Item at `i'-th position\n    do\n      Result := area_v2.item (i - 1)\n    end\n\n  first: like item\n      -- Item at first position\n    do\n      Result := area_v2.item (0)\n    end\n\n  last: like first\n      -- Item at last position\n    do\n      Result := area_v2.item (count - 1)\n    end\n\n  index: INTEGER\n      -- Index of `item', if valid.\n\n  cursor: ARRAYED_LIST_CURSOR\n      -- Current cursor position\n    do\n      create Result.make (index)\n    end\n\n  has (v: like item): BOOLEAN\n      -- Does current include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      l_area: like area_v2\n      i, nb: INTEGER\n    do\n      l_area := area_v2\n      nb := count - 1\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := v ~ l_area.item (i)\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := v = l_area.item (i)\n          i := i + 1\n        end\n      end\n    end\n\n  to_array: ARRAY [G]\n      -- Share content to be used as an ARRAY.\n      -- Note that although the content is shared, it might\n      -- not be shared when a resizing occur in either ARRAY or Current.\n    do\n      create Result.make_from_special (area_v2)\n    ensure\n      to_array_attached: Result /= Void\n      array_lower_set: Result.lower = 1\n      array_upper_set: Result.upper = count\n      shared_area: Result.area = area\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    do\n      area_v2.do_all_in_bounds (action, 0, area_v2.count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    do\n      area_v2.do_if_in_bounds (action, test, 0, area_v2.count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    do\n      Result := area_v2.there_exists_in_bounds (test, 0, area_v2.count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    do\n      Result := area_v2.for_all_in_bounds (test, 0, area_v2.count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, j, nb: INTEGER\n      l_area: like area_v2\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area_v2\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, j, nb: INTEGER\n      l_area: like area_v2\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area_v2\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER = 1\n      -- Lower bound for accessing list items via indexes\n\n  upper: INTEGER\n      -- Upper bound for accessing list items via indexes\n    do\n      Result := area_v2.count\n    end\n\n  count: INTEGER\n      -- Number of items\n    do\n      Result := area_v2.count\n    end\n\n  capacity: INTEGER\n    do\n      Result := area_v2.capacity\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif count = other.count and then object_comparison = other.object_comparison then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := i_th (i) ~ other.i_th (i)\n            i := i + 1\n          end\n        else\n          Result := area_v2.same_items (other.area_v2, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  valid_cursor (p: CURSOR): BOOLEAN\n      -- Can the cursor be moved to position `p'?\n    do\n      if attached {ARRAYED_LIST_CURSOR} p as al_c then\n        Result := valid_cursor_index (al_c.index)\n      end\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' a valid index?\n    do\n      Result := (1 <= i) and (i <= count)\n    end\n\n  is_inserted (v: G): BOOLEAN\n      -- Has `v' been inserted at the end by the most recent `put' or\n      -- `extend'?\n    do\n      if not is_empty then\n        Result := (v = last) or else (not off and then (v = item))\n      end\n    end\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    require\n      has_default: ({G}).has_default\n    do\n      Result := area_v2.filled_with (({G}).default, 0, area_v2.upper)\n    end\n\nfeature -- Cursor movement\n\n  move (i: INTEGER)\n      -- Move cursor `i' positions.\n    do\n      index := index + i\n      if (index > count + 1) then\n        index := count + 1\n      elseif (index < 0) then\n        index := 0\n      end\n    end\n\n  start\n      -- Move cursor to first position if any.\n    do\n      index := 1\n    ensure then\n      after_when_empty: is_empty implies after\n    end\n\n  finish\n      -- Move cursor to last position if any.\n    do\n      index := count\n    ensure then\n      before_when_empty: is_empty implies before\n    end\n\n  forth\n      -- Move cursor one position forward.\n    do\n      index := index + 1\n    end\n\n  back\n      -- Move cursor one position backward.\n    do\n      index := index - 1\n    end\n\n  go_i_th (i: INTEGER)\n      -- Move cursor to `i'-th position.\n    do\n      index := i\n    end\n\n  go_to (p: CURSOR)\n      -- Move cursor to position `p'.\n    do\n      if attached {ARRAYED_LIST_CURSOR} p as al_c then\n        index := al_c.index\n      else\n        check\n          correct_cursor_type: False\n        end\n      end\n    end\n\n  search (v: like item)\n      -- Move to first position (at or after current\n      -- position) where `item' and `v' are equal.\n      -- If structure does not include `v' ensure that\n      -- `exhausted' will be true.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      l_area: like area_v2\n      i, nb: INTEGER\n      l_found: BOOLEAN\n    do\n      l_area := area_v2\n      nb := count - 1\n        -- If we are before we need to be sure\n        -- that i is positive.\n      i := (index - 1).max (0)\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or l_found\n        loop\n          l_found := v ~ l_area.item (i)\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or l_found\n        loop\n          l_found := v = l_area.item (i)\n          i := i + 1\n        end\n      end\n        -- Set position of `index' to `i', location of item when\n        -- found, otherwise to `i + 1' which corresponds to `after'.\n      if l_found then\n        index := i\n      else\n        index := i + 1\n      end\n    end\n\nfeature -- Element change\n\n  put_front (v: like item)\n      -- Add `v' to the beginning.\n      -- Do not move cursor.\n    do\n      if is_empty then\n        extend (v)\n      else\n        insert (v, 1)\n      end\n      index := index + 1\n    end\n\n  put_i_th (v: like i_th; i: INTEGER_32)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area_v2.put (v, i - 1)\n    end\n\n  force, extend (v: like item)\n      -- Add `v' to end.\n      -- Do not move cursor.\n    local\n      i: INTEGER\n      l_area: like area_v2\n    do\n      i := count + 1\n      l_area := area_v2\n      if i > l_area.capacity then\n        l_area := l_area.aliased_resized_area (i + additional_space)\n        area_v2 := l_area\n      end\n      l_area.extend (v)\n    end\n\n  put_left (v: like item)\n      -- Add `v' to the left of current position.\n      -- Do not move cursor.\n    do\n      if after or is_empty then\n        extend (v)\n      else\n        insert (v, index)\n      end\n      index := index + 1\n    end\n\n  put_right (v: like item)\n      -- Add `v' to the right of current position.\n      -- Do not move cursor.\n    do\n      if index = count then\n        extend (v)\n      else\n        insert (v, index + 1)\n      end\n    end\n\n  replace (v: like first)\n      -- Replace current item by `v'.\n    do\n      put_i_th (v, index)\n    end\n\n  merge_left (other: ARRAYED_LIST [G])\n      -- Merge `other' into current structure before cursor.\n    local\n      old_index: INTEGER\n      old_other_count: INTEGER\n    do\n      old_index := index\n      old_other_count := other.count\n      index := index - 1\n      merge_right (other)\n      index := old_index + old_other_count\n    end\n\n  merge_right (other: ARRAYED_LIST [G])\n      -- Merge `other' into current structure after cursor.\n    local\n      l_new_count, l_old_count: INTEGER\n    do\n      if not other.is_empty then\n        l_old_count := count\n        l_new_count := l_old_count + other.count\n        if l_new_count > area_v2.capacity then\n          area_v2 := area_v2.aliased_resized_area (l_new_count)\n        end\n        area_v2.insert_data (other.area_v2, 0, index, other.count)\n        other.wipe_out\n      end\n    end\n\n  append (s: SEQUENCE [G])\n      -- Append a copy of `s'.\n    local\n      c, old_count, new_count: INTEGER\n    do\n      if attached {ARRAYED_LIST [G]} s as al then -- Optimization for arrayed lists\n        c := al.count\n          -- If `s' is empty nothing to be done.\n        if c > 0 then\n          old_count := count\n          new_count := old_count + al.count\n          if new_count > area_v2.capacity then\n            area_v2 := area_v2.aliased_resized_area (new_count)\n          end\n          area_v2.copy_data (al.area_v2, 0, old_count, c)\n        end\n      else\n        Precursor {DYNAMIC_LIST} (s)\n      end\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > area_v2.capacity then\n        area_v2 := area_v2.aliased_resized_area (i)\n      end\n    end\n\n  resize (new_capacity: INTEGER)\n      -- Resize list so that it can contain\n      -- at least `n' items. Do not lose any item.\n    require\n      resizable: resizable\n      new_capacity_large_enough: new_capacity >= capacity\n    do\n      grow (new_capacity)\n    ensure\n      capacity_set: capacity >= new_capacity\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area_v2.capacity then\n        area_v2 := area_v2.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: to_array.same_items (old to_array)\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area_v2.twin)\n      end\n    ensure then\n      equal_areas: area_v2 ~ other.area_v2\n    end\n\nfeature -- Removal\n\n  prune (v: like item)\n      -- Remove first occurrence of `v', if any,\n      -- after cursor position.\n      -- Move cursor to right neighbor.\n      -- (or `after' if no right neighbor or `v' does not occur)\n    do\n      if before then\n        index := 1\n      end\n      if object_comparison then\n        from\n        until\n          after or else item ~ v\n        loop\n          forth\n        end\n      else\n        from\n        until\n          after or else item = v\n        loop\n          forth\n        end\n      end\n      if not after then\n        remove\n      end\n    end\n\n  remove\n      -- Remove current item.\n      -- Move cursor to right neighbor\n      -- (or `after' if no right neighbor)\n    do\n      if index < count then\n        area_v2.move_data (index, index - 1, count - index)\n      end\n      area_v2.remove_tail (1)\n    ensure then\n      index: index = old index\n    end\n\n  prune_all (v: like item)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      offset: INTEGER\n      res: BOOLEAN\n      obj_cmp: BOOLEAN\n      l_area: like area_v2\n    do\n      obj_cmp := object_comparison\n      from\n        l_area := area_v2\n        i := 0\n        nb := count\n      until\n        i = count\n      loop\n        if i < nb - offset then\n          if offset > 0 then\n            l_area.put (l_area.item (i + offset), i)\n          end\n          if obj_cmp then\n            res := v ~ l_area.item (i)\n          else\n            res := v = l_area.item (i)\n          end\n          if res then\n            offset := offset + 1\n          else\n            i := i + 1\n          end\n        else\n          i := i + 1\n        end\n      end\n      l_area.remove_tail (offset)\n      index := count + 1\n    ensure then\n      is_after: after\n    end\n\n  remove_left\n      -- Remove item to the left of cursor position.\n      -- Do not move cursor.\n    do\n      index := index - 1\n      remove\n    end\n\n  remove_right\n      -- Remove item to the right of cursor position\n      -- Do not move cursor\n    do\n      index := index + 1\n      remove\n      index := index - 1\n    end\n\n  wipe_out\n      -- Remove all items.\n    do\n      area_v2.wipe_out\n      index := 0\n    end\n\nfeature -- Transformation\n\n  swap (i: INTEGER)\n      -- Exchange item at `i'-th position with item\n      -- at cursor position.\n    local\n      old_item: like item\n    do\n      old_item := item\n      replace (area_v2.item (i - 1))\n      area_v2.put (old_item, i - 1)\n    end\n\nfeature -- Retrieval\n\n  correct_mismatch\n    local\n      i: INTEGER\n    do\n      if\n        not mismatch_information.has (\"area_v2\") and then\n        attached {SPECIAL [G]} mismatch_information.item (\"area\") as l_area and then\n        attached {INTEGER} mismatch_information.item (\"count\") as l_count and then\n        attached {BOOLEAN} mismatch_information.item (\"object_comparison\") as l_comp and then\n        attached {INTEGER} mismatch_information.item (\"index\") as l_index\n      then\n        create area_v2.make_empty (l_count)\n        from\n          i := 0\n        until\n          i = l_count\n        loop\n          area_v2.extend (l_area.item (i))\n          i := i + 1\n        end\n        object_comparison := l_comp\n        index := l_index\n      else\n        Precursor\n      end\n    end\n\nfeature -- Duplication\n\n  duplicate (n: INTEGER): like Current\n      -- Copy of sub-list beginning at current position\n      -- and having min (`n', `count' - `index' + 1) items.\n    local\n      end_pos: INTEGER\n    do\n      if after then\n        Result := new_filled_list (0)\n      else\n        end_pos := count.min (index + n - 1)\n        Result := new_filled_list (end_pos - index + 1)\n        Result.area_v2.copy_data (area_v2, index - 1, 0, end_pos - index + 1)\n      end\n    end\n\nfeature {NONE} -- Inapplicable\n\n  new_chain: like Current\n      -- Unused\n    do\n      Result := Current\n    end\n\nfeature {NONE} -- Implementation\n\n  force_i_th (v: like i_th; pos: INTEGER)\n    do\n      if count + 1 > capacity then\n        grow (count + additional_space)\n      end\n      area_v2.force (v, pos)\n    end\n\n  insert (v: like item; pos: INTEGER)\n      -- Add `v' at `pos', moving subsequent items\n      -- to the right.\n    require\n      index_small_enough: pos <= count\n      index_large_enough: pos >= 1\n    do\n      if count + 1 > capacity then\n        grow (count + additional_space)\n      end\n      area_v2.move_data (pos - 1, pos, count - pos + 1)\n      put_i_th (v, pos)\n    ensure\n      new_count: count = old count + 1\n      index_unchanged: index = old index\n      insertion_done: i_th (pos) = v\n    end\n\n  new_filled_list (n: INTEGER): like Current\n      -- New list with `n' elements.\n    require\n      n_non_negative: n >=0\n    do\n      create Result.make (n)\n    ensure\n      new_filled_list_not_void: Result /= Void\n      new_filled_list_count_set: Result.count = 0\n      new_filled_list_before: Result.before\n    end\n\ninvariant\n  prunable: prunable\n  starts_from_one: lower = 1\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"bag.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bag, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BAG [G] inherit\n\n  COLLECTION [G]\n    redefine\n      extend\n    end\n\nfeature -- Measurement\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      non_negative_occurrences: Result >= 0\n    end\n\nfeature -- Element change\n\n  extend (v: G)\n      -- Add a new occurrence of `v'.\n    deferred\n    ensure then\n        -- Commented due to the expensive nature of the check when inserting a new item\n        -- in a containers with many items.\n      -- one_more_occurrence: occurrences (v) = old (occurrences (v)) + 1\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"bilinear.e","content":"note\n  description: \"Structures that may be traversed forward and backward\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bidirectional, traversing;\n  access: cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BILINEAR [G] inherit\n\n  LINEAR [G]\n    rename\n      search as sequential_search\n    export\n      {NONE}\n        sequential_search\n    redefine\n      off\n    end\n\n  LINEAR [G]\n    redefine\n      search, off\n    select\n      search\n    end\n\nfeature -- Access\n\n  off: BOOLEAN\n      -- Is there no current item?\n    do\n      Result := before or after\n    end\n\nfeature -- Cursor movement\n\n  before: BOOLEAN\n      -- Is there no valid position to the left of current one?\n    deferred\n    end\n\n  back\n      -- Move to previous position.\n    require\n      not_before: not before\n    deferred\n    ensure then\n      -- moved_forth_after_start: (not before) implies index = old index - 1\n    end\n\n  search (v: like item)\n      -- Move to first position (at or after current\n      -- position) where `item' and `v' are equal.\n      -- If structure does not include `v' ensure that\n      -- `exhausted' will be true.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    do\n      if before and not is_empty then\n        forth\n      end\n      sequential_search (v)\n    end\n\ninvariant\n\n  not_both: not (after and before)\n  before_constraint: before implies off\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"boolean.e","content":"note\n  description: \"Truth values, with the boolean operations\"\n  external_name: \"System.Boolean\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class BOOLEAN\n\ninherit\n  BOOLEAN_REF\n    redefine\n      conjuncted,\n      conjuncted_semistrict,\n      disjuncted,\n      disjuncted_semistrict,\n      disjuncted_exclusive,\n      implication,\n      negated\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({BOOLEAN_REF})\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: BOOLEAN): BOOLEAN\n      -- Boolean conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  implication alias \"implies\" (other: BOOLEAN): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    external\n      \"built_in\"\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    external\n      \"built_in\"\n    end\n\n  disjuncted alias \"or\" (other: BOOLEAN): BOOLEAN\n      -- Boolean disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: BOOLEAN): BOOLEAN\n      -- Boolean exclusive or with `other'\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"boolean_ref.e","content":"note\n  description: \"References to objects containing a boolean value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass BOOLEAN_REF inherit\n\n  HASHABLE\n    redefine\n      out\n    end\n\nfeature -- Access\n\n  item: BOOLEAN\n      -- Boolean value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      if item then\n        Result := 1\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: BOOLEAN_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: BOOLEAN_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n      same_item: Result.item = item\n    end\n\n  to_integer: INTEGER\n      -- 1 if `True'\n      -- 0 if `False'\n    do\n      if item then\n        Result := 1\n      end\n    ensure\n      not_item_implies_zero: not item implies Result = 0\n      item_implies_one: item implies Result = 1\n    end\n\nfeature -- Element change\n\n  set_item (b: BOOLEAN)\n      -- Make `b' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: like Current): BOOLEAN\n      -- Boolean conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and other.item\n    ensure\n      de_morgan: Result = not (not Current or not other)\n      commutative: Result = (other and Current)\n      consistent_with_semi_strict: Result implies (Current and then other)\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and then other.item\n    ensure\n      de_morgan: Result = not (not Current or else not other)\n    end\n\n  implication alias \"implies\" (other: like Current): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    require\n      other_exists: other /= Void\n    do\n      Result := item implies other.item\n    ensure\n      definition: Result = (not Current or else other)\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    do\n      Result := not item\n    end\n\n  disjuncted alias \"or\" (other: like Current): BOOLEAN\n      -- Boolean disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or other.item\n    ensure\n      de_morgan: Result = not (not Current and not other)\n      commutative: Result = (other or Current)\n      consistent_with_semi_strict: Result implies (Current or else other)\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or else other.item\n    ensure\n      de_morgan: Result = not (not Current and then not other)\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: like Current): BOOLEAN\n      -- Boolean exclusive or with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item xor other.item\n    ensure\n      definition: Result = ((Current or other) and not (Current and other))\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of boolean\n    do\n      Result := \"False\"\n      if item then\n        Result := \"True\"\n      end\n    end\n\ninvariant\n  involutive_negation: (not (not Current)).item = item\n  non_contradiction: not ((not Current) and Current)\n  completeness: (not Current) or Current\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"bounded.e","content":"note\n  description: \"Bounded data structures, with a notion of capacity.\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bounded, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOUNDED [G] inherit\n\n  FINITE [G]\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Number of items that may be stored\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure full?\n    do\n      Result := (count = capacity)\n    end\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed?\n    deferred\n    end\n\ninvariant\n\n  valid_count: count <= capacity\n  full_definition: full = (count = capacity)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"box.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOX [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure filled to capacity?\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"cell.e","content":"note\n  description: \"Cells containing an item\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: cell;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\nclass CELL [G]\n\ncreate\n  put\n\nfeature -- Access\n\n  item: G\n      -- Content of cell.\n\nfeature -- Element change\n\n  put, replace (v: like item)\n      -- Make `v' the cell's `item'.\n    do\n      item := v\n    ensure\n      item_inserted: item = v\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"chain.e","content":"note\n  description: \"[\n    Possibly circular sequences of items,\n    without commitment to a particular representation\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: chain, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2013-01-15 13:41:22 -0800 (Tue, 15 Jan 2013) $\"\n  revision: \"$Revision: 92122 $\"\n\ndeferred class CHAIN [G] inherit\n\n  CURSOR_STRUCTURE [G]\n    rename\n      put as sequence_put\n    undefine\n      prune_all\n    redefine\n      fill\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as i_th alias \"[]\",\n      put as put_i_th,\n      bag_put as sequence_put\n    undefine\n      prune_all, sequence_put\n    redefine\n      fill\n    end\n\n  SEQUENCE [G]\n    rename\n      put as sequence_put\n    export\n      {NONE} sequence_put\n    redefine\n      index_of, has, off, occurrences, fill, append\n    select\n      index_of, has, occurrences\n    end\n\n  SEQUENCE [G]\n    rename\n      put as sequence_put,\n      index_of as sequential_index_of,\n      has as sequential_has,\n      occurrences as sequential_occurrences\n    export\n      {NONE}\n        sequential_index_of, sequential_has,\n        sequence_put, sequential_occurrences\n    redefine\n      off, fill, append\n    end\n\nfeature -- Access\n\n  first: like item\n      -- Item at first position\n    require\n      not_empty: not is_empty\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      start\n      Result := item\n      go_to (pos)\n    end\n\n  last: like item\n      -- Item at last position\n    require\n      not_empty: not is_empty\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      finish\n      Result := item\n      go_to (pos)\n    end\n\n  has (v: like item): BOOLEAN\n      -- Does chain include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      Result := sequential_has (v)\n      go_to (pos)\n    end\n\n  index_of (v: like item; i: INTEGER): INTEGER\n      -- Index of `i'-th occurrence of item identical to `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      -- 0 if none.\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      Result := sequential_index_of (v, i)\n      go_to (pos)\n    end\n\n  i_th alias \"[]\", at alias \"@\" (i: INTEGER): like item assign put_i_th\n      -- Item at `i'-th position\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      go_i_th (i)\n      Result := item\n      go_to (pos)\n    end\n\nfeature -- Measurement\n\n  occurrences (v: like item): INTEGER\n      -- Number of times `v' appears.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      Result := sequential_occurrences (v)\n      go_to (pos)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      count_definition: Result.count = count\n    end\n\nfeature -- Cursor movement\n\n  start\n      -- Move cursor to first position.\n      -- (No effect if empty)\n    do\n      if not is_empty then\n        go_i_th (1)\n      end\n    ensure then\n      at_first: not is_empty implies isfirst\n    end\n\n  finish\n      -- Move cursor to last position.\n      -- (No effect if empty)\n    do\n      if not is_empty then\n        go_i_th (count)\n      end\n    ensure then\n      at_last: not is_empty implies islast\n    end\n\n  move (i: INTEGER)\n      -- Move cursor `i' positions. The cursor\n      -- may end up `off' if the absolute value of `i'\n      -- is too big.\n    local\n      counter, pos, final: INTEGER\n    do\n      if i > 0 then\n        from\n        until\n          (counter = i) or else after\n        loop\n          forth\n          counter := counter + 1\n        end\n      elseif i < 0 then\n        final := index + i\n        if final <= 0 then\n          start\n          back\n        else\n          from\n            start\n            pos := 1\n          until\n            pos = final\n          loop\n            forth\n            pos := pos + 1\n          end\n        end\n      end\n    ensure\n      too_far_right: (old index + i > count) implies exhausted\n      too_far_left: (old index + i < 1) implies exhausted\n      expected_index: (not exhausted) implies (index = old index + i)\n    end\n\n  go_i_th (i: INTEGER)\n      -- Move cursor to `i'-th position.\n    require\n      valid_cursor_index: valid_cursor_index (i)\n    do\n      move (i - index)\n    ensure\n      position_expected: index = i\n    end\n\n feature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within allowable bounds?\n    do\n      Result := (i >= 1) and (i <= count)\n    ensure then\n      valid_index_definition: Result = ((i >= 1) and (i <= count))\n    end\n\n\n  isfirst: BOOLEAN\n      -- Is cursor at first position?\n    do\n      Result := not is_empty and (index = 1)\n    ensure\n      valid_position: Result implies not is_empty\n    end\n\n  islast: BOOLEAN\n      -- Is cursor at last position?\n    do\n      Result := not is_empty and (index = count)\n    ensure\n      valid_position: Result implies not is_empty\n    end\n\n  off: BOOLEAN\n      -- Is there no current item?\n    do\n      Result := (index = 0) or (index = count + 1)\n    end\n\n\n  valid_cursor_index (i: INTEGER): BOOLEAN\n      -- Is `i' correctly bounded for cursor movement?\n    do\n      Result := (i >= 0) and (i <= count + 1)\n    ensure\n      valid_cursor_index_definition: Result = ((i >= 0) and (i <= count + 1))\n    end\n\nfeature -- Element change\n\n  put (v: like item)\n      -- Replace current item by `v'.\n      -- (Synonym for `replace')\n    require\n      writeable: writable\n      replaceable: replaceable\n    do\n      replace (v)\n    ensure\n      same_count: count = old count\n      is_inserted: is_inserted (v)\n    end\n\n  put_i_th (v: like item; i: INTEGER)\n      -- Put `v' at `i'-th position.\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      go_i_th (i)\n      replace (v)\n      go_to (pos)\n    end\n\n  append (s: SEQUENCE [G])\n      -- Append a copy of `s'.\n    local\n      l: SEQUENCE [G]\n      l_cursor: CURSOR\n    do\n      l := s\n      if s = Current then\n        l := twin\n      end\n      from\n        l_cursor := cursor\n        l.start\n      until\n        l.exhausted\n      loop\n        extend (l.item)\n        finish\n        l.forth\n      end\n      go_to (l_cursor)\n    end\n\n  fill (other: CONTAINER [G])\n      -- Fill with as many items of `other' as possible.\n      -- The representations of `other' and current structure\n      -- need not be the same.\n    local\n      lin_rep: LINEAR [G]\n      l_cursor: CURSOR\n    do\n      lin_rep := other.linear_representation\n      from\n        l_cursor := cursor\n        lin_rep.start\n      until\n        not extendible or else lin_rep.off\n      loop\n        extend (lin_rep.item)\n        finish\n        lin_rep.forth\n      end\n      go_to (l_cursor)\n    end\nfeature -- Transformation\n\n  swap (i: INTEGER)\n      -- Exchange item at `i'-th position with item\n      -- at cursor position.\n    require\n      not_off: not off\n      valid_index: valid_index (i)\n    local\n      old_item, new_item: like item\n      pos: CURSOR\n    do\n      pos := cursor\n      old_item := item\n      go_i_th (i)\n      new_item := item\n      replace (old_item)\n      go_to (pos)\n      replace (new_item)\n    ensure\n      swapped_to_item: item = old i_th (i)\n      swapped_from_item: i_th (i) = old item\n    end\n\nfeature -- Duplication\n\n  duplicate (n: INTEGER): like Current\n      -- Copy of sub-chain beginning at current position\n      -- and having min (`n', `from_here') items,\n      -- where `from_here' is the number of items\n      -- at or to the right of current position.\n    require\n      not_off_unless_after: off implies after\n      valid_subchain: n >= 0\n    deferred\n    end\n\nfeature {NONE} -- Inapplicable\n\n  remove\n      -- Remove current item.\n    do\n    end\n\ninvariant\n\n  non_negative_index: index >= 0\n  index_small_enough: index <= count + 1\n  off_definition: off = ((index = 0) or (index = count + 1))\n  isfirst_definition: isfirst = ((not is_empty) and (index = 1))\n  islast_definition: islast = ((not is_empty) and (index = count))\n  item_corresponds_to_index: (not off) implies (item = i_th (index))\n  index_set_has_same_count: index_set.count = count\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_32.e","content":"note\n  description: \"Unicode characters, with comparison operations\"\n  assembly: \"mscorlib\"\n  external_name: \"System.UInt32\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_32\n\ninherit\n  CHARACTER_32_REF\n    redefine\n      code,\n      natural_32_code,\n      to_character_8\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_32_REF})\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"character_32_ref.e","content":"note\n  description: \"References to objects containing a unicode character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  CHARACTER_32_REF\n\ninherit\n  COMPARABLE\n    redefine\n      is_equal, out\n    end\n\n  HASHABLE\n    redefine\n      is_equal, out\n    end\n\nfeature -- Access\n\n  item: CHARACTER_32\n      -- Unicode character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := natural_32_code.as_integer_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.natural_32_code\n    ensure\n      natural_32_code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  min_value: NATURAL_32 = 0\n  max_value: NATURAL_32 = 4294967295\n      -- Bounds for integer representation of CHARACTER_32\n\n  max_unicode_value: NATURAL_32 = 0x10FFFD\n      -- Maximum Unicode characters.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: NATURAL_32): CHARACTER_32\n      -- Add `incr' to the code of `item'.\n    require\n      valid_increment: (item.natural_32_code.to_natural_64 + incr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code + incr).to_character_32\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: NATURAL_32): CHARACTER_32\n      -- Subtract `decr' from the code of `item'.\n    require\n      valid_decrement: (item.natural_32_code.to_integer_64 - decr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code - decr).to_character_32\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_32): INTEGER_64\n      -- Difference between the codes of `item' and `other'.\n    do\n      Result := item.natural_32_code.to_integer_64 - other.natural_32_code.to_integer_64\n    ensure\n      valid_non_negative_result: Result >= 0 implies ((other + Result.to_natural_32) = item)\n      valid_negative_result: Result < 0 implies (other = (item + Result.to_natural_32))\n    end\n\n  next: CHARACTER_32\n      -- Next character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 + 1).is_valid_character_32_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_32\n      -- Previous character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 - 1).is_valid_character_32_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_32)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of wide character.\n    do\n      create Result.make (6)\n      Result.append_character ('U')\n      Result.append_character ('+')\n      Result.append_string (natural_32_code.to_hex_string)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_32_REF\n      -- Associated reference of Current.\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8.\n    require\n      is_character_8_compatible: is_character_8\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Convert current to CHARACTER_32.\n    do\n      Result := item\n    end\n\n  as_upper, upper: CHARACTER_32\n      -- Uppercase value of `item'.\n      -- Returns `item' if not `is_lower'.\n    do\n      Result := properties.to_upper (item)\n    end\n\n  as_lower, lower: CHARACTER_32\n      -- Lowercase value of `item'.\n      -- Returns `item' if not `is_upper'.\n    do\n      Result := properties.to_lower (item)\n    end\n\nfeature -- Status report\n\n  is_character_8: BOOLEAN\n      -- Can current be represented on a CHARACTER_8?\n    do\n      Result := natural_32_code <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'.\n    do\n      Result := properties.is_alpha (item)\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := properties.is_upper (item)\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := properties.is_lower (item)\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789.\n    do\n      Result := '0' <= item and item <= '9'\n    end\n\n  is_unicode_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for Unicode characters?\n    do\n      Result := properties.is_digit (item)\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' a hexadecimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789ABCDEFabcedf.\n    do\n      Result := properties.is_hexa_digit (item)\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := properties.is_space (item)\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := properties.is_punctuation (item)\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := properties.is_alpha (item) or properties.is_digit (item)\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := properties.is_control (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  properties: CHARACTER_PROPERTY\n      -- Property for Unicode characters.\n    once\n      create Result.make\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8.e","content":"note\n  description: \"Characters, with comparison operations and an ASCII code\"\n  external_name: \"System.Char\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_8\n\ninherit\n  CHARACTER_8_REF\n    redefine\n      code,\n      to_character_32\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_8_REF}),\n  to_character_32: {CHARACTER_32}\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8_ref.e","content":"note\n  description: \"References to objects containing a character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass CHARACTER_8_REF inherit\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      out, is_equal\n    end\n\nfeature -- Access\n\n  item: CHARACTER_8\n      -- Character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := item.code\n    ensure\n      code_non_negatif: Result >= 0\n      code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.code.to_natural_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  min_value: INTEGER = 0\n  max_value: INTEGER = 255\n  max_ascii_value: INTEGER = 127\n      -- Bounds for integer representation of characters (ASCII)\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: INTEGER): CHARACTER_8\n      -- Add `incr' to the code of `item'\n    require\n      valid_increment: (item.code + incr).is_valid_character_8_code\n    do\n      Result := (item.code + incr).to_character_8\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: INTEGER): CHARACTER_8\n      -- Subtract `decr' from the code of `item'\n    require\n      valid_decrement: (item.code - decr).is_valid_character_8_code\n    do\n      Result := (item.code - decr).to_character_8\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_8): INTEGER\n      -- Difference between the codes of `item' and `other'\n    do\n      Result := item.code - other.code\n    ensure\n      valid_result: other + Result = item\n    end\n\n  next: CHARACTER_8\n      -- Next character\n    require\n      valid_character: (item.code + 1).is_valid_character_8_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_8\n      -- Previous character\n    require\n      valid_character: (item.code - 1).is_valid_character_8_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_8)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of character\n    do\n      create Result.make (1)\n      Result.append_character (item)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version\n    do\n      Result := item\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    do\n      Result := item.to_character_32\n    end\n\n  as_upper, upper: CHARACTER_8\n      -- Uppercase value of `item'\n      -- Returns `item' if not `is_lower'\n    do\n      if is_lower then\n        Result := (item.code - ('a').code + ('A').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\n  as_lower, lower: CHARACTER_8\n      -- Lowercase value of `item'\n      -- Returns `item' if not `is_upper'\n    do\n      if is_upper then\n        Result := (item.code - ('A').code + ('a').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\nfeature -- Status report\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag)) > 0\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := (character_types (item.code) & is_upper_flag) > 0\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := (character_types (item.code) & is_lower_flag) > 0\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a digit?\n      -- A digit is one of 0123456789\n    do\n      Result := (character_types (item.code) & is_digit_flag) > 0\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' an hexadecimal digit?\n      -- A digit is one of 0123456789ABCDEFabcedf\n    do\n      Result := (character_types (item.code) & (is_hexa_digit_flag | is_digit_flag)) > 0\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := (character_types (item.code) & is_white_space_flag) > 0\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := (character_types (item.code) & is_punctuation_flag) > 0\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag | is_digit_flag)) > 0\n    end\n\n  is_printable: BOOLEAN\n      -- Is `item' a printable character including space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag | is_space_flag)) > 0\n    end\n\n  is_graph: BOOLEAN\n      -- Is `item' a printable character except space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag)) > 0\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := (character_types (item.code) & is_control_flag) > 0\n    end\n\nfeature {NONE} -- Implementation\n\n  character_types (a_code: INTEGER): NATURAL_8\n      -- Associated type for character of code `a_code'\n    do\n        -- For character whose code is above 256, it is as if\n        -- we had no information about it.\n      if a_code < 256 then\n        Result := internal_character_types.item (a_code)\n      end\n    end\n\n  internal_character_types: SPECIAL [NATURAL_8]\n      -- Array which stores the various type for the ASCII characters\n    once\n      create Result.make_empty (256)\n      Result.extend (is_control_flag)             -- 0  null\n      Result.extend (is_control_flag)                         -- 1  start of heading\n      Result.extend (is_control_flag)                         -- 2  start of text\n      Result.extend (is_control_flag)                         -- 3  end of text\n      Result.extend (is_control_flag)                         -- 4  end of transmission\n      Result.extend (is_control_flag)                         -- 5  enquiry\n      Result.extend (is_control_flag)                         -- 6  acknowledge\n      Result.extend (is_control_flag)                         -- 7  bell\n      Result.extend (is_control_flag)                         -- 8  backspace\n      Result.extend (is_control_flag | is_white_space_flag)   -- 9  horizontal tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 10 NL line feed, new line\n      Result.extend (is_control_flag | is_white_space_flag)   -- 11 vertical tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 12 NP form feed, new page\n      Result.extend (is_control_flag | is_white_space_flag)   -- 13 carriage return=CR\n      Result.extend (is_control_flag)                         -- 14 shift out\n      Result.extend (is_control_flag)                         -- 15 shift in\n      Result.extend (is_control_flag)                         -- 16\n      Result.extend (is_control_flag)                         -- 17\n      Result.extend (is_control_flag)                         -- 18\n      Result.extend (is_control_flag)                         -- 19\n      Result.extend (is_control_flag)                         -- 20\n      Result.extend (is_control_flag)                         -- 21\n      Result.extend (is_control_flag)                         -- 22\n      Result.extend (is_control_flag)                         -- 23\n      Result.extend (is_control_flag)                         -- 24\n      Result.extend (is_control_flag)                         -- 25\n      Result.extend (is_control_flag)                         -- 26\n      Result.extend (is_control_flag)                         -- 27 Escape\n      Result.extend (is_control_flag)                         -- 28 file separator\n      Result.extend (is_control_flag)                         -- 29 group separator\n      Result.extend (is_control_flag)                         -- 30 record separator\n      Result.extend (is_control_flag)                         -- 31 unit separator\n      Result.extend (is_white_space_flag | is_space_flag)     -- 32 Space\n      Result.extend (is_punctuation_flag)                     -- 33 !\n      Result.extend (is_punctuation_flag)                     -- 34 \"\n      Result.extend (is_punctuation_flag)                     -- 35 #\n      Result.extend (is_punctuation_flag)                     -- 36 $\n      Result.extend (is_punctuation_flag)                     -- 37 %\n      Result.extend (is_punctuation_flag)                     -- 38 &\n      Result.extend (is_punctuation_flag)                     -- 39 '\n      Result.extend (is_punctuation_flag)                     -- 40 (\n      Result.extend (is_punctuation_flag)                     -- 41 )\n      Result.extend (is_punctuation_flag)                     -- 42 *\n      Result.extend (is_punctuation_flag)                     -- 43 +\n      Result.extend (is_punctuation_flag)                     -- 44 ,\n      Result.extend (is_punctuation_flag)                     -- 45 -\n      Result.extend (is_punctuation_flag)                     -- 46 .\n      Result.extend (is_punctuation_flag)                     -- 47 /\n      Result.extend (is_digit_flag)                           -- 48 0\n      Result.extend (is_digit_flag)                           -- 49 1\n      Result.extend (is_digit_flag)                           -- 50 2\n      Result.extend (is_digit_flag)                           -- 51 3\n      Result.extend (is_digit_flag)                           -- 52 4\n      Result.extend (is_digit_flag)                           -- 53 5\n      Result.extend (is_digit_flag)                           -- 54 6\n      Result.extend (is_digit_flag)                           -- 55 7\n      Result.extend (is_digit_flag)                           -- 56 8\n      Result.extend (is_digit_flag)                           -- 57 9\n      Result.extend (is_punctuation_flag)                     -- 58 :\n      Result.extend (is_punctuation_flag)                     -- 59 ;\n      Result.extend (is_punctuation_flag)                     -- 60 <\n      Result.extend (is_punctuation_flag)                     -- 61 =\n      Result.extend (is_punctuation_flag)                     -- 62 >\n      Result.extend (is_punctuation_flag)                     -- 63 ?\n      Result.extend (is_punctuation_flag)                     -- 64 @\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 65 A\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 66 B\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 67 C\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 68 D\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 69 E\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 70 F\n      Result.extend (is_upper_flag)                           -- 71 G\n      Result.extend (is_upper_flag)                           -- 72 H\n      Result.extend (is_upper_flag)                           -- 73 I\n      Result.extend (is_upper_flag)                           -- 74 J\n      Result.extend (is_upper_flag)                           -- 75 K\n      Result.extend (is_upper_flag)                           -- 76 L\n      Result.extend (is_upper_flag)                           -- 77 M\n      Result.extend (is_upper_flag)                           -- 78 N\n      Result.extend (is_upper_flag)                           -- 79 O\n      Result.extend (is_upper_flag)                           -- 80 P\n      Result.extend (is_upper_flag)                           -- 81 Q\n      Result.extend (is_upper_flag)                           -- 82 R\n      Result.extend (is_upper_flag)                           -- 83 S\n      Result.extend (is_upper_flag)                           -- 84 T\n      Result.extend (is_upper_flag)                           -- 85 U\n      Result.extend (is_upper_flag)                           -- 86 V\n      Result.extend (is_upper_flag)                           -- 87 W\n      Result.extend (is_upper_flag)                           -- 88 X\n      Result.extend (is_upper_flag)                           -- 89 Y\n      Result.extend (is_upper_flag)                           -- 90 Z\n      Result.extend (is_punctuation_flag)                     -- 91 [\n      Result.extend (is_punctuation_flag)                     -- 92 \\\n      Result.extend (is_punctuation_flag)                     -- 93 ]\n      Result.extend (is_punctuation_flag)                     -- 94 ^\n      Result.extend (is_punctuation_flag)                     -- 95 _\n      Result.extend (is_punctuation_flag)                     -- 96 `\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 97 a\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 98 b\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 99 c\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 100  d\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 101  e\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 102  f\n      Result.extend (is_lower_flag)                           -- 103  g\n      Result.extend (is_lower_flag)                           -- 104  h\n      Result.extend (is_lower_flag)                           -- 105  i\n      Result.extend (is_lower_flag)                           -- 106  j\n      Result.extend (is_lower_flag)                           -- 107  k\n      Result.extend (is_lower_flag)                           -- 108  l\n      Result.extend (is_lower_flag)                           -- 109  m\n      Result.extend (is_lower_flag)                           -- 110  n\n      Result.extend (is_lower_flag)                           -- 111  o\n      Result.extend (is_lower_flag)                           -- 112  p\n      Result.extend (is_lower_flag)                           -- 113  q\n      Result.extend (is_lower_flag)                           -- 114  r\n      Result.extend (is_lower_flag)                           -- 115  s\n      Result.extend (is_lower_flag)                           -- 116  t\n      Result.extend (is_lower_flag)                           -- 117  u\n      Result.extend (is_lower_flag)                           -- 118  v\n      Result.extend (is_lower_flag)                           -- 119  w\n      Result.extend (is_lower_flag)                           -- 120  x\n      Result.extend (is_lower_flag)                           -- 121  y\n      Result.extend (is_lower_flag)                           -- 122  z\n      Result.extend (is_punctuation_flag)                     -- 123  {\n      Result.extend (is_punctuation_flag)                     -- 124  |\n      Result.extend (is_punctuation_flag)                     -- 125  }\n      Result.extend (is_punctuation_flag)                     -- 126  ~\n      Result.extend (is_control_flag)                         -- 127  DEL\n      Result.fill_with (0, 128, 255)              -- extended ASCII\n    ensure\n      internal_character_types_not_void: Result /= Void\n    end\n\n  is_upper_flag: NATURAL_8 = 0x01\n\n  is_lower_flag: NATURAL_8 = 0x02\n\n  is_digit_flag: NATURAL_8 = 0x04\n\n  is_white_space_flag: NATURAL_8 = 0x08\n\n  is_punctuation_flag: NATURAL_8 = 0x10\n\n  is_control_flag: NATURAL_8 = 0x20\n\n  is_hexa_digit_flag: NATURAL_8 = 0x40\n\n  is_space_flag: NATURAL_8 = 0x80;\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"collection.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: collection, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class COLLECTION [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  extendible: BOOLEAN\n      -- May new items be added?\n    deferred\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed?\n    deferred\n    end\n\n  is_inserted (v: G): BOOLEAN\n      -- Has `v' been inserted by the most recent insertion?\n      -- (By default, the value returned is equivalent to calling\n      -- `has (v)'. However, descendants might be able to provide more\n      -- efficient implementations.)\n    do\n      Result := has (v)\n    end\n\nfeature -- Element change\n\n  put, extend (v: G)\n      -- Ensure that structure includes `v'.\n    require\n      extendible: extendible\n    deferred\n    ensure\n      item_inserted: is_inserted (v)\n    end\n\n  fill (other: CONTAINER [G])\n      -- Fill with as many items of `other' as possible.\n      -- The representations of `other' and current structure\n      -- need not be the same.\n    require\n      other_not_void: other /= Void\n      extendible: extendible\n    local\n      lin_rep: LINEAR [G]\n    do\n      lin_rep := other.linear_representation\n      from\n        lin_rep.start\n      until\n        not extendible or else lin_rep.off\n      loop\n        extend (lin_rep.item)\n        lin_rep.forth\n      end\n    end\n\nfeature -- Removal\n\n  prune (v: G)\n      -- Remove one occurrence of `v' if any.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    require\n      prunable: prunable\n    deferred\n    end\n\n  prune_all (v: G)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      --|Default implementation, usually inefficient.\n    require\n      prunable: prunable\n    do\n      from\n      until not has (v) loop\n        prune (v)\n      end\n    ensure\n      no_more_occurrences: not has (v)\n    end\n\n  wipe_out\n      -- Remove all items.\n    require\n      prunable: prunable\n    deferred\n    ensure\n      wiped_out: is_empty\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"comparable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class COMPARABLE inherit\n\n  PART_COMPARABLE\n    redefine\n      is_less, is_less_equal,\n      is_greater, is_greater_equal,\n      is_equal\n    end\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    deferred\n    ensure then\n      asymmetric: Result implies not (other < Current)\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    do\n      Result := not (other < Current)\n    ensure then\n      definition: Result = ((Current < other) or (Current ~ other))\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    do\n      Result := other < Current\n    ensure then\n      definition: Result = (other < Current)\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    do\n      Result := not (Current < other)\n    ensure then\n      definition: Result = (other <= Current)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := (not (Current < other) and not (other < Current))\n    ensure then\n      trichotomy: Result = (not (Current < other) and not (other < Current))\n    end\n\n  three_way_comparison (other: like Current): INTEGER\n      -- If current object equal to `other', 0;\n      -- if smaller, -1; if greater, 1\n    require\n      other_exists: other /= Void\n    do\n      if Current < other then\n        Result := -1\n      elseif other < Current then\n        Result := 1\n      end\n    ensure\n      equal_zero: (Result = 0) = (Current ~ other)\n      smaller_negative: (Result = -1) = (Current < other)\n      greater_positive: (Result = 1) = (Current > other)\n    end\n\n  max (other: like Current): like Current\n      -- The greater of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current >= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_smaller: Current >= other implies Result = Current\n      other_if_smaller: Current < other implies Result = other\n    end\n\n  min (other: like Current): like Current\n      -- The smaller of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current <= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_greater: Current <= other implies Result = Current\n      other_if_greater: Current > other implies Result = other\n    end\n\ninvariant\n\n  irreflexive_comparison: not (Current < Current)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"container.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class\n  CONTAINER [G]\n\nfeature -- Access\n\n  has (v: G): BOOLEAN\n      -- Does structure include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      not_found_in_empty: Result implies not is_empty\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is there no element?\n    deferred\n    end\n\n  empty: BOOLEAN\n      -- Is there no element?\n    obsolete\n      \"ELKS 2000: Use `is_empty' instead\"\n    do\n      Result := is_empty\n    end\n\n  object_comparison: BOOLEAN\n      -- Must search operations use `equal' rather than `='\n      -- for comparing references? (Default: no, use `='.)\n\n  changeable_comparison_criterion: BOOLEAN\n      -- May `object_comparison' be changed?\n      -- (Answer: yes by default.)\n    do\n      Result := True\n    end\n\nfeature -- Status setting\n\n  compare_objects\n      -- Ensure that future search operations will use `equal'\n      -- rather than `=' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := True\n    ensure\n      object_comparison\n    end\n\n  compare_references\n      -- Ensure that future search operations will use `='\n      -- rather than `equal' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := False\n    ensure\n      reference_comparison: not object_comparison\n    end\n\nfeature -- Conversion\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"cursor.e","content":"note\n  description: \"Cursors for remembering positions in arbitrary data structures\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: cursor;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\nclass\n  CURSOR\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"cursor_structure.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: cursor_structure, access;\n  access: cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class CURSOR_STRUCTURE [G] inherit\n\n  ACTIVE [G]\n\nfeature -- Access\n\n  cursor: CURSOR\n      -- Current cursor position\n    deferred\n    ensure\n      cursor_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  valid_cursor (p: CURSOR): BOOLEAN\n      -- Can the cursor be moved to position `p'?\n    deferred\n    end\n\nfeature -- Cursor movement\n\n  go_to (p: CURSOR)\n      -- Move cursor to position `p'.\n    require\n      cursor_position_valid: valid_cursor (p)\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"debug_output.e","content":"note\n  description: \"Objects that provide an output in debugger\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-17 11:46:15 -0800 (Thu, 17 Jan 2013) $\"\n  revision: \"$Revision: 92124 $\"\n\ndeferred class\n  DEBUG_OUTPUT\n\nfeature -- Status report\n\n  debug_output: READABLE_STRING_GENERAL\n      -- String that should be displayed in debugger to represent `Current'.\n    deferred\n    ensure\n      result_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"developer_exception.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-12-26 18:57:50 -0800 (Wed, 26 Dec 2012) $\"\n  revision: \"$Revision: 92096 $\"\n\nclass\n  DEVELOPER_EXCEPTION\n\ninherit\n  EXCEPTION\n    redefine\n      code,\n      tag\n    end\n\nfeature -- Access\n\n  frozen code: INTEGER\n      -- Exception code\n    do\n      Result := {EXCEP_CONST}.developer_exception\n    end\n\n  tag: IMMUTABLE_STRING_32\n    once\n      create Result.make_from_string_8 (\"Developer exception.\")\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"disposable.e","content":"note\n  description: \"Perform cleanup operations before current instance is reclaimed by garbage collection.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  DISPOSABLE\n\nfeature -- Removal\n\n  dispose\n      -- Action to be executed just before garbage collection\n      -- reclaims an object.\n      -- Effect it in descendants to perform specific dispose\n      -- actions. Those actions should only take care of freeing\n      -- external resources; they should not perform remote calls\n      -- on other objects since these may also be dead and reclaimed.\n    deferred\n    end\n\nfeature {NONE} -- Status report\n\n  is_in_final_collect: BOOLEAN\n      -- Is GC currently performing final collection\n      -- after execution of current program?\n      -- Safe to use in `dispose'.\n    external\n      \"C inline use %\"eif_memory.h%\"\"\n    alias\n      \"return eif_is_in_final_collect;\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"dynamic_chain.e","content":"note\n  description: \"Dynamically modifiable chains\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: dynamic_chain, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class DYNAMIC_CHAIN [G] inherit\n\n  CHAIN [G]\n    export\n      {ANY} remove, prune_all, prune\n    undefine\n      remove, prune_all, prune\n    end\n\n  UNBOUNDED [G]\n\nfeature -- Status report\n\n  extendible: BOOLEAN\n      -- May new items be added? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\nfeature -- Element change\n\n  put_front (v: like item)\n      -- Add `v' at beginning.\n      -- Do not move cursor.\n    require\n      extendible: extendible\n    deferred\n    ensure\n      new_count: count = old count + 1\n      item_inserted: first = v\n    end\n\n  put_left (v: like item)\n      -- Add `v' to the left of cursor position.\n      -- Do not move cursor.\n    require\n      extendible: extendible\n      not_before: not before\n    deferred\n    ensure\n      new_count: count = old count + 1\n      new_index: index = old index + 1\n    end\n\n  put_right (v: like item)\n      -- Add `v' to the right of cursor position.\n      -- Do not move cursor.\n    require\n      extendible: extendible\n      not_after: not after\n    deferred\n    ensure\n      new_count: count = old count + 1\n      same_index: index = old index\n    end\n\n  merge_left (other: like Current)\n      -- Merge `other' into current structure before cursor\n      -- position. Do not move cursor. Empty `other'.\n    require\n      extendible: extendible\n      not_before: not before\n      other_exists: other /= Void\n      not_current: other /= Current\n    deferred\n    ensure\n      new_count: count = old count + old other.count\n      new_index: index = old index + old other.count\n      other_is_empty: other.is_empty\n    end\n\n  merge_right (other: like Current)\n      -- Merge `other' into current structure after cursor\n      -- position. Do not move cursor. Empty `other'.\n    require\n      extendible: extendible\n      not_after: not after\n      other_exists: other /= Void\n      not_current: other /= Current\n    deferred\n    ensure\n      new_count: count = old count + old other.count\n      same_index: index = old index\n      other_is_empty: other.is_empty\n    end\n\nfeature -- Removal\n\n  prune (v: like item)\n      -- Remove first occurrence of `v', if any,\n      -- after cursor position.\n      -- If found, move cursor to right neighbor;\n      -- if not, make structure `exhausted'.\n    do\n      search (v)\n      if not exhausted then\n        remove\n      end\n    end\n\n  remove_left\n      -- Remove item to the left of cursor position.\n      -- Do not move cursor.\n    require\n      left_exists: index > 1\n    deferred\n    ensure\n      new_count: count = old count - 1\n      new_index: index = old index - 1\n    end\n\n  remove_right\n      -- Remove item to the right of cursor position.\n      -- Do not move cursor.\n    require\n      right_exists: index < count\n    deferred\n    ensure\n      new_count: count = old count - 1\n      same_index: index = old index\n    end\n\n  prune_all (v: like item)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      -- Leave structure `exhausted'.\n    do\n      from\n        start\n        search (v)\n      until\n        exhausted\n      loop\n        remove\n        search (v)\n      end\n    ensure then\n      is_exhausted: exhausted\n    end\n\n  wipe_out\n      -- Remove all items.\n    do\n      from\n        start\n      until\n        is_empty\n      loop\n        remove\n      end\n    end\n\nfeature -- Duplication\n\n  duplicate (n: INTEGER): like Current\n      -- Copy of sub-chain beginning at current position\n      -- and having min (`n', `from_here') items,\n      -- where `from_here' is the number of items\n      -- at or to the right of current position.\n    local\n      pos: CURSOR\n      counter: INTEGER\n    do\n      from\n        Result := new_chain\n        if object_comparison then\n          Result.compare_objects\n        end\n        pos := cursor\n      until\n        (counter = n) or else exhausted\n      loop\n        Result.extend (item)\n        forth\n        counter := counter + 1\n      end\n      go_to (pos)\n    end\n\nfeature {DYNAMIC_CHAIN} -- Implementation\n\n  new_chain: like Current\n      -- A newly created instance of the same type.\n      -- This feature may be redefined in descendants so as to\n      -- produce an adequately allocated and initialized object.\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"dynamic_list.e","content":"note\n  description: \"[\n    Sequential, dynamically modifiable lists,\n    without commitment to a particular representation\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: dynamic_list, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class DYNAMIC_LIST [G] inherit\n\n  LIST [G]\n    undefine\n      prune,\n      sequential_index_of, sequential_has,\n      remove, prune_all\n    end\n\n  DYNAMIC_CHAIN [G]\n    rename\n      wipe_out as chain_wipe_out\n    export\n      {NONE} chain_wipe_out\n    undefine\n      is_equal\n    redefine\n      put_left, put_right,\n      remove_left, remove_right\n    end\n\n  DYNAMIC_CHAIN [G]\n    undefine\n      is_equal\n    redefine\n      put_left, put_right,\n      remove_left, remove_right, wipe_out\n    select\n      wipe_out\n    end\n\nfeature -- Element change\n\n  put_left (v: like item)\n      -- Add `v' to the left of cursor position.\n      -- Do not move cursor.\n    local\n      temp: like item\n    do\n      if is_empty then\n        put_front (v)\n      elseif after then\n        back\n        put_right (v)\n        move (2)\n      else\n        temp := item\n        replace (v)\n        put_right (temp)\n        forth\n      end\n    end\n\n  put_right (v: like item)\n      -- Add `v' to the right of cursor position.\n      -- Do not move cursor.\n    deferred\n    end\n\n  merge_left (other: like Current)\n      -- Merge `other' into current structure before cursor\n      -- position. Do not move cursor. Empty `other'.\n    do\n      from\n        other.start\n      until\n        other.is_empty\n      loop\n        put_left (other.item)\n        other.remove\n      end\n    end\n\n  merge_right (other: like Current)\n      -- Merge `other' into current structure after cursor\n      -- position. Do not move cursor. Empty `other'.\n    do\n      from\n        other.finish\n      until\n        other.is_empty\n      loop\n        put_right (other.item)\n        other.back\n        other.remove_right\n      end\n    end\n\nfeature -- Removal\n\n  remove\n      -- Remove current item.\n      -- Move cursor to right neighbor\n      -- (or `after' if no right neighbor).\n    deferred\n    ensure then\n      after_when_empty: is_empty implies after\n    end\n\n  remove_left\n      -- Remove item to the left of cursor position.\n      -- Do not move cursor.\n    deferred\n    end\n\n  remove_right\n      -- Remove item to the right of cursor position.\n      -- Do not move cursor.\n    deferred\n    end\n\n  wipe_out\n      -- Remove all items.\n    do\n      chain_wipe_out\n      back\n    ensure then\n      is_before: before\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"excep_const.e","content":"note\n  description: \"[\n    Constants used for exception handling.\n    This class may be used as ancestor by classes needing its facilities.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  EXCEP_CONST\n\nfeature -- Access\n\n  Void_call_target: INTEGER = 1\n      -- Exception code for feature applied to void reference\n\n  No_more_memory: INTEGER = 2\n      -- Exception code for failed memory allocation\n\n  Precondition: INTEGER = 3\n      -- Exception code for violated precondition\n\n  Postcondition: INTEGER = 4\n      -- Exception code for violated postcondition\n\n  Floating_point_exception: INTEGER = 5\n      -- Exception code for floating point exception\n\n  Class_invariant: INTEGER = 6\n      -- Exception code for violated class invariant\n\n  Check_instruction: INTEGER = 7\n      -- Exception code for violated check\n\n  Routine_failure: INTEGER = 8\n      -- Exception code for failed routine\n\n  Incorrect_inspect_value: INTEGER =  9\n      -- Exception code for inspect value which is not one\n      -- of the inspect constants, if there is no Else_part\n\n  Loop_variant: INTEGER = 10\n      -- Exception code for non-decreased loop variant\n\n  Loop_invariant: INTEGER = 11\n      -- Exception code for violated loop invariant\n\n  Signal_exception: INTEGER = 12\n      -- Exception code for operating system signal\n\n  Eiffel_runtime_panic: INTEGER = 13\n      -- Eiffel run-time panic\n\n  Rescue_exception: INTEGER = 14\n      -- Exception code for exception in rescue clause\n\n  Out_of_memory: INTEGER = 15\n      -- Out of memory (cannot be ignored)\n\n  Resumption_failed: INTEGER = 16\n      -- Resumption failed (retry did not succeed)\n\n  Create_on_deferred: INTEGER = 17\n      -- Create on deferred\n\n  External_exception: INTEGER = 18\n      -- Exception code for operating system error\n      -- which does not set the `errno' variable\n      -- (Unix-specific)\n\n  Void_assigned_to_expanded: INTEGER = 19\n      -- Exception code for assignment of void value\n      -- to expanded entity\n\n  Exception_in_signal_handler: INTEGER = 20\n      -- Exception in signal handler\n\n  Io_exception: INTEGER = 21\n      -- Exception code for I/O error\n\n  Operating_system_exception: INTEGER = 22\n      -- Exception code for operating system error\n      -- which sets the `errno' variable\n      -- (Unix-specific)\n\n  Retrieve_exception: INTEGER = 23\n      -- Exception code for retrieval error\n      -- may be raised by `retrieved' in `IO_MEDIUM'.\n\n  Developer_exception: INTEGER = 24\n      -- Exception code for developer exception\n\n  Eiffel_runtime_fatal_error: INTEGER = 25\n      -- Eiffel run-time fatal error\n\n  Dollar_applied_to_melted_feature: INTEGER = 26\n      -- $ applied to melted feature\n\n  Runtime_io_exception: INTEGER = 27\n      -- Exception code for I/O error raised by runtime functions\n      -- such as store/retrieve, file access...\n\n  Com_exception: INTEGER = 28\n      -- Exception code for a COM error.\n\n  Runtime_check_exception: INTEGER = 29\n      -- Exception code for runtime check being violated.\n\n  old_exception: INTEGER = 30\n      -- Old exception code.\n\n  serialization_exception: INTEGER = 31\n      -- Serialization exception code.\n\n  number_of_codes: INTEGER = 31\n      -- How many codes are there to represent exceptions?\n\n  valid_code (c: INTEGER): BOOLEAN\n      -- Is `c' a valid code to represent some kind of exceptions?\n    do\n      Result := c >= 1 and c <= number_of_codes\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exception.e","content":"note\n  description: \"[\n    Ancestor of all exception classes.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-12-28 06:07:03 -0800 (Fri, 28 Dec 2012) $\"\n  revision: \"$Revision: 92098 $\"\n\nclass\n  EXCEPTION\n\ninherit\n  EXCEPTION_MANAGER_FACTORY\n    undefine\n      out\n    end\n\ncreate\n  default_create,\n  make_with_tag_and_trace\n\nfeature {NONE} -- Initialization\n\n  make_with_tag_and_trace (a_tag, a_trace_string: STRING)\n      -- Make `Current' with `description' set to `a_tag'.\n    obsolete\n      \"Use `default_create' and `set_description' instead.\"\n    require\n      tag_not_void: a_tag /= Void\n      trace_string_not_void: a_trace_string /= Void\n    do\n      set_description (a_tag)\n    ensure\n      description_set: attached description as l_des and then a_tag.same_string_general (l_des)\n    end\n\nfeature -- Raise\n\n  raise\n      -- Raise current exception\n    require\n      is_raisable: is_raisable\n    do\n      exception_manager.raise (Current)\n    end\n\nfeature -- Access\n\n  meaning: STRING\n      -- A short message describing what current exception is\n    obsolete\n      \"Use `tag' instead.\"\n    do\n      Result := tag.as_string_8\n    end\n\n  tag: IMMUTABLE_STRING_32\n      -- A short message describing what current exception is\n    once\n      create Result.make_from_string_8 (\"General exception\")\n    end\n\n  message: detachable STRING\n      -- Message of current exception\n    obsolete\n      \"Use `description' instead.\"\n    do\n      if attached c_description as l_m then\n        Result := l_m.substring (1, l_m.count)\n      end\n    end\n\n  description: detachable READABLE_STRING_GENERAL\n      -- Detailed description of current exception\n    local\n      u: UTF_CONVERTER\n      l_res: STRING_32\n    do\n      if attached c_description as l_m then\n          -- Description is encoded in UTF-8 by the runtime.\n        create l_res.make (l_m.count)\n        u.utf_8_0_subpointer_into_escaped_string_32 (l_m.managed_data, 0, l_m.count - 1, False, l_res)\n        Result := l_res\n      end\n    end\n\n  exception_trace: detachable STRING\n      -- String representation of current exception trace\n    obsolete\n      \"Use `trace' instead.\"\n    do\n      Result := internal_trace\n    end\n\n  trace: detachable STRING_32\n      -- String representation of current exception trace\n    local\n      u: UTF_CONVERTER\n    do\n      if attached internal_trace as l_trace then\n        Result := u.utf_8_string_8_to_string_32 (l_trace)\n      end\n    end\n\n  code: INTEGER\n      -- Code of the exception.\n    do\n    end\n\n  frozen original: EXCEPTION\n      -- The original exception directly triggered current exception\n    local\n      t: like throwing_exception\n    do\n      t := throwing_exception\n      if t = Current or else t = Void then\n        Result := Current\n      elseif (attached {ROUTINE_FAILURE} Current) or else (attached {OLD_VIOLATION} Current) then\n        Result := t.original\n      else\n        Result := Current\n      end\n    ensure\n      original_not_void: Result /= Void\n    end\n\n  frozen cause: EXCEPTION\n      -- The cause of current exception raised during rescue processing\n    do\n      if attached original.throwing_exception as e then\n        Result := e\n      else\n        Result := Current\n      end\n    ensure\n      cause_not_void: Result /= Void\n    end\n\n  frozen recipient_name: detachable STRING\n      -- Name of the routine whose execution was\n      -- interrupted by current exception\n\n  frozen type_name: detachable STRING\n      -- Name of the class that includes the recipient\n      -- of original form of current exception\n\n  frozen line_number: INTEGER\n      -- Line number\n\nfeature -- Access obselete\n\n  trace_as_string: detachable STRING\n      -- Exception trace represented as a string\n    obsolete\n      \"Use `trace' instead.\"\n    do\n      Result := exception_trace\n    end\n\nfeature -- Status settings\n\n  set_message (a_message: like message)\n      -- Set `message' with `a_message'.\n    obsolete\n      \"Use `set_description' instead.\"\n    do\n      set_description (a_message)\n    ensure\n      message_set: message ~ a_message\n    end\n\n  set_description (a_description: detachable READABLE_STRING_GENERAL)\n      -- Set `description' with `a_description'.\n    local\n      u: UTF_CONVERTER\n      l_upper: CELL [INTEGER]\n      l_c: like c_description\n    do\n      if a_description /= Void then\n        create l_c.make_empty (a_description.count)\n        create l_upper.put (0)\n        u.utf_32_string_into_utf_8_0_pointer (a_description, l_c.managed_data, 0, l_upper)\n        l_c.set_count (l_upper.item)\n        c_description := l_c\n      else\n        c_description := Void\n      end\n    ensure\n      description_set: (attached a_description as a_des and then attached description as l_des and then l_des.same_string (l_des)) or else\n              (a_description = Void and then description = Void)\n    end\n\nfeature -- Status report\n\n  frozen is_ignorable: BOOLEAN\n      -- Is current exception ignorable?\n    do\n      Result := exception_manager.is_ignorable (generating_type)\n    end\n\n  frozen is_raisable: BOOLEAN\n      -- Is current exception raisable by `raise'?\n    do\n      Result := exception_manager.is_raisable (generating_type)\n    end\n\n  frozen is_ignored: BOOLEAN\n      -- If set, current exception is not raised.\n    do\n      Result := exception_manager.is_ignored (generating_type)\n    ensure\n      is_ignored_implies_is_ignorable: Result implies is_ignorable\n      not_is_caught: Result = not is_caught\n    end\n\n  frozen is_caught: BOOLEAN\n      -- If set, current exception is raised.\n    do\n      Result := not is_ignored\n    ensure\n      not_is_caught_implies_is_ignorable: not Result implies is_ignorable\n      not_is_ignored: Result = not is_ignored\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    local\n      t: detachable STRING_32\n    do\n      Result := generating_type\n      t := trace\n      if t /= Void then\n        Result.append_character ('%N')\n        Result.append_string (t.as_string_8)\n      end\n    end\n\nfeature {EXCEPTION} -- Access\n\n  frozen throwing_exception: detachable EXCEPTION\n      -- The exception throwing current exception\n\nfeature {EXCEPTION_MANAGER} -- Implementation\n\n  frozen set_throwing_exception (a_exception: detachable EXCEPTION)\n      -- Set `throwing_exception' with `a_exception'.\n    do\n      throwing_exception := a_exception\n    ensure\n      throwing_exception_set: throwing_exception = a_exception\n    end\n\n  frozen set_recipient_name (a_name: like recipient_name)\n      -- Set `recipient_name' with `a_name'\n    do\n      recipient_name := a_name\n    end\n\n  frozen set_line_number (a_number: like line_number)\n      -- Set `line_number' with `a_number'.\n    do\n      line_number := a_number\n    end\n\n  frozen set_c_description (a_des: detachable STRING_8)\n      -- Set `c_description' with `a_des'. `a_des' is in UTF-8.\n    do\n      if a_des /= Void then\n        create c_description.make (a_des)\n      else\n        c_description := Void\n      end\n    end\n\n  c_description: detachable C_STRING\n      -- Message, stored as C string to keep it alive and usable by the runtime trace printing.\n\n  frozen set_type_name (a_type: like type_name)\n      -- Set `type_name' with `a_type'\n    do\n      type_name := a_type\n    end\n\n  frozen internal_is_ignorable: BOOLEAN\n      -- Internal `is_ignorable'\n\n  frozen set_exception_trace (a_trace: like exception_trace)\n      -- Set `exception_trace' with `a_trace'.\n    do\n      internal_trace := a_trace\n    end\n\n  internal_trace: detachable STRING;\n      -- String representation of the exception trace\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exception_manager.e","content":"note\n  description: \"[\n    Common exception operations and management.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  EXCEPTION_MANAGER\n\nfeature -- Access\n\n  last_exception: detachable EXCEPTION\n      -- Last exception\n    external\n      \"built_in\"\n    end\n\nfeature -- Raise\n\n  raise (a_exception: EXCEPTION)\n      -- Raise `a_exception'.\n    require\n      a_exception_not_void: a_exception /= Void\n      a_exception_is_raisable: a_exception.is_raisable\n    external\n      \"built_in\"\n    end\n\nfeature -- Status setting\n\n  ignore (a_exception: TYPE [detachable EXCEPTION])\n      -- Ignore type of `a_exception'.\n    require\n      a_exception_not_void: a_exception /= Void\n      is_ignorable: is_ignorable (a_exception)\n    external\n      \"built_in\"\n    ensure\n      is_caught: is_ignored (a_exception)\n    end\n\n  catch (a_exception: TYPE [detachable EXCEPTION])\n      -- Set type of `a_exception' `is_caught'.\n    require\n      a_exception_not_void: a_exception /= Void\n    external\n      \"built_in\"\n    ensure\n      is_ignored: not is_ignored (a_exception)\n    end\n\n  set_is_ignored (a_exception: TYPE [detachable EXCEPTION]; a_ignored: BOOLEAN)\n      -- Set type of `a_exception' to be `a_ignored'.\n    require\n      a_exception_not_void: a_exception /= Void\n      a_ignored_implies_is_ignorable: a_ignored implies is_ignorable (a_exception)\n    external\n      \"built_in\"\n    ensure\n      is_ignored_set: is_ignored (a_exception) = a_ignored\n    end\n\nfeature -- Status report\n\n  is_ignorable (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is ignorable.\n    external\n      \"built_in\"\n    end\n\n  is_raisable (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is raisable.\n    external\n      \"built_in\"\n    end\n\n  is_ignored (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is not raised.\n    external\n      \"built_in\"\n    ensure\n      not_is_caught: Result = not is_caught (a_exception)\n    end\n\n  is_caught (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is raised.\n    external\n      \"built_in\"\n    ensure\n      not_is_ignored: Result = not is_ignored (a_exception)\n    end\n\nfeature {EXCEPTIONS} -- Backward compatibility support\n\n  type_of_code (a_code: INTEGER): detachable TYPE [EXCEPTION]\n      -- Exception type of `a_code'\n    external\n      \"built_in\"\n    end\n\n  exception_from_code (a_code: INTEGER): detachable EXCEPTION\n      -- Create exception object from `a_code'\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exception_manager_factory.e","content":"note\n  description: \"[\n    Exception manager factory.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  EXCEPTION_MANAGER_FACTORY\n\nfeature -- Access\n\n  exception_manager: EXCEPTION_MANAGER\n      -- Exception manager\n    external\n      \"built_in\"\n    ensure\n      exception_manager_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exceptions.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-18 11:50:31 -0800 (Fri, 18 Jan 2013) $\"\n  revision: \"$Revision: 92126 $\"\n\nclass EXCEPTIONS\n\ninherit\n  EXCEP_CONST\n\n  EXCEPTION_MANAGER_FACTORY\n\nfeature -- Status report\n\n  meaning (except: INTEGER): detachable STRING\n      -- A message in English describing what `except' is\n    do\n      if attached exception_manager.exception_from_code (except) as l_exception then\n        Result := l_exception.tag.as_string_8\n      end\n    end\n\n  assertion_violation: BOOLEAN\n      -- Is last exception originally due to a violated\n      -- assertion or non-decreasing variant?\n    do\n      Result := attached exception_manager.last_exception as l_exception and then\n            attached {ASSERTION_VIOLATION} l_exception.original\n    end\n\n  is_developer_exception: BOOLEAN\n      -- Is the last exception originally due to\n      -- a developer exception?\n    do\n      Result := attached exception_manager.last_exception as l_exception and then\n            attached {DEVELOPER_EXCEPTION} l_exception.original\n    end\n\n  is_developer_exception_of_name (name: detachable STRING): BOOLEAN\n      -- Is the last exception originally due to a developer\n      -- exception of name `name'?\n    do\n      if is_developer_exception then\n        Result := developer_exception_name ~ name\n      end\n    end\n\n  developer_exception_name: detachable STRING\n      -- Name of last developer-raised exception\n    require\n      applicable: is_developer_exception\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.original.description as l_des then\n        Result := l_des.as_string_8\n      end\n    end\n\n  is_signal: BOOLEAN\n      -- Is last exception originally due to an external\n      -- event (operating system signal)?\n    do\n      Result := attached exception_manager.last_exception as l_exception and then\n            attached {OPERATING_SYSTEM_SIGNAL_FAILURE} l_exception.original\n    end\n\n  is_system_exception: BOOLEAN\n      -- Is last exception originally due to an\n      -- external event (operating system error)?\n    do\n      if\n        attached exception_manager.last_exception as l_exception and\n        attached exception_manager.exception_from_code (external_exception) as l_external\n      then\n        Result := l_exception.original.conforms_to (l_external) or else\n            attached {OPERATING_SYSTEM_FAILURE} l_exception.original\n      end\n    end\n\n  tag_name: detachable STRING\n      -- Tag of last violated assertion clause\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.description as l_des then\n        Result := l_des.as_string_8\n      end\n    end\n\n  recipient_name: detachable STRING\n      -- Name of the routine whose execution was\n      -- interrupted by last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.recipient_name\n      end\n    end\n\n  class_name: detachable STRING\n      -- Name of the class that includes the recipient\n      -- of original form of last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.type_name\n      end\n    end\n\n  exception: INTEGER\n      -- Code of last exception that occurred\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.code\n      end\n    end\n\n  exception_trace: detachable STRING\n      -- String representation of the exception trace\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.original.trace as l_trace then\n        Result := l_trace.as_string_8\n      end\n    end\n\n  original_tag_name: detachable STRING\n      -- Assertion tag for original form of last\n      -- assertion violation.\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.cause.original.description as l_des then\n        Result := l_des.as_string_8\n      end\n    end\n\n  original_exception: INTEGER\n      -- Original code of last exception that triggered\n      -- current exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.cause.original.code\n      end\n    end\n\n  original_recipient_name: detachable STRING\n      -- Name of the routine whose execution was\n      -- interrupted by original form of last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.cause.original.recipient_name\n      end\n    end\n\n  original_class_name: detachable STRING\n      -- Name of the class that includes the recipient\n      -- of original form of last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.cause.original.type_name\n      end\n    end\n\nfeature -- Status setting\n\n  catch (code: INTEGER)\n      -- Make sure that any exception of code `code' will be\n      -- caught. This is the default.\n    do\n      if attached exception_manager.type_of_code (code) as l_type then\n        exception_manager.catch (l_type)\n      end\n    end\n\n  ignore (code: INTEGER)\n      -- Make sure that any exception of code `code' will be\n      -- ignored. This is not the default.\n    do\n      if attached exception_manager.type_of_code (code) as l_type then\n        exception_manager.ignore (l_type)\n      end\n    end\n\n  raise (name: detachable STRING)\n      -- Raise a developer exception of name `name'.\n    local\n      l_exception: DEVELOPER_EXCEPTION\n    do\n      create l_exception\n      l_exception.set_description (name)\n      l_exception.raise\n    end\n\n  raise_retrieval_exception (name: detachable STRING)\n      -- Raise a retrieval exception of name `name'.\n    do\n      if attached exception_manager.exception_from_code (serialization_exception) as l_exception then\n        l_exception.set_description (name)\n        l_exception.raise\n      end\n    end\n\n  die (code: INTEGER)\n      -- Terminate execution with exit status `code',\n      -- without triggering an exception.\n    external\n      \"C use %\"eif_except.h%\"\"\n    alias\n      \"esdie\"\n    ensure\n      False\n    end\n\n  new_die (code: INTEGER) obsolete \"Use ``die''\"\n      -- Terminate execution with exit status `code',\n      -- without triggering an exception.\n    external\n      \"C use %\"eif_except.h%\"\"\n    alias\n      \"esdie\"\n    ensure\n      False\n    end\n\n  message_on_failure\n      -- Print an exception history table\n      -- in case of failure.\n      -- This is the default.\n    do\n      c_trace_exception (True)\n    end\n\n  no_message_on_failure\n      -- Do not print an exception history table\n      -- in case of failure.\n    do\n      c_trace_exception (False)\n    end\n\nfeature {NONE} -- Implementation\n\n  c_trace_exception (b: BOOLEAN)\n    external\n      \"C use %\"eif_except.h%\"\"\n    alias\n      \"eetrace\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"finite.e","content":"note\n  description: \"Structures with a finite item count\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: finite, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class FINITE [G] inherit\n\n  BOX [G]\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of items\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    do\n      Result := (count = 0)\n    end\n\ninvariant\n  empty_definition: is_empty = (count = 0)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"function.e","content":"note\n  description: \"[\n    Objects representing delayed calls to a function,\n    with some arguments possibly still open.\n\n    Note: Features are the same as those of ROUTINE,\n      with `apply' made effective, and the addition\n      of `last_result' and `item'.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-28 14:35:23 -0800 (Tue, 28 Jan 2014) $\"\n  revision: \"$Revision: 94109 $\"\n\nclass\n  FUNCTION [BASE_TYPE -> detachable ANY, OPEN_ARGS -> detachable TUPLE create default_create end, RESULT_TYPE]\n\ninherit\n  ROUTINE [BASE_TYPE, OPEN_ARGS]\n    redefine\n      is_equal, copy\n    end\n\ncreate {NONE}\n  set_rout_disp\n\nfeature -- Access\n\n  last_result: detachable RESULT_TYPE\n      -- Result of last call, if any\n\n  call (args: detachable separate OPEN_ARGS)\n      -- <Precursor>\n    do\n      last_result := item (args)\n    end\n\n  item alias \"()\" (args: detachable separate OPEN_ARGS): RESULT_TYPE\n      -- Result of calling function with `args' as operands.\n    require\n      valid_operands: valid_operands (args)\n    local\n      l_closed_count: INTEGER\n      c: like closed_operands\n    do\n      c := closed_operands\n      if c/= Void then\n        l_closed_count :=  c.count\n      end\n      Result := fast_item (encaps_rout_disp, calc_rout_addr, $closed_operands, $args, routine_id,\n        is_basic, written_type_id_inline_agent, l_closed_count, open_count, $open_map)\n    end\n\n  apply\n      -- Call function with `operands' as last set.\n    do\n      last_result := item (operands)\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is associated function the same as the one\n      -- associated with `other'?\n    do\n      Result := Precursor (other) and then (last_result ~ other.last_result)\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Use same function as `other'.\n    do\n      if other /= Current then\n        Precursor (other)\n        last_result := other.last_result\n      end\n    end\n\nfeature -- Obsolete\n\n  eval (args: detachable OPEN_ARGS): RESULT_TYPE\n      -- Result of evaluating function for `args'.\n    obsolete\n      \"Please use `item' instead\"\n    require\n      valid_operands: valid_operands (args)\n    do\n      Result := item (args)\n    end\n\nfeature -- Removal\n\n  clear_last_result\n      -- Reset content of `last_result' to its default value.\n    local\n      l_result: detachable RESULT_TYPE\n    do\n      last_result := l_result\n    end\n\nfeature -- Extended operations\n\n  flexible_item (a: detachable separate TUPLE): RESULT_TYPE\n      -- Result of calling function with `a' as arguments.\n      -- Compared to `item' the type of `a' may be different from `{OPEN_ARGS}'.\n    require\n      valid_operands: valid_operands (a)\n    local\n      default_arguments: detachable OPEN_ARGS\n    do\n      if not attached a then\n        Result := item (default_arguments)\n      else\n        -- TODO: Implement in JavaScript\n        -- check\n        --   from_precondition: attached {OPEN_ARGS} new_tuple_from_tuple (({OPEN_ARGS}).type_id, a) as x\n        -- then\n        --   Result := item (x)\n        -- end\n      end\n    end\n\nfeature {NONE} -- Implementation\n\n  fast_item (a_rout_disp, a_calc_rout_addr: POINTER\n           a_closed_operands: POINTER; a_operands: POINTER\n         a_routine_id: INTEGER; a_is_basic: BOOLEAN; a_class_id_inline_agent: INTEGER;\n         a_closed_count, a_open_count: INTEGER; a_open_map: POINTER): RESULT_TYPE\n    external\n      \"C inline use %\"eif_rout_obj.h%\"\"\n    alias\n      \"[\n      #ifdef WORKBENCH\n        $$_result_type result;\n        if ($a_rout_disp != 0) {\n          return (FUNCTION_CAST(EIF_TYPED_VALUE, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n            $a_calc_rout_addr, $a_closed_operands, $a_operands).$$_result_value;\n        } else {\n          rout_obj_call_function_dynamic (\n            $a_routine_id,\n            $a_is_basic,\n            $a_class_id_inline_agent,\n            $a_closed_operands,\n            $a_closed_count,\n            $a_operands,\n            $a_open_count,\n            $a_open_map,\n            &result);\n          return result;\n        }\n      #else\n        return (FUNCTION_CAST($$_result_type, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n          $a_calc_rout_addr, $a_closed_operands, $a_operands);\n      #endif\n      ]\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"hash_table.e","content":"note\n  description: \"Hash tables, used to store items identified by hashable keys\"\n  library: \"Free implementation of ELKS library\"\n  instructions: \"See instructions at the end of the class.\"\n  warning: \"[\n    Modifying an object used as a key by an item present in a table will\n    cause incorrect behavior. If you will be modifying key objects,\n    pass a clone, not the object itself, as key argument to\n    `put' and `replace_key'.\n    ]\"\n\nclass HASH_TABLE [G, K -> detachable HASHABLE] inherit\n\n  UNBOUNDED [detachable G]\n    rename\n      has as has_item\n    redefine\n      has_item, copy, is_equal\n    end\n\n  TABLE [detachable G, K]\n    rename\n      has as has_item,\n      extend as collection_extend\n    export\n      {NONE} prune_all\n    redefine\n      copy, is_equal, wipe_out, has_item\n    end\n\n  TABLE_ITERABLE [G, K]\n    redefine\n      copy, is_equal\n    end\n\n  READABLE_INDEXABLE [G]\n    rename\n      item as iteration_item,\n      valid_index as valid_iteration_index,\n      index_set as iteration_index_set\n    redefine\n      copy, is_equal, new_cursor\n    end\n\n  MISMATCH_CORRECTOR\n    export\n      {NONE} all\n      {ANY} mismatch_information\n    undefine\n      copy, is_equal\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_equal\n\nfeature -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate hash table for at least `n' items.\n      -- The table will be resized automatically\n      -- if more than `n' items are inserted.\n    require\n      n_non_negative: n >= 0\n    local\n      clever: PRIMES\n      l_default_value: detachable G\n      l_default_key: detachable K\n      l_size: INTEGER\n    do\n      create clever\n      l_size := n.Max (minimum_capacity)\n      l_size := l_size + l_size // 2 + 1\n      l_size := clever.higher_prime (l_size)\n      capacity := l_size\n          -- Position `capacity' ignored by hash sequences,\n          -- used to store value for default key.\n      create content.make_empty (n + 1)\n      create keys.make_empty (n + 1)\n      create deleted_marks.make_filled (False, n + 1)\n      create indexes_map.make_filled (ht_impossible_position, l_size + 1)\n      iteration_position := n + 1\n      count := 0\n      deleted_item_position := ht_impossible_position\n      control := 0\n      found_item := l_default_value\n      has_default := False\n      item_position := 0\n      ht_lowest_deleted_position := ht_max_position\n      ht_deleted_item := l_default_value\n      ht_deleted_key := l_default_key\n    ensure\n      breathing_space: n < capacity\n      more_than_minimum: capacity > minimum_capacity\n      no_status: not special_status\n    end\n\n  make_equal (n: INTEGER)\n      -- Allocate hash table for at least `n' items.\n      -- The table will be resized automatically\n      -- if more than `n' items are inserted.\n      -- Use `~' to compare items.\n    require\n      n_non_negative: n >= 0\n    do\n      make (n)\n      compare_objects\n    ensure\n      breathing_space: n < capacity\n      more_than_minimum: capacity > minimum_capacity\n      no_status: not special_status\n      compare_objects: object_comparison\n    end\n\n  accommodate (n: INTEGER)\n      -- Reallocate table with enough space for `n' items;\n      -- keep all current items.\n    require\n      n >= 0\n    local\n      i, nb: INTEGER\n      new_table: like Current\n      l_content: like content\n      l_keys: like keys\n    do\n      from\n        new_table := empty_duplicate (keys.count.max (n))\n        l_content := content\n        l_keys := keys\n        nb := l_keys.count\n      until\n        i = nb\n      loop\n        if occupied (i) then\n          new_table.put (l_content.item (i), l_keys.item (i))\n        end\n        i := i + 1\n      end\n      if has_default then\n        i := indexes_map.item (capacity)\n        new_table.put (l_content.item (i), keys.item (i))\n      end\n\n      set_content (new_table.content)\n      set_keys (new_table.keys)\n      set_deleted_marks (new_table.deleted_marks)\n      set_indexes_map (new_table.indexes_map)\n      capacity := new_table.capacity\n      iteration_position := new_table.iteration_position\n    ensure\n      count_not_changed: count = old count\n      breathing_space: count < capacity\n    end\n\nfeature -- Access\n\n  found_item: detachable G\n      -- Item, if any, yielded by last search operation\n\n  item alias \"[]\", at alias \"@\" (key: K): detachable G assign force\n      -- Item associated with `key', if present\n      -- otherwise default value of type `G'.\n    local\n      l_default_key: detachable K\n      hash_value, increment, l_pos, l_item_pos, l_capacity: INTEGER\n      l_first_deleted_position: INTEGER\n      stop: INTEGER\n      l_keys: like keys\n      l_indexes: like indexes_map\n      l_deleted_marks: like deleted_marks\n      l_key: K\n    do\n      l_first_deleted_position := ht_impossible_position\n      if key = l_default_key or key = Void then\n        if has_default then\n          Result := content.item (indexes_map.item (capacity))\n        end\n      else\n        from\n          l_keys := keys\n          l_indexes := indexes_map\n          l_deleted_marks := deleted_marks\n          l_capacity := capacity\n          stop := l_capacity\n          hash_value := hash_code_of (key)\n          increment := 1 + hash_value \\\\ (l_capacity - 1)\n          l_item_pos := (hash_value \\\\ l_capacity) - increment\n        until\n          stop = 0\n        loop\n            -- Go to next increment.\n          l_item_pos := (l_item_pos + increment) \\\\ l_capacity\n          l_pos := l_indexes [l_item_pos]\n          if l_pos >= 0 then\n            l_key := l_keys.item (l_pos)\n            debug (\"detect_hash_table_catcall\")\n              check\n                catcall_detected: l_key /= Void and then l_key.same_type (key)\n              end\n            end\n            if same_keys (l_key, key) then\n                -- We found our item\n              stop := 1\n              Result := content.item (l_pos)\n            end\n          elseif l_pos = ht_impossible_position then\n            stop := 1\n          elseif l_first_deleted_position = ht_impossible_position then\n            l_pos := -l_pos + ht_deleted_position\n            check l_pos_valid: l_pos < l_deleted_marks.count end\n            if not l_deleted_marks [l_pos] then\n              stop := 1\n            else\n              l_first_deleted_position := l_item_pos\n            end\n          end\n          stop := stop - 1\n        end\n      end\n    ensure then\n      default_value_if_not_present:\n        (not (has (key))) implies (Result = computed_default_value)\n    end\n\n  has (key: K): BOOLEAN\n      -- Is there an item in the table with key `key'?\n    local\n      l_default_key: detachable K\n      hash_value, increment, l_pos, l_item_pos, l_capacity: INTEGER\n      l_first_deleted_position: INTEGER\n      stop: INTEGER\n      l_keys: like keys\n      l_indexes: like indexes_map\n      l_deleted_marks: like deleted_marks\n      l_key: K\n    do\n      l_first_deleted_position := ht_impossible_position\n      if key = l_default_key or key = Void then\n        if has_default then\n          Result := True\n        end\n      else\n        from\n          l_keys := keys\n          l_indexes := indexes_map\n          l_deleted_marks := deleted_marks\n          l_capacity := capacity\n          stop := l_capacity\n          hash_value := hash_code_of (key)\n          increment := 1 + hash_value \\\\ (l_capacity - 1)\n          l_item_pos := (hash_value \\\\ l_capacity) - increment\n        until\n          stop = 0\n        loop\n            -- Go to next increment.\n          l_item_pos := (l_item_pos + increment) \\\\ l_capacity\n          l_pos := l_indexes [l_item_pos]\n          if l_pos >= 0 then\n            l_key := l_keys.item (l_pos)\n            debug (\"detect_hash_table_catcall\")\n              check\n                catcall_detected: l_key /= Void and then l_key.same_type (key)\n              end\n            end\n            if same_keys (l_key, key) then\n                -- We found our item\n              stop := 1\n              Result := True\n            end\n          elseif l_pos = ht_impossible_position then\n            stop := 1\n          elseif l_first_deleted_position = ht_impossible_position then\n            l_pos := -l_pos + ht_deleted_position\n            check l_pos_valid: l_pos < l_deleted_marks.count end\n            if not l_deleted_marks [l_pos] then\n              stop := 1\n            else\n              l_first_deleted_position := l_item_pos\n            end\n          end\n          stop := stop - 1\n        end\n      end\n    ensure then\n      default_case: (key = computed_default_key) implies (Result = has_default)\n    end\n\n  has_key (key: K): BOOLEAN\n      -- Is there an item in the table with key `key'? Set `found_item' to the found item.\n    local\n      old_position: INTEGER\n      l_default_value: detachable G\n    do\n      old_position := item_position\n      internal_search (key)\n      Result := found\n      if Result then\n        found_item := content.item (position)\n      else\n        found_item := l_default_value\n      end\n      item_position := old_position\n    ensure then\n      default_case: (key = computed_default_key) implies (Result = has_default)\n      found: Result = found\n      item_if_found: found implies (found_item = item (key))\n    end\n\n  has_item (v: detachable G): BOOLEAN\n      -- Does structure include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_content: like content\n    do\n      if has_default then\n        Result := (v = content.item (indexes_map.item (capacity)))\n      end\n      if not Result then\n        l_content := content\n        nb := l_content.count\n        if object_comparison then\n          from\n          until\n            i = nb or else Result\n          loop\n            Result := occupied (i) and then (v ~ l_content.item (i))\n            i := i + 1\n          end\n        else\n          from\n          until\n            i = nb or else Result\n          loop\n            Result := occupied (i) and then (v = l_content.item (i))\n            i := i + 1\n          end\n        end\n      end\n    end\n\n  current_keys: ARRAY [K]\n      -- New array containing actually used keys, from 1 to `count'\n    local\n      j: INTEGER\n      old_iteration_position: INTEGER\n    do\n      if is_empty then\n        create Result.make_empty\n      else\n        old_iteration_position := iteration_position\n        from\n          start\n          create Result.make_filled (key_for_iteration, 1, count)\n          j := 1\n          forth\n        until\n          off\n        loop\n          j := j + 1\n          Result.put (key_for_iteration, j)\n          forth\n        end\n        iteration_position := old_iteration_position\n      end\n    ensure\n      good_count: Result.count = count\n    end\n\n  item_for_iteration: G\n      -- Element at current iteration position\n    require\n      not_off: not off\n    do\n      Result := content.item (iteration_position)\n    end\n\n  key_for_iteration: K\n      -- Key at current iteration position\n    require\n      not_off: not off\n    do\n      Result := keys.item (iteration_position)\n    end\n\n  cursor: CURSOR\n      -- Current cursor position\n    do\n      create {HASH_TABLE_CURSOR} Result.make (iteration_position)\n    ensure\n      cursor_not_void: Result /= Void\n    end\n\n  new_cursor: HASH_TABLE_ITERATION_CURSOR [G, K]\n      -- <Precursor>\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\n  iteration_item (i: INTEGER): G\n      -- <Precursor>\n    do\n      Result := content.item (i)\n    end\n\n  hash_code_of (a_key: attached K): INTEGER\n      -- Hash_code value associated to `a_key'.\n    do\n        -- Default implementation uses `{HASHABLE}.hash_code'.\n      Result := a_key.hash_code\n    ensure\n      non_negative: Result >= 0\n    end\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of items in table\n\n  capacity: INTEGER\n      -- Number of items that may be stored.\n\n  occurrences (v: detachable G): INTEGER\n      -- Number of table items equal to `v'.\n    local\n      old_iteration_position: INTEGER\n    do\n      old_iteration_position := iteration_position\n      if object_comparison then\n        from\n          start\n        until\n          off\n        loop\n          if item_for_iteration ~ v then\n            Result := Result + 1\n          end\n          forth\n        end\n      else\n        from\n          start\n        until\n          off\n        loop\n          if item_for_iteration = v then\n            Result := Result + 1\n          end\n          forth\n        end\n      end\n      iteration_position := old_iteration_position\n    end\n\n  iteration_index_set: INTEGER_INTERVAL\n      -- <Precursor>\n    do\n      create Result.make (next_iteration_position (-1), previous_iteration_position (keys.count))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Does table contain the same information as `other'?\n    do\n      if\n        count = other.count and then\n        object_comparison = other.object_comparison and then\n        has_default = other.has_default\n      then\n        Result := True\n        across\n          Current as l_c\n        until\n          not Result\n        loop\n          other.search (l_c.key)\n          if other.found then\n            if object_comparison then\n              Result := l_c.item ~ other.found_item\n            else\n              Result := l_c.item = other.found_item\n            end\n          else\n            Result := False\n          end\n        end\n      end\n    end\n\n  same_keys (a_search_key, a_key: K): BOOLEAN\n      -- Does `a_search_key' equal to `a_key'?\n      --| Default implementation is using ~.\n    require\n      valid_search_key: valid_key (a_search_key)\n      valid_key: valid_key (a_key)\n    do\n      Result := a_search_key ~ a_key\n    end\n\n  disjoint (other: HASH_TABLE [G, K]): BOOLEAN\n      -- Is `Current' and `other' disjoint on their keys?\n      -- Use `same_keys' for comparison.\n    do\n        -- If any of the tables are empty, it is clearly disjoint,\n        -- otherwise we check that no elements of `other' appears in Current.\n      Result := is_empty or else other.is_empty or else\n        not across other as o some has (o.key) end\n    end\n\nfeature -- Status report\n\n  full: BOOLEAN = False\n      -- Is structure filled to capacity?\n\n  extendible: BOOLEAN = False\n      -- May new items be added?\n\n  prunable: BOOLEAN\n      -- May items be removed?\n    do\n      Result := True\n    end\n\n  conflict: BOOLEAN\n      -- Did last operation cause a conflict?\n    do\n      Result := (control = conflict_constant)\n    end\n\n  inserted: BOOLEAN\n      -- Did last operation insert an item?\n    do\n      Result := (control = inserted_constant)\n    end\n\n  replaced: BOOLEAN\n      -- Did last operation replace an item?\n    do\n      Result := (control = replaced_constant)\n    end\n\n  removed: BOOLEAN\n      -- Did last operation remove an item?\n    do\n      Result := (control = removed_constant)\n    end\n\n  found: BOOLEAN\n      -- Did last operation find the item sought?\n    do\n      Result := (control = found_constant)\n    end\n\n  not_found: BOOLEAN\n      -- Did last operation fail to find the item sought?\n    do\n      Result := (control = not_found_constant)\n    end\n\n  after, off: BOOLEAN\n      -- Is cursor past last item?\n    do\n      Result := is_off_position (iteration_position)\n    end\n\n  valid_cursor (c: CURSOR): BOOLEAN\n      -- Can cursor be moved to position `c'?\n    require\n      c_not_void: c /= Void\n    local\n      i: INTEGER\n    do\n      if attached {HASH_TABLE_CURSOR} c as ht_cursor then\n        i := ht_cursor.position\n        Result := is_off_position (i) or else truly_occupied (i)\n      end\n    end\n\n  valid_key (k: K): BOOLEAN\n      -- Is `k' a valid key?\n    do\n      Result := True\n      debug (\"prevent_hash_table_catcall\")\n          -- If `K' is expanded then there will be no catcall.\n          -- If `K' is a reference, we make sure that the type of the object `k'\n          -- is the detachable version of `K' as objects have the detachable type by default.\n        if not ({K}).is_expanded and then attached k then\n          Result := k.generating_type ~ {detachable K}\n        end\n      end\n    end\n\n  valid_iteration_index (i: INTEGER): BOOLEAN\n      -- <Precursor>\n    do\n      Result := truly_occupied (i)\n    end\n\nfeature -- Cursor movement\n\n  start\n      -- Bring cursor to first position.\n    do\n        -- Get lower bound of iteration if any.\n      iteration_position := next_iteration_position (-1)\n    end\n\n  forth\n      -- Advance cursor to next occupied position,\n      -- or `off' if no such position remains.\n    require\n      not_off: not off\n    do\n      iteration_position := next_iteration_position (iteration_position)\n    end\n\n  go_to (c: CURSOR)\n      -- Move to position `c'.\n    require\n      c_not_void: c /= Void\n      valid_cursor: valid_cursor (c)\n    do\n      if attached {HASH_TABLE_CURSOR} c as ht_cursor then\n        iteration_position := ht_cursor.position\n      end\n    end\n\n  search (key: K)\n      -- Search for item of key `key'.\n      -- If found, set `found' to true, and set\n      -- `found_item' to item associated with `key'.\n    local\n      old_position: INTEGER\n      l_default_value: detachable G\n    do\n      old_position := item_position\n      internal_search (key)\n      if found then\n        found_item := content.item (position)\n      else\n        found_item := l_default_value\n      end\n      item_position := old_position\n    ensure\n      found_or_not_found: found or not_found\n      item_if_found: found implies (found_item = item (key))\n    end\n\n  search_item: detachable G\n    obsolete\n      \"Use found_item instead.\"\n    do\n      Result := found_item\n    end\n\nfeature {HASH_TABLE_ITERATION_CURSOR} -- Cursor movement\n\n  next_iteration_position (a_position: like iteration_position): like iteration_position\n      -- Given an iteration position, advanced to the next one taking into account deleted\n      -- slots in the `content' and `keys' structures.\n    require\n      a_position_big_enough: a_position >= -1\n      a_position_small_enough: a_position < keys.count\n    local\n      l_deleted_marks: like deleted_marks\n      l_table_size: INTEGER\n    do\n      Result := a_position + 1\n      l_deleted_marks := deleted_marks\n      l_table_size := content.count\n      from\n      until\n        Result >= l_table_size or else not l_deleted_marks.item (Result)\n      loop\n        Result := Result + 1\n      end\n    end\n\n  previous_iteration_position (a_position: like iteration_position): like iteration_position\n      -- Given an iteration position, go to the previous one taking into account deleted\n      -- slots in the `content' and `keys' structures.\n    require\n      a_position_big_enough: a_position >= 0\n      a_position_small_enough: a_position <= keys.count\n    local\n      l_deleted_marks: like deleted_marks\n    do\n      l_deleted_marks := deleted_marks\n      from\n        Result := a_position - 1\n      until\n        Result <= 0 or else not l_deleted_marks.item (Result)\n      loop\n        Result := Result - 1\n      end\n    end\n\nfeature -- Element change\n\n  put (new: G; key: K)\n      -- Insert `new' with `key' if there is no other item\n      -- associated with the same key.\n      -- Set `inserted' if and only if an insertion has\n      -- been made (i.e. `key' was not present).\n      -- If so, set `position' to the insertion position.\n      -- If not, set `conflict'.\n      -- In either case, set `found_item' to the item\n      -- now associated with `key' (previous item if\n      -- there was one, `new' otherwise).\n      --\n      -- To choose between various insert/replace procedures,\n      -- see `instructions' in the Indexing clause.\n    local\n      l_default_key: detachable K\n      l_new_pos, l_new_index_pos: like position\n    do\n      internal_search (key)\n      if found then\n        set_conflict\n        found_item := content.item (position)\n      else\n        if soon_full then\n          add_space\n          internal_search (key)\n          check\n              -- The key didn't magically insert itself.\n            not_present: not found\n          end\n        end\n        if deleted_item_position /= ht_impossible_position then\n          l_new_pos := deleted_position (deleted_item_position)\n          l_new_index_pos := deleted_item_position\n          deleted_marks.force (False, l_new_pos)\n        else\n          l_new_pos := keys.count\n          l_new_index_pos := item_position\n        end\n        indexes_map.put (l_new_pos, l_new_index_pos)\n        content.force (new, l_new_pos)\n        keys.force (key, l_new_pos)\n        if key = l_default_key then\n          has_default := True\n        end\n        count := count + 1\n        found_item := new\n        control := inserted_constant\n      end\n    ensure then\n      conflict_or_inserted: conflict or inserted\n      insertion_done: inserted implies item (key) = new\n      now_present: inserted implies has (key)\n      one_more_if_inserted: inserted implies (count = old count + 1)\n      unchanged_if_conflict: conflict implies (count = old count)\n      same_item_if_conflict: conflict implies (item (key) = old (item (key)))\n      found_item_associated_with_key: found_item = item (key)\n      new_item_if_inserted: inserted implies (found_item = new)\n      old_item_if_conflict: conflict implies (found_item = old (item (key)))\n      default_property:\n        has_default =\n          ((inserted and (key = computed_default_key)) or\n            ((conflict or (key /= computed_default_key))\n              and (old has_default)))\n    end\n\n  force (new: G; key: K)\n      -- Update table so that `new' will be the item associated\n      -- with `key'.\n      -- If there was an item for that key, set `found'\n      -- and set `found_item' to that item.\n      -- If there was none, set `not_found' and set\n      -- `found_item' to the default value.\n      --\n      -- To choose between various insert/replace procedures,\n      -- see `instructions' in the Indexing clause.\n    local\n      l_default_key: detachable K\n      l_default_value: detachable G\n      l_new_pos, l_new_index_pos: like position\n    do\n      internal_search (key)\n      if not_found then\n        if soon_full then\n          add_space\n          internal_search (key)\n        end\n        if deleted_item_position /= ht_impossible_position then\n          l_new_pos := deleted_position (deleted_item_position)\n          l_new_index_pos := deleted_item_position\n          deleted_marks.force (False, l_new_pos)\n        else\n          l_new_pos := keys.count\n          l_new_index_pos := item_position\n        end\n        indexes_map.put (l_new_pos, l_new_index_pos)\n        keys.force (key, l_new_pos)\n        if key = l_default_key then\n          has_default := True\n        end\n        count := count + 1\n        found_item := l_default_value\n      else\n        l_new_pos := position\n        found_item := content.item (l_new_pos)\n      end\n      content.force (new, l_new_pos)\n    ensure then\n      insertion_done: item (key) = new\n      now_present: has (key)\n      found_or_not_found: found or not_found\n      not_found_if_was_not_present: not_found = not (old has (key))\n      same_count_or_one_more: (count = old count) or (count = old count + 1)\n      found_item_is_old_item: found implies (found_item = old (item (key)))\n      default_value_if_not_found:\n        not_found implies (found_item = computed_default_value)\n          -- The reverse is not true, as we can always insert\n          -- an item with the default value, for any key.\n\n      default_property:\n        has_default =\n          ((key = computed_default_key) or\n            ((key /= computed_default_key) and (old has_default)))\n    end\n\n  extend (new: G; key: K)\n      -- Assuming there is no item of key `key',\n      -- insert `new' with `key'.\n      -- Set `inserted'.\n      --\n      -- To choose between various insert/replace procedures,\n      -- see `instructions' in the Indexing clause.\n    require\n      not_present: not has (key)\n    local\n      l_default_key: detachable K\n      l_new_pos, l_new_index_pos: like position\n    do\n      search_for_insertion (key)\n      if soon_full then\n        add_space\n        search_for_insertion (key)\n      end\n      if deleted_item_position /= ht_impossible_position then\n        l_new_pos := deleted_position (deleted_item_position)\n        l_new_index_pos := deleted_item_position\n        deleted_marks.force (False, l_new_pos)\n      else\n        l_new_pos := keys.count\n        l_new_index_pos := item_position\n      end\n      indexes_map.put (l_new_pos, l_new_index_pos)\n      content.force (new, l_new_pos)\n      keys.force (key, l_new_pos)\n      if key = l_default_key then\n        has_default := True\n      end\n      count := count + 1\n      control := inserted_constant\n    ensure\n      inserted: inserted\n      insertion_done: item (key) = new\n      one_more: count = old count + 1\n      default_property:\n        has_default =\n          ((key = computed_default_key) or (old has_default))\n    end\n\n  replace (new: G; key: K)\n      -- Replace item at `key', if present,\n      -- with `new'; do not change associated key.\n      -- Set `replaced' if and only if a replacement has been made\n      -- (i.e. `key' was present); otherwise set `not_found'.\n      -- Set `found_item' to the item previously associated\n      -- with `key' (default value if there was none).\n      --\n      -- To choose between various insert/replace procedures,\n      -- see `instructions' in the Indexing clause.\n    local\n      l_default_item: detachable G\n    do\n      internal_search (key)\n      if found then\n        found_item := content.item (position)\n        content.put (new, position)\n        control := replaced_constant\n      else\n        found_item := l_default_item\n      end\n    ensure\n      replaced_or_not_found: replaced or not_found\n      insertion_done: replaced implies item (key) = new\n      no_change_if_not_found: not_found implies\n            item (key) = old (item (key))\n      found_item_is_old_item: found_item = old (item (key))\n    end\n\n  replace_key (new_key: K; old_key: K)\n      -- If there is an item of key `old_key' and no item of key\n      -- `new_key', replace the former's key by `new_key',\n      -- set `replaced', and set `found_item' to the item\n      -- previously associated with `old_key'.\n      -- Otherwise set `not_found' or `conflict' respectively.\n      -- If `conflict', set `found_item' to the item previously\n      -- associated with `new_key'.\n      --\n      -- To choose between various insert/replace procedures,\n      -- see `instructions' in the Indexing clause.\n    local\n      l_item: G\n    do\n      internal_search (new_key)\n      if not found then\n        internal_search (old_key)\n        if found then\n          l_item := content.item (position)\n          remove (old_key)\n          put (l_item, new_key)\n          control := replaced_constant\n        end\n      else\n        set_conflict\n        found_item := content.item (position)\n      end\n    ensure\n      same_count: count = old count\n      replaced_or_conflict_or_not_found: replaced or conflict or not_found\n      old_absent: (replaced and not same_keys (new_key, old_key)) implies (not has (old_key))\n      new_present: (replaced or conflict) = has (new_key)\n      new_item: replaced implies (item (new_key) = old (item (old_key)))\n      not_found_implies_no_old_key: not_found implies old (not has (old_key))\n      conflict_iff_already_present: conflict = old (has (new_key))\n      not_inserted_if_conflict: conflict implies\n            (item (new_key) = old (item (new_key)))\n    end\n\n  merge (other: HASH_TABLE [G, K])\n      -- Merge `other' into Current. If `other' has some elements\n      -- with same key as in `Current', replace them by one from\n      -- `other'.\n    require\n      other_not_void: other /= Void\n    do\n      from\n        other.start\n      until\n        other.after\n      loop\n        force (other.item_for_iteration, other.key_for_iteration)\n        other.forth\n      end\n    ensure\n      inserted: other.current_keys.linear_representation.for_all (agent has)\n    end\n\nfeature -- Removal\n\n  remove (key: K)\n      -- Remove item associated with `key', if present.\n      -- Set `removed' if and only if an item has been\n      -- removed (i.e. `key' was present);\n      -- if so, set `position' to index of removed element.\n      -- If not, set `not_found'.\n      -- Reset `found_item' to its default value if `removed'.\n    local\n      l_default_key: detachable K\n      l_default_value: detachable G\n      l_pos: like position\n      l_nb_removed_items: INTEGER\n    do\n      internal_search (key)\n      if found then\n        l_pos := position\n        if key = l_default_key then\n          has_default := False\n        end\n        deleted_marks.put (True, l_pos)\n        indexes_map.put (-l_pos + ht_deleted_position, item_position)\n        if iteration_position = l_pos then\n          forth\n        end\n        count := count - 1\n          -- For void-safety concerns and to avoid leaking too many objects,\n          -- we set all deleted positions to the same item and key when removing\n          -- on the inside of the SPECIALs, otherwise we simply shrink the SPECIALs.\n        ht_lowest_deleted_position := l_pos.min (ht_lowest_deleted_position)\n        if (ht_lowest_deleted_position = count) then\n            -- We have removed all elements above `ht_lowest_deleted_position', we can\n            -- shrink our SPECIALs.\n          l_nb_removed_items := content.count - ht_lowest_deleted_position\n          content.remove_tail (l_nb_removed_items)\n          keys.remove_tail (l_nb_removed_items)\n            -- All elements above `ht_lowest_deleted_position' of `deleted_marks' are reset\n            -- to False. To be correct, we should also reset their corresponding indexes\n            -- in `indexes_map' to `ht_impossible_position' however that would be too\n            -- expensive to traverse the structure. Instead we leave items as they are but\n            -- we cope with them in `internal_search'.\n          deleted_marks.fill_with (False, ht_lowest_deleted_position, deleted_marks.count - 1)\n          ht_deleted_item := l_default_value\n          ht_deleted_key := l_default_key\n          ht_lowest_deleted_position := ht_max_position\n        elseif attached ht_deleted_item as l_item and attached ht_deleted_key as l_key then\n          content.put (l_item, l_pos)\n          keys.put (l_key, l_pos)\n        else\n            -- First time we actually remove an item from the table.\n          ht_deleted_item := content.item (l_pos)\n          ht_deleted_key := keys.item (l_pos)\n        end\n        control := removed_constant\n        found_item := l_default_value\n      end\n    ensure\n      removed_or_not_found: removed or not_found\n      not_present: not has (key)\n      one_less: found implies (count = old count - 1)\n      default_case:\n        (key = computed_default_key) implies (not has_default)\n      non_default_case:\n        (key /= computed_default_key) implies\n          (has_default = old has_default)\n    end\n\n  prune (v: detachable G)\n      -- Remove first occurrence of `v', if any,\n      -- after cursor position.\n      -- Move cursor to right neighbor.\n      -- (or after if no right neighbor or `v' does not occur)\n    do\n        -- No need to check if we are before because `iteration_position' is either\n        -- a valid position or `off' (see invariant `valid_iteration_position').\n        -- Thus we can start iterating right away.\n      if object_comparison then\n        from\n        until\n          after or else item_for_iteration ~ v\n        loop\n          forth\n        end\n      else\n        from\n        until\n          after or else item_for_iteration = v\n        loop\n          forth\n        end\n      end\n      if not after then\n        remove (key_for_iteration)\n      end\n    end\n\n  wipe_out\n      -- Reset all items to default values; reset status.\n    local\n      l_default_value: detachable G\n    do\n      content.wipe_out\n      keys.wipe_out\n      deleted_marks.fill_with (False, 0, deleted_marks.upper)\n      indexes_map.fill_with (ht_impossible_position, 0, capacity)\n      found_item := l_default_value\n      count := 0\n      item_position := 0\n      iteration_position := keys.count\n      control := 0\n      has_default := False\n    ensure then\n      position_equal_to_zero: item_position = 0\n      count_equal_to_zero: count = 0\n      has_default_set: not has_default\n      no_status: not special_status\n    end\n\n  clear_all\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      wipe_out\n    end\n\nfeature -- Conversion\n\n  linear_representation: ARRAYED_LIST [G]\n      -- Representation as a linear structure\n    local\n      old_iteration_position: INTEGER\n    do\n      old_iteration_position := iteration_position\n      from\n        create Result.make (count)\n        start\n      until\n        off\n      loop\n        Result.extend (item_for_iteration)\n        forth\n      end\n      iteration_position := old_iteration_position\n    ensure then\n      Result_exists: Result /= Void\n      good_count: Result.count = count\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Re-initialize from `other'.\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_content (other.content.twin)\n        set_keys (other.keys.twin)\n        set_deleted_marks (other.deleted_marks.twin)\n        set_indexes_map (other.indexes_map.twin)\n      end\n    end\n\nfeature {NONE} -- Duplication\n\n  empty_duplicate (n: INTEGER): like Current\n      -- Create an empty copy of Current that can accommodate `n' items\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make (n)\n      if object_comparison then\n        Result.compare_objects\n      end\n    ensure\n      empty_duplicate_attached: Result /= Void\n    end\n\nfeature {NONE} -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    local\n      l_old_deleted_marks: detachable SPECIAL [BOOLEAN]\n      i, l_capacity, l_count: INTEGER\n      l_new_table: like Current\n      l_default_item: like ht_deleted_item\n      l_default_key: like ht_deleted_key\n    do\n      if not mismatch_information.has (\"hash_table_version_64\") then\n          -- In version 5.1 and earlier, `content', `keys' and `deleted_marks'\n          -- where of base class ARRAY. In 5.2 we changed it to be a SPECIAL for\n          -- efficiency reasons. In order to retrieve an old HASH_TABLE we\n          -- need to convert those ARRAY instances into SPECIAL instances.\n\n          -- Convert `content' from ARRAY to SPECIAL\n        if attached {ARRAY [G]} mismatch_information.item (\"content\") as array_content then\n          content := array_content.area\n        end\n\n          -- Convert `keys' from ARRAY to SPECIAL\n        if attached {ARRAY [K]} mismatch_information.item (\"keys\") as array_keys then\n          keys := array_keys.area\n        end\n\n          -- Convert `deleted_marks' from ARRAY to SPECIAL\n        if attached {ARRAY [BOOLEAN]} mismatch_information.item (\"deleted_marks\") as array_marks then\n          deleted_marks := array_marks.area\n        end\n\n          -- In version 5.5 and later, `deleted_marks' had its size increased by 1 to take\n          -- into account removal of default key, and therefore if we hit a 5.4 or earlier\n          -- version, we need to resize `deleted_marks' to the new expected size.\n        if deleted_marks /= Void and keys /= Void then\n          if not mismatch_information.has (\"hash_table_version_57\") then\n              -- Unfortunately this handling of the mismatch was added in 5.7 and\n              -- therefore we might have stored a valid HASH_TABLE using 5.5 or 5.6.\n              -- Fortunately enough we can simply compare the counts of\n              -- `deleted_marks' and `keys'. If they are the same it is 5.5 or 5.6,\n              -- otherwise it is 5.4 or older.\n            if deleted_marks.count /= keys.count then\n              l_old_deleted_marks := deleted_marks\n              create deleted_marks.make_empty (keys.count)\n              deleted_marks.copy_data (l_old_deleted_marks, 0, 0, l_old_deleted_marks.count)\n            end\n          end\n        end\n\n        if attached {INTEGER} mismatch_information.item (\"count\") as l_retrieved_count then\n          l_count := l_retrieved_count\n        end\n\n        if content = Void or keys = Void or deleted_marks = Void then\n            -- Could not retrieve old version of HASH_TABLE. We throw an exception.\n          Precursor {MISMATCH_CORRECTOR}\n        else\n            -- Now we build the new HASH_TABLE from the old one.\n          from\n            l_capacity := keys.count\n            l_new_table := empty_duplicate (l_count)\n          until\n            i = l_capacity\n          loop\n            if attached keys.item (i) as l_key_item and then l_key_item /= l_default_key then\n              l_new_table.put (content.item (i), l_key_item)\n            end\n            i := i + 1\n          end\n          if attached {BOOLEAN} mismatch_information.item (\"has_default\") as l_bool and then l_bool then\n            l_new_table.put (content.item (content.capacity - 1), keys.item (l_capacity - 1))\n          end\n\n          set_content (l_new_table.content)\n          set_keys (l_new_table.keys)\n          set_deleted_marks (l_new_table.deleted_marks)\n          set_indexes_map (l_new_table.indexes_map)\n          capacity := l_new_table.capacity\n          iteration_position := l_new_table.iteration_position\n          deleted_item_position := l_new_table.deleted_item_position\n          item_position := l_new_table.item_position\n            -- We reset the following attributes to their default value\n          ht_lowest_deleted_position := ht_max_position\n          ht_deleted_item := l_default_item\n          ht_deleted_key := l_default_key\n            -- We don't change `object_comparison' from the value it was retrieved from.\n        end\n\n          -- Reset `control' to an acceptable value.\n        control := 0\n      end\n    end\n\n  hash_table_version_64: BOOLEAN\n      -- Fake attribute for versioning purposes. Used in `correct_mismatch'.\n\nfeature {HASH_TABLE, HASH_TABLE_ITERATION_CURSOR} -- Implementation: content attributes and preservation\n\n  content: SPECIAL [G]\n      -- Array of contents\n\n  keys: SPECIAL [K]\n      -- Array of keys\n\nfeature {HASH_TABLE} -- Implementation: content attributes and preservation\n\n  indexes_map: SPECIAL [INTEGER]\n      -- Indexes of items in `content', and `keys'.\n      -- If item is not present, then it has `ht_impossible_position'.\n      -- If item is deleted, then it has `ht_deleted_position'.\n\n  deleted_marks: SPECIAL [BOOLEAN]\n      -- Indexes of deleted positions in `content' and `keys'.\n\n  item_position: INTEGER\n      -- Position in `indexes_map' for item at position `position'. Set by `internal_search'.\n\n  has_default: BOOLEAN\n      -- Is the default key present?\n\nfeature {HASH_TABLE} -- Implementation: search attributes\n\n  iteration_position: INTEGER\n      -- Cursor for iteration primitives\n\n  position: INTEGER\n      -- Hash table cursor, updated after each operation:\n      -- put, remove, has, replace, force, change_key...\n    do\n      Result := indexes_map.item (item_position)\n    end\n\n  soon_full: BOOLEAN\n      -- Is table close to being filled to current capacity?\n    do\n      Result := keys.count = keys.capacity\n    ensure\n      Result = (keys.count = keys.capacity)\n    end\n\n  control: INTEGER\n      -- Control code set by operations that may produce\n      -- several possible conditions.\n\n  deleted_item_position: INTEGER\n      -- Place where a deleted element was found during a search\n\nfeature {NONE} -- Implementation\n\n  ht_max_position: INTEGER = 0x7FFFFFFD\n      -- Maximum possible position\n\n  ht_impossible_position: INTEGER = -1\n      -- Position outside the array indices.\n\n  ht_deleted_position: INTEGER = -2\n      -- Marked a deleted position.\n\n  ht_lowest_deleted_position: INTEGER\n      -- Index of the lowest deleted position thus far.\n\n  ht_deleted_item: detachable G\n  ht_deleted_key: detachable K\n      -- Store the item and key that will be used to replace an element of the HASH_TABLE\n      -- that will be removed. If elements being removed are at the end of `content' or `keys'\n      -- then they are both Void. It is only used when removing an element at a position strictly\n      -- less than `count'.\n\n  deleted_position (a_pos: INTEGER): INTEGER\n      -- Given the position of a deleted item at `a_pos' gives the associated position\n      -- in `content/keys'.\n    require\n      deleted: deleted (a_pos)\n    do\n      Result := -indexes_map.item (a_pos) + ht_deleted_position\n        -- Sometime we shrink `keys' and `content' while removing items, as a result, some\n        -- stored deleted position in `indexes_map' are beyond `keys' and `content'. In those\n        -- cases, we simply return the location for the next insertion instead.\n      Result := Result.min (keys.count)\n    ensure\n      deleted_position_non_negative: Result >= 0\n      deleted_position_valid: Result <= keys.count and Result <= content.count\n    end\n\n  occupied (i: INTEGER): BOOLEAN\n      -- Is position `i' occupied by a non-default key and a value?\n    require\n      in_bounds: deleted_marks.valid_index (i)\n    do\n      if has_default then\n        Result := i /= indexes_map.item (capacity) and then not deleted_marks.item (i)\n      else\n        Result := not deleted_marks.item (i)\n      end\n    end\n\n  truly_occupied (i: INTEGER): BOOLEAN\n      -- Is position `i' occupied by a key and a value?\n    do\n      if i >= 0 and i < keys.count then\n        Result := (has_default and i = indexes_map.item (capacity)) or else occupied (i)\n      end\n    ensure\n      normal_key: (i >= 0 and i < keys.count and i /= indexes_map.item (capacity)) implies (occupied (i) implies Result)\n      default_key: (i = indexes_map.item (capacity)) implies (Result = has_default)\n    end\n\n  is_off_position (pos: INTEGER): BOOLEAN\n      -- Is `pos' a cursor position outside the authorized range?\n    do\n      Result := pos < 0 or pos >= keys.count\n    end\n\n  set_content (c: like content)\n      -- Assign `c' to `content'.\n    require\n      c_attached: c /= Void\n    do\n      content := c\n    ensure\n      content_set: content = c\n    end\n\n  deleted (i: INTEGER): BOOLEAN\n      -- Is position `i' that of a deleted item?\n    require\n      in_bounds: i >= 0 and i <= capacity\n    do\n      Result := indexes_map.item (i) <= ht_deleted_position\n    end\n\n  set_keys (c: like keys)\n      -- Assign `c' to `keys'.\n    require\n      c_attached: c /= Void\n    do\n      keys := c\n    ensure\n      keys_set: keys = c\n    end\n\n  set_deleted_marks (d: like deleted_marks)\n      -- Assign `c' to `content'.\n    require\n      d_attached: d /= Void\n    do\n      deleted_marks := d\n    ensure\n      deleted_marks_set: deleted_marks = d\n    end\n\n  set_indexes_map (v: like indexes_map )\n      -- Assign `v' to `indexes_map'.\n    do\n      indexes_map := v\n    ensure\n      indexes_map_set: indexes_map = v\n    end\n\n  default_key_value: G\n      -- Value associated with the default key, if any\n    require\n      has_default: has_default\n    do\n      Result := content [indexes_map [capacity]]\n    end\n\n  computed_default_key: detachable K\n      -- Default key\n      -- (For performance reasons, used only in assertions;\n      -- elsewhere, see use of local entity `l_default_key'.)\n    do\n      -- No instructions necessary (returns default value of type K)\n    end\n\n  computed_default_value: detachable G\n      -- Default value of type G\n      -- (For performance reasons, used only in assertions;\n      -- elsewhere, see use of local entity `l_default_value'.)\n    do\n      -- No instructions necessary (returns default value of type G)\n    end\n\n  internal_search (key: K)\n      -- Search for item of key `key'.\n      -- If successful, set `position' to index\n      -- of item with this key (the same index as the key's index).\n      -- If not, set `position' to possible position for insertion,\n      -- and set status to `found' or `not_found'.\n    local\n      l_default_key: detachable K\n      hash_value, increment, l_pos, l_item_pos, l_capacity: INTEGER\n      l_first_deleted_position: INTEGER\n      stop: INTEGER\n      l_keys: like keys\n      l_indexes: like indexes_map\n      l_deleted_marks: like deleted_marks\n      l_key: K\n    do\n      l_first_deleted_position := ht_impossible_position\n      if key = l_default_key or key = Void then\n        item_position := capacity\n        if has_default then\n          control := found_constant\n        else\n          control := not_found_constant\n        end\n      else\n        from\n          l_keys := keys\n          l_indexes := indexes_map\n          l_deleted_marks := deleted_marks\n          l_capacity := capacity\n          stop := l_capacity\n          hash_value := hash_code_of (key)\n          increment := 1 + hash_value \\\\ (l_capacity - 1)\n          l_item_pos := (hash_value \\\\ l_capacity) - increment\n          control := not_found_constant\n        until\n          stop = 0\n        loop\n            -- Go to next increment.\n          l_item_pos := (l_item_pos + increment) \\\\ l_capacity\n          l_pos := l_indexes [l_item_pos]\n          if l_pos >= 0 then\n            l_key := l_keys.item (l_pos)\n            debug (\"detect_hash_table_catcall\")\n              check\n                catcall_detected: l_key /= Void and then l_key.same_type (key)\n              end\n            end\n            if same_keys (l_key, key) then\n              stop := 1\n              control := found_constant\n            end\n          elseif l_pos = ht_impossible_position then\n            stop := 1\n          elseif l_first_deleted_position = ht_impossible_position then\n            l_pos := -l_pos + ht_deleted_position\n            check l_pos_valid: l_pos < l_deleted_marks.count end\n            if not l_deleted_marks [l_pos] then\n              stop := 1\n            else\n              l_first_deleted_position := l_item_pos\n            end\n          end\n          stop := stop - 1\n        end\n        item_position := l_item_pos\n      end\n      deleted_item_position := l_first_deleted_position\n    ensure\n      found_or_not_found: found or not_found\n      deleted_item_at_deleted_position:\n        (deleted_item_position /= ht_impossible_position) implies (deleted (deleted_item_position))\n      default_iff_at_capacity: (item_position = capacity) = (key = computed_default_key)\n    end\n\n  search_for_insertion (key: K)\n      -- Assuming there is no item of key `key', compute\n      -- `position' at which to insert such an item.\n    require\n      not_present: not has (key)\n    local\n      l_default_key: detachable K\n      hash_value, increment, l_pos, l_item_pos, l_capacity: INTEGER\n      l_first_deleted_position: INTEGER\n      stop: INTEGER\n      l_indexes: like indexes_map\n      l_deleted_marks: like deleted_marks\n    do\n      l_first_deleted_position := ht_impossible_position\n      if key = l_default_key or key = Void then\n        check\n            -- Because of the precondition\n          not has_default\n        end\n        item_position := capacity\n      else\n        from\n          l_indexes := indexes_map\n          l_deleted_marks := deleted_marks\n          l_capacity := capacity\n          stop := l_capacity\n          hash_value := hash_code_of (key)\n          increment := 1 + hash_value \\\\ (l_capacity - 1)\n          l_item_pos := (hash_value \\\\ l_capacity) - increment\n        until\n          stop = 0\n        loop\n            -- Go to next increment.\n          l_item_pos := (l_item_pos + increment) \\\\ l_capacity\n          l_pos := l_indexes [l_item_pos]\n          if l_pos >= 0 then\n              -- Because of precondition, we are sure there is no key corresponding to `key'.\n          elseif l_pos = ht_impossible_position then\n            stop := 1\n          elseif l_first_deleted_position = ht_impossible_position then\n            l_pos := -l_pos + ht_deleted_position\n            check l_pos_valid: l_pos < l_deleted_marks.count end\n            if not l_deleted_marks [l_pos] then\n              stop := 1\n            else\n              l_first_deleted_position := l_item_pos\n            end\n          end\n          stop := stop - 1\n        end\n        item_position := l_item_pos\n      end\n      deleted_item_position := l_first_deleted_position\n    ensure\n      deleted_item_at_deleted_position:\n        (deleted_item_position /= ht_impossible_position) implies (deleted (deleted_item_position))\n      default_iff_at_capacity: (item_position = capacity) = (key = computed_default_key)\n    end\n\n  key_at (n: INTEGER): detachable K\n      -- Key at position `n'\n    do\n      if keys.valid_index (n) then\n        Result := keys.item (n)\n      end\n    end\n\n  initial_position (hash_value: INTEGER): INTEGER\n      -- Initial position for an item of hash code `hash_value'\n    do\n      Result := (hash_value \\\\ capacity)\n    end\n\n  position_increment (hash_value: INTEGER): INTEGER\n      -- Distance between successive positions for hash code\n      -- `hash_value' (computed for no cycle: `capacity' is prime)\n    do\n      Result := 1 + hash_value \\\\ (capacity - 1)\n    end\n\n  conflict_constant: INTEGER = 1\n      -- Could not insert an already existing key\n\n  set_conflict\n      -- Set status to conflict.\n    do\n      control := conflict_constant\n    ensure\n      conflict: conflict\n    end\n\n  found_constant: INTEGER = 2\n      -- Key found\n\n  set_found\n      -- Set status to found.\n    do\n      control := found_constant\n    ensure\n      found: found\n    end\n\n  inserted_constant: INTEGER = 4\n      -- Insertion successful\n\n  set_inserted\n      -- Set status to inserted.\n    do\n      control := inserted_constant\n    ensure\n      inserted: inserted\n    end\n\n  not_found_constant: INTEGER = 8\n      -- Key not found\n\n  set_not_found\n      -- Set status to not found.\n    do\n      control := not_found_constant\n    ensure\n      not_found: not_found\n    end\n\n  set_no_status\n      -- Set status to normal.\n    do\n      control := 0\n    ensure\n      default_status: not special_status\n    end\n\n  removed_constant: INTEGER = 16\n      -- Remove successful\n\n  set_removed\n      -- Set status to removed.\n    do\n      control := removed_constant\n    ensure\n      removed: removed\n    end\n\n  replaced_constant: INTEGER = 32\n      -- Replaced value\n\n  set_replaced\n      -- Set status to replaced.\n    do\n      control := replaced_constant\n    ensure\n      replaced: replaced\n    end\n\n  special_status: BOOLEAN\n      -- Has status been set to some non-default value?\n    do\n      Result := (control > 0)\n    ensure\n      Result = (control > 0)\n    end\n\n  add_space\n      -- Increase capacity.\n    do\n        -- Be pessimistic: plan for more growth by allocating 1.5 more than before\n      accommodate (count + count // 2)\n    ensure\n      count_not_changed: count = old count\n      breathing_space: count < capacity\n    end\n\n  minimum_capacity: INTEGER = 2\n\nfeature {NONE} -- Inapplicable\n\n  collection_extend (v: detachable G)\n      -- Insert a new occurrence of `v'.\n    do\n    end\n\ninvariant\n\n  keys_not_void: keys /= Void\n  content_not_void: content /= Void\n  keys_enough_capacity: keys.count <= capacity + 1\n  content_enough_capacity: content.count <= capacity + 1\n  valid_iteration_position: off or truly_occupied (iteration_position)\n  control_non_negative: control >= 0\n  special_status: special_status =\n    (conflict or inserted or replaced or removed or found or not_found)\n\n  count_big_enough: 0 <= count\n  count_small_enough: count <= capacity\n  slot_count_big_enough: 0 <= count\n\nnote\n  instruction: \"[\n    Several procedures are provided for inserting an item\n    with a given key.\n\n    Here is how to choose between them:\n\n      - Use `put' if you want to do an insertion only if\n        there was no item with the given key, doing nothing\n        otherwise. (You can find out on return if there was one,\n        and what it was.)\n\n      - Use `force' if you always want to insert the item;\n        if there was one for the given key it will be removed,\n        (and you can find out on return what it was).\n\n      - Use `extend' if you are sure there is no item with\n        the given key, enabling faster insertion (but\n        unpredictable behavior if this assumption is not true).\n\n      - Use `replace' if you want to replace an already present\n        item with the given key, and do nothing if there is none.\n\n    In addition you can use `replace_key' to change the key of an\n    already present item, identified by its previous key, or\n    do nothing if there is nothing for that previous key.\n    You can find out on return.\n\n    To find out whether a key appears in the table, use `has'.\n    To find out the item, if any, associated with a certain key,\n    use `item'.\n\n    Both of these routines perform a search. If you need\n    both pieces of information (does a key appear? And, if so,\n    what is the associated item?), you can avoid performing\n    two redundant traversals by using instead the combination\n    of `search', `found' and `found_item' as follows:\n\n      your_table.search (your_key)\n      if your_table.found then\n        what_you_where_looking_for := your_table.found_item\n        ... Do whatever is needed to `what_you_were_looking_for' ...\n      else\n        ... No item was present for `your_key' ...\n      end\n    ]\"\n  date: \"$Date: 2014-04-10 08:28:38 -0700 (Thu, 10 Apr 2014) $\"\n  revision: \"$Revision: 94809 $\"\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"hashable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  HASHABLE\n\nfeature -- Access\n\n  hash_code: INTEGER\n      -- Hash code value\n    deferred\n    ensure\n      good_hash_value: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True by default.)\n    do\n      Result := True\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"immutable_string_8.e","content":"note\n  description: \"[\n    Sequences of immutable 8-bit characters, accessible through integer indices\n    in a contiguous range.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-03 14:26:20 -0800 (Fri, 03 Jan 2014) $\"\n  revision: \"$Revision: 93888 $\"\n\nfrozen class\n  IMMUTABLE_STRING_8\n\ninherit\n  READABLE_STRING_8\n    undefine\n      is_immutable\n    redefine\n      copy, area_lower\n    end\n\n  IMMUTABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    undefine\n      is_equal, out, copy\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_c,\n  make_from_cil\n\ncreate {IMMUTABLE_STRING_8}\n  make_from_area_and_bounds\n\nconvert\n  make_from_string ({READABLE_STRING_8, STRING_8}),\n  make_from_cil ({SYSTEM_STRING}),\n  to_cil: {SYSTEM_STRING},\n  as_string_32: {STRING_32},\n  as_string_8: {STRING_8}\n\nfeature {NONE} -- Initialization\n\n  make_from_area_and_bounds (a: like area; low, n: like count)\n      -- Initialize current with area `a' with lower bounds `low' and count `n'.\n    require\n      a_not_void: a /= Void\n      a_valid_count: (a.count - low) >= count + 1\n      low_non_negative: low >= 0\n      n_non_negative: n >= 0\n    do\n      area := a\n      area_lower := low\n      count := n\n    ensure\n      area_set: area = a\n      area_lower_set: area_lower = low\n      count_set: count = n\n    end\n\n  make_from_cil (a_system_string: SYSTEM_STRING)\n      -- <Precursor>\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 then\n        dotnet_convertor.read_system_string_into_area_8 (a_system_string, area)\n        count := l_count\n      end\n    end\n\nfeature {IMMUTABLE_STRING_8} -- Duplication\n\n  copy (other: like Current)\n      -- <Precursor>\n    do\n      if other /= Current then\n          -- Because it is immutable we can simply share the `area' from `other'.\n        standard_copy (other)\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8\n      -- Character at position `i'.\n    do\n      Result := area.item (i + area_lower - 1)\n    end\n\n  character_32_item (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    do\n      Result := area.item (i + area_lower - 1).to_character_32\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Numeric code of character at position `i'.\n    do\n      Result := area.item (i + area_lower - 1).natural_32_code\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n      -- Use `code' instead for consistency with Unicode handling.\n      --| Not obsolete because old code using just ASCII is safe.\n    do\n      Result := area.item (i + area_lower - 1).code\n    end\n\nfeature -- Element change\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    local\n      a, a_8: like area\n      i, j, nb: INTEGER\n      l_s32_area: SPECIAL [CHARACTER_32]\n    do\n      create a.make_empty (count + s.count + 1)\n      a.copy_data (area, area_lower, 0, count)\n      if attached {READABLE_STRING_8} s as l_s8 then\n        a.copy_data (l_s8.area, l_s8.area_lower, count, l_s8.count + 1)\n      elseif attached {READABLE_STRING_32} s as l_s32 then\n        create a_8.make_empty (l_s32.count + 1)\n        from\n          i := 0\n          j := l_s32.area_lower\n          l_s32_area := l_s32.area\n          nb := l_s32.count - 1\n        until\n          i > nb\n        loop\n          a_8.extend (l_s32_area [j].to_character_8)\n          i := i + 1\n          j := j + 1\n        end\n        a_8.extend ('%/000/')\n        a.copy_data (a_8, 0, count, nb + 2)\n      end\n      create Result.make_from_area_and_bounds (a, 0, count + s.count)\n    end\n\n  mirrored: like Current\n      -- <Precursor>\n    local\n      a: like area\n    do\n      create a.make_empty (count + 1)\n      a.copy_data (area, area_lower, 0, count + 1)\n      mirror_area (a, 0, count - 1)\n      create Result.make_from_area_and_bounds (a, 0, count)\n    end\n\n  as_lower: like Current\n      -- <Precursor>\n    local\n      a: like area\n    do\n      create a.make_empty (count + 1)\n      a.copy_data (area, area_lower, 0, count + 1)\n      to_lower_area (a, 0, count - 1)\n      create Result.make_from_area_and_bounds (a, 0, count)\n    end\n\n  as_upper: like Current\n      -- <Precursor>\n    local\n      a: like area\n    do\n      create a.make_empty (count + 1)\n      a.copy_data (area, area_lower, 0, count + 1)\n      to_upper_area (a, 0, count - 1)\n      create Result.make_from_area_and_bounds (a, 0, count)\n    end\n\n  substring (start_index, end_index: INTEGER_32): like Current\n      -- <Precursor>\n    local\n      a: like area\n      nb: INTEGER\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        nb := end_index - start_index + 1\n        create a.make_empty (nb + 1)\n        a.copy_data (area, area_lower + start_index - 1, 0, nb)\n        a.extend ('%/000/')\n        create Result.make_from_area_and_bounds (a, 0, nb)\n      else\n        Result := empty_string\n      end\n    end\n\n  shared_substring (start_index, end_index: INTEGER_32): like Current\n      -- <Precursor>\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        create Result.make_from_area_and_bounds (area, area_lower + start_index - 1, end_index - start_index + 1)\n      else\n        Result := empty_string\n      end\n    end\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    do\n      Result := count = 0\n    end\n\n  linear_representation: LINEAR [CHARACTER_8]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_8]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER_32): IMMUTABLE_STRING_8\n      -- <Precursor>\n    do\n      create Result.make (n)\n    end\n\n  empty_string: IMMUTABLE_STRING_8\n      -- Shared empty immutable string\n    once\n      create Result.make (0)\n    ensure\n      empty_string_not_void: Result /= Void\n      empty_string_empty: Result.is_empty\n    end\n\nfeature {READABLE_STRING_8, READABLE_STRING_32} -- Implementation\n\n  area_lower: INTEGER;\n      -- Index where current string starts in `area'\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"immutable_string_general.e","content":"note\n  description: \"Common ancestors to all immutable STRING classes.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  IMMUTABLE_STRING_GENERAL\n\ninherit\n  READABLE_STRING_GENERAL\n    redefine\n      is_immutable\n    end\n\nfeature -- Status report\n\n  is_immutable: BOOLEAN = True\n      -- <Precursor>\n\ninvariant\n  immutable: is_immutable\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class INDEXABLE [G, H -> INTEGER] inherit\n\n  TABLE [G, INTEGER]\n    rename\n      valid_key as valid_index,\n      force as put\n    end\n\n  READABLE_INDEXABLE [G]\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"note\n  description: \"Integer values\"\n  external_name: \"System.Int32\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_32_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64},\n  to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_16.e","content":"note\n  description: \"Integer values coded on 16 bits\"\n  external_name: \"System.Int16\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_16 inherit\n\n  INTEGER_16_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_16_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_16): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_16): INTEGER_16\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_16): INTEGER_16\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_16): INTEGER_16\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_16): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_16\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_16\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_16): INTEGER_16\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_16): INTEGER_16\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_16): INTEGER_16\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_16): INTEGER_16\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_16): INTEGER_16\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_16\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_16\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_16\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_16_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 16 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_16_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_16\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item.to_integer.hash_code\n    end\n\n  sign: INTEGER_16\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_16 = -32768\n  Max_value: INTEGER_16 = 32767\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_16)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_16\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: INTEGER_16_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_16_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_16_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_16_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): INTEGER_16\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_16: n <= 16\n      n_greater_or_equal_to_minus_16: n >= -16\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      Result := item & ((1).to_integer_16 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_16\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      if b then\n        Result := item | ((1).to_integer_16 |<< n)\n      else\n        Result := item & ((1).to_integer_16 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_16): INTEGER_16\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (6)\n      Result.append_integer_16 (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := item & 0x7FFFFFFF\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_32 = -2147483648\n  Max_value: INTEGER_32 = 2147483647\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_32\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: INTEGER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_small: item >= {INTEGER_16}.Min_value\n      not_too_big: item <= {INTEGER_16}.Max_value\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER_32): INTEGER\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & (1 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | (1 |<< n)\n      else\n        Result := item & (1 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_32): INTEGER_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (11)\n      Result.append_integer (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_64.e","content":"note\n  description: \"Integer values coded on 64 bits\"\n  external_name: \"System.Int64\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_64\n\ninherit\n  INTEGER_64_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_64_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_64): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_64): INTEGER_64\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_64): INTEGER_64\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_64): INTEGER_64\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_64): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_64\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_64\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_64): INTEGER_64\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_64): INTEGER_64\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_64): INTEGER_64\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_64): INTEGER_64\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_64): INTEGER_64\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_64\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_64\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_64\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_64_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 64 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_64_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_64\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Get the positive value of `item' and then do\n        -- a modulo on the maximum INTEGER_32 value.\n      Result := (item & 0x000000007FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_64 = -9223372036854775808\n  Max_value: INTEGER_64 = 9223372036854775807\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_64)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0 and item.to_natural_64 <= {CHARACTER_32}.Max_value\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_64 >= {CHARACTER_32}.Min_value and\n        item.to_natural_64 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_64\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: INTEGER_64_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_64_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_32}.Max_value\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_small: item >= {INTEGER_16}.Min_value\n      not_too_big: item <= {INTEGER_16}.Max_value\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_small: item >= {INTEGER_32}.Min_value\n      not_too_big: item <= {INTEGER_32}.Max_value\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      val: INTEGER_64\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_64_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0x0F).to_integer\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_64_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): INTEGER_64\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_64: n <= 64\n      n_greater_or_equal_to_minus_64: n >= -64\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      Result := item & ((1).to_integer_64 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_64\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      if b then\n        Result := item | ((1).to_integer_64 |<< n)\n      else\n        Result := item & ((1).to_integer_64 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_64): INTEGER_64\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_integer_64 (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_8.e","content":"note\n  description: \"Integer values coded on 8 bits\"\n  external_name: \"System.SByte\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_8 inherit\n\n  INTEGER_8_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_8_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64},\n  to_integer_16: {INTEGER_16},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_8): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_8): INTEGER_8\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_8): INTEGER_8\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_8): INTEGER_8\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_8): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_8\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_8\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_8): INTEGER_8\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_8): INTEGER_8\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_8): INTEGER_8\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_8): INTEGER_8\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_8): INTEGER_8\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_8\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_8\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_8\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_8_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 8 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_8_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_8\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item.to_integer.hash_code\n    end\n\n  sign: INTEGER_8\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_8 = -128\n  Max_value: INTEGER_8 = 127\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_8)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_8\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: INTEGER_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: V /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := 2\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 15)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      result_not_void: Result /= Void\n      result_valid_count: Result.count = 2\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      Result := tmp.to_hex_character\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): INTEGER_8\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_8: n <= 8\n      n_greater_or_equal_to_minus_8: n >= -8\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      Result := item & ((1).to_integer_8 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_8\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      if b then\n        Result := item | ((1).to_integer_8 |<< n)\n      else\n        Result := item & ((1).to_integer_8 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_8): INTEGER_8\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (4)\n      Result.append_integer_8 (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"iterable.e","content":"note\n  description: \"Structure that can be iterated over using `across...loop...end'.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  ITERABLE [G]\n\nfeature -- Access\n\n  new_cursor: ITERATION_CURSOR [G]\n      -- Fresh cursor associated with current structure\n    deferred\n    ensure\n      result_attached: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"linear.e","content":"note\n  description: \"Structures whose items may be accessed sequentially, one-way\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: sequential, traversing;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class LINEAR [G] inherit\n\n  TRAVERSABLE [G]\n    redefine\n      do_all, do_if, there_exists, for_all\n    end\n\nfeature -- Access\n\n  has (v: like item): BOOLEAN\n      -- Does structure include an occurrence of `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    do\n      start\n      if not off then\n        search (v)\n      end\n      Result := not exhausted\n    end\n\n  index_of (v: like item; i: INTEGER): INTEGER\n      -- Index of `i'-th occurrence of `v'.\n      -- 0 if none.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    require\n      positive_occurrences: i > 0\n    local\n      occur, pos: INTEGER\n    do\n      if object_comparison and v /= Void then\n        from\n          start\n          pos := 1\n        until\n          exhausted or (occur = i)\n        loop\n          if item ~ v then\n            occur := occur + 1\n          end\n          forth\n          pos := pos + 1\n        end\n      else\n        from\n          start\n          pos := 1\n        until\n          exhausted or (occur = i)\n        loop\n          if item = v then\n            occur := occur + 1\n          end\n          forth\n          pos := pos + 1\n        end\n      end\n      if occur = i then\n        Result := pos - 1\n      end\n    ensure\n      non_negative_result: Result >= 0\n    end\n\n  search (v: like item)\n      -- Move to first position (at or after current\n      -- position) where `item' and `v' are equal.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      -- If no such position ensure that `exhausted' will be true.\n    do\n      if object_comparison then\n        from\n        until\n          exhausted or else v ~ item\n        loop\n          forth\n        end\n      else\n        from\n        until\n          exhausted or else v = item\n        loop\n          forth\n        end\n      end\n    ensure\n      object_found: (not exhausted and object_comparison)\n         implies v ~ item\n      item_found: (not exhausted and not object_comparison)\n         implies v = item\n    end\n\n  index: INTEGER\n      -- Index of current position\n    deferred\n    end\n\n  occurrences (v: like item): INTEGER\n      -- Number of times `v' appears.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    do\n      from\n        start\n        search (v)\n      until\n        exhausted\n      loop\n        Result := Result + 1\n        forth\n        search (v)\n      end\n    end\n\n  item_for_iteration: G\n      -- Item at current position\n    require\n      not_off: not off\n    do\n      Result := item\n    end\n\nfeature -- Status report\n\n  exhausted: BOOLEAN\n      -- Has structure been completely explored?\n    do\n      Result := off\n    ensure\n      exhausted_when_off: off implies Result\n    end\n\n  after: BOOLEAN\n      -- Is there no valid position to the right of current one?\n    deferred\n    end\n\n  off: BOOLEAN\n      -- Is there no current item?\n    do\n      Result := is_empty or after\n    end\n\nfeature -- Cursor movement\n\n  finish\n      -- Move to last position.\n    deferred\n    end\n\n  forth\n      -- Move to next position; if no next position,\n      -- ensure that `exhausted' will be true.\n    require\n      not_after: not after\n    deferred\n    ensure\n      -- moved_forth_before_end: (not after) implies index = old index + 1\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n      until\n        after\n      loop\n        action.call ([item])\n        forth\n      end\n\n      if cs /= Void and c /= Void then\n        cs.go_to (c)\n      end\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test'.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n      until\n        after\n      loop\n        if test.item ([item]) then\n          action.call ([item])\n        end\n        forth\n      end\n\n      if cs /= Void and c /= Void then\n        cs.go_to (c)\n      end\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n      -- Semantics not guaranteed if `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable  CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n      until\n        after or Result\n      loop\n        Result := test.item ([item])\n        forth\n      end\n\n      if cs /= Void and c /=Void then\n        cs.go_to (c)\n      end\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n      -- Semantics not guaranteed if `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable  CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n        Result := True\n      until\n        after or not Result\n      loop\n        Result := test.item ([item])\n        forth\n      end\n\n      if cs /= Void and c /= Void then\n        cs.go_to (c)\n      end\n    ensure then\n      empty: is_empty implies Result\n    end\n\nfeature -- Conversion\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    do\n      Result := Current\n    end\n\ninvariant\n\n  after_constraint: after implies off\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"list.e","content":"note\n  description: \"Sequential lists, without commitment to a particular representation\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: list, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class LIST [G] inherit\n\n  CHAIN [G]\n    export\n      {ANY} remove\n    redefine\n      forth, is_equal\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Does `other' contain the same elements?\n    do\n      if Current = other then\n        Result := True\n      else\n        Result := (is_empty = other.is_empty) and\n            (object_comparison = other.object_comparison) and\n            (count = other.count)\n        if Result and not is_empty then\n          if\n            attached {CURSOR} cursor as c1 and then\n            attached {CURSOR} other.cursor as c2\n          then\n            from\n              start\n              other.start\n            until\n              after or not Result\n            loop\n              if object_comparison then\n                Result := item ~ other.item\n              else\n                Result := item = other.item\n              end\n              forth\n              other.forth\n            end\n            go_to (c1)\n            other.go_to (c2)\n          else\n            check\n              cursors_exist: False\n                -- Because every list contains a cursor object\n            end\n          end\n        elseif is_empty and other.is_empty and\n          object_comparison = other.object_comparison then\n          Result := True\n        end\n      end\n    ensure then\n      indices_unchanged:\n        index = old index and other.index = old other.index\n      true_implies_same_size: Result implies count = other.count\n    end\n\nfeature -- Status report\n\n  after: BOOLEAN\n      -- Is there no valid cursor position to the right of cursor?\n    do\n      Result := (index = count + 1)\n    end\n\n  before: BOOLEAN\n      -- Is there no valid cursor position to the left of cursor?\n    do\n      Result := (index = 0)\n    end\n\nfeature -- Cursor movement\n\n  forth\n      -- Move to next position; if no next position,\n      -- ensure that `exhausted' will be true.\n    deferred\n    ensure then\n      moved_forth: index = old index + 1\n    end\n\ninvariant\n\n  before_definition: before = (index = 0)\n  after_definition: after = (index = count + 1)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"managed_pointer.e","content":"note\n  description: \"[\n    To easily manage allocation and release of allocated C memory, and\n    to perform insertion of basic elements. Byte order is by default\n    platform specific.\n    Although memory allocation routines do not accept a zero sized pointer\n    MANAGED_POINTER does by allocating in fact a 1 byte sized pointer for\n    this particular case.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-29 17:12:00 -0700 (Mon, 29 Oct 2012) $\"\n  revision: \"$Revision: 92015 $\"\n\nclass\n  MANAGED_POINTER\n\ninherit\n  DISPOSABLE\n    redefine\n      is_equal, copy\n    end\n\n  PLATFORM\n    redefine\n      is_equal, copy\n    end\n\ncreate\n  make, make_from_array, make_from_pointer, share_from_pointer, own_from_pointer\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate `item' with `n' bytes.\n    require\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := item.memory_calloc (n.max (1), 1)\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      count := n\n      is_shared := False\n    ensure\n      item_set: item /= default_pointer\n      count_set: count = n\n      is_shared_set: not is_shared\n    end\n\n  make_from_array (data: ARRAY [NATURAL_8])\n      -- Allocate `item' with `data.count' bytes and copy\n      -- content of `data' into `item'.\n    require\n      data_not_void: data /= Void\n    do\n      increment_counter\n      count := data.count\n      item := item.memory_alloc (count.max (1))\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      put_array (data, 0)\n      is_shared := False\n    ensure\n      item_set: item /= default_pointer\n      count_set: count = data.count\n      is_shared_set: not is_shared\n    end\n\n  make_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Copy `a_count' bytes from `a_ptr' into current.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := item.memory_alloc (n.max (1))\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      item.memory_copy (a_ptr, n)\n      count := n\n      is_shared := False\n    ensure\n      item_set: item /= default_pointer\n      count_set: count = n\n      is_shared_set: not is_shared\n    end\n\n  share_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Use directly `a_ptr' with count `n' to hold current data.\n    require\n      a_ptr_valid: a_ptr = default_pointer implies n = 0\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := a_ptr\n      count := n\n      is_shared := True\n    ensure\n      item_set: item = a_ptr\n      count_set: count = n\n      is_shared_set: is_shared\n    end\n\n  own_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Use directly `a_ptr' with count `n' to hold current data and free\n      -- its associated C memory when Current is collected.\n      -- It assumes that `a_ptr' was allocated using the C-`malloc' routine and thus\n      -- will be freed by calling the C-`free' routine.\n    require\n      a_ptr_valid: a_ptr /= default_pointer\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := a_ptr\n      count := n\n      is_shared := False\n    ensure\n      item_set: item = a_ptr\n      count_set: count = n\n      is_shared_set: not is_shared\n    end\n\nfeature -- Settings\n\n  set_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Use directly `a_ptr' with count `n' to hold current data.\n    require\n      is_shared: is_shared\n      a_ptr_not_null: a_ptr = default_pointer implies n = 0\n      n_non_negative: n >= 0\n    do\n      item := a_ptr\n      count := n\n    ensure\n      item_set: item = a_ptr\n      count_set: count = n\n      is_shared_unchanged: is_shared\n    end\n\nfeature -- Access\n\n  item: POINTER note option: transient attribute end\n      -- Access to allocated memory.\n\n  count: INTEGER\n      -- Number of elements that Current can hold.\n\n  is_shared: BOOLEAN\n      -- Is `item' shared with another memory area?\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered equal to current object?\n    do\n      if count = other.count then\n        Result := (item = other.item) or else item.memory_compare (other.item, count)\n      end\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Update current object using fields of object attached\n      -- to `other', so as to yield equal objects. If `is_shared'\n      -- and current is not large enough to hold `other' create\n      -- a new pointer area and `is_shared' is set to `False'.\n    do\n      if other /= Current then\n        if item = other.item or is_shared then\n            -- Copy was most likely called via `twin' but even\n            -- if it is not, it makes sense to duplicate the memory.\n            -- Or before `item' was shared, so we simply allocate\n            -- a new memory area from `other' and reset\n            -- the `is_shared' flag.\n          make_from_pointer (other.item, other.count)\n        else\n            -- Simply resize Current and copy data.\n          resize (other.count)\n          item.memory_copy (other.item, other.count)\n        end\n      end\n    ensure then\n      sharing_status_not_preserved: (other /= Current) implies (old is_shared implies not is_shared)\n      count_preserved: count = other.count\n    end\n\nfeature -- Access: Platform specific\n\n  read_natural_8 (pos: INTEGER): NATURAL_8\n      -- Read NATURAL_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_8_bytes)\n    end\n\n  read_natural_16 (pos: INTEGER): NATURAL_16\n      -- Read NATURAL_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_16_bytes)\n    end\n\n  read_natural_32 (pos: INTEGER): NATURAL_32\n      -- Read NATURAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_32_bytes)\n    end\n\n  read_natural_64 (pos: INTEGER): NATURAL_64\n      -- Read NATURAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_64_bytes)\n    end\n\n  read_integer_8 (pos: INTEGER): INTEGER_8\n      -- Read INTEGER_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      Result := read_natural_8 (pos).as_integer_8\n    end\n\n  read_integer_16 (pos: INTEGER): INTEGER_16\n      -- Read INTEGER_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      Result := read_natural_16 (pos).as_integer_16\n    end\n\n  read_integer_32 (pos: INTEGER): INTEGER\n      -- Read INTEGER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      Result := read_natural_32 (pos).as_integer_32\n    end\n\n  read_integer_64 (pos: INTEGER): INTEGER_64\n      -- Read INTEGER_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      Result := read_natural_64 (pos).as_integer_64\n    end\n\n  read_pointer (pos: INTEGER): POINTER\n      -- Read POINTER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Pointer_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Pointer_bytes)\n    end\n\n  read_boolean (pos: INTEGER): BOOLEAN\n      -- Read BOOLEAN at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Boolean_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Boolean_bytes)\n    end\n\n  read_character (pos: INTEGER): CHARACTER\n      -- Read CHARACTER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Character_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Character_8_bytes)\n    end\n\n  read_real (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    obsolete \"Use read_real_32 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_32_bytes)\n    end\n\n  read_real_32 (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_32_bytes)\n    end\n\n  read_double (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    obsolete \"Use read_real_64 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_64_bytes)\n    end\n\n  read_real_64 (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_64_bytes)\n    end\n\n  read_array (pos, a_count: INTEGER): ARRAY [NATURAL_8]\n      -- Read `count' bytes at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      count_positive: a_count > 0\n      valid_position: (pos + a_count) <= count\n    local\n      i: INTEGER\n      l_area: SPECIAL [NATURAL_8]\n    do\n      from\n        create l_area.make_empty (a_count)\n      until\n        i >= a_count\n      loop\n        l_area.extend (read_natural_8 (pos + i))\n        i := i + 1\n      end\n      create Result.make_from_special (l_area)\n    ensure\n      read_array_not_void: Result /= Void\n      read_array_valid_count: Result.count = a_count\n    end\n\nfeature -- Element change: Platform specific\n\n  put_natural_8 (i: NATURAL_8; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_8_bytes)\n    ensure\n      inserted: i = read_natural_8 (pos)\n    end\n\n  put_natural_16 (i: NATURAL_16; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_16_bytes)\n    ensure\n      inserted: i = read_natural_16 (pos)\n    end\n\n  put_natural_32 (i: NATURAL_32; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_32_bytes)\n    ensure\n      inserted: i = read_natural_32 (pos)\n    end\n\n  put_natural_64 (i: NATURAL_64; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_64_bytes)\n    ensure\n      inserted: i = read_natural_64 (pos)\n    end\n\n  put_integer_8 (i: INTEGER_8; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      put_natural_8 (i.as_natural_8, pos)\n    ensure\n      inserted: i = read_integer_8 (pos)\n    end\n\n  put_integer_16 (i: INTEGER_16; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      put_natural_16 (i.as_natural_16, pos)\n    ensure\n      inserted: i = read_integer_16 (pos)\n    end\n\n  put_integer_32 (i: INTEGER; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      put_natural_32 (i.as_natural_32, pos)\n    ensure\n      inserted: i = read_integer_32 (pos)\n    end\n\n  put_integer_64 (i: INTEGER_64; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      put_natural_64 (i.as_natural_64, pos)\n    ensure\n      inserted: i = read_integer_64 (pos)\n    end\n\n  put_pointer (p: POINTER; pos: INTEGER)\n      -- Insert `p' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Pointer_bytes) <= count\n    do\n      (item + pos).memory_copy ($p, Pointer_bytes)\n    ensure\n      inserted: p = read_pointer (pos)\n    end\n\n  put_boolean (b: BOOLEAN; pos: INTEGER)\n      -- Insert `b' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Boolean_bytes) <= count\n    do\n      (item + pos).memory_copy ($b, Boolean_bytes)\n    ensure\n      inserted: b = read_boolean (pos)\n    end\n\n  put_character (c: CHARACTER; pos: INTEGER)\n      -- Insert `c' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Character_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($c, Character_8_bytes)\n    ensure\n      inserted: c = read_character (pos)\n    end\n\n  put_real (r: REAL; pos: INTEGER)\n      -- Insert `r' at position `pos'.\n    obsolete \"Use put_real_32 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      (item + pos).memory_copy ($r, Real_32_bytes)\n    ensure\n      inserted: r = read_real_32 (pos)\n    end\n\n  put_real_32 (r: REAL; pos: INTEGER)\n      -- Insert `r' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      (item + pos).memory_copy ($r, Real_32_bytes)\n    ensure\n      inserted: r = read_real_32 (pos)\n    end\n\n  put_double (d: DOUBLE; pos: INTEGER)\n      -- Insert `d' at position `pos'.\n    obsolete \"Use put_real_64 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      (item + pos).memory_copy ($d, Real_64_bytes)\n    ensure\n      inserted: d = read_real_64 (pos)\n    end\n\n  put_real_64 (d: DOUBLE; pos: INTEGER)\n      -- Insert `d' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      (item + pos).memory_copy ($d, Real_64_bytes)\n    ensure\n      inserted: d = read_real_64 (pos)\n    end\n\n  put_array (data: ARRAY [NATURAL_8]; pos: INTEGER)\n      -- Copy content of `data' into `item' at position `pos'.\n    require\n      data_not_void: data /= Void\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + data.count) <= count\n    local\n      l_sp: SPECIAL [NATURAL_8]\n    do\n      l_sp := data.area;\n      (item + pos).memory_copy ($l_sp, data.count)\n    ensure\n      inserted: read_array (pos, data.count) ~ data\n    end\n\nfeature -- Access: Little-endian format\n\n  read_natural_8_le (pos: INTEGER): NATURAL_8\n      -- Read NATURAL_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_8_bytes)\n    end\n\n  read_natural_16_le (pos: INTEGER): NATURAL_16\n      -- Read NATURAL_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    local\n      l_high, l_low: NATURAL_16\n    do\n      if is_little_endian then\n        Result := read_natural_16 (pos)\n      else\n        l_low := {NATURAL_16} 0x00FF & read_natural_8 (pos)\n        l_high := read_natural_8 (pos + natural_8_bytes)\n        Result := (l_high.to_natural_16 |<< 8) | l_low\n      end\n    end\n\n  read_natural_32_le (pos: INTEGER): NATURAL_32\n      -- Read NATURAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    local\n      l_high, l_low: NATURAL_32\n    do\n      if is_little_endian then\n        Result := read_natural_32 (pos)\n      else\n        l_low := {NATURAL_32} 0x0000FFFF & read_natural_16_le (pos)\n        l_high := read_natural_16_le (pos + natural_16_bytes)\n        Result := (l_high.to_natural_32 |<< 16) | l_low\n      end\n    end\n\n  read_natural_64_le (pos: INTEGER): NATURAL_64\n      -- Read NATURAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    local\n      l_high, l_low: NATURAL_64\n    do\n      if is_little_endian then\n        Result := read_natural_64 (pos)\n      else\n        l_low := {NATURAL_64} 0x00000000FFFFFFFF & read_natural_32_le (pos)\n        l_high := read_natural_32_le (pos + natural_32_bytes)\n        Result := (l_high.to_natural_64 |<< 32) | l_low\n      end\n    end\n\n  read_integer_8_le (pos: INTEGER): INTEGER_8\n      -- Read INTEGER_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      Result := read_natural_8_le (pos).as_integer_8\n    end\n\n  read_integer_16_le (pos: INTEGER): INTEGER_16\n      -- Read INTEGER_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      Result := read_natural_16_le (pos).as_integer_16\n    end\n\n  read_integer_32_le (pos: INTEGER): INTEGER\n      -- Read INTEGER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      Result := read_natural_32_le (pos).as_integer_32\n    end\n\n  read_integer_64_le (pos: INTEGER): INTEGER_64\n      -- Read INTEGER_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      Result := read_natural_64_le (pos).as_integer_64\n    end\n\n  read_real_32_le (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      l_nat32 := read_natural_32_le (pos)\n      ($Result).memory_copy ($l_nat32, natural_32_bytes)\n    end\n\n  read_real_64_le (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      l_nat64 := read_natural_64_le (pos)\n      ($Result).memory_copy ($l_nat64, natural_64_bytes)\n    end\n\nfeature -- Element change: Little-endian format\n\n  put_natural_8_le (i: NATURAL_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_8_bytes)\n    ensure\n      inserted: i = read_natural_8_le (pos)\n    end\n\n  put_natural_16_le (i: NATURAL_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_16 (i, pos)\n      else\n        put_natural_8 ((i & 0x00FF).to_natural_8, pos)\n        put_natural_8 ((((i & 0xFF00) |>> 8) & 0x00FF).to_natural_8, pos + natural_8_bytes)\n      end\n    ensure\n      inserted: i = read_natural_16_le (pos)\n    end\n\n  put_natural_32_le (i: NATURAL_32; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_32 (i, pos)\n      else\n        put_natural_16_le ((i & 0x0000FFFF).to_natural_16, pos)\n        put_natural_16_le ((((i & 0xFFFF0000) |>> 16) & 0x0000FFFF).to_natural_16, pos + natural_16_bytes)\n      end\n    ensure\n      inserted: i = read_natural_32_le (pos)\n    end\n\n  put_natural_64_le (i: NATURAL_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_64 (i, pos)\n      else\n        put_natural_32_le ((i & 0x00000000FFFFFFFF).to_natural_32, pos)\n        put_natural_32_le (\n          (((i & 0xFFFFFFFF00000000) |>> 32) & 0x00000000FFFFFFFF).to_natural_32,\n          pos+ natural_32_bytes)\n      end\n    ensure\n      inserted: i = read_natural_64_le (pos)\n    end\n\n  put_integer_8_le (i: INTEGER_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      put_natural_8_le (i.as_natural_8, pos)\n    ensure\n      inserted: i = read_integer_8_le (pos)\n    end\n\n  put_integer_16_le (i: INTEGER_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      put_natural_16_le (i.as_natural_16, pos)\n    ensure\n      inserted: i = read_integer_16_le (pos)\n    end\n\n  put_integer_32_le (i: INTEGER; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      put_natural_32_le (i.as_natural_32, pos)\n    ensure\n      inserted: i = read_integer_32_le (pos)\n    end\n\n  put_integer_64_le (i: INTEGER_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      put_natural_64_le (i.as_natural_64, pos)\n    ensure\n      inserted: i = read_integer_64_le (pos)\n    end\n\n  put_real_32_le (v: REAL; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      ($l_nat32).memory_copy ($v, natural_32_bytes)\n      put_natural_32_le (l_nat32, pos)\n    ensure\n      inserted: v = read_real_32_le (pos)\n    end\n\n  put_real_64_le (v: DOUBLE; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      ($l_nat64).memory_copy ($v, natural_64_bytes)\n      put_natural_64_le (l_nat64, pos)\n    ensure\n      inserted: v = read_real_64_le (pos)\n    end\n\nfeature -- Access: Big-endian format\n\n  read_natural_8_be (pos: INTEGER): NATURAL_8\n      -- Read NATURAL_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_8_bytes)\n    end\n\n  read_natural_16_be (pos: INTEGER): NATURAL_16\n      -- Read NATURAL_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    local\n      l_high, l_low: NATURAL_16\n    do\n      if is_little_endian then\n        l_high := read_natural_8 (pos)\n        l_low := (0x00FF).to_natural_16 & read_natural_8 (pos + natural_8_bytes)\n        Result := (l_high.to_natural_16 |<< 8) | l_low\n      else\n        Result := read_natural_16 (pos)\n      end\n    end\n\n  read_natural_32_be (pos: INTEGER): NATURAL_32\n      -- Read NATURAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    local\n      l_high, l_low: NATURAL_32\n    do\n      if is_little_endian then\n        l_high := read_natural_16_be (pos)\n        l_low := (0x0000FFFF).to_natural_32 & read_natural_16_be (pos + natural_16_bytes)\n        Result := (l_high.to_natural_32 |<< 16) | l_low\n      else\n        Result := read_natural_32 (pos)\n      end\n    end\n\n  read_natural_64_be (pos: INTEGER): NATURAL_64\n      -- Read NATURAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    local\n      l_high, l_low: NATURAL_64\n    do\n      if is_little_endian then\n        l_high := read_natural_32_be (pos)\n        l_low := {NATURAL_64} 0x00000000FFFFFFFF & read_natural_32_be (pos + natural_32_bytes)\n        Result := (l_high.to_natural_64 |<< 32) | l_low\n      else\n        Result := read_natural_64 (pos)\n      end\n    end\n\n  read_integer_8_be (pos: INTEGER): INTEGER_8\n      -- Read INTEGER_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      Result := read_natural_8_be (pos).as_integer_8\n    end\n\n  read_integer_16_be (pos: INTEGER): INTEGER_16\n      -- Read INTEGER_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      Result := read_natural_16_be (pos).as_integer_16\n    end\n\n  read_integer_32_be (pos: INTEGER): INTEGER\n      -- Read INTEGER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      Result := read_natural_32_be (pos).as_integer_32\n    end\n\n  read_integer_64_be (pos: INTEGER): INTEGER_64\n      -- Read INTEGER_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      Result := read_natural_64_be (pos).as_integer_64\n    end\n\n  read_real_32_be (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      l_nat32 := read_natural_32_be (pos)\n      ($Result).memory_copy ($l_nat32, natural_32_bytes)\n    end\n\n  read_real_64_be (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      l_nat64 := read_natural_64_be (pos)\n      ($Result).memory_copy ($l_nat64, natural_64_bytes)\n    end\n\nfeature -- Element change: Big-endian format\n\n  put_natural_8_be (i: NATURAL_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_8_bytes)\n    ensure\n      inserted: i = read_natural_8_be (pos)\n    end\n\n  put_natural_16_be (i: NATURAL_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_8 ((((i & 0xFF00) |>> 8) & 0x00FF).to_natural_8, pos)\n        put_natural_8 ((i & 0x00FF).to_natural_8, pos + natural_8_bytes)\n      else\n        put_natural_16 (i, pos)\n      end\n    ensure\n      inserted: i = read_natural_16_be (pos)\n    end\n\n  put_natural_32_be (i: NATURAL_32; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_16_be ((((i & 0xFFFF0000) |>> 16) & 0x0000FFFF).to_natural_16, pos)\n        put_natural_16_be ((i & 0x0000FFFF).to_natural_16, pos + natural_16_bytes)\n      else\n        put_natural_32 (i, pos)\n      end\n    ensure\n      inserted: i = read_natural_32_be (pos)\n    end\n\n  put_natural_64_be (i: NATURAL_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_32_be (\n          (((i & 0xFFFFFFFF00000000) |>> 32) & 0x00000000FFFFFFFF).to_natural_32, pos)\n        put_natural_32_be ((i & 0x00000000FFFFFFFF).to_natural_32,\n          pos + natural_32_bytes)\n      else\n        put_natural_64 (i, pos)\n      end\n    ensure\n      inserted: i = read_natural_64_be (pos)\n    end\n\n  put_integer_8_be (i: INTEGER_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      put_natural_8_be (i.as_natural_8, pos)\n    ensure\n      inserted: i = read_integer_8_be (pos)\n    end\n\n  put_integer_16_be (i: INTEGER_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      put_natural_16_be (i.as_natural_16, pos)\n    ensure\n      inserted: i = read_integer_16_be (pos)\n    end\n\n  put_integer_32_be (i: INTEGER; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      put_natural_32_be (i.as_natural_32, pos)\n    ensure\n      inserted: i = read_integer_32_be (pos)\n    end\n\n  put_integer_64_be (i: INTEGER_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      put_natural_64_be (i.as_natural_64, pos)\n    ensure\n      inserted: i = read_integer_64_be (pos)\n    end\n\n  put_real_32_be (v: REAL; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      ($l_nat32).memory_copy ($v, natural_32_bytes)\n      put_natural_32_be (l_nat32, pos)\n    ensure\n      inserted: v = read_real_32_be (pos)\n    end\n\n  put_real_64_be (v: DOUBLE; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      ($l_nat64).memory_copy ($v, natural_64_bytes)\n      put_natural_64_be (l_nat64, pos)\n    ensure\n      inserted: v = read_real_64_be (pos)\n    end\n\nfeature -- Concatenation\n\n  append (other: like Current)\n      -- Append `other' at the end of Current.\n    require\n      not_shared: not is_shared\n      other_not_void: other /= Void\n    local\n      new_count: INTEGER\n    do\n      new_count := count + other.count\n      item := item.memory_realloc (new_count.max (1))\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      (item + count).memory_copy (other.item, other.count)\n      count := new_count\n    end\n\nfeature -- Resizing\n\n  resize (n: INTEGER)\n      -- Reallocate `item' to hold `n' bytes.\n    require\n      n_non_negative: n >= 0\n      not_shared: not is_shared\n    do\n        -- Reallocate.\n      if n /= count then\n        item := item.memory_realloc (n.max (1))\n        if item = default_pointer then\n          (create {EXCEPTIONS}).raise (\"No more memory\")\n        end\n      end\n\n      if n > count then\n          -- Reset newly allocated memory to `0'.\n        (item + count).memory_set (0, n - count)\n      end\n      count := n\n    end\n\nfeature {NONE} -- Disposal\n\n  dispose\n      -- Release memory pointed by `item'.\n    local\n      null: POINTER\n    do\n      if not is_shared then\n        item.memory_free\n      end\n      item := null\n      is_shared := False\n    ensure then\n      shared_reset: not is_shared\n    end\n\nfeature {NONE} -- Debugging\n\n  allocation_counter: CELL [NATURAL_64]\n      -- Store current number of allocation being made.\n    once\n      create Result.put (0)\n    end\n\n  counter: NATURAL_64 note option: transient attribute end\n      -- Allocation number associated to Current.\n\n  increment_counter\n      -- Set `counter' with a new allocation number.\n    do\n      debug (\"MANAGED_POINTER_allocation\")\n        counter := allocation_counter.item + 1\n        allocation_counter.put (counter)\n      end\n    end\n\n\ninvariant\n  item_not_null: item = default_pointer implies (count = 0 and is_shared)\n  valid_count: count >= 0\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"mismatch_corrector.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  MISMATCH_CORRECTOR\n\nfeature -- Correction\n\n  correct_mismatch\n      -- Attempt to correct object mismatch using `mismatch_information'.\n    local\n      l_msg: STRING\n      l_exc: EXCEPTIONS\n    do\n        -- If it is not redefined then we raise an exception.\n      create l_msg.make_from_string (\"Mismatch: \")\n      create l_exc\n      l_msg.append (generating_type)\n      l_exc.raise_retrieval_exception (l_msg)\n    end\n\n  mismatch_information: MISMATCH_INFORMATION\n      -- Original attribute values of mismatched object\n    once\n      create Result\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"native_array.e","content":"note\n  description: \"Fake abstraction of a .NET NATIVE_ARRAY in a non-.NET system\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-04-23 14:49:02 -0700 (Tue, 23 Apr 2013) $\"\n  revision: \"$Revision: 92470 $\"\n\nfrozen class\n  NATIVE_ARRAY [G]\n\ninvariant\n  is_dotnet: {PLATFORM}.is_dotnet\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_16.e","content":"note\n  description: \"Unsigned integer values coded on 16 bits\"\n  external_name: \"System.UInt16\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class NATURAL_16\n\ninherit\n  NATURAL_16_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_16_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64},\n  to_natural_32: {NATURAL_32},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_16): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_16): NATURAL_16\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_16): NATURAL_16\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_16): NATURAL_16\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_16): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_16\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_16): NATURAL_16\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_16): NATURAL_16\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_16): NATURAL_16\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_16): NATURAL_16\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_16): NATURAL_16\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_16\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_16\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_16\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_16_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 16 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_16_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_16\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_16 = 0\n  Max_value: NATURAL_16 = 65535\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_16)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: NATURAL_16_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_16_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_16\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_16\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_16_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_16_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_16\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_16: n <= 16\n      n_greater_or_equal_to_minus_16: n >= -16\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      Result := item & ((1).to_natural_16 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_16\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      if b then\n        Result := item | ((1).to_natural_16 |<< n)\n      else\n        Result := item & ((1).to_natural_16 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_16): NATURAL_16\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (5)\n      Result.append_natural_16 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32.e","content":"note\n  description: \"Unsigned integer values coded on 32 bits.\"\n  external_name: \"System.UInt32\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_32 inherit\n\n  NATURAL_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_32_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_64: {INTEGER_64},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_32): NATURAL_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_32): NATURAL_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_32): NATURAL_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_32): NATURAL_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_32): NATURAL_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_32): NATURAL_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := (item & 0x7FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_32 = 0\n  Max_value: NATURAL_32 = 4294967295\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value.to_natural_32\n    ensure\n      in_bounds: Result = (\n        item >= {CHARACTER_8}.Min_value.to_natural_32 and\n        item <= {CHARACTER_8}.Max_value.to_natural_32)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: NATURAL_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_32\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_32\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_big: item <= {INTEGER_32}.Max_value.to_natural_32\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      a_digit, val: NATURAL_32\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & ((1).to_natural_32 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | ((1).to_natural_32 |<< n)\n      else\n        Result := item & ((1).to_natural_32 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_32): NATURAL_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_natural_32 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_64.e","content":"note\n  description: \"Unsigned integer values coded on 64 bits\"\n  external_name: \"System.UInt64\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class NATURAL_64\n\ninherit\n  NATURAL_64_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_64_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_64): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_64): NATURAL_64\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_64): NATURAL_64\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_64): NATURAL_64\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_64): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_64\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_64): NATURAL_64\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_64): NATURAL_64\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_64): NATURAL_64\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_64): NATURAL_64\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_64): NATURAL_64\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_64\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_64\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_64\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_64_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 64 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_64_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_64\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Get the positive value of `item' and then do\n        -- a modulo on the maximum INTEGER_32 value.\n      Result := (item & 0x000000007FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_64 = 0\n  Max_value: NATURAL_64 = 18446744073709551615\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_64)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value.to_natural_64\n    ensure\n      in_bounds: Result = (\n        item >= {CHARACTER_8}.Min_value.to_natural_64 and\n        item <= {CHARACTER_8}.Max_value.to_natural_64)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item <= {CHARACTER_32}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other + 0\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: NATURAL_64_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_64_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      not_too_big: item <= {NATURAL_32}.Max_value\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_64\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_64\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_big: item <= {INTEGER_32}.Max_value.to_natural_64\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    require\n      not_too_big: item <= {INTEGER_64}.Max_value.to_natural_64\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      val: NATURAL_64\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_64_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0x0F).to_integer_32\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_64_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_64\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_64: n <= 64\n      n_greater_or_equal_to_minus_64: n >= -64\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      Result := item & ((1).to_natural_64 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_64\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      if b then\n        Result := item | ((1).to_natural_64 |<< n)\n      else\n        Result := item & ((1).to_natural_64 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_64): NATURAL_64\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_natural_64 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_8.e","content":"note\n  description: \"Integer values coded on 8 bits\"\n  external_name: \"System.Byte\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_8 inherit\n\n  NATURAL_8_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_8_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_16: {INTEGER_16},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64},\n  to_natural_16: {NATURAL_16},\n  to_natural_32: {NATURAL_32},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_8): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_8): NATURAL_8\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_8): NATURAL_8\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_8): NATURAL_8\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_8): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_8\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_8): NATURAL_8\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_8): NATURAL_8\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_8): NATURAL_8\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_8\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"natural_8_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 8 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_8_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_8\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead.\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_8 = 0\n  Max_value: NATURAL_8 = 255\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_8)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: NATURAL_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: V /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_8\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := 2\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 15)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      result_not_void: Result /= Void\n      result_valid_count: Result.count = 2\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      Result := tmp.to_hex_character\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_8: n <= 8\n      n_greater_or_equal_to_minus_8: n >= -8\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      Result := item & ((1).to_natural_8 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_8\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      if b then\n        Result := item | ((1).to_natural_8 |<< n)\n      else\n        Result := item & ((1).to_natural_8 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_8): NATURAL_8\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (3)\n      Result.append_natural_8 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"numeric.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n\n  NUMERIC\n\ninherit\n  DEBUG_OUTPUT\n    rename\n      debug_output as out\n    end\n\nfeature -- Access\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    obsolete\n      \"[2008_04_01] Will be removed since not used.\"\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other' (commutative).\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n      commutative: Result ~ (other + Current)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\ninvariant\n\n--  neutral_addition: equal (Current + zero, Current);\n--  self_subtraction: equal (Current - Current, zero);\n--  neutral_multiplication: equal (Current * one, Current);\n--  self_division: divisible (Current) implies equal (Current / Current, one)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"part_comparable.e","content":"note\n  description: \"Objects that may be compared according to a partial order relation\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  PART_COMPARABLE\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (Current < other) or (Current ~ other)\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := other < Current\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (other < Current) or (Current ~ other)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"platform.e","content":"note\n  description: \"Platform-dependent properties.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-06-15 12:34:32 -0700 (Fri, 15 Jun 2012) $\"\n  revision: \"$Revision: 91984 $\"\n\nclass PLATFORM\n\nfeature -- Platform\n\n  is_thread_capable: BOOLEAN\n      -- Is current platform capable of multi-threading?\n    external\n      \"built_in static\"\n    end\n\n  is_scoop_capable: BOOLEAN\n      -- Is current platform capable of SCOOP?\n    external\n      \"built_in static\"\n    end\n\n  is_dotnet: BOOLEAN\n      -- Are we targetting .NET?\n    external\n      \"built_in static\"\n    end\n\n  is_windows: BOOLEAN\n      -- Are we running on Windows platform?\n    external\n      \"built_in static\"\n    end\n\n  is_unix: BOOLEAN\n      -- Are we running on a Unix like platform?\n    external\n      \"built_in static\"\n    end\n\n  is_vms: BOOLEAN\n      -- Are we running on VMS?\n    external\n      \"built_in static\"\n    end\n\n  is_mac: BOOLEAN\n      -- Are we running on Mac OS?\n    external\n      \"built_in static\"\n    end\n\n  is_vxworks: BOOLEAN\n      -- Are we running on VxWorks?\n    external\n      \"built_in static\"\n    end\n\n  is_little_endian: BOOLEAN\n      -- Is current platform a little endian one?\n    local\n      l_nat16: NATURAL_16\n      l_nat8: NATURAL_8\n      l_first: NATURAL_8\n    once\n      l_nat16 := 0x4321\n      l_nat8 := 0x21\n      ($l_first).memory_copy ($l_nat16, 1)\n      Result := l_first = l_nat8\n    end\n\nfeature -- Access bytes size\n\n  boolean_bytes: INTEGER\n      -- Number of bytes in a value of type `BOOLEAN'\n    external\n      \"built_in static\"\n    end\n\n  character_8_bytes: INTEGER = 1\n      -- Number of bytes in a value of type `CHARACTER_8'\n\n  character_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `CHARACTER_32'\n\n  natural_8_bytes: INTEGER = 1\n      -- Number of bytes in a value of type `NATURAL_8'\n\n  natural_16_bytes: INTEGER = 2\n      -- Number of bytes in a value of type `NATURAL_16'\n\n  natural_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `NATURAL_32'\n\n  natural_64_bytes: INTEGER = 8\n      -- Number of bytes in a value of type `NATURAL_64'\n\n  integer_8_bytes: INTEGER = 1\n      -- Number of bytes in a value of type `INTEGER_8'\n\n  integer_16_bytes: INTEGER = 2\n      -- Number of bytes in a value of type `INTEGER_16'\n\n  integer_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `INTEGER_32'\n\n  integer_64_bytes: INTEGER = 8\n      -- Number of bytes in a value of type `INTEGER_64'\n\n  real_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `REAL_32'\n\n  real_64_bytes: INTEGER = 8\n      -- Number of bytes in a value of type `REAL_64'\n\n  pointer_bytes: INTEGER\n      -- Number of bytes in a value of type `POINTER'\n    external\n      \"built_in static\"\n    end\n\nfeature -- Access bits size\n\n  boolean_bits: INTEGER\n      -- Number of bits in a value of type `BOOLEAN'\n    do\n      Result := boolean_bytes * 8\n    end\n\n  character_8_bits: INTEGER = 8\n      -- Number of bits in a value of type `CHARACTER_8'\n\n  character_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `CHARACTER_32'\n\n  natural_8_bits: INTEGER = 8\n      -- Number of bits in a value of type `NATURAL_8'\n\n  natural_16_bits: INTEGER = 16\n      -- Number of bits in a value of type `NATURAL_16'\n\n  natural_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `NATURAL_32'\n\n  natural_64_bits: INTEGER = 64\n      -- Number of bits in a value of type `NATURAL_64'\n\n  integer_8_bits: INTEGER = 8\n      -- Number of bits in a value of type `INTEGER_8'\n\n  integer_16_bits: INTEGER = 16\n      -- Number of bits in a value of type `INTEGER_16'\n\n  integer_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `INTEGER_32'\n\n  integer_64_bits: INTEGER = 64\n      -- Number of bits in a value of type `INTEGER_64'\n\n  real_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `REAL_32'\n\n  real_64_bits: INTEGER = 64\n      -- Number of bits in a value of type `REAL_64'\n\n  pointer_bits: INTEGER\n      -- Number of bits in a value of type `POINTER'\n    do\n      Result := pointer_bytes * 8\n    end\n\nfeature -- Obsoletes\n\n  character_bytes: INTEGER\n      -- Number of bytes in a value of type `CHARACTER_8'\n    obsolete\n      \"Use `character_8_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  wide_character_bytes: INTEGER\n      -- Number of bytes in a value of type `CHARACTER_32'\n    obsolete\n      \"Use `character_32_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  integer_bytes: INTEGER\n      -- Number of bytes in a value of type `INTEGER_32'\n    obsolete\n      \"Use `integer_32_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  real_bytes: INTEGER\n      -- Number of bytes in a value of type `REAL_32'\n    obsolete\n      \"Use `real_32_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  double_bytes: INTEGER\n      -- Number of bytes in a value of type `REAL_64'\n    obsolete\n      \"Use `real_64_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  character_bits: INTEGER\n      -- Number of bits in a value of type `CHARACTER_8'\n    obsolete\n      \"Use `character_8_bits' instead.\"\n    do\n      Result := 8\n    end\n\n  integer_bits: INTEGER\n      -- Number of bits in a value of type `INTEGER_32'\n    obsolete\n      \"Use `integer_32_bits' instead.\"\n    do\n      Result := 32\n    end\n\n  real_bits: INTEGER\n      -- Number of bits in a value of type `REAL_32'\n    obsolete\n      \"Use `real_32_bits' instead.\"\n    do\n      Result := 32\n    end\n\n  double_bits: INTEGER\n      -- Number of bits in a value of type `REAL_64'\n    obsolete\n      \"Use `real_64_bits' instead.\"\n    do\n      Result := 64\n    end\n\n  maximum_character_code: INTEGER\n      -- Largest supported code for CHARACTER_8 values\n    obsolete\n      \"Use `{CHARACTER}.max_value' instead.\"\n    do\n      Result := {CHARACTER}.max_value\n    ensure\n      meaningful: Result >= 127\n    end\n\n  maximum_integer: INTEGER\n      -- Largest supported value of type INTEGER_32\n    obsolete\n      \"Use `{INTEGER}.max_value' instead.\"\n    do\n      Result := {INTEGER}.max_value\n    ensure\n      meaningful: Result >= 0\n    end\n\n  minimum_character_code: INTEGER\n      -- Smallest supported code for CHARACTER_8 values\n    obsolete\n      \"Use `{CHARACTER}.min_value' instead.\"\n    do\n      Result := {CHARACTER}.min_value\n    ensure\n      meaningful: Result <= 0\n    end\n\n  minimum_integer: INTEGER\n      -- Smallest supported value of type INTEGER_32\n    obsolete\n      \"Use `{INTEGER}.min_value' instead.\"\n    do\n      Result := {INTEGER}.min_value\n    ensure\n      meaningful: Result <= 0\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"pointer.e","content":"note\n  description: \"References to objects meant to be exchanged with non-Eiffel software.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class POINTER inherit\n\n  POINTER_REF\n    redefine\n      hash_code,\n      plus,\n      to_integer_32,\n      is_default_pointer,\n      out\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({POINTER_REF})\n\nfeature -- Access\n\n  hash_code: INTEGER\n      -- Hash code value\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  is_default_pointer: BOOLEAN\n      -- <Precursor>\n    external\n      \"built_in\"\n    end\n\nfeature -- Operations\n\n  plus alias \"+\" (offset: INTEGER): POINTER\n      -- Pointer moved by an offset of `offset' bytes.\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of pointer value\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"pointer_ref.e","content":"note\n  description: \"[\n    References to objects containing reference to object\n    meant to be exchanged with non-Eiffel software.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass POINTER_REF\ninherit\n  HASHABLE\n    redefine\n      out, is_equal, is_hashable\n    end\n\n  REFACTORING_HELPER\n    redefine\n      out, is_equal\n    end\n\nfeature -- Access\n\n  item: POINTER\n      -- Pointer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item.hash_code\n    end\n\nfeature -- Element change\n\n  frozen set_item (p: POINTER)\n      -- Make `p' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Status report\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= default_pointer\n    end\n\n  is_default_pointer: BOOLEAN\n      -- Is current `default_pointer'?\n    do\n      Result := item = default_pointer\n    ensure\n      definition: Result = (item = default_pointer)\n    end\n\nfeature -- Operations\n\n  plus alias \"+\" (offset: INTEGER): POINTER\n      -- Pointer moved by an offset of `offset' bytes.\n    do\n      Result := item + offset\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: POINTER_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: POINTER_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n--      not_too_small: item >= {INTEGER_32}.Min_value\n--      not_too_big: item <= {INTEGER_32}.Max_value\n    do\n      -- TODO: Fix ONCE arguments\n      --fixme (once \"Do not forget to add proper precondition to ensure we can convert pointer %\n      --  %value into an INTEGER_32\")\n      Result := item.to_integer_32\n    end\n\nfeature -- Memory copy\n\n  memory_copy (a_source: POINTER; a_size: INTEGER)\n      -- Copy `a_size' bytes from `a_source' to `Current'.\n      -- `a_source' and `Current' should not overlap.\n    require\n      valid_size: a_size >= 0\n      valid_source: a_source /= default_pointer\n    do\n      c_memcpy (item, a_source, a_size)\n    end\n\n  memory_move (a_source: POINTER; a_size: INTEGER)\n      -- Copy `a_size' bytes from `a_source' to `Current'.\n      -- `a_source' and `Current' can overlap.\n    require\n      valid_size: a_size >= 0\n      valid_source: a_source /= default_pointer\n    do\n      c_memmove (item, a_source, a_size)\n    end\n\n  memory_set (val, n: INTEGER)\n      -- Fill first `n' bytes of the memory pointed by `Current'\n      -- with constant `val'.\n    require\n      valid_val: val >= 0\n      valid_n: n >= 0\n    do\n      c_memset (item, val, n)\n    end\n\nfeature -- Allocation/free\n\n  memory_alloc (a_size: INTEGER): POINTER\n      -- Allocated `size' bytes using `malloc'.\n    require\n      valid_size: a_size > 0\n    do\n      Result := c_malloc (a_size)\n    end\n\n  memory_calloc (a_count, a_element_size: INTEGER): POINTER\n      -- Allocate `a_count' elements of size `a_element_size' bytes using `calloc.\n    require\n      valid_element_count: a_count > 0\n      valid_element_size: a_element_size > 0\n    do\n      Result := c_calloc (a_count, a_element_size)\n    end\n\n  memory_realloc (a_size: INTEGER): POINTER\n      -- Realloc `Current'.\n    require\n      valid_size: a_size >= 0\n    do\n      Result := c_realloc (item, a_size)\n    end\n\n  memory_free\n      -- Free allocated memory with `malloc'.\n    do\n      c_free (item)\n      set_item (default_pointer)\n    end\n\nfeature -- Comparison\n\n  memory_compare (other: POINTER; a_size: INTEGER): BOOLEAN\n      -- True if `Current' and `other' are identical on `a_size' bytes.\n    require\n      valid_size: a_size > 0\n      valid_other: other /= default_pointer\n    do\n      Result := c_memcmp (item, other, a_size) = 0\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of pointer value\n    do\n      Result := item.out\n    end\n\nfeature {NONE} -- Implementation\n\n  c_memcpy (destination, source: POINTER; count: INTEGER)\n      -- C memcpy\n    external\n      \"C signature (void *, const void *, size_t) use <string.h>\"\n    alias\n      \"memcpy\"\n    end\n\n  c_memmove (destination, source: POINTER; count: INTEGER)\n      -- C memmove\n    external\n      \"C signature (void *, const void *, size_t) use <string.h>\"\n    alias\n      \"memmove\"\n    end\n\n  c_memset (source: POINTER; val: INTEGER; count: INTEGER)\n      -- C memset\n    external\n      \"C signature (void *, int, size_t) use <string.h>\"\n    alias\n      \"memset\"\n    end\n\n  c_memcmp (source, other: POINTER; count: INTEGER): INTEGER\n      -- C memcmp\n    external\n      \"C signature (void *, void *, size_t): EIF_INTEGER use <string.h>\"\n    alias\n      \"memcmp\"\n    end\n\n  c_malloc (size: INTEGER): POINTER\n      -- C malloc\n    external\n      \"C signature (size_t): EIF_POINTER use <stdlib.h>\"\n    alias\n      \"malloc\"\n    end\n\n  c_calloc (nmemb, size: INTEGER): POINTER\n      -- C calloc\n    external\n      \"C signature (size_t, size_t): EIF_POINTER use <stdlib.h>\"\n    alias\n      \"calloc\"\n    end\n\n  c_realloc (source: POINTER; size: INTEGER): POINTER\n      -- C realloc\n    external\n      \"C signature (void *, size_t): EIF_POINTER use <stdlib.h>\"\n    alias\n      \"realloc\"\n    end\n\n  c_free (p: POINTER)\n      -- C free\n    external\n      \"C signature (void *) use <stdlib.h>\"\n    alias\n      \"free\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"procedure.e","content":"note\n  description: \"[\n    Objects representing delayed calls to a procedure.\n    with some operands possibly still open.\n\n    Note: Features are the same as those of ROUTINE,\n      with `apply' made effective, and no further\n      redefinition of `is_equal' and `copy'.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-28 14:35:23 -0800 (Tue, 28 Jan 2014) $\"\n  revision: \"$Revision: 94109 $\"\n\nclass\n  PROCEDURE [BASE_TYPE -> detachable ANY, OPEN_ARGS -> detachable TUPLE create default_create end]\n\ninherit\n  ROUTINE [BASE_TYPE, OPEN_ARGS]\n    rename\n      call as call alias \"()\"\n    end\n\ncreate {NONE}\n  set_rout_disp\n\nfeature -- Calls\n\n  apply\n      -- Call procedure with `args' as last set.\n    do\n      call (operands)\n    end\n\n  call alias \"()\" (args: detachable separate OPEN_ARGS)\n    local\n      c: like closed_operands\n      l_closed_count: INTEGER\n    do\n      c := closed_operands\n      if c /= Void then\n        l_closed_count :=  c.count\n      end\n      fast_call (encaps_rout_disp, calc_rout_addr, $closed_operands, $args, routine_id,\n               is_basic, written_type_id_inline_agent, l_closed_count, open_count, $open_map)\n    end\n\nfeature {NONE} -- Implementation\n\n  fast_call (a_rout_disp, a_calc_rout_addr: POINTER;\n           a_closed_operands: POINTER; a_operands: POINTER;\n         a_routine_id: INTEGER; a_is_basic: BOOLEAN; a_class_id_inline_agent: INTEGER;\n         a_closed_count, a_open_count: INTEGER; a_open_map: POINTER)\n    external\n      \"C inline use %\"eif_rout_obj.h%\"\"\n    alias\n      \"[\n      #ifdef WORKBENCH\n        if ($a_rout_disp != 0) {\n          (FUNCTION_CAST(void, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n            $a_calc_rout_addr, $a_closed_operands, $a_operands);\n        } else {\n          rout_obj_call_procedure_dynamic (\n            $a_routine_id,\n            $a_is_basic,\n            $a_class_id_inline_agent,\n            $a_closed_operands,\n            $a_closed_count,\n            $a_operands,\n            $a_open_count,\n            $a_open_map);\n        }\n      #else\n        (FUNCTION_CAST(void, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n          $a_calc_rout_addr, $a_closed_operands, $a_operands);\n      #endif\n      ]\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class READABLE_INDEXABLE [G]\n\ninherit\n  ITERABLE [G]\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): G\n      -- Entry at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  new_cursor: INDEXABLE_ITERATION_CURSOR [G]\n      -- <Precursor>\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nfeature -- Measurement\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    deferred\n    ensure\n      not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' a valid index?\n    deferred\n    ensure\n      only_if_in_index_set:\n        Result implies ((i >= index_set.lower) and (i <= index_set.upper))\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"readable_string_32.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:21:19 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95060 $\"\n\ndeferred class\n  READABLE_STRING_32\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    redefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    end\n\n  READABLE_INDEXABLE [CHARACTER_32]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_readable_string_8: {READABLE_STRING_8},\n  as_string_8: {STRING_8},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_32; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_32)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    deferred\n    ensure\n      not_shared_implementation: Current /= s\n      initialized: same_string_general (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_32_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c'.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_32): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_32; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    end\n\n  last_index_of (c: CHARACTER_32; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_32\n      -- New STRING_32 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_32\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_32}\n    do\n      if same_type (create {STRING_32}.make_empty) and then attached {STRING_32} Current as l_s32 then\n        Result := l_s32\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_32]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n        nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n      do\n        if other = Current then\n          Result := True\n        else\n          nb := count\n          if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n          end\n        end\n\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_32): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER_32\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_32): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = False\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = True\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN\n      -- <Precursor>\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      from\n        Result := True\n        i := area_lower\n        nb := count + i\n        l_area := area\n      until\n        i = nb or not Result\n      loop\n        Result := l_area.item (i).code <= {CHARACTER_8}.max_value\n        i := i + 1\n      end\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_prop: like character_properties\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n        l_prop := character_properties\n      until\n        i > n or not l_prop.is_space (l_area.item (i))\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_32): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    end\n\n  starts_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := True\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        Result := is_case_insensitive_equal_general (true_constant)\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        Result := is_case_insensitive_equal_general (false_constant)\n      end\n    end\n\nfeature {READABLE_STRING_32} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_32)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (as_string_8)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies same_string_general (Result)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_32_SEARCHER\n      -- String searcher specialized for READABLE_STRING_32 instances\n    once\n      create Result.make\n    end\n\nfeature {NONE} -- Implementation\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_lower (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_upper (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:22:02 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95061 $\"\n\ndeferred class\n  READABLE_STRING_8\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    redefine\n      copy, is_equal, out\n    end\n\n  READABLE_INDEXABLE [CHARACTER_8]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_string_8: {STRING_8},\n  as_readable_string_32: {READABLE_STRING_32},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_8; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_8)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_8_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c' instead.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8\n      -- Character at position `i'.\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n    obsolete\n      \"For consistency with Unicode string handling, use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_8): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_8; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: CHARACTER_8; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_8\n      -- New STRING_8 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_8\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_8}\n    do\n      if same_type (create {STRING_8}.make_empty) and then attached {STRING_8} Current as l_s8 then\n        Result := l_s8\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_8): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_8]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n        end\n      end\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_8): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then c1.as_lower /= c2.as_lower then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: l_area.upper - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_8): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = False\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n      until\n        i > n or not l_area.item (i).is_space\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_8): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    ensure\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  starts_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := v <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n      l_area: like area\n      i: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 't' and then\n          l_area.item (i + 1).lower = 'r' and then\n          l_area.item (i + 2).lower = 'u' and then\n          l_area.item (i + 3).lower = 'e'\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 'f' and then\n          l_area.item (i + 1).lower = 'a' and then\n          l_area.item (i + 2).lower = 'l' and then\n          l_area.item (i + 3).lower = 's' and then\n          l_area.item (i + 4).lower = 'e'\n      end\n    end\n\nfeature {READABLE_STRING_8} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_8)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (Current)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies Result.same_string (Current)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_8_SEARCHER\n      -- String searcher specialized for READABLE_STRING_8 instances\n    once\n      create Result.make\n    end\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).lower, i)\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).upper, i)\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes. Read-only interface.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 06:27:01 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94630 $\"\n\ndeferred class\n  READABLE_STRING_GENERAL\n\ninherit\n  COMPARABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    end\n\n  HASHABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\n  STRING_HANDLER\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n    require\n      non_negative_size: n >= 0\n    deferred\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\n  make_empty\n      -- Create empty string.\n    do\n      make (0)\n    ensure\n      empty: count = 0\n      area_allocated: capacity >= 0\n    end\n\nfeature -- Access\n\n  code (i: INTEGER): NATURAL_32\n      -- Code at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  item alias \"[]\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  index_of (c: like item; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else item (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: like item; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else item (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  index_of_code (c: like code; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else code (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has_code (c)\n      found_if_present: substring (start_index, count).has_code (c) implies code (Result) = c\n      none_before: substring (start_index, count).has_code (c) implies\n        not substring (start_index, Result - 1).has_code (c)\n    end\n\n  last_index_of_code (c: like code; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else code (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has_code (c)\n      found_if_present: substring (1, start_index_from_end).has_code (c) implies code (Result) = c\n      none_after: substring (1, start_index_from_end).has_code (c) implies\n        not substring (Result + 1, start_index_from_end).has_code (c)\n    end\n\n  false_constant: STRING_8 = \"false\"\n      -- Constant string \"false\"\n\n  true_constant: STRING_8 = \"true\"\n      -- Constant string \"true\"\n\n  hash_code: INTEGER\n      -- Hash code value\n    local\n      i, nb: INTEGER\n    do\n      Result := internal_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + item (i).code\n          i := i + 1\n        end\n        internal_hash_code := Result\n      end\n    end\n\n  case_insensitive_hash_code: INTEGER\n      -- Hash code value of the lower case version of `Current'.\n    local\n      l_props: like character_properties\n      i, nb: INTEGER\n    do\n      Result := internal_case_insensitive_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n          l_props := character_properties\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + l_props.to_lower (item (i)).code\n          i := i + 1\n        end\n        internal_case_insensitive_hash_code := Result\n      end\n    ensure\n      consistent: Result = as_lower.hash_code\n    end\n\nfeature -- Status report\n\n  is_immutable: BOOLEAN\n      -- Can the character sequence of `Current' be not changed?\n    do\n      Result := False\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the string?\n    do\n      Result := (i > 0) and (i <= count)\n    ensure\n      definition: Result = (1 <= i and i <= count)\n    end\n\n  valid_code (v: like code): BOOLEAN\n      -- Is `v' a valid code for Current?\n    deferred\n    end\n\n  is_string_8: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_8?\n    deferred\n    end\n\n  is_string_32: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_32?\n    deferred\n    end\n\n  is_valid_as_string_8: BOOLEAN\n      -- Is `Current' convertible to a sequence of CHARACTER_8 without information loss?\n    deferred\n    end\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    deferred\n    end\n\n  is_whitespace: BOOLEAN\n      -- Is structure containing only whitespace characters?\n    do\n      Result := is_substring_whitespace (1, count)\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- Is substring between `start_index' and `end_index' containing only whitespace characters?\n    require\n      start_index_big_enough: 1 <= start_index\n      end_index_small_enough: end_index <= count\n      consistent_indexes: start_index - 1 <= end_index\n    deferred\n    end\n\n  has (c: like item): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  has_code (c: like code): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (code (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then code (1) = c implies Result\n      recurse: (count > 0 and then code (1) /= c) implies\n        (Result = substring (2, count).has_code (c))\n    end\n\n  is_number_sequence: BOOLEAN\n      -- Does `Current' represent a number sequence?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_no_limitation)\n    ensure\n      syntax_and_range:\n        -- Result is true if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  Current can be produced by \"Integer_literal\":\n        --\n        -- Integer_literal = [Space] [Sign] Integer [Space]\n        -- Space  = \" \" | \" \" Space\n        -- Sign   = \"+\" | \"-\"\n        -- Integer  = Digit | Digit Integer\n        -- Digit  = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n    end\n\n  is_real_sequence: BOOLEAN\n      -- Does `Current' represent a real sequence?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following condition is satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n    end\n\n  is_real, is_real_32: BOOLEAN\n      -- Does `Current' represent a REAL_32?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_real)\n      Result := l_convertor.is_integral_real\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type REAL.\n    end\n\n  is_double, is_real_64: BOOLEAN\n      -- Does `Current' represent a REAL_64?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_double)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type DOUBLE.\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    deferred\n    ensure\n      is_boolean: Result = (true_constant.same_string_general (as_lower) or\n        false_constant.same_string_general (as_lower))\n    end\n\n  is_integer_8: BOOLEAN\n      -- Does `Current' represent an INTEGER_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_8)\n    end\n\n  is_integer_16: BOOLEAN\n      -- Does `Current' represent an INTEGER_16?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_16)\n    end\n\n  is_integer, is_integer_32: BOOLEAN\n      -- Does `Current' represent an INTEGER_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_32)\n    end\n\n  is_integer_64: BOOLEAN\n      -- Does `Current' represent an INTEGER_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_64)\n    end\n\n  is_natural_8: BOOLEAN\n      -- Does `Current' represent a NATURAL_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_8)\n    end\n\n  is_natural_16: BOOLEAN\n      -- Does `Current' represent a NATURAL_16?\n\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_16)\n    end\n\n  is_natural, is_natural_32: BOOLEAN\n      -- Does `Current' represent a NATURAL_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_32)\n    end\n\n  is_natural_64: BOOLEAN\n      -- Does `Current' represent a NATURAL_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_64)\n    end\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of characters in Current\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Number of characters allocated in Current\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          if item (i) = c then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\nfeature -- Comparison\n\n  is_case_insensitive_equal (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      c1,c2: like item\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := item (i)\n          c2 := other.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  has_substring (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `Current' contain `other'?\n    require\n      other_not_void: other /= Void\n    do\n      if other = Current then\n        Result := True\n      elseif other.count <= count then\n        Result := substring_index (other, 1) > 0\n      end\n    ensure\n      false_if_too_small: count < other.count implies not Result\n      true_if_initial: (count >= other.count and then\n        other.same_string (substring (1, other.count))) implies Result\n      recurse: (count >= other.count and then\n        not other.same_string (substring (1, other.count))) implies\n        (Result = substring (2, count).has_substring (other))\n    end\n\n  same_string (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `other' represent the same string as `Current'?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    end\n\n  same_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          if item (i) /= other.item (j) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  starts_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code (i) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code(j) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n            j := j - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start_pos'\n      -- and to or before `end_pos';\n      -- 0 if none.\n    require\n      other_nonvoid: other /= Void\n      other_notempty: not other.is_empty\n      start_pos_large_enough: start_pos >= 1\n      start_pos_small_enough: start_pos <= count\n      end_pos_large_enough: end_pos >= start_pos\n      end_pos_small_enough: end_pos <= count\n    deferred\n    ensure\n      correct_place: Result > 0 implies other.same_string (substring (Result, Result + other.count - 1))\n      -- forall x : start_pos..Result\n      --  not substring (x, x+other.count -1).is_equal (other)\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- Index of first occurrence of other at or after start_index;\n      -- 0 if none\n    require\n      other_not_void: other /= Void\n      valid_start_index: start_index >= 1 and start_index <= count + 1\n    deferred\n    ensure\n      valid_result: Result = 0 or else\n        (start_index <= Result and Result <= count - other.count + 1)\n      zero_if_absent: (Result = 0) =\n        not substring (start_index, count).has_substring (other)\n      at_this_index: Result >= start_index implies\n        other.same_string (substring (Result, Result + other.count - 1))\n      none_before: Result > start_index implies\n        not substring (start_index, Result + other.count - 2).has_substring (other)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start'\n      -- with 0..`fuzz' mismatches between the string and `other'.\n      -- 0 if there are no fuzzy matches\n    require\n      other_exists: other /= Void\n      other_not_empty: not other.is_empty\n      start_large_enough: start >= 1\n      start_small_enough: start <= count\n      acceptable_fuzzy: fuzz <= other.count\n    deferred\n    end\n\nfeature -- Conversion\n\n  frozen to_cil: SYSTEM_STRING\n      -- Create an instance of SYSTEM_STRING using characters\n      -- of Current between indices `1' and `count'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := dotnet_convertor.from_string_to_system_string (Current)\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_string_8: STRING_8\n      -- Convert `Current' as a STRING_8.\n    require\n      is_valid_as_string_8: is_valid_as_string_8\n    do\n      Result := as_string_8\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_8_conversion: STRING_8\n      -- Equivalent to `as_string_8' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the target recipient of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update recipient of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_readable_string_8: READABLE_STRING_8\n      --\n    obsolete\n      \"Use explicit conversion `to_string_8' instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_string_8: STRING_8\n      -- Convert `Current' as a STRING_8. If a code of `Current' is\n      -- not a valid code for a STRING_8 it is replaced with the null\n      -- character.\n    local\n      i, nb: INTEGER\n      l_code: like code\n    do\n      if attached {STRING_8} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          l_code := code (i)\n          if Result.valid_code (l_code) then\n            Result.put_code (l_code, i)\n          else\n            Result.put_code (0, i)\n          end\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_32_conversion: STRING_32\n      -- Equivalent to `as_string_32' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the source of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update target of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_readable_string_32: READABLE_STRING_32\n      --\n    obsolete\n      \"Use explicit conversion `to_string_32' instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_string_32, to_string_32: STRING_32\n      -- Convert `Current' as a STRING_32.\n    local\n      i, nb: INTEGER\n    do\n      if attached {STRING_32} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          Result.put_code (code (i), i)\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_32_not_void: Result /= Void\n      identity: (conforms_to (create {STRING_32}.make_empty) and Result = Current) or (not conforms_to (create {STRING_32}.make_empty) and Result /= Current)\n    end\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    deferred\n    ensure\n      as_lower_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_lower\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    deferred\n    ensure\n      as_upper_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_upper\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_upper\n    end\n\n  to_integer_8: INTEGER_8\n      -- 8-bit integer value\n    require\n      is_integer_8: is_integer_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_8\n    end\n\n  to_integer_16: INTEGER_16\n      -- 16-bit integer value\n    require\n      is_integer_16: is_integer_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_16\n    end\n\n  to_integer, to_integer_32: INTEGER_32\n      -- 32-bit integer value\n    require\n      is_integer: is_integer_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer\n    end\n\n  to_integer_64: INTEGER_64\n      -- 64-bit integer value\n    require\n      is_integer_64: is_integer_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_64\n    end\n\n  to_natural_8: NATURAL_8\n      -- 8-bit natural value\n    require\n      is_natural_8: is_natural_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_8\n    end\n\n  to_natural_16: NATURAL_16\n      -- 16-bit natural value\n    require\n      is_natural_16: is_natural_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_16\n    end\n\n  to_natural, to_natural_32: NATURAL_32\n      -- 32-bit natural value\n    require\n      is_natural: is_natural_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_32\n    end\n\n  to_natural_64: NATURAL_64\n      -- 64-bit natural value\n    require\n      is_natural_64: is_natural_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_64\n    end\n\n  to_real, to_real_32: REAL\n      -- Real value;\n      -- for example, when applied to \"123.0\", will yield 123.0\n    require\n      represents_a_real: is_real\n    do\n      Result := to_double.truncated_to_real\n    end\n\n  to_double, to_real_64: DOUBLE\n      -- \"Double\" value;\n      -- for example, when applied to \"123.0\", will yield 123.0 (double)\n    require\n      represents_a_double: is_double\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_double\n    end\n\n  to_boolean: BOOLEAN\n      -- Boolean value;\n      -- \"True\" yields `True', \"False\" yields `False'\n      -- (case-insensitive)\n    require\n      is_boolean: is_boolean\n    do\n      check true_constant.count = 4 end\n      if count = 4 then\n        Result := True\n      end\n    ensure\n      to_boolean: (Result = as_lower.same_string (true_constant)) or\n        (not Result = as_lower.same_string (false_constant))\n    end\n\nfeature -- Conversion\n\n  split (a_separator: CHARACTER_32): LIST [like Current]\n      -- Split on `a_separator'.\n    local\n      l_list: ARRAYED_LIST [like Current]\n      part: like Current\n      i, j, c: INTEGER\n    do\n      c := count\n        -- Worse case allocation: every character is a separator\n      create l_list.make (c + 1)\n      if c > 0 then\n        from\n          i := 1\n        until\n          i > c\n        loop\n          j := index_of (a_separator, i)\n          if j = 0 then\n              -- No separator was found, we will\n              -- simply create a list with a copy of\n              -- Current in it.\n            j := c + 1\n          end\n          part := substring (i, j - 1)\n          l_list.extend (part)\n          i := j + 1\n        end\n        if j = c then\n          check\n            last_character_is_a_separator: item (j) = a_separator\n          end\n            -- A separator was found at the end of the string\n          l_list.extend (new_string (0))\n        end\n      else\n          -- Extend empty string, since Current is empty.\n        l_list.extend (new_string (0))\n      end\n      Result := l_list\n      check\n        l_list.count = occurrences (a_separator) + 1\n      end\n    ensure\n      Result /= Void\n    end\n\nfeature -- Element change\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    deferred\n    ensure\n      plus_not_void: Result /= Void\n      new_count: Result.count = count + s.count\n      initial: elks_checking implies Result.substring (1, count) ~ Current\n      final: elks_checking implies Result.substring (count + 1, count + s.count).same_string (s)\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    ensure\n      substring_not_void: Result /= Void\n      substring_count: Result.count = end_index - start_index + 1 or Result.count = 0\n      first_code: Result.count > 0 implies Result.item (1) = item (start_index)\n      recurse: Result.count > 0 implies\n        Result.substring (2, Result.count) ~ substring (start_index + 1, end_index)\n    end\n\n  head (n: INTEGER): like Current\n      -- Prefix, retaining first `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (1, n)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\n  tail (n: INTEGER): like Current\n      -- Suffix, retaining last `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (count - n + 1, count)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\nfeature {NONE} -- Assertion helper\n\n  elks_checking: BOOLEAN = False\n      -- Are ELKS checkings verified? Must be True when changing implementation of STRING_GENERAL or descendant.\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    require\n      n_non_negative: n >= 0\n    deferred\n    ensure\n      new_string_not_void: Result /= Void\n      new_string_empty: Result.is_empty\n      new_string_area_big_enough: Result.capacity >= n\n    end\n\n  is_valid_integer_or_natural (type: INTEGER) : BOOLEAN\n      -- Is `Current' a valid number according to given `type'?\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.reset (type)\n      l_convertor.parse_string_with_type (Current, type)\n      Result := l_convertor.is_integral_integer\n    end\n\n  string_searcher: STRING_SEARCHER\n      -- Facilities to search string in another string.\n    deferred\n    ensure\n      string_searcher_not_void: Result /= Void\n    end\n\n  c_string_provider: C_STRING\n      -- To create Eiffel strings from C string.\n    once\n      create Result.make_empty (0)\n    ensure\n      c_string_provider_not_void: Result /= Void\n    end\n\n  ctoi_convertor: STRING_TO_INTEGER_CONVERTOR\n      -- Convertor used to convert string to integer or natural\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctoi_convertor_not_void: Result /= Void\n    end\n\n  ctor_convertor: STRING_TO_REAL_CONVERTOR\n      -- Convertor used to convert string to real or double\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctor_convertor_not_void: Result /= Void\n    end\n\n  dotnet_convertor: SYSTEM_STRING_FACTORY\n      -- Convertor used to convert from and to SYSTEM_STRING.\n    once\n      create Result\n    ensure\n      dotnet_convertor_not_void: Result /= Void\n    end\n\n  character_properties: CHARACTER_PROPERTY\n      -- Access to Unicode character properties\n    once\n      create Result.make\n    end\n\nfeature {READABLE_STRING_GENERAL} -- Implementation\n\n  internal_hash_code: INTEGER\n      -- Cache for `hash_code'.\n\n  internal_case_insensitive_hash_code: INTEGER;\n      -- Cash for `case_insensitive_hash_code'.\n\n\nfeature -- Access: Cursor\n\n  new_character_32_cursor: STRING_ITERATION_CURSOR\n      -- Fresh cursor for this string that iterates over code points (see `code')\n      -- exposed as {CHARACTER_32}.\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_32.e","content":"note\n  description: \"Real values, single precision\"\n  external_name: \"System.Single\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class REAL_32 inherit\n\n  REAL_32_REF\n    redefine\n      is_less,\n      is_nan,\n      is_negative_infinity,\n      is_positive_infinity,\n      truncated_to_integer,\n      truncated_to_integer_64,\n      to_double,\n      ceiling_real_32,\n      floor_real_32,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      opposite,\n      identity,\n      out\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({REAL_32_REF}),\n  to_double: {REAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: REAL_32): BOOLEAN\n      -- Is `other' greater than current real?\n    external\n      \"built_in\"\n    end\n\nfeature -- Status Report\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    external\n      \"built_in\"\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    external\n      \"built_in\"\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Current seen as a double\n    external\n      \"built_in\"\n    end\n\n  ceiling_real_32: REAL_32\n      -- Smallest integral value no smaller than current object\n    external\n      \"built_in\"\n    end\n\n  floor_real_32: REAL_32\n      -- Greatest integral value no greater than current object\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: REAL_32): REAL_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: REAL_32): REAL_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: REAL_32): REAL_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: REAL_32): REAL_32\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current real to the power `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": REAL_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": REAL_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of real value\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_32_ref.e","content":"note\n  description: \"References to objects containing a real value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-12-30 16:54:49 -0800 (Mon, 30 Dec 2013) $\"\n  revision: \"$Revision: 93855 $\"\n\nclass REAL_32_REF inherit\n\n  NUMERIC\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: REAL_32\n      -- Numeric real value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := truncated_to_integer.hash_code\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0.0 then\n        Result := 1\n      elseif item < 0.0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item ({REAL_32} 1.0)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item ({REAL_32} 0.0)\n    end\n\n  nan: REAL_32\n      -- Representation of not a number (NaN)\n    external\n      \"built_in static\"\n    end\n\n  negative_infinity: REAL_32\n      -- Representation of negative infinity\n    external\n      \"built_in static\"\n    end\n\n  positive_infinity: REAL_32\n      -- Representation of positive infinity\n    external\n      \"built_in static\"\n    end\n\n  min_value: REAL_32 = -3.4028234663852885981170e+038\n  max_value: REAL_32 = 3.4028234663852885981170e+038\n      -- Minimum and Maximum value hold in `item'.\n\n  machine_epsilon: REAL_32 = 1.1920928955078125000000e-007\n      -- The difference between 1 and the least value greater than\n      -- 1 that is representable in the given floating point type.\n\n  epsilon: REAL_32 = 1.1754943508222875079688e-038\n      -- Minimum normalized positive floating-point number.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current real?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (r: REAL_32)\n      -- Make `r' the value of `item'.\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  divisible (other: REAL_32_REF): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0.0\n    ensure then\n      ref_not_exact_zero: Result implies (other.item /= 0.0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0.0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0.0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0.0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0.0) or\n        (other.conforms_to (0.0) and item > 0.0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0.0\n    end\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    do\n      Result := item.is_nan\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    do\n      Result := item.is_negative_infinity\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    do\n      Result := item.is_positive_infinity\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: REAL_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: REAL_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer_64\n    end\n\n  to_double: REAL_64\n      -- Current seen as a double\n    do\n      Result := item.to_double\n    end\n\n  ceiling: INTEGER_32\n      -- Smallest integral value no smaller than current object\n    do\n      Result := ceiling_real_32.truncated_to_integer\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor: INTEGER_32\n      -- Greatest integral value no greater than current object\n    do\n      Result := floor_real_32.truncated_to_integer\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded: INTEGER_32\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + 0.5).floor)\n    ensure\n      definition: Result = sign * ((abs + 0.5).floor)\n    end\n\n  ceiling_real_32: REAL_32\n      -- Smallest integral value no smaller than current object\n    do\n      Result := item.ceiling_real_32\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor_real_32: REAL_32\n      -- Greatest integral value no greater than current object\n    do\n      Result := item.floor_real_32\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded_real_32: REAL_32\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + {REAL_32} 0.5).floor_real_32)\n    ensure\n      definition: Result = sign * ((abs + {REAL_32} 0.5).floor_real_32)\n    end\n\nfeature -- Basic operations\n\n  abs: REAL_32\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0.0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    do\n      create Result\n      Result.set_item (item / other.item)\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current real to the power `other'\n    do\n      Result := item ^ other\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of real value\n    do\n      Result := item.out\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item = 0.0 then\n          -- Special case when `item' is `-0'.\n        Result := zero\n      elseif item > 0.0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n  sign_times_abs: not item.is_nan implies sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_64.e","content":"note\n  description: \"Real values, double precision\"\n  external_name: \"System.Double\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class REAL_64 inherit\n\n  REAL_64_REF\n    redefine\n      is_less,\n      is_nan,\n      is_negative_infinity,\n      is_positive_infinity,\n      truncated_to_integer,\n      truncated_to_integer_64,\n      truncated_to_real,\n      ceiling_real_64,\n      floor_real_64,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      opposite,\n      identity,\n      out\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({REAL_64_REF})\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: REAL_64): BOOLEAN\n      -- Is `other' greater than current double?\n    external\n      \"built_in\"\n    end\n\nfeature -- Status Report\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    external\n      \"built_in\"\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    external\n      \"built_in\"\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  truncated_to_real: REAL_32\n      -- Real part (Same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  ceiling_real_64: REAL_64\n      -- Smallest integral value no smaller than current object\n    external\n      \"built_in\"\n    end\n\n  floor_real_64: REAL_64\n      -- Greatest integral value no greater than current object\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: REAL_64): REAL_64\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: REAL_64): REAL_64\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: REAL_64): REAL_64\n      -- Product with `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: REAL_64): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current double to the power `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": REAL_64\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": REAL_64\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of double value\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_64_ref.e","content":"note\n  description: \"References to objects containing a double-precision real number\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-12-30 16:49:34 -0800 (Mon, 30 Dec 2013) $\"\n  revision: \"$Revision: 93854 $\"\n\nclass REAL_64_REF inherit\n\n  NUMERIC\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: REAL_64\n      -- Numeric double value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := truncated_to_integer.hash_code\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0.0 then\n        Result := 1\n      elseif item < 0.0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1.0)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0.0)\n    end\n\n  nan: REAL_64\n      -- Representation of not a number (NaN)\n    external\n      \"built_in static\"\n    end\n\n  negative_infinity: REAL_64\n      -- Representation of negative infinity\n    external\n      \"built_in static\"\n    end\n\n  positive_infinity: REAL_64\n      -- Representation of positive infinity\n    external\n      \"built_in static\"\n    end\n\n  min_value: REAL_64 = -1.7976931348623157081452e+308\n  max_value: REAL_64 = 1.7976931348623157081452e+308\n      -- Minimum and Maximum value hold in `item'.\n\n  machine_epsilon: REAL_64 = 2.2204460492503130808473e-016\n      -- The difference between 1 and the least value greater than\n      -- 1 that is representable in the given floating point type.\n\n  epsilon: REAL_64 = 2.2250738585072013830903e-308\n      -- Minimum normalized positive floating-point number.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current double?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (d: REAL_64)\n      -- Make `d' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  divisible (other: REAL_64_REF): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0.0\n    ensure then\n      not_exact_zero: Result implies (other.item /= 0.0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0.0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0.0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0.0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0.0) or\n        (other.conforms_to (0.0) and item > 0.0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0.0\n    end\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    do\n      Result := item.is_nan\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    do\n      Result := item.is_negative_infinity\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    do\n      Result := item.is_positive_infinity\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: REAL_64_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: REAL_64_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer_64\n    end\n\n  truncated_to_real: REAL_32\n      -- Real part (Same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_real\n    end\n\n  ceiling: INTEGER_32\n      -- Smallest integral value no smaller than current object\n    do\n      Result := ceiling_real_64.truncated_to_integer\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor: INTEGER_32\n      -- Greatest integral value no greater than current object\n    do\n      Result := floor_real_64.truncated_to_integer\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded: INTEGER_32\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + 0.5).floor)\n    ensure\n      definition: Result = sign * ((abs + 0.5).floor)\n    end\n\n  ceiling_real_64: REAL_64\n      -- Smallest integral value no smaller than current object\n    do\n      Result := item.ceiling_real_64\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor_real_64: REAL_64\n      -- Greatest integral value no greater than current object\n    do\n      Result := item.floor_real_64\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded_real_64: REAL_64\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + 0.5).floor_real_64)\n    ensure\n      definition: Result = sign * ((abs + 0.5).floor_real_64)\n    end\n\nfeature -- Basic operations\n\n  abs: REAL_64\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0.0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product with `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    do\n      create Result\n      Result.set_item (item / other.item)\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current double to the power `other'\n    do\n      Result := item ^ other\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of double value\n    do\n      Result := item.out\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item = 0.0 then\n          -- Special case when `item' is `-0'.\n        Result := zero\n      elseif item > 0.0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n  sign_times_abs: not item.is_nan implies sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"refactoring_helper.e","content":"note\n  description: \"[\n    Collection of features that are used to mark\n    places in code that needs refactoring.\n    ]\"\n\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass REFACTORING_HELPER\n\nfeature -- Markers\n\n  fixme (comment: STRING)\n      -- Mark code that has to be \"fixed\" with `comment'.\n    require\n      comment_not_void: comment /= Void\n    do\n      -- debug (\"refactor_fixme\")\n      --   io.error.put_string (\"FIXME: \")\n      --   io.error.put_string (comment)\n      --   io.error.put_new_line\n      -- end\n    end\n\n  to_implement (comment: STRING)\n      -- Mark code that has to be \"implemented\" with `comment'.\n    require\n      comment_not_void: comment /= Void\n    do\n      -- debug (\"refactor_fixme\")\n      --   io.error.put_string (\"TO_BE_IMPLEMENTED: \")\n      --   io.error.put_string (comment)\n      --   io.error.put_new_line\n      -- end\n    end\n\n  to_implement_assertion (comment: STRING): BOOLEAN\n      -- Mark assertion that has to be \"implemented\" with `comment'.\n    require\n      comment_not_void: comment /= Void\n    do\n      -- TODO implement debug statement\n      -- debug (\"refactor_fixme\")\n      --   io.error.put_string (\"ASSERTION_TO_BE_IMPLEMENTED: \")\n      --   io.error.put_string (comment)\n      --   io.error.put_new_line\n      -- end\n      Result := True\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"reflector.e","content":"note\n  description: \"[\n      Access to internal object properties.\n      This class may be used as ancestor by classes needing its facilities.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-09-06 21:45:47 -0700 (Fri, 06 Sep 2013) $\"\n  revision: \"$Revision: 92917 $\"\n\nclass\n  REFLECTOR\n\ninherit\n  REFLECTOR_HELPER\n\n  REFLECTOR_CONSTANTS\n\nfeature -- Conformance\n\n  type_conforms_to (type1, type2: INTEGER): BOOLEAN\n      -- Does `type1' conform to `type2'?\n    require\n      type1_nonnegative: type1 >= 0\n      type2_nonnegative: type2 >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.type_conforms_to (type1, type2)\n    end\n\n  field_conforms_to (a_source_type, a_field_type: INTEGER): BOOLEAN\n      -- Does `a_source_type' conform to `a_field_type'?\n      --| Different from `type_conforms_to' since possible attachment mark of `a_field_type'\n      --| is discarded.\n    require\n      a_source_type_non_negative: a_source_type >= 0\n      a_field_type_non_negative: a_field_type >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.type_conforms_to (a_source_type, {ISE_RUNTIME}.detachable_type (a_field_type))\n    end\n\nfeature -- Creation\n\n  dynamic_type_from_string (class_type: READABLE_STRING_GENERAL): INTEGER\n      -- Dynamic type corresponding to `class_type'.\n      -- If no dynamic type available, returns -1.\n    require\n      class_type_not_void: class_type /= Void\n      class_type_not_empty: not class_type.is_empty\n      is_valid_type_string: is_valid_type_string (class_type)\n    local\n      l_cstr: C_STRING\n      l_table: like internal_dynamic_type_string_table\n      l_pre_ecma_status: BOOLEAN\n    external\n      \"built_in\"\n      -- l_table := internal_dynamic_type_string_table\n      -- l_table.search (class_type)\n      -- if l_table.found then\n      --   Result := l_table.found_item\n      -- else\n      --   create l_cstr.make (class_type)\n      --     -- Take into consideration possible pre-ECMA mapping.\n      --   l_pre_ecma_status := {ISE_RUNTIME}.pre_ecma_mapping_status\n      --   {ISE_RUNTIME}.set_pre_ecma_mapping (not is_pre_ecma_mapping_disabled)\n      --   Result := {ISE_RUNTIME}.type_id_from_name (l_cstr.item)\n      --   {ISE_RUNTIME}.set_pre_ecma_mapping (l_pre_ecma_status)\n      --   l_table.put (Result, class_type)\n      -- end\n    ensure\n      dynamic_type_from_string_valid: Result = -1 or Result = none_type or Result >= 0\n    end\n\n  new_instance_of (type_id: INTEGER): ANY\n      -- New instance of dynamic `type_id'.\n      -- Note: returned object is not initialized and may\n      -- hence violate its invariant.\n      -- `type_id' cannot represent a SPECIAL type, use\n      -- `new_special_any_instance' instead.\n    require\n      type_id_nonnegative: type_id >= 0\n      not_special_type: not is_special_type (type_id)\n    do\n      Result := c_new_instance_of (type_id)\n    ensure\n      not_special_type: not attached {SPECIAL [detachable ANY]} Result\n      dynamic_type_set: Result.generating_type.type_id = type_id\n    end\n\n  new_special_any_instance (type_id, count: INTEGER): SPECIAL [detachable ANY]\n      -- New instance of dynamic `type_id' that represents\n      -- a SPECIAL with `count' element. To create a SPECIAL of\n      -- basic type, use `SPECIAL'.\n    require\n      count_valid: count >= 0\n      type_id_nonnegative: type_id >= 0\n      special_type: is_special_any_type (type_id)\n    do\n      create Result.make_empty (count)\n      c_set_dynamic_type (Result, type_id)\n    ensure\n      dynamic_type_set: Result.generating_type.type_id = type_id\n      count_set: Result.count = 0\n      capacity_set: Result.capacity = count\n    end\n\n  new_tuple_from_special (type_id: INTEGER; values: SPECIAL [detachable separate ANY]): detachable TUPLE\n      -- New instance of a tuple of type `type_id' filled with `values' if all types of items are suitable.\n      -- `Void' if some items from `values' are inappropriate for a tuple of type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n      is_tuple_type: is_tuple_type (type_id)\n      -- sufficient_values_count: values.count >= tuple_type_count (type_id)\n      -- valid_value_types: across 1 |..| tuple_type_count (type_id) as i all valid_object_for_tuple_index (values [i - 1], i)\n    local\n      i: INTEGER\n      v: detachable separate ANY\n    do\n      Result := c_new_tuple_instance_of (type_id)\n      i := Result.count\n      if i <= values.count then\n        from\n        until\n          i <= 0 or else not attached Result\n        loop\n          v := values [i - 1]\n          if Result.valid_type_for_index (v, i) then\n              -- Value `v' is compatible with tuple item at index `i'.\n            Result [i] := v\n          else\n              -- Value `v' is not compatible with tuple item at index `i'.\n            Result := Void\n          end\n          i := i - 1\n        end\n      else\n          -- Insufficient number of values.\n        Result := Void\n      end\n    ensure\n      dynamic_type_set: attached Result implies Result.generating_type.type_id = type_id\n      values_set: attached Result implies across 1 |..| Result.count as k all Result.item (k.item) = values [k.item - 1] end\n    end\n\n  new_tuple_from_tuple (type_id: INTEGER; source: separate TUPLE): detachable TUPLE\n      -- New instance of a tuple of type `type_id' filled with values fom `source' if all value types are suitable.\n      -- `Void' if some values from `source' are inappropriate for a tuple of type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n      is_tuple_type: is_tuple_type (type_id)\n      -- sufficient_values_count: source.count >= tuple_type_count (type_id)\n      -- valid_value_types: across 1 |..| tuple_type_count (type_id) as i all valid_object_for_tuple_index (values [i - 1], i)\n    local\n      i: INTEGER\n      v: detachable separate ANY\n    do\n      Result := c_new_tuple_instance_of (type_id)\n      i := Result.count\n      if i <= source.count then\n        if source.object_comparison then\n          Result.compare_objects\n        end\n        from\n        until\n          i <= 0 or else not attached Result\n        loop\n          v := source [i]\n          if Result.valid_type_for_index (v, i) then\n              -- Value `v' is compatible with tuple item at index `i'.\n            Result [i] := v\n          else\n              -- Value `v' is not compatible with tuple item at index `i'.\n            Result := Void\n          end\n          i := i - 1\n        end\n      else\n          -- Insufficient number of values.\n        Result := Void\n      end\n    ensure\n      dynamic_type_set: attached Result implies Result.generating_type.type_id = type_id\n      object_comparison_set: attached Result implies Result.object_comparison = source.object_comparison\n      values_set: attached Result implies across 1 |..| Result.count as k all Result.item (k.item) = source [k.item] end\n    end\n\n  type_of_type (type_id: INTEGER): TYPE [detachable ANY]\n      -- Associated TYPE instance for an object of type id `type_id'\n    require\n      type_id_nonnegative: type_id >= 0\n    do\n      Result := c_new_type_instance_of (type_id)\n    ensure\n      result_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  is_special_any_type (type_id: INTEGER): BOOLEAN\n      -- Is type represented by `type_id' represent\n      -- a SPECIAL [XX] where XX is a reference type.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C signature (EIF_INTEGER): EIF_BOOLEAN use %\"eif_internal.h%\"\"\n    alias\n      \"eif_special_any_type\"\n    end\n\n  is_special_type (type_id: INTEGER): BOOLEAN\n      -- Is type represented by `type_id' represent\n      -- a SPECIAL [XX] where XX is a reference type\n      -- or a basic type.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C signature (EIF_INTEGER): BOOLEAN use %\"eif_internal.h%\"\"\n    alias\n      \"eif_is_special_type\"\n    end\n\n  is_tuple_type (type_id: INTEGER): BOOLEAN\n      -- Is type represented by `type_id' represent a TUPLE?\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C signature (EIF_INTEGER): BOOLEAN use %\"eif_internal.h%\"\"\n    alias\n      \"eif_is_tuple_type\"\n    end\n\n  is_attached_type (a_type_id: INTEGER): BOOLEAN\n      -- Is `a_type_id' an attached type?\n    require\n      a_type_non_negative: a_type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.is_attached_type (a_type_id)\n    end\n\n  is_field_transient_of_type (i: INTEGER; a_type_id: INTEGER): BOOLEAN\n      -- Is `i'-th field of `object' a transient attribute?\n      -- I.e. an attribute that does not need to be stored?\n    require\n      a_type_non_negative: a_type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (a_type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.is_field_transient_of_type (i, a_type_id)\n    end\n\n  is_field_expanded_of_type (i: INTEGER; a_type_id: INTEGER): BOOLEAN\n      -- Is `i'-th field of type `a_type_id' a user-defined expanded attribute?\n    require\n      a_type_non_negative: a_type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (a_type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.is_field_expanded_of_type (i, a_type_id)\n    end\n\nfeature -- Access\n\n  class_name_of_type (type_id: INTEGER): STRING\n      -- Name of class associated with dynamic type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.generator_of_type (type_id)\n    end\n\n  type_name_of_type (type_id: INTEGER): STRING\n      -- Name of `type_id''s generating type (type of which `type_id'\n      -- is a direct instance).\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.generating_type_of_type (type_id)\n    end\n\n  attached_type (type_id: INTEGER): INTEGER\n      -- Attached version of `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.attached_type (type_id)\n    ensure\n      unchanged_if_attached: is_attached_type (type_id) implies type_id = Result\n    end\n\n  detachable_type (type_id: INTEGER): INTEGER\n      -- Detachable version of `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.detachable_type (type_id)\n    ensure\n      unchanged_if_detachable: not is_attached_type (type_id) implies type_id = Result\n    end\n\n  generic_count_of_type (type_id: INTEGER): INTEGER\n      -- Number of generic parameter in `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.generic_parameter_count (type_id)\n    end\n\n  generic_dynamic_type_of_type (type_id: INTEGER; i: INTEGER): INTEGER\n      -- Dynamic type of generic parameter of `type_id' at position `i'.\n    require\n      type_id_nonnegative: type_id >= 0\n      type_id_generic: generic_count_of_type (type_id) > 0\n      i_valid: i > 0 and i <= generic_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.eif_gen_param_id (type_id, i)\n    ensure\n      dynamic_type_nonnegative: Result >= 0\n    end\n\n  storable_version_of_type (a_type_id: INTEGER): detachable IMMUTABLE_STRING_8\n      -- Storable version if any specified.\n    require\n      a_type_id_nonnegative: a_type_id >= 0\n    local\n      l_result, l_null: POINTER\n    external\n      \"built_in\"\n      -- id_to_storable_version.search (a_type_id)\n      -- if id_to_storable_version.found then\n      --   Result := id_to_storable_version.found_item\n      -- else\n      --   l_result := {ISE_RUNTIME}.storable_version_of_type (a_type_id)\n      --   if l_result /= l_null then\n      --     create Result.make_from_c (l_result)\n      --     if Result.is_empty then\n      --       Result := Void\n      --     end\n      --   end\n      --   id_to_storable_version.put (Result, a_type_id)\n      -- end\n    end\n\n  field_name_of_type (i: INTEGER; type_id: INTEGER): STRING\n      -- Name of `i'-th field of dynamic type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enought: i <= field_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- create Result.make_from_c ({ISE_RUNTIME}.field_name_of_type (i, type_id))\n    end\n\n  field_type_of_type (i: INTEGER; type_id: INTEGER): INTEGER\n      -- Abstract type of `i'-th field of dynamic type `type_id'\n    require\n      type_id_nonnegative: type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.field_type_of_type (i, type_id)\n    ensure\n      field_type_nonnegative: Result >= 0\n    end\n\n  field_static_type_of_type (i: INTEGER; type_id: INTEGER): INTEGER\n      -- Static type of declared `i'-th field of dynamic type `type_id'\n    require\n      type_id_nonnegative: type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.field_static_type_of_type (i, type_id)\n    ensure\n      field_type_nonnegative: Result >= 0\n    end\n\nfeature -- Version\n\n  compiler_version: INTEGER\n    do\n      Result := 0\n    end\n\nfeature -- Measurement\n\n  field_count_of_type (type_id: INTEGER): INTEGER\n      -- Number of logical fields in dynamic type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C macro signature (EIF_INTEGER): EIF_INTEGER use %\"eif_internal.h%\"\"\n    alias\n      \"ei_count_field_of_type\"\n    end\n\n  persistent_field_count_of_type (a_type_id: INTEGER): INTEGER\n      -- Number of logical fields in dynamic type `type_id' that are not transient.\n    require\n      a_type_non_negative: a_type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.persistent_field_count_of_type (a_type_id)\n    end\n\nfeature {NONE} -- Implementation\n\n  internal_dynamic_type_string_table: STRING_TABLE [INTEGER]\n      -- Table of dynamic type indexed by type name\n    once\n      create Result.make (100)\n    ensure\n      internal_dynamic_type_string_table_not_void: Result /= Void\n    end\n\n  id_to_storable_version: HASH_TABLE [detachable IMMUTABLE_STRING_8, INTEGER]\n      -- Buffer for `storable_version_of_type' lookups index by type_id.\n    once\n      create Result.make (100)\n    ensure\n      id_to_storable_version_not_void: Result /= Void\n    end\n\n  c_new_instance_of (type_id: INTEGER): ANY\n      -- New instance of dynamic `type_id'.\n      -- Note: returned object is not initialized and may\n      -- hence violate its invariant.\n      -- `type_id' cannot represent a SPECIAL type, use\n      -- `new_special_any_instance' instead.\n    external\n      \"C macro use %\"eif_macros.h%\"\"\n    alias\n      \"RTLNSMART\"\n    end\n\n  c_new_tuple_instance_of (type_id: INTEGER): TUPLE\n      -- New instance of tuple of type `type_id'.\n      -- Note: returned object is not initialized and may\n      -- hence violate its invariant.\n    external\n      \"C macro use %\"eif_macros.h%\"\"\n    alias\n      \"RTLNT\"\n    end\n\n  c_new_type_instance_of (type_id: INTEGER): TYPE [detachable ANY]\n      -- New instance of TYPE for object of type `type_id'.\n    external\n      \"C macro use %\"eif_macros.h%\"\"\n    alias\n      \"RTLNTY\"\n    end\n\n  c_set_dynamic_type (obj: SPECIAL [detachable ANY]; dtype: INTEGER)\n      -- Set `obj' dynamic type to `dtype'.\n    external\n      \"built_in static\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"reflector_constants.e","content":"note\n  description: \"Constants to represent abstract types in {REFFLECTOR} and {OBJECT_PROXY}.\"\n  cecil: \"The values are in sync with CECIL constants EIF_*_TYPE.\"\n  runtime: \"The values represent abstract types used by run-time, e.g. {ISE_RUNTIME}.field_type_of_type.\"\n  date: \"$Date: 2013-05-20 16:15:17 -0700 (Mon, 20 May 2013) $\"\n  revision: \"$Revision: 92557 $\"\n\nclass\n  REFLECTOR_CONSTANTS\n\nfeature -- Access\n\n  none_type: INTEGER = -2\n      -- Type ID representation for NONE.\n\n  pointer_type: INTEGER = 0\n      -- Abstract type ID for predefined type {POINTER}.\n\n  reference_type: INTEGER = 1\n      -- Abstract type ID for a reference type.\n\n  character_8_type, character_type: INTEGER = 2\n      -- Abstract type ID for predefined type {CHARACTER_8}.\n\n  boolean_type: INTEGER = 3\n      -- Abstract type ID for predefined type {BOOLEAN}.\n\n  integer_32_type, integer_type: INTEGER = 4\n      -- Abstract type ID for predefined type {INTEGER_32}.\n\n  real_32_type, real_type: INTEGER = 5\n      -- Abstract type ID for predefined type {REAL_32}.\n\n  real_64_type, double_type: INTEGER = 6\n      -- Abstract type ID for predefined type {REAL_64}.\n\n  expanded_type: INTEGER = 7\n      -- Abstract type ID for a non-predefined expanded type.\n\n  bit_type: INTEGER = 8\n      -- This type is obsolete and is not used anymore.\n\n  integer_8_type: INTEGER = 9\n      -- Abstract type ID for predefined type {INTEGER_8}.\n\n  integer_16_type: INTEGER = 10\n      -- Abstract type ID for predefined type {INTEGER_16}.\n\n  integer_64_type: INTEGER = 11\n      -- Abstract type ID for predefined type {INTEGER_64}.\n\n  character_32_type, wide_character_type: INTEGER = 12\n      -- Abstract type ID for predefined type {CHARACTER_32}.\n\n  natural_8_type: INTEGER = 13\n      -- Abstract type ID for predefined type {NATURAL_8}.\n\n  natural_16_type: INTEGER = 14\n      -- Abstract type ID for predefined type {NATURAL_16}.\n\n  natural_32_type: INTEGER = 15\n      -- Abstract type ID for predefined type {NATURAL_32}.\n\n  natural_64_type: INTEGER = 16\n      -- Abstract type ID for predefined type {NATURAL_64}.\n\n  min_predefined_type: INTEGER = -2\n  max_predefined_type: INTEGER = 16\n\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license: \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\nend\n"});
__eiffel_builtin.push({"filename":"reflector_helper.e","content":"note\n  description: \"Helper for routines in INTERNAL class.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-03-04 15:01:25 -0800 (Mon, 04 Mar 2013) $\"\n  revision: \"$Revision: 92178 $\"\n\nclass\n  REFLECTOR_HELPER\n\nfeature -- Status report\n\n  is_pre_ecma_mapping_disabled: BOOLEAN\n      -- Are we mapping old names to new ECMA names?\n      -- False means mapping STRING to STRING_8, INTEGER to INTEGER_32,...\n      -- Redefine in descendants of REFLECTOR to modify the behavior of inspection queries of REFLECTOR.\n    do\n      Result := False\n    end\n\n  is_valid_type_string (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `s' a valid string representation for a TYPE.\n    local\n      l_type_name: STRING_32\n      l_start_pos, l_end_pos: INTEGER\n      l_class_type_name: STRING_32\n      l_parameters: like parameters_decomposition\n    do\n      if s /= Void and then not s.is_empty then\n        create l_class_type_name.make_from_string_general (s)\n        l_class_type_name.left_adjust\n        l_class_type_name.right_adjust\n\n          -- Let's see if it is a generic type.\n        l_start_pos := l_class_type_name.index_of ('[', 1)\n\n        if l_start_pos > 1 then\n            -- Looks like it is a generic class.\n          l_end_pos := l_class_type_name.count\n          if l_class_type_name.item (l_end_pos) /= ']' then\n            l_end_pos := 0\n          end\n          if\n            l_end_pos = l_class_type_name.count and l_start_pos < l_end_pos and\n            l_class_type_name.occurrences ('[') = l_class_type_name.occurrences (']')\n          then\n              -- A well formed generic class.\n            l_type_name := l_class_type_name.substring (1, l_start_pos - 1)\n            l_type_name.left_adjust\n            l_type_name.right_adjust\n\n            if is_valid_identifier (l_type_name) then\n              l_parameters := parameters_decomposition (\n                l_class_type_name.substring (l_start_pos + 1, l_end_pos - 1))\n              if l_parameters /= Void then\n                from\n                  Result := True\n                  l_parameters.start\n                until\n                  l_parameters.after or not Result\n                loop\n                  Result := is_valid_type_string (l_parameters.item)\n                  l_parameters.forth\n                end\n              end\n            end\n          end\n        else\n            -- Ensures that it is a valid type name.\n          Result := is_valid_identifier (l_class_type_name)\n        end\n      end\n    end\n\n  mapped_type (a_type: READABLE_STRING_GENERAL): READABLE_STRING_GENERAL\n      -- If `is_pre_ecma_mapping_disabled' `a_type', otherwise\n      -- the mapped typed.\n    require\n      a_type_not_void: a_type /= Void\n    local\n      l_table: like pre_ecma_type_mapping\n      r: detachable READABLE_STRING_GENERAL\n    do\n      if not is_pre_ecma_mapping_disabled then\n        l_table := pre_ecma_type_mapping\n        l_table.search (a_type)\n        if l_table.found then\n          r := l_table.found_item\n        end\n      end\n      if r = Void then\n        r := a_type\n      end\n      Result := r\n    ensure\n      mapped_type_not_void: Result /= Void\n    end\n\nfeature {NONE} -- Implementation: status report\n\n  is_valid_identifier (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `s' a valid Eiffel identifier?\n    require\n      name_not_void: s /= Void\n    local\n      i, nb: INTEGER\n      cc: CHARACTER_32\n    do\n      if not s.is_empty then\n        cc := s.item (1)\n        nb := s.count + 1\n        if cc = attached_mark or cc = detachable_mark then\n          i := 2\n        elseif s.substring_index (attached_keyword, 1) = 1 then\n          i := attached_keyword.count + 1\n        elseif s.substring_index (detachable_keyword, 1) = 1 then\n          i := detachable_keyword.count + 1\n        elseif s.substring_index (expanded_keyword, 1) = 1 then\n          i := expanded_keyword.count + 1\n        else\n          i := 1\n        end\n        if i > 1 then\n            -- Remove any whitespace between the attachment mark and the type name.\n          from\n          until\n            i = nb or not s.item (i).is_space\n          loop\n            i := i + 1\n          end\n        end\n        if s.item (i).is_alpha then\n          from\n            Result := True\n          until\n            i = nb\n          loop\n            cc := s.item (i)\n            if not (cc.is_alpha or cc.is_digit or cc = '_') then\n              Result := False\n              i := nb - 1\n            end\n            i := i + 1\n          end\n        end\n      end\n    end\n\nfeature {NONE} -- Decompose string type\n\n  parameters_decomposition (a_str: READABLE_STRING_32): detachable ARRAYED_LIST [READABLE_STRING_32]\n      -- Decompose `a_str' which should be of the form \"A, B, D [G], H [E ,F]\"\n      -- into a list of strings \"A\", \"B\", \"D [G]\", \"H [E, F]\"\n      -- If decomposition is not possible, Void.\n    require\n      a_str_not_void: a_str /= Void\n    local\n      i, nb: INTEGER\n      l_invalid: BOOLEAN\n      l_first_pos: INTEGER\n      l_nesting: INTEGER\n    do\n      from\n        create Result.make (5)\n        i := 1\n        l_first_pos := 1\n        nb := a_str.count\n      until\n        i > nb or l_invalid\n      loop\n        inspect\n          a_str.item (i)\n        when ',' then\n          if l_nesting = 0 then\n            Result.extend (a_str.substring (l_first_pos, i - 1))\n            l_first_pos := i + 1\n          end\n        when '[' then\n          l_nesting := l_nesting + 1\n        when ']' then\n          l_nesting := l_nesting - 1\n          l_invalid := l_nesting < 0\n        else\n          -- Do nothing\n        end\n        i := i + 1\n      end\n      if not l_invalid and then l_nesting = 0 then\n        Result.extend (a_str.substring (l_first_pos, i - 1))\n      else\n        Result := Void\n      end\n    end\n\nfeature {NONE} -- ECMA mapping helper\n\n  pre_ecma_type_mapping: STRING_TABLE [STRING]\n      -- Mapping between pre-ECMA type naming and new names.\n    once\n      create Result.make (12)\n      Result.put (\"STRING_8\", \"STRING\")\n      Result.put (\"INTEGER_32\", \"INTEGER\")\n      Result.put (\"INTEGER_32_REF\", \"INTEGER_REF\")\n      Result.put (\"CHARACTER_8\", \"CHARACTER\")\n      Result.put (\"CHARACTER_8_REF\", \"CHARACTER_REF\")\n      Result.put (\"CHARACTER_32\", \"WIDE_CHARACTER\")\n      Result.put (\"CHARACTER_32_REF\", \"WIDE_CHARACTER_REF\")\n      Result.put (\"REAL_32\", \"REAL\")\n      Result.put (\"REAL_32_REF\", \"REAL_REF\")\n      Result.put (\"REAL_64\", \"DOUBLE\")\n      Result.put (\"REAL_64_REF\", \"DOUBLE_REF\")\n    ensure\n      pre_ecma_type_mapping_not_void: Result /= Void\n    end\n\n  attached_mark: CHARACTER_32 = '!'\n  detachable_mark: CHARACTER_32 = '?'\n  attached_keyword: STRING = \"attached\"\n  detachable_keyword: STRING = \"detachable\"\n  expanded_keyword: STRING = \"expanded\"\n      -- Symbols use for attachment marks.\n\nfeature {NONE} -- Type creation\n\n  type_keyword: STRING = \"TYPE\";\n      -- Used for creating type objects.\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"resizable.e","content":"note\n  description: \"Finite structures whose item count is subject to change\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  size: resizable;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class RESIZABLE [G] inherit\n\n  BOUNDED [G]\n\nfeature -- Measurement\n\n  Growth_percentage: INTEGER = 50\n      -- Percentage by which structure will grow automatically\n\n  Minimal_increase: INTEGER = 5\n      -- Minimal number of additional items\n\n  additional_space: INTEGER\n      -- Proposed number of additional items\n      --| Result is a reasonable value, resulting from a space-time tradeoff.\n    do\n        -- To prevent overflow we do not use `growth_percentage' but its known value.\n      Result := (capacity // 2).max (Minimal_increase)\n    ensure\n      At_least_one: Result >= 1\n    end\n\nfeature -- Status report\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed? (Answer: yes.)\n    do\n      Result := True\n    end\n\nfeature -- Resizing\n\n  automatic_grow\n      -- Change the capacity to accommodate at least\n      -- `Growth_percentage' more items.\n      --| Trades space for time:\n      --| allocates fairly large chunks of memory but not very often.\n    require\n      resizable: resizable\n    do\n      grow (capacity + additional_space)\n    ensure\n      increased_capacity: capacity >= old capacity + old additional_space\n    end\n\n  grow (i: INTEGER)\n      -- Ensure that capacity is at least `i'.\n    require\n      resizable: resizable\n    deferred\n    ensure\n      new_capacity: capacity >= i\n    end\n\n  trim\n      -- Decrease `capacity' to the minimum value.\n      -- Apply to reduce allocated storage.\n    deferred\n    ensure\n      same_count: count = old count\n      minimal_capacity: capacity = count\n    end\n\ninvariant\n\n  increase_by_at_least_one: Minimal_increase >= 1\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"routine.e","content":"note\n  description: \"[\n    Objects representing delayed calls to a routine,\n    with some operands possibly still open\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-28 14:35:23 -0800 (Tue, 28 Jan 2014) $\"\n  revision: \"$Revision: 94109 $\"\n\ndeferred class\n  ROUTINE [BASE_TYPE -> detachable ANY, OPEN_ARGS -> detachable TUPLE create default_create end]\n\ninherit\n  HASHABLE\n    redefine\n      copy,\n      is_equal\n    end\n\n  REFLECTOR\n    export\n      {NONE} all\n    redefine\n      copy,\n      is_equal\n    end\n\nfeature -- Initialization\n\n  adapt (other: like Current)\n      -- Initialize from `other'.\n      -- Useful in descendants.\n    require\n      other_exists: other /= Void\n      conforming: conforms_to (other)\n    do\n      rout_disp := other.rout_disp\n      encaps_rout_disp := other.encaps_rout_disp\n      calc_rout_addr := other.calc_rout_addr\n      closed_operands := other.closed_operands\n      operands := other.operands\n      routine_id := other.routine_id\n      is_basic := other.is_basic\n      is_target_closed := other.is_target_closed\n      written_type_id_inline_agent := other.written_type_id_inline_agent\n      open_count := other.open_count\n    end\n\nfeature -- Access\n\n  frozen operands: detachable OPEN_ARGS\n\n  target: detachable ANY\n      -- Target of call\n    local\n      c: like closed_operands\n    do\n        -- Because a target object is never separate relative to the routine object,\n        -- the first argument is checked against {ANY} rather than {separate ANY}.\n      if is_target_closed then\n        c := closed_operands\n        if c /= Void and then c.count > 0 and then attached {ANY} c.item (1) as r then\n          Result := r\n        end\n      elseif attached {TUPLE} operands as o and then o.count > 0 and then attached {ANY} o.item (1) as r then\n        Result := r\n      end\n    end\n\n  hash_code: INTEGER\n      -- Hash code value.\n    do\n      Result := rout_disp.hash_code.bit_xor (routine_id.hash_code)\n    end\n\n  precondition (args: like operands): BOOLEAN\n      -- Do `args' satisfy routine's precondition\n      -- in current state?\n    do\n      Result := True\n      --| FIXME compiler support needed!\n    end\n\n  postcondition (args: like operands): BOOLEAN\n      -- Does current state satisfy routine's\n      -- postcondition for `args'?\n    do\n      Result := True\n      --| FIXME compiler support needed!\n    end\n\n  empty_operands: attached OPEN_ARGS\n      -- Empty tuple matching open operands.\n    obsolete \"This function will be removed as non-void-safe. [22.07.2013]\"\n    do\n      create Result\n    ensure\n      empty_operands_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  callable: BOOLEAN = True\n      -- Can routine be called on current object?\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is associated routine the same as the one\n      -- associated with `other'.\n    do\n      --| Do not compare implementation data\n      Result := closed_operands ~ other.closed_operands\n        and then operands ~ other.operands\n        and then open_map ~ other.open_map\n        and then (rout_disp = other.rout_disp)\n        and then (routine_id = other.routine_id)\n        and then (written_type_id_inline_agent = other.written_type_id_inline_agent)\n        and then (encaps_rout_disp = other.encaps_rout_disp)\n        and then (calc_rout_addr = other.calc_rout_addr)\n    end\n\n  valid_operands (args: detachable separate TUPLE): BOOLEAN\n      -- Are `args' valid operands for this routine?\n    local\n      i, arg_type_code: INTEGER\n      arg: like {TUPLE}.item\n      open_type_codes: STRING\n      l_type: INTEGER\n    do\n      if args = Void then\n          -- Void operands are only allowed\n          -- if object has no open operands.\n        Result := (open_count = 0)\n      elseif args.count >= open_count then\n        from\n          Result := True\n          open_type_codes := eif_gen_typecode_str ($Current)\n          i := 1\n        until\n          i > open_count or not Result\n        loop\n          arg_type_code := args.item_code (i)\n          Result := arg_type_code = open_type_codes.item (i + 1).code\n          if Result and then arg_type_code = {TUPLE}.reference_code then\n            arg := args.item (i)\n            l_type := open_operand_type (i)\n              -- If expected type is attached, then we need to verify that the actual\n              -- is indeed attached.\n            if is_attached_type (l_type) then\n              Result := arg /= Void and then\n                field_conforms_to (type_id_of (arg), l_type)\n            else\n              Result := arg = Void or else\n                field_conforms_to (type_id_of (arg), l_type)\n            end\n          end\n          i := i + 1\n        end\n      end\n      if Result and then not is_target_closed and then args /= Void then\n        Result := args.item (1) /= Void\n      end\n    end\n\n  valid_target (args: detachable TUPLE): BOOLEAN\n      -- Is the first element of tuple `args' a valid target\n    do\n      if args /= Void and then args.count > 0 then\n        if args.is_reference_item (1) then\n          Result := args.reference_item (1) /= Void\n        else\n          Result := True\n        end\n      end\n    end\n\n  is_target_closed: BOOLEAN\n      -- Is target for current agent closed, i.e. specified at creation time?\n\nfeature -- Measurement\n\n  open_count: INTEGER\n      -- Number of open operands.\n\nfeature -- Settings\n\n  frozen set_operands (args: detachable OPEN_ARGS)\n      -- Use `args' as operands for next call.\n    require\n      valid_operands: valid_operands (args)\n    do\n      operands := args\n    ensure\n      operands_set: (operands /= Void implies (operands ~ args)) or\n        (operands = Void implies (args = Void or else args.is_empty))\n    end\n\n  set_target (a_target: like target)\n      -- Set `a_target' as the next `target' for remaining calls to Current.\n    require\n      a_target_not_void: a_target /= Void\n      is_target_closed: is_target_closed\n      target_not_void: target /= Void\n      same_target_type: attached target as t and then t.same_type (a_target)\n    local\n      c: like closed_operands\n    do\n      c := closed_operands\n      if c /= Void then\n        c.put (a_target, 1)\n      end\n    ensure\n      target_set: target = a_target\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Use same routine as `other'.\n    do\n      if other /= Current then\n        standard_copy (other)\n        if attached operands as l_operands then\n          operands := l_operands.twin\n        end\n      end\n    ensure then\n      same_call_status: other.callable implies callable\n    end\n\nfeature -- Basic operations\n\n  call (args: detachable separate OPEN_ARGS)\n      -- Call routine with `args'.\n    require\n      valid_operands: valid_operands (args)\n    deferred\n    end\n\n  apply\n      -- Call routine with `operands' as last set.\n    require\n      valid_operands: valid_operands (operands)\n    deferred\n    end\n\nfeature -- Extended operations\n\n  flexible_call (a: detachable separate TUPLE)\n      -- Call routine with arguments `a'.\n      -- Compared to `call' the type of `a' may be different from `{OPEN_ARGS}'.\n    require\n      valid_operands: valid_operands (a)\n    local\n      default_arguments: detachable OPEN_ARGS\n    do\n      if not attached a then\n        call (default_arguments)\n      else\n        -- TODO implement in javascript\n        -- check\n        --   from_precondition: attached {OPEN_ARGS} new_tuple_from_tuple (({OPEN_ARGS}).type_id, a) as x\n        -- then\n        --   call (x)\n        -- end\n      end\n    end\n\nfeature -- Obsolete\n\n  adapt_from (other: like Current)\n      -- Adapt from `other'. Useful in descendants.\n    obsolete\n      \"Please use `adapt' instead (it's also a creation procedure)\"\n    require\n      other_exists: other /= Void\n      conforming: conforms_to (other)\n    do\n      adapt (other)\n    end\n\nfeature {ROUTINE} -- Implementation\n\n  frozen closed_operands: detachable TUPLE\n      -- All closed arguments provided at creation time\n\n  closed_count: INTEGER\n      -- The number of closed operands (including the target if it is closed)\n    local\n      c: detachable TUPLE\n    do\n      c := closed_operands\n      if c /= Void then\n        Result := c.count\n      end\n    end\n\n  frozen rout_disp: POINTER\n      -- Routine dispatcher\n\n  frozen calc_rout_addr: POINTER\n      -- Address of the final routine\n\n  frozen open_map: detachable ARRAY [INTEGER]\n      -- Index map for open arguments\n\n  frozen encaps_rout_disp: POINTER\n      -- Eiffel routine dispatcher\n\n  frozen routine_id: INTEGER\n\n  frozen is_basic: BOOLEAN\n\n  frozen written_type_id_inline_agent: INTEGER\n\n  frozen set_rout_disp (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: POINTER;\n              a_routine_id: INTEGER; a_open_map: like open_map;\n              a_is_basic, a_is_target_closed: BOOLEAN; a_written_type_id_inline_agent: INTEGER;\n              a_closed_operands: TUPLE; a_open_count: INTEGER)\n      -- Initialize object.\n    require\n      target_valid: a_is_target_closed implies valid_target (a_closed_operands)\n    do\n      set_rout_disp_int (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr, a_routine_id,\n                 a_open_map, a_is_basic, a_is_target_closed,\n                 a_written_type_id_inline_agent, a_closed_operands, a_open_count)\n    end\n\n  frozen set_rout_disp_final (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: POINTER\n                  a_closed_operands: TUPLE; a_is_target_closed: BOOLEAN; a_open_count: INTEGER)\n      -- Initialize object.\n    do\n      rout_disp := a_rout_disp\n      encaps_rout_disp := a_encaps_rout_disp\n      calc_rout_addr := a_calc_rout_addr\n      closed_operands := a_closed_operands\n      is_target_closed := a_is_target_closed\n      open_count := a_open_count\n    end\n\n  frozen set_rout_disp_int (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: POINTER;\n                  a_routine_id: INTEGER; a_open_map: like open_map;\n                a_is_basic, a_is_target_closed: BOOLEAN; a_written_type_id_inline_agent: INTEGER;\n                a_closed_operands: TUPLE; a_open_count: INTEGER)\n      -- Initialize object.\n    require\n      a_routine_id_valid: a_routine_id > -1\n    do\n      rout_disp := a_rout_disp\n      encaps_rout_disp := a_encaps_rout_disp\n      calc_rout_addr := a_calc_rout_addr\n      routine_id := a_routine_id\n      open_map := a_open_map\n      is_basic := a_is_basic\n      is_target_closed := a_is_target_closed\n      written_type_id_inline_agent := a_written_type_id_inline_agent\n      closed_operands := a_closed_operands\n      open_count := a_open_count\n    ensure\n      rout_disp_set: rout_disp = a_rout_disp\n      encaps_rout_disp_set: encaps_rout_disp = a_encaps_rout_disp\n      calc_rout_addr_set: calc_rout_addr = a_calc_rout_addr\n      routine_id_set: routine_id = a_routine_id\n      open_map_set: open_map = a_open_map\n      is_target_closed_set: is_target_closed = a_is_target_closed\n      is_basic_set: is_basic = a_is_basic\n      written_type_id_inline_agent_set: written_type_id_inline_agent = a_written_type_id_inline_agent\n      closed_operands_set: closed_operands = a_closed_operands\n      open_count_set: open_count = a_open_count\n    end\n\nfeature {NONE} -- Implementation\n\n  frozen open_types: detachable ARRAY [INTEGER]\n      -- Types of open operands\n\n  open_operand_type (i: INTEGER): INTEGER\n      -- Type of `i'th open operand.\n    require\n      positive: i >= 1\n      within_bounds: i <= open_count\n    local\n      o: like open_types\n    do\n      o := open_types\n      if o = Void then\n        create o.make_filled (-1, 1, open_count)\n        open_types := o\n      end\n      Result := o.item (i)\n      if Result = -1 then\n        Result := ({OPEN_ARGS}).generic_parameter_type (i).type_id\n        o.put (Result, i)\n      end\n    end\n\n  type_id_of (a: separate ANY): INTEGER\n      -- Type ID of an object `a'.\n    do\n      Result := a.generating_type.type_id\n    end\n\nfeature {NONE} -- Externals\n\n  eif_gen_typecode_str (obj: POINTER): STRING\n      -- Code name for generic parameter `pos' in `obj'.\n    external\n      \"C signature (EIF_REFERENCE): EIF_REFERENCE use %\"eif_gen_conf.h%\"\"\n    end\n\nfeature -- Obsolete\n\n  arguments: detachable OPEN_ARGS\n    obsolete\n      \"use operands\"\n    do\n      Result := operands\n    end\n\n  set_arguments (args: detachable OPEN_ARGS)\n    obsolete\n      \"use set_operands\"\n    do\n      set_operands (args)\n    end\n\n  valid_arguments (args: detachable OPEN_ARGS): BOOLEAN\n    obsolete\n      \"use valid_operands\"\n    do\n      Result := valid_operands (args)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"sequence.e","content":"note\n  description: \"[\n    Finite sequences: structures where existing items are arranged\n    and accessed sequentially, and new ones can be added at the end.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: sequence;\n  access: cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class SEQUENCE [G] inherit\n\n  ACTIVE [G]\n    redefine\n      prune_all\n    end\n\n  BILINEAR [G]\n\n  FINITE [G]\n\nfeature -- Status report\n\n  readable: BOOLEAN\n      -- Is there a current item that may be read?\n    do\n      Result := not off\n    end\n\n\n  writable: BOOLEAN\n      -- Is there a current item that may be modified?\n    do\n      Result := not off\n    end\n\nfeature -- Element change\n\n  force (v: like item)\n      -- Add `v' to end.\n    require\n      extendible: extendible\n    do\n      extend (v)\n    ensure then\n      new_count: count = old count + 1\n      item_inserted: has (v)\n    end\n\n  append (s: SEQUENCE [G])\n      -- Append a copy of `s'.\n    require\n      argument_not_void: s /= Void\n    local\n      l: like s\n    do\n      l := s\n      if s = Current then\n        l := twin\n      end\n      from\n        l.start\n      until\n        l.exhausted\n      loop\n        extend (l.item)\n        l.forth\n      end\n    ensure\n      new_count: count >= old count\n    end\n\n  put (v: like item)\n      -- Add `v' to end.\n    do\n      extend (v)\n    ensure then\n      new_count: count = old count + 1\n    end\n\nfeature -- Removal\n\n  prune (v: like item)\n      -- Remove the first occurrence of `v' if any.\n      -- If no such occurrence go `off'.\n    do\n      start\n      search (v)\n      if not exhausted then\n        remove\n      end\n    end\n\n  prune_all (v: like item)\n      -- Remove all occurrences of `v'; go `off'.\n    do\n      from\n        start\n      until\n        exhausted\n      loop\n        search (v)\n        if not exhausted then\n          remove\n        end\n      end\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"special.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-03-04 15:01:25 -0800 (Mon, 04 Mar 2013) $\"\n  revision: \"$Revision: 92178 $\"\n\nfrozen class\n  SPECIAL [T]\n\ninherit\n  ABSTRACT_SPECIAL\n    redefine\n      debug_output\n    end\n\n  READABLE_INDEXABLE [T]\n\ncreate\n  make_empty,\n  make_filled,\n  make_from_native_array\n\nfeature {NONE} -- Initialization\n\n  make_empty (n: INTEGER)\n      -- Create a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    external\n      \"built_in\"\n    ensure\n      capacity_set: capacity = n\n      count_set: count = 0\n    end\n\n  make_filled (v: T; n: INTEGER)\n      -- Create a special object for `n' entries initialized with `v'.\n    require\n      non_negative_argument: n >= 0\n    do\n      make_empty (n)\n      fill_with (v, 0, n - 1)\n    ensure\n      capacity_set: capacity = n\n      count_set: count = n\n      filled: filled_with (v, 0, n - 1)\n    end\n\n  make_from_native_array (an_array: like native_array)\n      -- Create a special object from `an_array'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      an_array_not_void: an_array /= Void\n    do\n    end\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): T assign put\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    external\n      \"built_in\"\n    end\n\n  at alias \"@\" (i: INTEGER): T\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    require\n      valid_index: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  index_of (v: T; start_position: INTEGER): INTEGER\n      -- Index of first occurrence of item identical to `v'.\n      -- -1 if none.\n      -- (Use object equality for comparison.)\n    require\n      valid_start_position: start_position >= 0\n    local\n      nb: INTEGER\n    do\n      from\n        Result := start_position\n        nb := count\n      until\n        Result >= nb or else item (Result) ~ v\n      loop\n        Result := Result + 1\n      end\n      if Result >= nb then\n        Result := -1\n      end\n    ensure\n      found_or_not_found: Result = -1 or else (Result >= 0 and then Result < count)\n    end\n\n  item_address (i: INTEGER): POINTER\n      -- Address of element at position `i'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    do\n      Result := base_address + i * element_size\n    ensure\n      element_address_not_null: Result /= default_pointer\n    end\n\n  base_address: POINTER\n      -- Address of element at position `0'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n    external\n      \"built_in\"\n    ensure\n      base_address_not_null: Result /= default_pointer\n    end\n\n  native_array: NATIVE_ARRAY [T]\n      -- Only for compatibility with .NET\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      create Result\n    end\n\n  to_array: ARRAY [T]\n      -- Build an array representation of Current from `1' to `count'.\n    do\n      create Result.make_from_special (Current)\n    ensure\n      to_array_attached: Result /= Void\n      to_array_lower_set: Result.lower = 1\n      to_array_upper_set: Result.upper = count\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- <Precursor>\n    do\n      create Result.make (lower, upper)\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER = 0\n      -- Minimum index of Current\n\n  upper: INTEGER\n      -- Maximum index of Current\n    do\n      Result := count - 1\n    ensure\n      definition: lower <= Result + 1\n    end\n\n  count: INTEGER\n      -- Count of special area\n    external\n      \"built_in\"\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  filled_with (v: T; start_index, end_index: INTEGER): BOOLEAN\n      -- Are all items between index `start_index' and `end_index'\n      -- set to `v'?\n      -- (Use reference equality for comparison.)\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    local\n      i: INTEGER\n    do\n      from\n        Result := True\n        i := start_index\n      until\n        i > end_index or else not Result\n      loop\n        Result := item (i) = v\n        i := i + 1\n      end\n    end\n\n  same_items (other: like Current; source_index, destination_index, n: INTEGER): BOOLEAN\n      -- Are the `n' elements of `other' from `source_index' position the same as\n      -- the `n' elements of `Current' from `destination_index'?\n      -- (Use reference equality for comparison.)\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= count\n    local\n      i, j, nb: INTEGER\n    do\n      Result := True\n      if other /= Current then\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          if other.item (i) /= item (j) then\n            Result := False\n            i := nb - 1\n          end\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      valid_on_empty_area: (n = 0) implies Result\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := (0 <= i) and (i < count)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    external\n      \"built_in\"\n    ensure\n      inserted: item (i) = v\n      same_count: count = old count\n      same_capacity: capacity = old capacity\n    end\n\n  force (v: T; i: INTEGER)\n      -- If `i' is equal to `count' increase `count' by one and insert `v' at index `count',\n      -- otherwise replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i <= count\n      not_full: i = count implies count < capacity\n    do\n      if i < count then\n        put (v, i)\n      else\n        extend (v)\n      end\n    ensure\n      count_updated: count = (i + 1).max (old count)\n      same_capacity: capacity = old capacity\n      inserted: item (i) = v\n    end\n\n  extend (v: T)\n      -- Add `v' at index `count'.\n    require\n      count_small_enough: count < capacity\n    external\n      \"built_in\"\n    ensure\n      count_increased: count = old count + 1\n      same_capacity: capacity = old capacity\n      inserted: item (count - 1) = v\n    end\n\n  extend_filled (v: T)\n      -- Set items between `count' and `capacity - 1' with `v'.\n    do\n      fill_with (v, count, capacity - 1)\n    ensure\n      same_capacity: capacity = old capacity\n      count_increased: count = capacity\n      filled: filled_with (v, old count, capacity - 1)\n    end\n\n  fill_with (v: T; start_index, end_index: INTEGER)\n      -- Set items between `start_index' and `end_index' with `v'.\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_in_bound: start_index <= count\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < capacity\n    local\n      i, nb: INTEGER\n      l_count: like count\n    do\n      from\n        i := start_index\n        l_count := count.min (end_index + 1)\n        nb := l_count\n      until\n        i = nb\n      loop\n        put (v, i)\n        i := i + 1\n      end\n      from\n        i := l_count\n        nb := end_index + 1\n      until\n        i = nb\n      loop\n        extend (v)\n        i := i + 1\n      end\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = (old count).max (end_index + 1)\n      filled: filled_with (v, start_index, end_index)\n    end\n\n  fill_with_default (start_index, end_index: INTEGER)\n      -- Clear items between `start_index' and `end_index'.\n    require\n      is_self_initializing: ({T}).has_default\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    do\n      fill_with (({T}).default, start_index, end_index)\n    ensure\n      filled: filled_with (({T}).default, start_index, end_index)\n    end\n\n  insert_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Insert `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index' and shift elements between `destination_index' and `count'\n      -- to the right. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: count + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      l_remaining_items, l_offset, l_nb_items_left: INTEGER\n      l_source_index, l_end_index, l_destination_index: INTEGER\n    do\n      l_remaining_items := count - destination_index\n      if l_remaining_items = 0 then\n          -- It is being added at the end of Current, therefore we can simply extend.\n        copy_data (other, source_index, destination_index, n)\n      elseif n <= l_remaining_items then\n          -- Simple case where we can perform a move of the existing items to the end\n          -- and then copy the elements of `other'.\n        move_data (destination_index, destination_index + n, l_remaining_items)\n        copy_data (other, source_index, destination_index, n)\n      else\n          -- Because we cannot have uninitialized items, we cannot move all the remaining items beyond count\n          -- instead we copy by chunks of `l_remaining_items'.\n        from\n          l_source_index := source_index\n          l_destination_index := destination_index\n          l_end_index := source_index + n\n          l_nb_items_left := n\n          l_offset := l_remaining_items\n        until\n          l_source_index >= l_end_index\n        loop\n          move_data (l_destination_index, l_destination_index + l_offset, l_remaining_items)\n          copy_data (other, l_source_index, l_destination_index, l_offset)\n          l_destination_index := l_destination_index + l_offset\n          l_source_index := l_source_index + l_offset\n            -- Compute how many more items we have to copy.\n          l_nb_items_left := l_nb_items_left - l_remaining_items\n          l_offset := l_offset.min (l_nb_items_left)\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = old count + n\n    end\n\n  copy_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Copy `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index'. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      i, j, nb: INTEGER\n    do\n      if other = Current then\n        move_data (source_index, destination_index, n)\n      else\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          force (other.item (i), j)\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  move_data (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    do\n      if source_index = destination_index then\n      elseif source_index > destination_index then\n        if destination_index + n < source_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      else\n        if source_index + n < destination_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      if source_index < destination_index then\n          -- We shift from left to right starting from the end\n          -- due to possible overlapping.\n        from\n          i := source_index + n - 1\n          nb := source_index - 1\n          l_offset := destination_index - source_index\n          if (destination_index + n >= count) then\n              -- Initialize elements above `count' to a dummy item.\n            fill_with (item (source_index), count, destination_index + n - 1)\n          end\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          put (item (i), i + l_offset)\n          i := i - 1\n        end\n      else\n          -- We shift from right to left.\n        from\n          i := source_index\n          nb := source_index + n\n          l_offset := source_index - destination_index\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          force (item (i), i - l_offset)\n          i := i + 1\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  non_overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      non_overlapping:\n        (source_index < destination_index implies source_index + n < destination_index) or\n        (source_index > destination_index implies destination_index + n < source_index)\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      from\n        i := source_index\n        nb := source_index + n\n        l_offset := destination_index - source_index\n      until\n        i = nb\n      loop\n        force (item (i), i + l_offset)\n        i := i + 1\n      end\n    ensure\n      moved: same_items (Current, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\nfeature -- Resizing\n\n  keep_head (n: INTEGER)\n      -- Keep the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, 0, 0, n)\n    end\n\n  keep_tail (n: INTEGER)\n      -- Keep the last `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      overlapping_move (count - n, 0, n)\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, n, 0, n)\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_tail (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, n, 0, count)\n    end\n\n  remove_tail (n: INTEGER)\n      -- Keep the first  `count - n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_head (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, 0, 0, count)\n    end\n\n  resized_area (n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n'\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      Result.copy_data (Current, 0, 0, n.min (count))\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n' where not yet initialized\n      -- entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      if n > count then\n        Result.copy_data (Current, 0, 0, count)\n        Result.fill_with (a_default_value, count, n - 1)\n      else\n        Result.copy_data (Current, 0, 0, n)\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area (n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy\n    require\n      n_non_negative: n >= 0\n    external\n      \"built_in\"\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy. Non yet initialized entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      Result := aliased_resized_area (n)\n      Result.fill_with (a_default_value, Result.count, n - 1)\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\nfeature -- Removal\n\n  replace_all (v: T)\n      -- Replace all items with `v'.\n    local\n      i: INTEGER\n    do\n      from\n        i := count - 1\n      until\n        i < 0\n      loop\n        put (v, i)\n        i := i - 1\n      end\n    ensure\n      cleared: filled_with (v, 0, upper)\n    end\n\n  wipe_out\n      -- Reset count to zero.\n    do\n      set_count (0)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = 0\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    obsolete\n      \"Because of the new precondition, it is recommended to use `fill_with' instead.\"\n    require\n      has_default: ({T}).has_default\n    do\n      fill_with_default (0, upper)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = old count\n    end\n\nfeature -- Iteration\n\n  do_all_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_if_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i)]) then\n          action.call ([item (i)])\n        end\n        i := i + 1\n      end\n    end\n\n  there_exists_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb or Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  for_all_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n        Result := True\n      until\n        i > nb or not Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_all_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; test: FUNCTION [ANY, TUPLE [T, INTEGER], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i), j]) then\n          action.call ([item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      Result := Precursor\n      Result.append_string (\", capacity=\")\n      Result.append_integer (capacity)\n    end\n\nfeature {NONE} -- Implementation\n\n  element_size: INTEGER\n      -- Size of elements\n    external\n      \"built_in\"\n    ensure\n      element_size_non_negative: Result >= 0\n    end\n\n  set_count (n: INTEGER)\n      -- Set `count' with `n'.\n    require\n      n_non_negative: n >= 0\n      valid_new_count: n <= count\n    external\n      \"built_in\"\n    ensure\n      count_set: count = n\n      capacity_preserved: capacity = old capacity\n    end\n\ninvariant\n  count_less_than_capacity: count <= capacity\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    external\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_32.e","content":"note\n  description: \"[\n    Sequences of 32-bit characters, accessible through integer indices\n    in a contiguous range.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-25 20:46:54 -0700 (Tue, 25 Mar 2014) $\"\n  revision: \"$Revision: 94717 $\"\n\nclass\n  STRING_32\n\ninherit\n  READABLE_STRING_32\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    redefine\n      area\n    end\n\n  STRING_GENERAL\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    local\n      l_first_pos, l_next_pos: INTEGER\n      l_orig_count, l_new_count, l_new_lower, l_count, i, l_index_count: INTEGER\n      l_src_index, l_dest_index, l_prev_index, l_copy_delta: INTEGER\n      l_area, l_new_area: like area\n      l_offset: INTEGER\n      l_string_searcher: like string_searcher\n      l_index_list: SPECIAL [INTEGER]\n    do\n      if not is_empty then\n        l_count := count\n        l_string_searcher := string_searcher\n        l_string_searcher.initialize_deltas (original)\n        l_orig_count := original.count\n        l_new_count := new.count\n        if l_orig_count >= l_new_count then\n          l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, 1, l_count)\n          if l_first_pos > 0 then\n            if l_orig_count = l_new_count then\n                -- String will not be resized, simply perform character substitution\n              from\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_first_pos = 0\n              loop\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1, l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_new_count, l_count)\n                else\n                  l_first_pos := 0\n              end\n            end\n          elseif l_orig_count > l_new_count then\n              -- New string is smaller than previous string, we can optimize\n              -- substitution by only moving block between two occurrences of `orginal'.\n            from\n              l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n              l_area := area\n              l_new_area := new.area\n              l_new_lower := new.area_lower\n            until\n              l_next_pos = 0\n            loop\n                -- Copy new string into Current\n              l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                -- Shift characters between `l_first_pos' and `l_next_pos'\n              l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                l_first_pos + l_new_count - 1 - l_offset, l_next_pos - l_first_pos - l_orig_count)\n              l_first_pos := l_next_pos\n              l_offset := l_offset + (l_orig_count - l_new_count)\n              if l_first_pos + l_new_count <= l_count then\n                l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n              else\n                l_next_pos := 0\n              end\n            end\n              -- Perform final substitution:\n              -- Copy new string into Current\n            l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n              -- Shift characters between `l_first_pos' and the end of the string\n            l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n              l_first_pos + l_new_count - 1 - l_offset, l_count + 1 - l_first_pos - l_orig_count)\n                -- Perform last substitution\n            l_offset := l_offset + (l_orig_count - l_new_count)\n\n              -- Update `count'\n            set_count (l_count - l_offset)\n            end\n              -- String was modified we need to recompute the `hash_code'.\n            internal_hash_code := 0\n          end\n        elseif attached l_string_searcher.substring_index_list_with_deltas (Current, original, 1, l_count) as l_list then\n            -- Get the number of substitution to be performed by getting a list\n            -- of location where `original' appears.\n          l_index_list := l_list.area\n          l_index_count := l_index_list.count\n            -- Store the index of the last character up to which we need to move\n            -- characters in the reallocated string.\n          l_prev_index := l_count\n            -- Resize Current with the appropriate number of characters\n          l_copy_delta := l_new_count - l_orig_count\n          l_count := l_count + (l_index_count * l_copy_delta)\n          l_area := area.resized_area_with_default ('%U', l_count + 1)\n          area := l_area\n            -- Perform the substitution starting from the end.\n          from\n            i := l_index_count\n            l_new_lower := new.area_lower\n            l_new_area := new.area\n          until\n            i = 0\n          loop\n            i := i - 1\n            l_src_index := l_index_list.item (i)\n            l_dest_index := l_src_index + i * l_copy_delta\n              -- Shift non-matching characters to the right of the newly replaced string.\n            l_area.overlapping_move (l_src_index + l_orig_count - 1, l_dest_index + l_new_count - 1, l_prev_index - l_src_index - l_orig_count + 1)\n              -- Store new end of string where characters will be moved.\n            l_prev_index := l_src_index - 1\n\n              -- Copy `new' to its appropriate position\n            l_area.copy_data (l_new_area, l_new_lower, l_dest_index - 1, l_new_count)\n          end\n            -- Update the new `count' which also resets the `hash_code'.\n          set_count (l_count)\n        end\n      end\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-26 14:49:40 -0700 (Wed, 26 Mar 2014) $\"\n  revision: \"$Revision: 94721 $\"\n\nclass\n  STRING_8\n\ninherit\n  READABLE_STRING_8\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    redefine\n      area\n    end\n\n  STRING_GENERAL\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    undefine\n      copy, is_equal, out\n    redefine\n      append_string_general,\n      prepend_string_general\n    end\n\n  INDEXABLE [CHARACTER_8, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_8]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_8]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_32: {READABLE_STRING_32, STRING_32}\n\nfeature -- Initialization\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_8): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8 assign put\n      -- Character at position `i'.\n    do\n      Result := area.item (i - 1)\n    end\n\n  character_32_item (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    do\n        -- We should be using `area.item (i - 1).to_character_32'\n        -- but some descendants of STRING that have their content encoded\n        -- in UTF-8 for example relies on `code' to get the corresponding\n        -- CHARACTER_32 by reading more than one byte. Once they have\n        -- been updated to use `character_32_item' we can revert the code\n        -- back to using `area' directly.\n      Result := code (i).to_character_32\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Numeric code of character at position `i'.\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n      -- Use `code' instead for consistency with Unicode handling.\n      --| Not obsolete because old code using just ASCII is safe.\n    do\n      Result := area.item (i - 1).code\n    end\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters.\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_8; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_8\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_8)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    local\n      l_first_pos, l_next_pos: INTEGER\n      l_orig_count, l_new_count, l_new_lower, l_count, i, l_index_count: INTEGER\n      l_src_index, l_dest_index, l_prev_index, l_copy_delta: INTEGER\n      l_area, l_new_area: like area\n      l_offset: INTEGER\n      l_string_searcher: like string_searcher\n      l_index_list: SPECIAL [INTEGER]\n    do\n      if not is_empty then\n        l_count := count\n        l_string_searcher := string_searcher\n        l_string_searcher.initialize_deltas (original)\n        l_orig_count := original.count\n        l_new_count := new.count\n        if l_orig_count >= l_new_count then\n          l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, 1, l_count)\n          if l_first_pos > 0 then\n            if l_orig_count = l_new_count then\n                -- String will not be resized, simply perform character substitution\n              from\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_first_pos = 0\n              loop\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1, l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_new_count, l_count)\n                else\n                  l_first_pos := 0\n                end\n              end\n            elseif l_orig_count > l_new_count then\n                -- New string is smaller than previous string, we can optimize\n                -- substitution by only moving block between two occurrences of `orginal'.\n              from\n                l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_next_pos = 0\n              loop\n                  -- Copy new string into Current\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                  -- Shift characters between `l_first_pos' and `l_next_pos'\n                l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                  l_first_pos + l_new_count - 1 - l_offset, l_next_pos - l_first_pos - l_orig_count)\n                l_first_pos := l_next_pos\n                l_offset := l_offset + (l_orig_count - l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                else\n                  l_next_pos := 0\n                end\n              end\n                -- Perform final substitution:\n                -- Copy new string into Current\n              l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                -- Shift characters between `l_first_pos' and the end of the string\n              l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                l_first_pos + l_new_count - 1 - l_offset, l_count + 1 - l_first_pos - l_orig_count)\n                  -- Perform last substitution\n              l_offset := l_offset + (l_orig_count - l_new_count)\n\n                -- Update `count'\n              set_count (l_count - l_offset)\n            end\n              -- String was modified we need to recompute the `hash_code'.\n            internal_hash_code := 0\n          end\n        elseif attached l_string_searcher.substring_index_list_with_deltas (Current, original, 1, l_count) as l_list then\n            -- Get the number of substitution to be performed by getting a list\n            -- of location where `original' appears.\n          l_index_list := l_list.area\n          l_index_count := l_index_list.count\n            -- Store the index of the last character up to which we need to move\n            -- characters in the reallocated string.\n          l_prev_index := l_count\n            -- Resize Current with the appropriate number of characters\n          l_copy_delta := l_new_count - l_orig_count\n          l_count := l_count + (l_index_count * l_copy_delta)\n          l_area := area.resized_area_with_default ('%U', l_count + 1)\n          area := l_area\n            -- Perform the substitution starting from the end.\n          from\n            i := l_index_count\n            l_new_lower := new.area_lower\n            l_new_area := new.area\n          until\n            i = 0\n          loop\n            i := i - 1\n            l_src_index := l_index_list.item (i)\n            l_dest_index := l_src_index + i * l_copy_delta\n              -- Shift non-matching characters to the right of the newly replaced string.\n            l_area.overlapping_move (l_src_index + l_orig_count - 1, l_dest_index + l_new_count - 1, l_prev_index - l_src_index - l_orig_count + 1)\n              -- Store new end of string where characters will be moved.\n            l_prev_index := l_src_index - 1\n\n              -- Copy `new' to its appropriate position\n            l_area.copy_data (l_new_area, l_new_lower, l_dest_index - 1, l_new_count)\n          end\n            -- Update the new `count' which also resets the `hash_code'.\n          set_count (l_count)\n        end\n      end\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_area.item (nb_space).is_space\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0 or else not l_area.item (i).is_space\n      loop\n        nb_space := nb_space + 1\n        i := i - 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_8)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_8; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_8, i - 1)\n      internal_hash_code := 0\n    end\n\n  precede, prepend_character (c: CHARACTER_8)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        prepend (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  prepend (s: READABLE_STRING_8)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_8)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        append (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_8)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_8)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_8)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append (b.out)\n    end\n\n  insert (s: READABLE_STRING_8; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_8; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_8; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_8)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_8)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_8\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_8)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_8)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_area.item (left_nb_space).is_space\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_area.item (i).is_space\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_8; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_8]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_8]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n      -- Nothing to be done because we only added `internal_hash_code' that will\n      -- be recomputed next time we query `hash_code'.\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: SPECIAL [CHARACTER_8]\n      -- Empty `area' to avoid useless creation of empty areas when wiping out a STRING.\n    obsolete\n      \"Simply create `area' directly.\"\n    do\n      create Result.make_empty (1)\n      Result.extend ('%U')\n    ensure\n      empty_area_not_void: Result /= Void\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 07:36:10 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94633 $\"\n\ndeferred class\n  STRING_GENERAL\n\ninherit\n  READABLE_STRING_GENERAL\n    export\n      {ANY} copy, standard_copy, deep_copy\n    end\n\nconvert\n  as_string_32: {READABLE_STRING_32, STRING_32},\n  to_cil: {SYSTEM_STRING}\n\nfeature -- Settings\n\n  put_code (v: like code; i: INTEGER)\n      -- Put code `v' at position `i'.\n    require\n      valid_code: valid_code (v)\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      inserted: code (i) = v\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\nfeature {STRING_HANDLER} -- Settings\n\n  set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    require\n      valid_count: 0 <= number and number <= capacity\n    deferred\n    ensure\n      new_count: count = number\n    end\n\n  set_internal_hash_code (v: like internal_hash_code)\n      -- Set `internal_hash_code' with `v'.\n    require\n      v_nonnegative: v >= 0\n    do\n      internal_hash_code := v\n    ensure\n      internal_hash_code_set: internal_hash_code = v\n    end\n\nfeature -- Element change\n\n  append_code (c: like code)\n      -- Append `c' at end.\n    require\n      valid_code: valid_code (c)\n    local\n      current_count: INTEGER\n    do\n      current_count := count + 1\n      if current_count > capacity then\n        resize (current_count)\n      end\n      set_count (current_count)\n      put_code (c, current_count)\n    ensure then\n      item_inserted: code (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (to_string_32 + s))\n    end\n\n  append_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := start_index\n        until\n          i > end_index\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      appended: elks_checking implies same_string (old (to_string_32 + s.substring (start_index, end_index)))\n    end\n\n  prepend (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          put_code (s.code (i), i)\n          i := i + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s.to_string_32 + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i, j: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := start_index\n          j := 1\n        until\n          i > end_index\n        loop\n          put_code (s.code (i), j)\n          i := i + 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index).to_string_32 + Current))\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (1, n.min (count)))\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (count - n.min(count) + 1, count))\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (1).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (old count - count + 1, old count))\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (count).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (1, count))\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\n  adjust\n      -- Remove leading and/or trailing whitespace.\n    do\n      left_adjust\n      right_adjust\n    ensure\n      valid_count: count <= old count\n      new_count_left: not is_empty implies not item (1).is_space\n      new_count_right: not is_empty implies not item (count).is_space\n      kept: elks_checking implies (old twin).has_substring (Current)\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    require\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      new_count: count = old count - 1\n      removed: elks_checking implies\n        to_string_32 ~ (old substring (1, i - 1).to_string_32 + old substring (i + 1, count).to_string_32)\n    end\n\nfeature -- Resizing\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    require\n      new_size_large_enough: newsize >= count\n    deferred\n    ensure\n      same_count: count = old count\n      capacity_large_enough: capacity >= newsize\n      same_content: elks_checking implies same_string (old twin)\n    end\n\ninvariant\n  mutable: not is_immutable\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_handler.e","content":"note\n  description: \"Objects that can access `set_count' from STRING\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  STRING_HANDLER\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_table.e","content":"note\n  description: \"[\n    Hash tables, used to store items identified by string keys that are compared with or without case sensitivity.\n    ]\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  warning: \"[\n    Modifying an object used as a key by an item present in a table will\n    cause incorrect behavior. If you will be modifying key objects,\n    pass a clone, not the object itself, or an immutable object, as key argument to\n    `put' and `replace_key'.\n    ]\"\n  date: \"$Date: 2013-05-20 16:15:17 -0700 (Mon, 20 May 2013) $\"\n  revision: \"$Revision: 92557 $\"\n\nclass\n  STRING_TABLE [G]\n\ninherit\n  HASH_TABLE [G, READABLE_STRING_GENERAL]\n    redefine\n      same_keys, hash_code_of, empty_duplicate, is_equal\n    end\n\ncreate\n  make, make_equal, make_caseless, make_equal_caseless\n\nfeature {NONE} -- Initialization\n\n  make_caseless (n: INTEGER)\n      -- Allocate hash table for at least `n' items.\n      -- The table will be resized automatically\n      -- if more than `n' items are inserted.\n      -- Keys will be compared caseless.\n    require\n      n_non_negative: n >= 0\n    do\n      is_case_insensitive := True\n      make (n)\n    ensure\n      breathing_space: n < capacity\n      more_than_minimum: capacity > Minimum_capacity\n      no_status: not special_status\n      is_case_insensitive: is_case_insensitive\n    end\n\n  make_equal_caseless (n: INTEGER)\n      -- Allocate hash table for at least `n' items.\n      -- The table will be resized automatically\n      -- if more than `n' items are inserted.\n      -- Keys will be compared caseless.\n      -- Items will be compared using `~'.\n    require\n      n_non_negative: n >= 0\n    do\n      is_case_insensitive := True\n      make_equal (n)\n    ensure\n      breathing_space: n < capacity\n      more_than_minimum: capacity > Minimum_capacity\n      no_status: not special_status\n      is_case_insensitive: is_case_insensitive\n      compare_objects: object_comparison\n    end\n\nfeature -- Hash code\n\n  hash_code_of (a_key: READABLE_STRING_GENERAL): INTEGER\n      -- Hash code value\n    do\n      if is_case_insensitive then\n        Result := a_key.case_insensitive_hash_code\n      else\n        Result := a_key.hash_code\n      end\n    end\n\nfeature -- Status report\n\n  is_case_insensitive: BOOLEAN\n      -- Ignoring case when comparing keys?\n      -- (Default: False)\n\nfeature -- Comparison\n\n  same_keys (a_search_key, a_key: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `a_search_key' the same key as `a_key' ?\n    do\n      if is_case_insensitive then\n        Result := a_search_key.is_case_insensitive_equal (a_key)\n      else\n        Result := a_search_key.same_string (a_key)\n      end\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Does table contain the same information as `other'?\n    do\n      if is_case_insensitive = other.is_case_insensitive then\n        Result := Precursor (other)\n      end\n    end\n\nfeature {NONE} -- Duplication\n\n  empty_duplicate (n: INTEGER): like Current\n      -- Create an empty copy of Current that can accommodate `n' items\n    do\n      if is_case_insensitive then\n        create Result.make_caseless (n)\n      else\n        create Result.make (n)\n      end\n      if object_comparison then\n        Result.compare_objects\n      end\n    end\n\nfeature {NONE} -- Helper\n\n  character_properties: CHARACTER_PROPERTY\n      -- Helper for efficient case conversions.\n    once\n      create Result.make\n    end\n\nnote\n  copyright:  \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:  \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"system_string.e","content":"note\n  description: \"Fake abstraction of a .NET SYSTEM_STRING in a non-.NET system\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  SYSTEM_STRING\n\nfeature -- Access\n\n  length: INTEGER do end\n\ninvariant\n  is_dotnet: {PLATFORM}.is_dotnet\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"table.e","content":"note\n  description: \"Containers whose items are accessible through keys\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: table, access;\n  access: key, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class TABLE [G, H] inherit\n\n  BAG [G]\n    rename\n      put as bag_put\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (k: H): G assign force\n      -- Entry of key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\nfeature -- Status report\n\n  valid_key (k: H): BOOLEAN\n      -- Is `k' a valid key?\n    deferred\n    end\n\nfeature -- Element change\n\n  put (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\n  force (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    ensure\n      inserted: item (k) = v\n    end\n\nfeature {NONE} -- Inapplicable\n\n  bag_put (v: G)\n    do\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"table_iterable.e","content":"note\n  description: \"[\n    Structure that can be iterated over using `across...loop...end'.\n    using `key' and `item'.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-05-20 16:15:17 -0700 (Mon, 20 May 2013) $\"\n  revision: \"$Revision: 92557 $\"\n\ndeferred class\n  TABLE_ITERABLE [G,K]\n\ninherit\n  ITERABLE [G]\n\nfeature -- Access\n\n  new_cursor: TABLE_ITERATION_CURSOR [G,K]\n      -- Fresh cursor associated with current structure\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"to_special.e","content":"note\n  description: \"References to special objects, for direct access to arrays and strings\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass TO_SPECIAL [T]\n\ncreate\n  make_empty_area,\n  make_filled_area\n\nfeature -- Access\n\n  area: SPECIAL [T]\n      -- Special data zone\n\nfeature {NONE} -- Initialization\n\n  make_empty_area (n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_empty (n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = 0\n    end\n\n  make_filled_area (a_default_value: T; n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_filled (a_default_value, n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = n\n      area_filled: area.filled_with (a_default_value, 0, n - 1)\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): T assign put\n      -- Entry at index `i', if in index interval\n    require\n      valid_index: valid_index (i)\n    do\n      Result := area.item (i)\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := area.valid_index (i)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_index: valid_index (i)\n    do\n      area.put (v, i)\n    ensure\n      inserted: item (i) = v\n    end\n\nfeature {NONE} -- Element change\n\n  set_area (other: like area)\n      -- Make `other' the new `area'\n    do\n      area := other\n    ensure\n      area_set: area = other\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"traversable.e","content":"note\n  description: \"[\n    Structures for which there exists a traversal policy\n    that will visit every element exactly once.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: traversable, traversing;\n  access: cursor;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class\n  TRAVERSABLE [G]\n\ninherit\n\n  CONTAINER [G]\n\nfeature -- Access\n\n  item: G\n      -- Item at current position\n    require\n      not_off: not off\n    deferred\n    end\n\nfeature -- Status report\n\n  off: BOOLEAN\n      -- Is there no current item?\n    deferred\n    end\n\nfeature -- Cursor movement\n\n  start\n      -- Move to first position if any.\n    deferred\n    end\n\nfeature -- Iteration\n\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_exists: action /= Void\n    do\n      linear_representation.do_all (action)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]];\n   test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test'.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_exists: action /= Void\n      test_exists: test /= Void\n      -- test.is_pure\n    do\n      linear_representation.do_if (action, test)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_exists: test /= Void\n      -- test.is_pure\n    do\n      Result := linear_representation.there_exists (test)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_exists: test /= Void\n      -- test.is_pure\n    do\n      Result := linear_representation.for_all (test)\n    end\n\ninvariant\n\n  empty_constraint: is_empty implies off\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"tuple.e","content":"note\n  description: \"Implementation of TUPLE\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-01 04:33:47 -0800 (Wed, 01 Jan 2014) $\"\n  revision: \"$Revision: 93865 $\"\n\nclass\n  TUPLE\n\ninherit\n  HASHABLE\n    redefine\n      is_equal\n    end\n\n  MISMATCH_CORRECTOR\n    redefine\n      correct_mismatch, is_equal\n    end\n\n  READABLE_INDEXABLE [detachable separate ANY]\n    redefine\n      is_equal\n    end\n\ncreate\n  default_create\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (index: INTEGER): detachable separate ANY assign put\n      -- Entry of key `index'.\n    do\n      inspect eif_item_type ($Current, index)\n      when boolean_code then Result := eif_boolean_item ($Current, index)\n      when character_8_code then Result := eif_character_8_item ($Current, index)\n      when character_32_code then Result := eif_character_32_item ($Current, index)\n      when real_64_code then Result := eif_real_64_item ($Current, index)\n      when real_32_code then Result := eif_real_32_item ($Current, index)\n      when pointer_code then Result := eif_pointer_item ($Current, index)\n      when natural_8_code then Result := eif_natural_8_item ($Current, index)\n      when natural_16_code then Result := eif_natural_16_item ($Current, index)\n      when natural_32_code then Result := eif_natural_32_item ($Current, index)\n      when natural_64_code then Result := eif_natural_64_item ($Current, index)\n      when integer_8_code then Result := eif_integer_8_item ($Current, index)\n      when integer_16_code then Result := eif_integer_16_item ($Current, index)\n      when integer_32_code then Result := eif_integer_32_item ($Current, index)\n      when integer_64_code then Result := eif_integer_64_item ($Current, index)\n      when Reference_code then Result := eif_reference_item ($Current, index)\n      end\n    end\n\n  reference_item (index: INTEGER): detachable separate ANY\n      -- Reference item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_reference: is_reference_item (index)\n    do\n      Result := eif_reference_item ($Current, index)\n    end\n\n  boolean_item (index: INTEGER): BOOLEAN\n      -- Boolean item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_boolean: is_boolean_item (index)\n    do\n      Result := eif_boolean_item ($Current, index)\n    end\n\n  character_8_item, character_item (index: INTEGER): CHARACTER_8\n      -- Character item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_character_8: is_character_8_item (index)\n    do\n      Result := eif_character_8_item ($Current, index)\n    end\n\n  character_32_item, wide_character_item (index: INTEGER): CHARACTER_32\n      -- Character item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_character_32: is_character_32_item (index)\n    do\n      Result := eif_character_32_item ($Current, index)\n    end\n\n  real_64_item, double_item (index: INTEGER): REAL_64\n      -- Double item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_numeric: is_double_item (index)\n    do\n      Result := eif_real_64_item ($Current, index)\n    end\n\n  natural_8_item (index: INTEGER): NATURAL_8\n      -- NATURAL_8 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_8_item (index)\n    do\n      Result := eif_natural_8_item ($Current, index)\n    end\n\n  natural_16_item (index: INTEGER): NATURAL_16\n      -- NATURAL_16 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_16_item (index)\n    do\n      Result := eif_natural_16_item ($Current, index)\n    end\n\n  natural_32_item (index: INTEGER): NATURAL_32\n      -- NATURAL_32 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_32_item (index)\n    do\n      Result := eif_natural_32_item ($Current, index)\n    end\n\n  natural_64_item (index: INTEGER): NATURAL_64\n      -- NATURAL_64 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_64_item (index)\n    do\n      Result := eif_natural_64_item ($Current, index)\n    end\n\n  integer_8_item (index: INTEGER): INTEGER_8\n      -- INTEGER_8 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_8_item (index)\n    do\n      Result := eif_integer_8_item ($Current, index)\n    end\n\n  integer_16_item (index: INTEGER): INTEGER_16\n      -- INTEGER_16 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_16_item (index)\n    do\n      Result := eif_integer_16_item ($Current, index)\n    end\n\n  integer_item, integer_32_item (index: INTEGER): INTEGER_32\n      -- INTEGER_32 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_32_item (index)\n    do\n      Result := eif_integer_32_item ($Current, index)\n    end\n\n  integer_64_item (index: INTEGER): INTEGER_64\n      -- INTEGER_64 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_64_item (index)\n    do\n      Result := eif_integer_64_item ($Current, index)\n    end\n\n  pointer_item (index: INTEGER): POINTER\n      -- Pointer item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_pointer: is_pointer_item (index)\n    do\n      Result := eif_pointer_item ($Current, index)\n    end\n\n  real_32_item, real_item (index: INTEGER): REAL_32\n      -- real item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_real_or_integer: is_real_item (index)\n    do\n      Result := eif_real_32_item ($Current, index)\n    end\nfeature -- Comparison\n\n  object_comparison: BOOLEAN\n      -- Must search operations use `equal' rather than `='\n      -- for comparing references? (Default: no, use `='.)\n    do\n      Result := eif_boolean_item ($Current, 0)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    local\n      i, nb: INTEGER\n      l_object_compare: BOOLEAN\n    do\n      l_object_compare := object_comparison\n      if l_object_compare = other.object_comparison then\n        if l_object_compare then\n          nb := count\n          if nb = other.count then\n            from\n              Result := True\n              i := 1\n            until\n              i > nb or not Result\n            loop\n              Result := item (i) ~ other.item (i)\n              i := i + 1\n            end\n          end\n        else\n          Result := Precursor {HASHABLE} (other)\n        end\n      end\n    end\n\nfeature -- Status setting\n\n  compare_objects\n      -- Ensure that future search operations will use `equal'\n      -- rather than `=' for comparing references.\n    do\n      eif_put_boolean_item ($Current, 0, True)\n    ensure\n      object_comparison: object_comparison\n    end\n\n  compare_references\n      -- Ensure that future search operations will use `='\n      -- rather than `equal' for comparing references.\n    do\n      eif_put_boolean_item ($Current, 0, False)\n    ensure\n      reference_comparison: not object_comparison\n    end\n\nfeature -- Status report\n\n  hash_code: INTEGER\n      -- Hash code value\n    local\n      i, nb, l_hash: INTEGER\n    do\n      from\n        i := 1\n        nb := count\n      until\n        i > nb\n      loop\n        inspect eif_item_type($Current, i)\n        when boolean_code then l_hash := eif_boolean_item ($Current, i).hash_code\n        when character_8_code then l_hash := eif_character_8_item ($Current, i).hash_code\n        when character_32_code then l_hash := eif_character_32_item ($Current, i).hash_code\n        when real_64_code then l_hash := eif_real_64_item ($Current, i).hash_code\n        when real_32_code then l_hash := eif_real_32_item ($Current, i).hash_code\n        when pointer_code then l_hash := eif_pointer_item ($Current, i).hash_code\n        when natural_8_code then l_hash := eif_natural_8_item ($Current, i).hash_code\n        when natural_16_code then l_hash := eif_natural_16_item ($Current, i).hash_code\n        when natural_32_code then l_hash := eif_natural_32_item ($Current, i).hash_code\n        when natural_64_code then l_hash := eif_natural_64_item ($Current, i).hash_code\n        when integer_8_code then l_hash := eif_integer_8_item ($Current, i).hash_code\n        when integer_16_code then l_hash := eif_integer_16_item ($Current, i).hash_code\n        when integer_32_code then l_hash := eif_integer_32_item ($Current, i).hash_code\n        when integer_64_code then l_hash := eif_integer_64_item ($Current, i).hash_code\n        when reference_code then\n          if attached {HASHABLE} eif_reference_item ($Current, i) as l_key then\n            l_hash := l_key.hash_code\n          else\n            l_hash := 0\n          end\n        end\n        Result := Result + l_hash * internal_primes.i_th (i)\n        i := i + 1\n      end\n        -- Ensure it is a positive value.\n      Result := Result.hash_code\n    end\n\n  valid_index (k: INTEGER): BOOLEAN\n      -- Is `k' a valid key?\n    do\n      Result := k >= 1 and then k <= count\n    end\n\n  valid_type_for_index (v: detachable separate ANY; index: INTEGER): BOOLEAN\n      -- Is object `v' a valid target for element at position `index'?\n    require\n      valid_index: valid_index (index)\n    local\n      l_reflector: REFLECTOR\n    do\n      if v = Void then\n          -- A Void entry is valid only for references and as long as the expected type\n          -- is detachable.\n        if eif_item_type ($Current, index) = reference_code then\n          Result := not generating_type.generic_parameter_type (index).is_attached\n        end\n      else\n        inspect eif_item_type ($Current, index)\n        when boolean_code then Result := attached {BOOLEAN_REF} v as l_b\n        when character_8_code then Result := attached {CHARACTER_8_REF} v as l_c\n        when character_32_code then Result := attached {CHARACTER_32_REF} v as l_wc\n        when real_64_code then Result := attached {REAL_64_REF} v as l_d\n        when real_32_code then Result := attached {REAL_32_REF} v as l_r\n        when pointer_code then Result := attached {POINTER_REF} v as l_p\n        when natural_8_code then Result := attached {NATURAL_8_REF} v as l_ui8\n        when natural_16_code then Result := attached {NATURAL_16_REF} v as l_ui16\n        when natural_32_code then Result := attached {NATURAL_32_REF} v as l_ui32\n        when natural_64_code then Result := attached {NATURAL_64_REF} v as l_ui64\n        when integer_8_code then Result := attached {INTEGER_8_REF} v as l_i8\n        when integer_16_code then Result := attached {INTEGER_16_REF} v as l_i16\n        when integer_32_code then Result := attached {INTEGER_32_REF} v as l_i32\n        when integer_64_code then Result := attached {INTEGER_64_REF} v as l_i64\n        when Reference_code then\n            -- Let's check that type of `v' conforms to specified type of `index'-th\n            -- arguments of current TUPLE.\n          create l_reflector\n          Result := l_reflector.field_conforms_to (v.generating_type.type_id, generating_type.generic_parameter_type (index).type_id)\n        end\n      end\n    end\n\n  count: INTEGER\n      -- Number of element in Current.\n    external\n      \"built_in\"\n    end\n\n  lower: INTEGER = 1\n      -- Lower bound of TUPLE.\n\n  upper: INTEGER\n      -- Upper bound of TUPLE.\n    do\n      Result := count\n    end\n\n  is_empty: BOOLEAN\n      -- Is Current empty?\n    do\n      Result := count = 0\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    end\n\nfeature -- Element change\n\n  put (v: detachable separate ANY; index: INTEGER)\n      -- Insert `v' at position `index'.\n    require\n      valid_index: valid_index (index)\n      valid_type_for_index: valid_type_for_index (v, index)\n    do\n      inspect eif_item_type ($Current, index)\n      when boolean_code then eif_put_boolean_item_with_object ($Current, index, $v)\n      when character_8_code then eif_put_character_8_item_with_object ($Current, index, $v)\n      when character_32_code then eif_put_character_32_item_with_object ($Current, index, $v)\n      when real_64_code then eif_put_real_64_item_with_object ($Current, index, $v)\n      when real_32_code then eif_put_real_32_item_with_object ($Current, index, $v)\n      when pointer_code then eif_put_pointer_item_with_object ($Current, index, $v)\n      when natural_8_code then eif_put_natural_8_item_with_object ($Current, index, $v)\n      when natural_16_code then eif_put_natural_16_item_with_object ($Current, index, $v)\n      when natural_32_code then eif_put_natural_32_item_with_object ($Current, index, $v)\n      when natural_64_code then eif_put_natural_64_item_with_object ($Current, index, $v)\n      when integer_8_code then eif_put_integer_8_item_with_object ($Current, index, $v)\n      when integer_16_code then eif_put_integer_16_item_with_object ($Current, index, $v)\n      when integer_32_code then eif_put_integer_32_item_with_object ($Current, index, $v)\n      when integer_64_code then eif_put_integer_64_item_with_object ($Current, index, $v)\n      when Reference_code then eif_put_reference_item_with_object ($Current, index, $v)\n      end\n    end\n\n  put_reference (v: detachable separate ANY; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type_for_index: valid_type_for_index (v, index)\n      valid_type: is_reference_item (index)\n    do\n      eif_put_reference_item_with_object ($Current, index, $v)\n    end\n\n  put_boolean (v: BOOLEAN; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_boolean_item (index)\n    do\n      eif_put_boolean_item ($Current, index, v)\n    end\n\n  put_character_8, put_character (v: CHARACTER_8; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_character_8_item (index)\n    do\n      eif_put_character_8_item ($Current, index, v)\n    end\n\n  put_character_32, put_wide_character (v: CHARACTER_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_character_32_item (index)\n    do\n      eif_put_character_32_item ($Current, index, v)\n    end\n\n  put_real_64, put_double (v: REAL_64; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_double_item (index)\n    do\n      eif_put_real_64_item ($Current, index, v)\n    end\n\n  put_real_32, put_real (v: REAL_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_real_item (index)\n    do\n      eif_put_real_32_item ($Current, index, v)\n    end\n\n  put_pointer (v: POINTER; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_pointer_item (index)\n    do\n      eif_put_pointer_item ($Current, index, v)\n    end\n\n  put_natural_8 (v: NATURAL_8; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_8_item (index)\n    do\n      eif_put_natural_8_item ($Current, index, v)\n    end\n\n  put_natural_16 (v: NATURAL_16; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_16_item (index)\n    do\n      eif_put_natural_16_item ($Current, index, v)\n    end\n\n  put_natural_32 (v: NATURAL_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_32_item (index)\n    do\n      eif_put_natural_32_item ($Current, index, v)\n    end\n\n  put_natural_64 (v: NATURAL_64; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_64_item (index)\n    do\n      eif_put_natural_64_item ($Current, index, v)\n    end\n\n  put_integer, put_integer_32 (v: INTEGER_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_32_item (index)\n    do\n      eif_put_integer_32_item ($Current, index, v)\n    end\n\n  put_integer_8 (v: INTEGER_8; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_8_item (index)\n    do\n      eif_put_integer_8_item ($Current, index, v)\n    end\n\n  put_integer_16 (v: INTEGER_16; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_16_item (index)\n    do\n      eif_put_integer_16_item ($Current, index, v)\n    end\n\n  put_integer_64 (v: INTEGER_64; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_64_item (index)\n    do\n      eif_put_integer_64_item ($Current, index, v)\n    end\n\nfeature -- Type queries\n\n  is_boolean_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a BOOLEAN?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = boolean_code)\n    end\n\n  is_character_8_item, is_character_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a CHARACTER_8?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = character_8_code)\n    end\n\n  is_character_32_item, is_wide_character_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a CHARACTER_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = character_32_code)\n    end\n\n  is_double_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a REAL_64?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = real_64_code)\n    end\n\n  is_natural_8_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_8?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_8_code)\n    end\n\n  is_natural_16_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_16?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_16_code)\n    end\n\n  is_natural_32_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_32_code)\n    end\n\n  is_natural_64_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_64?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_64_code)\n    end\n\n  is_integer_8_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_8?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_8_code)\n    end\n\n  is_integer_16_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_16?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_16_code)\n    end\n\n  is_integer_item, is_integer_32_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_32_code)\n    end\n\n  is_integer_64_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_64?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_64_code)\n    end\n\n  is_pointer_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a POINTER?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = pointer_code)\n    end\n\n  is_real_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a REAL_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = real_32_code)\n    end\n\n  is_reference_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a REFERENCE?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = reference_code)\n    end\n\n  is_numeric_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a number?\n    obsolete\n      \"Use the precise type query instead.\"\n    require\n      valid_index: valid_index (index)\n    local\n      tcode: like item_code\n    do\n      tcode := eif_item_type ($Current, index)\n      inspect tcode\n      when\n        integer_8_code, integer_16_code, integer_32_code,\n        integer_64_code, real_32_code, real_64_code\n      then\n        Result := True\n      else\n        -- Nothing to do here since Result already initialized to False.\n      end\n    end\n\n  is_uniform: BOOLEAN\n      -- Are all items of the same basic type or all of reference type?\n    do\n      Result := is_tuple_uniform (any_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_boolean: BOOLEAN\n      -- Are all items of type BOOLEAN?\n    do\n      Result := is_tuple_uniform (boolean_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_character_8, is_uniform_character: BOOLEAN\n      -- Are all items of type CHARACTER_8?\n    do\n      Result := is_tuple_uniform (character_8_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_character_32, is_uniform_wide_character: BOOLEAN\n      -- Are all items of type CHARACTER_32?\n    do\n      Result := is_tuple_uniform (character_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_double: BOOLEAN\n      -- Are all items of type REAL_64?\n    do\n      Result := is_tuple_uniform (real_64_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_8: BOOLEAN\n      -- Are all items of type NATURAL_8?\n    do\n      Result := is_tuple_uniform (natural_8_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_16: BOOLEAN\n      -- Are all items of type NATURAL_16?\n    do\n      Result := is_tuple_uniform (natural_16_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_32: BOOLEAN\n      -- Are all items of type NATURAL_32?\n    do\n      Result := is_tuple_uniform (natural_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_64: BOOLEAN\n      -- Are all items of type NATURAL_64?\n    do\n      Result := is_tuple_uniform (natural_64_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer_8: BOOLEAN\n      -- Are all items of type INTEGER_8?\n    do\n      Result := is_tuple_uniform (integer_8_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer_16: BOOLEAN\n      -- Are all items of type INTEGER_16?\n    do\n      Result := is_tuple_uniform (integer_16_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer, is_uniform_integer_32: BOOLEAN\n      -- Are all items of type INTEGER?\n    do\n      Result := is_tuple_uniform (integer_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer_64: BOOLEAN\n      -- Are all items of type INTEGER_64?\n    do\n      Result := is_tuple_uniform (integer_64_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_pointer: BOOLEAN\n      -- Are all items of type POINTER?\n    do\n      Result := is_tuple_uniform (pointer_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_real: BOOLEAN\n      -- Are all items of type REAL_32?\n    do\n      Result := is_tuple_uniform (real_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_reference: BOOLEAN\n      -- Are all items of reference type?\n    do\n      Result := is_tuple_uniform (reference_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\nfeature -- Access\n\n  plus alias \"+\" (a_other: TUPLE): detachable like Current\n      -- Concatenation of `Current' with `a_other'\n      --| note: it may be Void if the result exceeds the allowed capacity for a tuple.\n      --| warning: this function has poor performance, use it with parsimony.\n    local\n      l_reflector: REFLECTOR\n      i, n1,n2: INTEGER\n      t1, t2: TYPE [detachable TUPLE]\n      l_type_id: INTEGER\n      l_items: SPECIAL [detachable separate ANY]\n      l_type_string: STRING\n    do\n      n1 := count\n      n2 := a_other.count\n\n      if n1 = 0 then\n        Result := a_other.twin\n      elseif n2 = 0 then\n        Result := twin\n      else\n        create l_type_string.make_from_string (\"TUPLE [\")\n\n        create l_items.make_empty (n1 + n2)\n        from\n          t1 := generating_type\n          check same_count: t1.generic_parameter_count = n1 end\n          i := 1\n        until\n          i > n1\n        loop\n          if i > 1 then\n            l_type_string.append_character (',')\n          end\n          l_type_string.append (t1.generic_parameter_type (i).name)\n          l_items.force (item (i), i - 1)\n          i := i + 1\n        end\n        from\n          t2 := a_other.generating_type\n          check same_count: t2.generic_parameter_count = n2 end\n        until\n          i > n1 + n2\n        loop\n          l_type_string.append_character (',')\n          l_type_string.append (t2.generic_parameter_type (i - n1).name)\n          l_items.force (a_other.item (i - n1), i - 1)\n          i := i + 1\n        end\n\n        l_type_string.append_character (']')\n        create l_reflector\n        l_type_id := l_reflector.dynamic_type_from_string (l_type_string)\n        if l_type_id >= 0 then\n          if attached {like plus} l_reflector.new_tuple_from_special (l_type_id, l_items) as res then\n            Result := res\n          end\n        else\n            --| It may be that the maximum tuple capacity was reached.\n            --| better return Void than a truncated tuple.\n        end\n      end\n    ensure\n      has_expected_count: Result /= Void implies Result.count = count + a_other.count\n      has_expected_items: Result /= Void implies (\n            (across 1 |..| count as ic_1 all Result[ic_1.item] = item (ic_1.item) end) and\n            (across 1 |..| a_other.count as ic_2 all Result[count + ic_2.item] = a_other [ic_2.item] end)\n          )\n    end\n\nfeature -- Type conversion queries\n\n  convertible_to_double: BOOLEAN\n      -- Is current convertible to an array of doubles?\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n      tcode: like item_code\n    do\n      Result := True\n      from\n        i := 1\n        cnt := count\n      until\n        i > cnt or else not Result\n      loop\n        tcode := eif_item_type ($Current, i)\n        inspect tcode\n        when\n          integer_8_code, integer_16_code, integer_32_code,\n          integer_64_code, real_32_code, real_64_code\n        then\n          Result := True\n        else\n          Result := False\n        end\n        i := i + 1\n      end\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  convertible_to_real: BOOLEAN\n      -- Is current convertible to an array of reals?\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n      tcode: like item_code\n    do\n      Result := True\n      from\n        i := 1\n        cnt := count\n      until\n        i > cnt or else not Result\n      loop\n        tcode := eif_item_type ($Current, i)\n        inspect tcode\n        when\n          integer_8_code, integer_16_code, integer_32_code,\n          integer_64_code, real_32_code\n        then\n          Result := True\n        else\n          Result := False\n        end\n        i := i + 1\n      end\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\nfeature -- Conversion\n\n  arrayed: ARRAY [detachable separate ANY]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (Void, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  boolean_arrayed: ARRAY [BOOLEAN]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_boolean: is_uniform_boolean\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (False, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (boolean_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  character_8_arrayed, character_arrayed: ARRAY [CHARACTER_8]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_character: is_uniform_character\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (' ', 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (character_8_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  double_arrayed: ARRAY [REAL_64]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      convertible: convertible_to_double\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled ({REAL_64} 0.0, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (double_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  integer_arrayed: ARRAY [INTEGER]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_integer: is_uniform_integer\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled ({INTEGER} 0, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (integer_32_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  pointer_arrayed: ARRAY [POINTER]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_pointer: is_uniform_pointer\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (Default_pointer, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (pointer_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  real_arrayed: ARRAY [REAL_32]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      convertible: convertible_to_real\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled ({REAL_32} 0.0, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (real_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  string_arrayed: ARRAY [detachable STRING]\n      -- Items of Current as array\n      -- NOTE: Items with a type not cconforming to\n      --       type STRING are set to Void.\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (Void, 1, cnt)\n      until\n        i > cnt\n      loop\n        if attached {STRING} item (i) as s then\n          Result.put (s, i)\n        end\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n    end\n\nfeature -- Retrieval\n\n  correct_mismatch\n      -- Attempt to correct object mismatch using `mismatch_information'.\n    local\n      i, nb: INTEGER\n      l_any: ANY\n    do\n        -- Old version of TUPLE had a SPECIAL [ANY] to store all values.\n        -- If we can get access to it, then most likely we can recover this\n        -- old TUPLE implementation.\n      if attached {SPECIAL [ANY]} Mismatch_information.item (area_name) as l_area then\n        from\n          i := 1\n          nb := l_area.count\n        until\n          i > nb\n        loop\n          l_any := l_area.item (i - 1)\n          if valid_type_for_index (l_any, i) then\n            put (l_any, i)\n          else\n              -- We found an unexpected type in old special. We cannot go on.\n            Precursor {MISMATCH_CORRECTOR}\n          end\n          i := i + 1\n        end\n      else\n        Precursor {MISMATCH_CORRECTOR}\n      end\n    end\n\nfeature -- Access\n\n  item_code (index: INTEGER): NATURAL_8\n      -- Type code of item at `index'. Used for\n      -- argument processing in ROUTINE\n    require\n      valid_index: valid_index (index)\n    do\n      Result := eif_item_type ($Current, index)\n    end\n\n  reference_code: NATURAL_8 = 0x00\n  boolean_code: NATURAL_8 = 0x01\n  character_8_code, character_code: NATURAL_8 = 0x02\n  real_64_code: NATURAL_8 = 0x03\n  real_32_code: NATURAL_8 = 0x04\n  pointer_code: NATURAL_8 = 0x05\n  integer_8_code: NATURAL_8 = 0x06\n  integer_16_code: NATURAL_8 = 0x07\n  integer_32_code: NATURAL_8 = 0x08\n  integer_64_code: NATURAL_8 = 0x09\n  natural_8_code: NATURAL_8 = 0x0A\n  natural_16_code: NATURAL_8 = 0x0B\n  natural_32_code: NATURAL_8 = 0x0C\n  natural_64_code: NATURAL_8 = 0x0D\n  character_32_code, wide_character_code: NATURAL_8 = 0x0E\n  any_code: NATURAL_8 = 0xFF\n      -- Code used to identify type in TUPLE.\n\nfeature {NONE} -- Implementation\n\n  area_name: STRING = \"area\"\n      -- Name of attributes where TUPLE elements were stored.\n\n  is_tuple_uniform (code: like item_code): BOOLEAN\n      -- Are all items of type `code'?\n    local\n      i, nb: INTEGER\n      l_code: like item_code\n    do\n      Result := True\n      if count > 0 then\n        from\n          nb := count\n          if code = any_code then\n              -- We take first type code and compare all the remaining ones\n              -- against it.\n            i := 2\n            l_code := eif_item_type ($Current, 1)\n          else\n            i := 1\n            l_code := code\n          end\n        until\n          i > nb or not Result\n        loop\n          Result := l_code = eif_item_type ($Current, i)\n          i := i + 1\n        end\n      end\n    end\n\n  internal_primes: PRIMES\n      -- For quick access to prime numbers.\n    once\n      create Result\n    end\n\nfeature {NONE} -- Externals: Access\n\n  eif_item_type (obj: POINTER; pos: INTEGER): NATURAL_8\n      -- Code for generic parameter `pos' in `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    alias\n      \"eif_item_type\"\n    end\n\n  eif_boolean_item (obj: POINTER; pos: INTEGER): BOOLEAN\n      -- Boolean item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_character_8_item (obj: POINTER; pos: INTEGER): CHARACTER_8\n      -- Character item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_character_32_item (obj: POINTER; pos: INTEGER): CHARACTER_32\n      -- Wide character item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_real_64_item (obj: POINTER; pos: INTEGER): REAL_64\n      -- Double item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_real_32_item (obj: POINTER; pos: INTEGER): REAL_32\n      -- Real item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_pointer_item (obj: POINTER; pos: INTEGER): POINTER\n      -- Pointer item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_8_item (obj: POINTER; pos: INTEGER): NATURAL_8\n      -- NATURAL_8 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_16_item (obj: POINTER; pos: INTEGER):  NATURAL_16\n      -- NATURAL_16 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_32_item (obj: POINTER; pos: INTEGER):  NATURAL_32\n      -- NATURAL_32 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_64_item (obj: POINTER; pos: INTEGER):  NATURAL_64\n      -- NATURAL_64 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_8_item (obj: POINTER; pos: INTEGER): INTEGER_8\n      -- INTEGER_8 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_16_item (obj: POINTER; pos: INTEGER): INTEGER_16\n      -- INTEGER_16 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_32_item (obj: POINTER; pos: INTEGER): INTEGER_32\n      -- INTEGER_32 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_64_item (obj: POINTER; pos: INTEGER): INTEGER_64\n      -- INTEGER_64 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_reference_item (obj: POINTER; pos: INTEGER): detachable ANY\n      -- Reference item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\nfeature {NONE} -- Externals: Setting\n\n  eif_put_boolean_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set boolean item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_8_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set character item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set wide character item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_64_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set double item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set real item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_pointer_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set pointer item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_8_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_16_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_64_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_8_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_16_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_64_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_reference_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set reference item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_boolean_item (obj: POINTER; pos: INTEGER; v: BOOLEAN)\n      -- Set boolean item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_8_item (obj: POINTER; pos: INTEGER; v: CHARACTER_8)\n      -- Set character_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_32_item (obj: POINTER; pos: INTEGER; v: CHARACTER_32)\n      -- Set character_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_64_item (obj: POINTER; pos: INTEGER; v: REAL_64)\n      -- Set double item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_32_item (obj: POINTER; pos: INTEGER; v: REAL_32)\n      -- Set real item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_pointer_item (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set pointer item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_8_item (obj: POINTER; pos: INTEGER; v: NATURAL_8)\n      -- Set NATURAL_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_16_item (obj: POINTER; pos: INTEGER; v: NATURAL_16)\n      -- Set NATURAL_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_32_item (obj: POINTER; pos: INTEGER; v: NATURAL_32)\n      -- Set NATURAL_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_64_item (obj: POINTER; pos: INTEGER; v: NATURAL_64)\n      -- Set NATURAL_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_8_item (obj: POINTER; pos: INTEGER; v: INTEGER_8)\n      -- Set integer_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_16_item (obj: POINTER; pos: INTEGER; v: INTEGER_16)\n      -- Set integer_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_32_item (obj: POINTER; pos: INTEGER; v: INTEGER_32)\n      -- Set integer_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_64_item (obj: POINTER; pos: INTEGER; v: INTEGER_64)\n      -- Set integer_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"type.e","content":"note\n  description: \"Representation of an Eiffel type.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-09-05 03:29:24 -0700 (Thu, 05 Sep 2013) $\"\n  revision: \"$Revision: 92913 $\"\n\nclass\n  TYPE [G]\n\ninherit\n  HASHABLE\n    rename\n      default as any_default\n    redefine\n      is_equal, out\n    end\n\n  PART_COMPARABLE\n    rename\n      default as any_default,\n      is_less as is_strictly_conforming_to alias \"<\",\n      is_less_equal as is_conforming_to alias \"<=\"\n    redefine\n      is_conforming_to, is_equal, out\n    end\n\n  DEBUG_OUTPUT\n    rename\n      default as any_default\n    redefine\n      is_equal, out\n    end\n\ncreate {NONE}\n  -- Creation is done either by using manifest types\n  -- or by calling ANY.generating_type.\n\nconvert\n    -- Conversion useful for the transition period because of the\n    -- modification in ANY:\n    --    generating_type: STRING\n    -- becomes:\n    --    generating_type: TYPE [like Current]\n  to_string_8: {STRING_8, STRING_GENERAL, READABLE_STRING_GENERAL, READABLE_STRING_8},\n  to_string_32: {STRING_32, READABLE_STRING_32}\n\nfeature -- Access\n\n  name: IMMUTABLE_STRING_8\n      -- Name of Eiffel type represented by `Current', using Eiffel style guidelines\n      -- as specified in OOSC2 (e.g. COMPARABLE, HASH_TABLE [FOO, BAR], ...)\n    do\n      if attached internal_name as l_name then\n        Result := l_name\n      else\n        create Result.make_from_string (runtime_name)\n        internal_name := Result\n      end\n    ensure\n      name_not_void: Result /= Void\n    end\n\n  generic_parameter_type (i: INTEGER): TYPE [detachable ANY]\n      -- `i'-th generic parameter of Eiffel type represented by `Current'\n    require\n      i_large_enough: i >= 1\n      i_small_enough: i <= generic_parameter_count\n    external\n      \"built_in\"\n    ensure\n      generic_parameter_not_void: Result /= Void\n    end\n\n  type_id: INTEGER\n      -- Id of the Eiffel type represented by `Current'\n    external\n      \"built_in\"\n    ensure\n      type_id_not_negative: Result >= 0\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := type_id\n    end\n\nfeature -- Measurement\n\n  generic_parameter_count: INTEGER\n      -- Number of generic parameters in Eiffel type represented by `Current'\n    external\n      \"built_in\"\n    ensure\n      generic_parameter_count_not_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  has_default: BOOLEAN\n      -- Is current type a type that has a default value?\n      -- I.e. a detachable type or an expanded type.\n    external\n      \"built_in\"\n    end\n\n  is_expanded: BOOLEAN\n      -- Is current type an expanded type?\n    external\n      \"built_in\"\n    end\n\n  is_attached: BOOLEAN\n      -- Is current type attached?\n    external\n      \"built_in\"\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    do\n      Result := type_id = other.type_id\n    end\n\n  is_strictly_conforming_to alias \"<\" (other: like Current): BOOLEAN\n      -- Does type represented by `Current' conform to type represented by `other' and differ from it?\n    do\n      Result := type_id /= other.type_id and then is_conforming_to (other)\n    end\n\n  is_conforming_to alias \"<=\" (other: like Current): BOOLEAN\n      -- Does type represented by `Current' conform to type represented by `other'?\n    external\n      \"magic\"\n      -- Result := {ISE_RUNTIME}.type_conforms_to (type_id, other.type_id)\n    end\n\nfeature -- Conversion\n\n  adapt alias \"[]\" (g: detachable G): detachable G\n      -- Adapts `g' or calls necessary conversion routine to adapt `g'\n    do\n      Result := g\n    ensure\n      adapted: Result ~ g\n    end\n\n  attempt alias \"#?\" (obj: detachable separate ANY): detachable G\n      -- Result of assignment attempt of `obj' to entity of type G\n    do\n      if attached {G} obj as l_g then\n        Result := l_g\n      end\n    ensure\n      assigned_or_void: Result = obj or Result = default_detachable_value\n    end\n\n  default_detachable_value: detachable G\n    do\n    end\n\n  default: G\n    require\n      has_default: has_default\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- <Precursor>\n    do\n      create Result.make_from_string (name)\n    end\n\n  debug_output: STRING\n      -- <Precursor>\n    do\n      create Result.make_from_string (name)\n    end\n\nfeature -- Features from STRING needed here for the transition period (see convert clause)\n\n  plus alias \"+\" (other: STRING): STRING\n      -- Append a copy of 's' at the end of a copy of the name of the\n      -- Eiffel type represented by `Current', then return the Result.\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name + other' instead (or 'out + other' during the transition period).\"\n    require\n      argument_not_void: other /= Void\n    do\n      create Result.make (name.count + other.count)\n      Result.append (name)\n      Result.append (other)\n    ensure\n      result_exists: Result /= Void\n      definition: Result.same_string (name + other)\n    end\n\n  same_string (other: STRING): BOOLEAN\n      -- Do the name of the Eiffel type represented by `Current'\n      -- and `other' have same character sequence?\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.same_string (other)' instead (or 'out.same_string (other)' during the transition period).\"\n    require\n      other_not_void: other /= Void\n    do\n      Result := name.same_string (other)\n    ensure\n      definition: Result = name.same_string (other)\n    end\n\n  is_case_insensitive_equal (other: STRING): BOOLEAN\n      -- Is the name of the Eiffel type represented by `Current'\n      -- made of same character sequence as `other' regardless\n      -- of casing (possibly with a different capacity)?\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.is_case_insensitive_equal (other)' instead (or 'out.is_case_insensitive_equal (other)' during the transition period).\"\n    require\n      other_not_void: other /= Void\n    do\n      Result := name.is_case_insensitive_equal (other)\n    ensure\n      definition: Result = name.is_case_insensitive_equal (other)\n    end\n\n  as_lower: STRING\n      -- New object with all letters of the name of the Eiffel type\n      -- represented by `Current' in lower case.\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.as_lower' instead (or 'out.as_lower' during the transition period).\"\n    do\n      create Result.make_from_string (name)\n      Result.to_lower\n    ensure\n      as_lower_not_void: Result /= Void\n      definition: Result.same_string (name.as_lower)\n    end\n\n  as_upper: STRING\n      -- New object with all letters of the name of the Eiffel type\n      -- represented by `Current' in upper case.\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.as_upper' instead (or 'out.as_upper' during the transition period).\"\n    do\n      create Result.make_from_string (name)\n      Result.to_upper\n    ensure\n      as_upper_not_void: Result /= Void\n      definition: Result.same_string (name.as_upper)\n    end\n\n  to_string_8: STRING_8\n    obsolete\n      \"Use `name' instead (or `out' during the transition period).\"\n    do\n      create Result.make_from_string (name)\n    ensure\n      to_string_8_not_void: Result /= Void\n    end\n\n  to_string_32: STRING_32\n      -- Name of type\n    obsolete\n      \"[080717] Use 'name' instead (or 'out' during the transition period).\"\n    do\n      create Result.make_from_string_general (name)\n    ensure\n      to_string_32_not_void: Result /= Void\n    end\n\nfeature {NONE} -- Implementation: Access\n\n  internal_name: detachable IMMUTABLE_STRING_8\n      -- Storage for once per object `name'\n\nfeature {NONE} -- Implementation\n\n  runtime_name: STRING\n      -- Name of Eiffel type represented by `Current', using Eiffel style guidelines\n      -- as specified in OOSC2 (e.g. COMPARABLE, HASH_TABLE [FOO, BAR], ...)\n    external\n      \"built_in\"\n    ensure\n      name_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"unbounded.e","content":"note\n  description: \"Finite structures whose item count is not bounded\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: unbounded, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class UNBOUNDED [G] inherit\n\n  FINITE [G]\n\nfeature -- Status report\n\n  --extendible: BOOLEAN is true;\n    -- Can new items be added? (Answer: yes)\n\n-- invariant\n\n  -- extendible: extendible\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"utf_converter.e","content":"note\n  description: \"[\n      Converter from/to UTF-8, UTF-16 and UTF-32 encodings.\n\n      Handling of invalid encodings\n      =============================\n\n      Whenever a UTF-8 or UTF-16 sequence is decoded, the decoding routines also check\n      that the sequence is valid. If it is not, it will replace the invalid unit (e.g. a byte\n      for UTF-8 and a 2-byte for UTF-16 by the replacement character U+FFFD as described by\n      variant #3 of the recommended practice for replacement character in Unicode (see\n      http://www.unicode.org/review/pr-121.html for more details).\n\n      However it means that you cannot roundtrip incorrectly encoded sequence back and forth\n      between the encoded version and the decoded STRING_32 version. To allow roundtrip, an\n      escaped representation of a bad encoded sequence has been introduced. It is adding a\n      a fourth variant (which is a slight modification of variant #3) to the recommended\n      practice where the replacement character is followed by the printed hexadecimal value\n      of the invalid byte or the invalid 2-byte sequence.\n\n      To provide an example (assuming that the Unicode character U+FFFD is represented as\n      ? textually):\n      1 - on UNIX, any invalid UTF-8 byte sequence such as 0x8F 0x8F is encoded as the\n      following Unicode sequence: U+FFFD U+0038 U+0046 U+FFFF U+0038 U+0046, and textually\n      it looks like \"?8F?8F\".\n      2 - on Windows, any invalid UTF-16 2-byte sequence such as 0xD800 0x0054 is encoded as the\n      following Unicode sequence: U+FFFD U+0075 U+0044 U+0038 U+0030 U+0030 U+FFFD U+0035 U+0033,\n      and textually it looks like \"?uD800?54\". The rule is that if the 2-byte sequence does not fit\n      into 1 byte, it uses the letter `u' followed by the hexadecimal value of the 2-byte sequence,\n      otherwise it simply uses the 1-byte hexadecimal representation.\n    ]\"\n  date: \"$Date: 2014-04-29 14:26:38 -0700 (Tue, 29 Apr 2014) $\"\n  revision: \"$Revision: 94920 $\"\n\nexpanded class\n  UTF_CONVERTER\n\nfeature -- Access\n\n  escape_character: CHARACTER_32 = '%/0xFFFD/'\n      -- Unicode replacement character to escape invalid UTF-8 or UTF-16 encoding.\n      -- UTF-8 encoding: 0xEF 0xBF 0xBD\n      -- Binary UTF-8 encoding: 11101111 10111111 10111101\n      -- UTF-16 encoding: 0xFFFD\n\nfeature -- Status report\n\n  is_valid_utf_8_string_8 (s: READABLE_STRING_8): BOOLEAN\n      -- Is `s' a valid UTF-8 Unicode sequence?\n    local\n      c: NATURAL_32\n      i, nb: INTEGER\n    do\n      from\n        nb := s.count\n        Result := True\n      until\n        i >= nb or not Result\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 127 then\n            -- Form 0xxxxxxx.\n        elseif (c & 0xE0) = 0xC0 and i < nb then\n            -- Form 110xxxxx 10xxxxxx.\n          i := i + 1\n          Result := (s.code (i) & 0xC0) = 0x80\n        elseif (c & 0xF0) = 0xE0 and i + 1 < nb then\n          -- Form 1110xxxx 10xxxxxx 10xxxxxx.\n          i := i + 2\n          Result := (s.code (i - 1) & 0xC0) = 0x80 and\n            (s.code (i) & 0xC0) = 0x80\n        elseif (c & 0xF8) = 0xF0 and i + 2 < nb then\n          -- Form 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx.\n          i := i + 3\n          Result := (s.code (i - 2) & 0xC0) = 0x80 and\n            (s.code (i - 1) & 0xC0) = 0x80 and\n            (s.code (i) & 0xC0) = 0x80\n        else\n            -- Anything else is not a valid UTF-8 sequence that would yield a valid Unicode character.\n          Result := False\n        end\n      end\n    end\n\n  is_valid_utf_16le_string_8 (s: READABLE_STRING_8): BOOLEAN\n      -- Is `s' a valid UTF-16LE Unicode sequence?\n    local\n      c1, c2: NATURAL_32\n      i, nb: INTEGER\n    do\n      nb := s.count\n        -- If `nb' is not even, then clearly not a valid UTF-16 string.\n      if (nb \\\\ 2) = 0 then\n        from\n          Result := True\n        until\n          i >= nb or not Result\n        loop\n          i := i + 2\n          c1 := s.code (i - 1) | (s.code (i) |<< 8)\n          if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n          elseif c1 <= 0xDBFF then\n            i := i + 2\n            if i <= nb then\n              c2 := s.code (i - 1) | (s.code (i) |<< 8)\n              Result := 0xDC00 <= c2 and c2 <= 0xDFF\n            else\n                -- Surrogate pair is incomplete, clearly not a valid UTF-16 sequence.\n              Result := False\n            end\n          else\n              -- Invalid starting surrogate pair which should be between 0xD800 and 0xDBFF.\n            Result := False\n          end\n        end\n      end\n    end\n\n  is_valid_utf_16_subpointer (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): BOOLEAN\n      -- Is `p' a valid UTF-16 Unicode sequence between code unit `start_pos' and `end_pos'?\n      -- If `a_stop_at_null' we stop checking after finding a null character.\n    local\n      i, n: INTEGER\n      c1, c2: NATURAL_32\n    do\n      if p.count >= 2 and start_pos >= 0 and start_pos <= end_pos + 1 and end_pos < (p.count // 2) then\n        from\n          i := start_pos * 2\n          n := end_pos * 2\n          Result := True\n        until\n          i > n or not Result\n        loop\n          c1 := p.read_natural_16 (i)\n          if c1 = 0 and a_stop_at_null then\n              -- We hit our null terminating character, we can stop\n            i := n + 1\n          else\n            if c1 < 0xD800 or c1 >= 0xE000 then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n              i := i + 1\n            elseif c1 <= 0xDBFF then\n              i := i + 2\n              if i <= n then\n                c2 := p.read_natural_16 (i)\n                Result := 0xDC00 <= c2 and c2 <= 0xDFF\n              else\n                  -- Surrogate pair is incomplete, clearly not a valid UTF-16 sequence.\n                Result := False\n              end\n            else\n                -- Invalid starting surrogate pair which should be between 0xD800 and 0xDBFF.\n              Result := False\n            end\n          end\n        end\n      end\n    end\n\n  is_valid_utf_16 (s: SPECIAL [NATURAL_16]): BOOLEAN\n      -- Is `s' a valid UTF-16 Unicode sequence?\n    local\n      i, n: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n        i := 0\n        n := s.count\n        Result := True\n      until\n        i > n or not Result\n      loop\n        c1 := s.item (i)\n        if c1 = 0 then\n            -- We hit our null terminating character, we can stop\n          i := n + 1\n        else\n          if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n          elseif c1 <= 0xDBFF then\n            i := i + 1\n            if i <= n then\n              c2 := s.item (i)\n              Result := 0xDC00 <= c2 and c2 <= 0xDFF\n            else\n                -- Surrogate pair is incomplete, clearly not a valid UTF-16 sequence.\n              Result := False\n            end\n          else\n              -- Invalid starting surrogate pair which should be between 0xD800 and 0xDBFF.\n            Result := False\n          end\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  utf_8_bytes_count (s: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Number of bytes necessary to encode in UTF-8 `s.substring (start_pos, end_pos)'.\n      -- Note that this feature can be used for both escaped and non-escaped string.\n      -- In the case of escaped strings, the result will be possibly higher than really needed.\n      -- It does not include the terminating null character.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n    local\n      i: INTEGER\n      c: NATURAL_32\n    do\n      from\n        i := start_pos\n      until\n        i > end_pos\n      loop\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx.\n          Result := Result + 1\n        elseif c <= 0x7FF then\n            -- 110xxxxx 10xxxxxx\n          Result := Result + 2\n        elseif c <= 0xFFFF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          Result := Result + 3\n        else\n            -- c <= 1FFFFF - there are no higher code points\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          Result := Result + 4\n        end\n        i := i + 1\n      end\n    end\n\n  utf_16_characters_count_form_pointer (m: MANAGED_POINTER; start_pos, end_pos: INTEGER): INTEGER\n      -- Number of characters of the UTF-16 encoded `m' starting at `start_pos' in `m' up to `end_pos - 1'.\n      -- It does not include the terminating null character.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position: start_pos <= end_pos + 2\n      end_pos_small_enought: end_pos < m.count\n      even_start_position: start_pos \\\\ 2 = 0\n      even_end_position: end_pos \\\\ 2 = 0\n    local\n      i, n: INTEGER\n      c: NATURAL_32\n    do\n      from\n        i := start_pos\n        n := end_pos\n      until\n        i >= end_pos\n      loop\n        c := m.read_natural_16 (i)\n        if c < 0xD800 or c >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          i := i + 2\n        elseif i <= n then\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          i := i + 4\n        end\n        Result := Result + 1\n      end\n    end\n\n  utf_16_bytes_count (s: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Number of bytes necessary at the very least to encode in UTF-16 `s.substring (start_pos, end_pos)'.\n      -- Note that this feature can be used for both escaped and non-escaped string.\n      -- In the case of escaped strings, the result will be possibly higher than really needed.\n      -- It does not include the terminating null character.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n    local\n      i: INTEGER\n      c: NATURAL_32\n    do\n      from\n        i := start_pos\n      until\n        i > end_pos\n      loop\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Code point from Basic Multilingual Plane: one 16-bit code unit.\n          Result := Result + 2\n        else\n          Result := Result + 4\n        end\n        i := i + 1\n      end\n    end\n\n  utf_8_to_string_32_count (s: SPECIAL [CHARACTER]; start_pos, end_pos: INTEGER): INTEGER\n      -- Count of characters corresponding to UTF-8 sequence `s'.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < s.count\n    local\n      i: INTEGER\n      n: INTEGER\n      c: INTEGER\n    do\n      from\n        i := start_pos\n        n := end_pos\n      until\n        i > n\n      loop\n        c := s [i].code\n        if c <= 0x7F then\n            -- 0xxxxxxx\n          i := i + 1\n          Result := Result + 1\n        elseif c <= 0xDF then\n            -- 110xxxxx 10xxxxxx\n          i := i + 2\n          if i <= n then\n            Result := Result + 1\n          end\n        elseif c <= 0xEF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          i := i + 3\n          if i <= n then\n            Result := Result + 1\n          end\n        elseif c <= 0xF7 then\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          i := i + 4\n          if i <= n then\n            Result := Result + 1\n          end\n        end\n      end\n    end\n\nfeature -- UTF-32 to UTF-8\n\n  string_32_to_utf_8_string_8 (s: READABLE_STRING_32): STRING_8\n      -- UTF-8 sequence corresponding to `s'.\n    do\n      Result := utf_32_string_to_utf_8_string_8 (s)\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (Result).same_string (s)\n    end\n\n  string_32_into_utf_8_string_8 (s: READABLE_STRING_32; a_result: STRING_8)\n      -- Copy the UTF-8 sequence corresponding to `s' appended into `a_result'.\n    do\n      utf_32_string_into_utf_8_string_8 (s, a_result)\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\n  utf_32_string_to_utf_8_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence.\n    do\n      create Result.make (s.count)\n      utf_32_string_into_utf_8_string_8 (s, Result)\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (Result).same_string_general (s)\n    end\n\n  utf_32_string_into_utf_8_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy the UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence\n      -- appended into `a_result'.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c.to_character_8)\n        elseif c <= 0x7FF then\n            -- 110xxxxx 10xxxxxx\n          a_result.extend (((c |>> 6) | 0xC0).to_character_8)\n          a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n        elseif c <= 0xFFFF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          a_result.extend (((c |>> 12) | 0xE0).to_character_8)\n          a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n          a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n        else\n            -- c <= 1FFFFF - there are no higher code points\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          a_result.extend (((c |>> 18) | 0xF0).to_character_8)\n          a_result.extend ((((c |>> 12) & 0x3F) | 0x80).to_character_8)\n          a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n          a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\n  escaped_utf_32_substring_into_utf_8_0_pointer (\n        s: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER; p: MANAGED_POINTER;\n        p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER]\n    )\n      -- Write UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence that could\n      -- be escaped, with terminating zero to address `p + p_offset' and update the size of `p' to the\n      -- number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      p_offset_non_negative: p_offset >= 0\n    local\n      i, n, m, l_count: INTEGER\n      c: NATURAL_32\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded, l_resized: BOOLEAN\n    do\n        -- Basic assumptions that there will be only one-byte code units.\n      n := end_pos - start_pos + 1\n      l_count := p.count\n        -- Check that there is at least `n' bytes available plus the terminating null character.\n      if l_count - p_offset < (n + 1) then\n          -- Optimize resizing, once we have to resize, we actually perform the resizing\n          -- only once.\n        l_count := p_offset + utf_8_bytes_count (s, start_pos, end_pos) + 1\n        p.resize (l_count)\n        l_resized := True\n      end\n\n      from\n        m := p_offset\n        i := start_pos - 1\n      until\n        i >= end_pos\n      loop\n        i := i + 1\n        c := s.code (i)\n\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n            -- In the Unix case, we only accept the 1-byte encoded format.\n          if i < n and then s.item (i + 1) = escape_character then\n              -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n            i := i + 1\n          elseif i + 1 < n then\n              -- We have at least 2 characters to read, make sure they represent an hexadecimal\n              -- value.\n            l_encoded_value := s.substring (i + 1, i + 2)\n            if is_hexa_decimal (l_encoded_value) then\n              c := to_natural_32 (l_encoded_value)\n              if c <= 0x7F then\n                  -- Value was encoded when it should not have been\n                  -- do nothing, we leave the original content as is.\n                c := escape_character.natural_32_code\n              else\n                l_decoded := True\n                i := i + 2\n              end\n            else\n              -- Not an hexadecimal value, it was not escaped.\n            end\n          else\n            -- Not enough to read to make it valid, it was not escaped.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0x7F then\n              -- 0xxxxxxx\n            p.put_natural_8 (c.to_natural_8, m)\n            m := m + 1\n          else\n              -- Make sure there is sufficient room for all the remaining characters and\n              -- at least 5 bytes, i.e. 4 bytes for the maximum UTF-8 encoding,\n              -- and one byte for the terminating null character. Note that we do not\n              -- take into account `p_offset' because `m' already includes it.\n              -- Note that `end_pos - i' represents the number of remaining characters\n              -- to process in the current string.\n            if not l_resized and then (m + 5 + (end_pos - i) > l_count) then\n                -- Optimize resizing, once we have to resize, we actually perform the resizing\n                -- only once.\n              l_count := m + utf_8_bytes_count (s, i, end_pos) + 1\n              p.resize (l_count)\n              l_resized := True\n            end\n            if c <= 0x7FF then\n                -- 110xxxxx 10xxxxxx\n              p.put_natural_8 (((c |>> 6) | 0xC0).to_natural_8, m)\n              p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 1)\n              m := m + 2\n            elseif c <= 0xFFFF then\n                -- 1110xxxx 10xxxxxx 10xxxxxx\n              p.put_natural_8 (((c |>> 12) | 0xE0).to_natural_8, m)\n              p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 1)\n              p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 2)\n              m := m + 3\n            else\n                -- c <= 1FFFFF - there are no higher code points\n                -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n              p.put_natural_8 (((c |>> 18) | 0xF0).to_natural_8, m)\n              p.put_natural_8 ((((c |>> 12) & 0x3F) | 0x80).to_natural_8, m + 1)\n              p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 2)\n              p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 3)\n              m := m + 4\n            end\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          p.put_natural_8 (c.to_natural_8, m)\n          m := m + 1\n        end\n      end\n      if l_resized then\n          -- `p' was resized so we adjust it to accommodate up to the terminating null character.\n        p.resize (m + 1)\n      end\n      p.put_natural_8 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, a_new_upper.item - 1, False).same_string_general (s.substring (start_pos, end_pos))\n      roundtrip: (a_new_upper = Void and then not s.substring (start_pos, end_pos).has ('%U')) implies\n         utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, p.count, True).same_string_general (s.substring (start_pos, end_pos))\n    end\n\n  escaped_utf_32_string_to_utf_8_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence that could be escaped.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    do\n      create Result.make (s.count)\n      escaped_utf_32_string_into_utf_8_string_8 (s, Result)\n    ensure\n      roundtrip: utf_8_string_8_to_escaped_string_32 (Result).same_string_general (s)\n    end\n\n  escaped_utf_32_string_into_utf_8_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy the UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence that could\n      -- be escaped appended into `a_result'.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded: BOOLEAN\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n            -- In the Unix case, we only accept the 1-byte encoded format.\n          if i < n and then s.item (i + 1) = escape_character then\n              -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n            i := i + 1\n          elseif i + 1 < n then\n              -- We have at least 2 characters to read, make sure they represent an hexadecimal\n              -- value.\n            l_encoded_value := s.substring (i + 1, i + 2)\n            if is_hexa_decimal (l_encoded_value) then\n              c := to_natural_32 (l_encoded_value)\n              if c <= 0x7F then\n                  -- Value was encoded when it should not have been\n                  -- do nothing, we leave the original content as is.\n                c := escape_character.natural_32_code\n              else\n                l_decoded := True\n                i := i + 2\n              end\n            else\n              -- Not an hexadecimal value, it was not escaped.\n            end\n          else\n            -- Not enough to read to make it valid, it was not escaped.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0x7F then\n              -- 0xxxxxxx\n            a_result.extend (c.to_character_8)\n          elseif c <= 0x7FF then\n              -- 110xxxxx 10xxxxxx\n            a_result.extend (((c |>> 6) | 0xC0).to_character_8)\n            a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n          elseif c <= 0xFFFF then\n              -- 1110xxxx 10xxxxxx 10xxxxxx\n            a_result.extend (((c |>> 12) | 0xE0).to_character_8)\n            a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n            a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n          else\n              -- c <= 1FFFFF - there are no higher code points\n              -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            a_result.extend (((c |>> 18) | 0xF0).to_character_8)\n            a_result.extend ((((c |>> 12) & 0x3F) | 0x80).to_character_8)\n            a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n            a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          a_result.extend (c.to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_8_string_8_to_escaped_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\n  string_32_into_utf_8_0_pointer (s: READABLE_STRING_32; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-8 sequence corresponding to `s' with terminating zero\n      -- to address `p + p_offset' and update the size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      p_offset_non_negative: p_offset >= 0\n    do\n      utf_32_string_into_utf_8_0_pointer (s, p, p_offset, a_new_upper)\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, a_new_upper.item - 1, False).same_string (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies\n         utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, p.count, True).same_string_general (s)\n    end\n\n  utf_32_string_into_utf_8_0_pointer (s: READABLE_STRING_GENERAL; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence,\n      -- with terminating zero to address `p + p_offset' and update the size of `p' to the\n      -- number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      p_offset_non_negative: p_offset >= 0\n    local\n      m: INTEGER\n      i, n, l_count: INTEGER\n      c: NATURAL_32\n      l_resized: BOOLEAN\n    do\n        -- Basic assumptions that there will be only one-byte code units.\n      n := s.count\n      l_count := p.count\n        -- Check that there is at least `n' bytes available plus the terminating null character.\n      if l_count - p_offset < (n + 1) then\n          -- Optimize resizing, once we have to resize, we actually perform the resizing\n          -- only once.\n        l_count := p_offset + utf_8_bytes_count (s, 1, n) + 1\n        p.resize (l_count)\n        l_resized := True\n      end\n\n        -- Fill `p' with the converted data.\n      from\n        i := 0\n        m := p_offset\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx.\n          p.put_natural_8 (c.to_natural_8, m)\n          m := m + 1\n        else\n            -- Make sure there is sufficient room for all the remaining characters and\n            -- at least 5 bytes, i.e. 4 bytes for the maximum UTF-8 encoding,\n            -- and one byte for the terminating null character. Note that we do not\n            -- take into account `p_offset' because `m' already includes it.\n            -- Note that `n - i' represents the number of remaining characters\n            -- to process in the current string.\n          if not l_resized and then (m + 5 + (n - i) > l_count) then\n              -- Optimize resizing, once we have to resize, we actually perform the resizing\n              -- only once.\n            l_count := m + utf_8_bytes_count (s, i, n) + 1\n            p.resize (l_count)\n            l_resized := True\n          end\n\n          if c <= 0x7FF then\n              -- 110xxxxx 10xxxxxx.\n            p.put_natural_8 (((c |>> 6) | 0xC0).to_natural_8, m)\n            p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 1)\n            m := m + 2\n          elseif c <= 0xFFFF then\n              -- 1110xxxx 10xxxxxx 10xxxxxx\n            p.put_natural_8 (((c |>> 12) | 0xE0).to_natural_8, m)\n            p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 1)\n            p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 2)\n            m := m + 3\n          else\n              -- c <= 1FFFFF - there are no higher code points\n              -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            p.put_natural_8 (((c |>> 18) | 0xF0).to_natural_8, m)\n            p.put_natural_8 ((((c |>> 12) & 0x3F) | 0x80).to_natural_8, m + 1)\n            p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 2)\n            p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 3)\n            m := m + 4\n          end\n        end\n      end\n      if l_resized then\n          -- `p' was resized so we adjust it to accommodate up to the terminating null character.\n        p.resize (m + 1)\n      end\n      p.put_natural_8 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, a_new_upper.item - 1, False).same_string_general (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies\n         utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, p.count, True).same_string_general (s)\n    end\n\n  utf_32_string_to_utf_8 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_8]\n      -- UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence.\n      -- The sequence is not zero-terminated.\n    do\n      Result := utf_32_string_to_utf_8_0 (s)\n      Result := Result.aliased_resized_area_with_default (0, Result.count - 1)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_8_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = l_ref.code (l_spec.cursor_index) end\n    end\n\n  utf_32_string_to_utf_8_0 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_8]\n      -- UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence.\n      -- The sequence is zero-terminated.\n    local\n      m: INTEGER\n      i, n: like {STRING_32}.count\n      c: NATURAL_32\n    do\n      n := s.count\n\n        -- First compute how many bytes we need to convert `s' to UTF-8.\n      m := utf_8_bytes_count (s, 1, n)\n\n        -- Fill `Result' with the converted data.\n      from\n        create Result.make_filled (0, m + 1)\n        i := 0\n        m := 0\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx.\n          Result.put (c.to_natural_8, m)\n          m := m + 1\n        elseif c <= 0x7FF then\n            -- 110xxxxx 10xxxxxx.\n          Result.put (((c |>> 6) | 0xC0).to_natural_8, m)\n          Result.put (((c & 0x3F) | 0x80).to_natural_8, m + 1)\n          m := m + 2\n        elseif c <= 0xFFFF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          Result.put (((c |>> 12) | 0xE0).to_natural_8, m)\n          Result.put ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 1)\n          Result.put (((c & 0x3F) | 0x80).to_natural_8, m + 2)\n          m := m + 3\n        else\n            -- c <= 1FFFFF - there are no higher code points\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          Result.put (((c |>> 18) | 0xF0).to_natural_8, m)\n          Result.put ((((c |>> 12) & 0x3F) | 0x80).to_natural_8, m + 1)\n          Result.put ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 2)\n          Result.put (((c & 0x3F) | 0x80).to_natural_8, m + 3)\n          m := m + 4\n        end\n      end\n      Result.put (0, m)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_8_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = l_ref.code (l_spec.cursor_index) end\n    end\n\nfeature -- UTF-8 to UTF-32\n\n  utf_8_0_pointer_to_escaped_string_32 (p: MANAGED_POINTER): STRING_32\n      -- {STRING_32} object corresponding to UTF-8 sequence `p' which is zero-terminated,\n      -- where invalid UTF-8 sequences are escaped.\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_8_0_pointer_into_escaped_string_32 (p, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (Result) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_0_pointer_into_escaped_string_32 (p: MANAGED_POINTER; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-8 sequence `p' which is zero-terminated,\n      -- where invalid UTF-8 sequences are escaped, appended into `a_result'.\n    do\n      utf_8_0_subpointer_into_escaped_string_32 (p, 0, p.count - 1, True, a_result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_0_subpointer_to_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): STRING_32\n      -- {STRING_32} object corresponding to UTF-8 sequence `p' between indexes `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-8 sequences are escaped.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_8_0_subpointer_into_escaped_string_32 (p, start_pos, end_pos, a_stop_at_null, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (Result) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (start_pos + l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_0_subpointer_into_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-8 sequence `p' between indexes `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-8 sequences are escaped, appended into `a_result'.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count\n    local\n      i: like {STRING_8}.count\n      c1, c2, c3, c4: NATURAL_8\n      l_last_char: CHARACTER_32\n    do\n      from\n        a_result.grow (a_result.count + end_pos - start_pos + 1)\n        i := start_pos\n      until\n        i > end_pos\n      loop\n        c1 := p.read_natural_8 (i)\n        if c1 = 0 and a_stop_at_null then\n            -- We hit our null terminating character, we can stop\n          i := end_pos + 1\n        elseif c1 <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c1.to_character_32)\n          i := i + 1\n        elseif (c1 & 0xE0) = 0xC0 then\n          if i < end_pos then\n            c2 := p.read_natural_8 (i + 1)\n            if (c2 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 110xxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x1F) |<< 6) |\n                (c2.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 2\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n              i := i + 1\n            end\n          else\n              -- Invalid UTF-8 sequence, we escape the first byte.\n            escape_code_into (a_result, c1)\n            i := i + 1\n          end\n        elseif (c1 & 0xF0) = 0xE0 then\n          if i + 1 < end_pos then\n            c2 := p.read_natural_8 (i + 1)\n            c3 := p.read_natural_8 (i + 2)\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 1110xxxx 10xxxxxx 10xxxxxx\n              l_last_char := (((c1.as_natural_32 & 0xF) |<< 12) |\n                ((c2.as_natural_32 & 0x3F) |<< 6) |\n                (c3.as_natural_32 & 0x3F)\n                ).to_character_32\n              a_result.extend (l_last_char)\n              i := i + 3\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n              i := i + 1\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n            i := i + 1\n          end\n        elseif (c1 & 0xF8) = 0xF0 then\n          if i + 2 < end_pos then\n            c2 := p.read_natural_8 (i + 1)\n            c3 := p.read_natural_8 (i + 2)\n            c4 := p.read_natural_8 (i + 3)\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 and (c4 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x7) |<< 18) |\n                ((c2.as_natural_32 & 0x3F) |<< 12) |\n                ((c3.as_natural_32 & 0x3F) |<< 6) |\n                (c4.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 4\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n              i := i + 1\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n            i := i + 1\n          end\n\n        else\n            -- Clearly invalid UTF-8\n          escape_code_into (a_result, c1)\n          i := i + 1\n        end\n      end\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (start_pos + l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_string_8_to_string_32 (s: READABLE_STRING_8): STRING_32\n      -- STRING_32 corresponding to UTF-8 sequence `s'.\n    do\n      create Result.make (s.count)\n      utf_8_string_8_into_string_32 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_32_string_to_utf_8_string_8 (Result).same_string (s)\n    end\n\n  utf_8_string_8_into_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy STRING_32 corresponding to UTF-8 sequence `s' appended into `a_result'.\n    local\n      i: like {STRING_8}.count\n      n: like {STRING_8}.count\n      c: NATURAL_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c.to_character_32)\n        elseif c <= 0xDF then\n            -- 110xxxxx 10xxxxxx\n          i := i + 1\n          if i <= n then\n            a_result.extend ((\n              ((c & 0x1F) |<< 6) |\n              (s.code (i) & 0x3F)\n            ).to_character_32)\n          end\n        elseif c <= 0xEF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          i := i + 2\n          if i <= n then\n            a_result.extend ((\n              ((c & 0xF) |<< 12) |\n              ((s.code (i - 1) & 0x3F) |<< 6) |\n              (s.code (i) & 0x3F)\n            ).to_character_32)\n          end\n        elseif c <= 0xF7 then\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          i := i + 3\n          if i <= n then\n            a_result.extend ((\n              ((c & 0x7) |<< 18) |\n              ((s.code (i - 2) & 0x3F) |<< 12) |\n              ((s.code (i - 1) & 0x3F) |<< 6) |\n              (s.code (i) & 0x3F)\n            ).to_character_32)\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\n  utf_8_string_8_to_escaped_string_32 (s: READABLE_STRING_8): STRING_32\n      -- STRING_32 corresponding to UTF-8 sequence `s', where invalid UTF-8 sequences are escaped.\n    do\n      create Result.make (s.count)\n      utf_8_string_8_into_escaped_string_32 (s, Result)\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_8_string_8 (Result).same_string (s)\n    end\n\n  utf_8_string_8_into_escaped_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy STRING_32 corresponding to UTF-8 sequence `s', where invalid UTF-8 sequences are escaped,\n      -- appended into `a_result'.\n    local\n      i: like {STRING_8}.count\n      n: like {STRING_8}.count\n      c1, c2, c3, c4: NATURAL_8\n      l_last_char: CHARACTER_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c1 := s.code (i).as_natural_8\n        if c1 <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c1.to_character_32)\n        elseif (c1 & 0xE0) = 0xC0 then\n          if i < n then\n            c2 := s.code (i + 1).as_natural_8\n            if (c2 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 110xxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x1F) |<< 6) |\n                (c2.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 1\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n            end\n          else\n              -- Invalid UTF-8 sequence, we escape the first byte.\n            escape_code_into (a_result, c1)\n          end\n        elseif (c1 & 0xF0) = 0xE0 then\n          if i + 1 < n then\n            c2 := s.code (i + 1).as_natural_8\n            c3 := s.code (i + 2).as_natural_8\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 1110xxxx 10xxxxxx 10xxxxxx\n              l_last_char := (((c1.as_natural_32 & 0xF) |<< 12) |\n                ((c2.as_natural_32 & 0x3F) |<< 6) |\n                (c3.as_natural_32 & 0x3F)\n                ).to_character_32\n              a_result.extend (l_last_char)\n              i := i + 2\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n          end\n        elseif (c1 & 0xF8) = 0xF0 then\n          if i + 2 < n then\n            c2 := s.code (i + 1).as_natural_8\n            c3 := s.code (i + 2).as_natural_8\n            c4 := s.code (i + 3).as_natural_8\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 and (c4 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x7) |<< 18) |\n                ((c2.as_natural_32 & 0x3F) |<< 12) |\n                ((c3.as_natural_32 & 0x3F) |<< 6) |\n                (c4.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 3\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n          end\n\n        else\n            -- Clearly invalid UTF-8\n          escape_code_into (a_result, c1)\n        end\n      end\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\nfeature -- UTF-32 to UTF-16\n\n  string_32_to_utf_16 (s: READABLE_STRING_32): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s'.\n      -- The sequence is not zero-terminated.\n    do\n      Result := utf_32_string_to_utf_16 (s)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 16)) end\n    end\n\n  utf_32_string_to_utf_16 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s' interpreted as a UTF-32 sequence.\n      -- The sequence is not zero-terminated.\n    do\n      Result := utf_32_string_to_utf_16_0 (s)\n      Result := Result.aliased_resized_area_with_default (0, Result.count - 1)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 8)) end\n    end\n\n  string_32_to_utf_16_0 (s: READABLE_STRING_32): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s' with terminating zero.\n    do\n      Result := utf_32_string_to_utf_16_0 (s)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result.resized_area_with_default (0, Result.count - 1) as l_spec all\n          l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 8))\n        end\n    end\n\n  utf_32_string_to_utf_16_0 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s', interpreted as a UTF-32 sequence,\n      -- with terminating zero.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      m: like {STRING_32}.count\n      p: like {STRING_32}.count\n      c: NATURAL_32\n    do\n      from\n        m := 0\n        n := s.count\n        p := n\n        create Result.make_empty (p + 1)\n      invariant\n        m = Result.count\n        p + 1 = Result.capacity\n      until\n        i >= n\n      loop\n        i := i + 1\n          -- Make sure there is sufficient room for at least 2 code units.\n        if p < m + 2 then\n          p := m + (n - i) + 2\n          Result := Result.aliased_resized_area (p + 1)\n        end\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          Result.extend (c.to_natural_16)\n          m := m + 1\n        else\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          Result.extend ((0xD7C0 + (c |>> 10)).to_natural_16)\n          Result.extend ((0xDC00 + (c & 0x3FF)).to_natural_16)\n          m := m + 2\n        end\n      end\n      Result.extend (0)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result.resized_area_with_default (0, Result.count - 1) as l_spec all\n          l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 8))\n        end\n    end\n\n  string_32_into_utf_16_pointer (s: READABLE_STRING_32; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to `s' to address `p + p_offset'\n      -- and update the size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is not zero-terminated.\n    require\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    do\n      utf_32_substring_into_utf_16_pointer (s, 1, s.count, p, p_offset, a_new_upper)\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string (s)\n    end\n\n  string_32_into_utf_16_0_pointer (s: READABLE_STRING_32; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to `s' with terminating zero\n      -- to address `p + p_offset' and update the size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    do\n      utf_32_substring_into_utf_16_0_pointer (s, 1, s.count, p, p_offset, a_new_upper)\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string (s)\n    end\n\n  utf_32_substring_into_utf_16_pointer\n      (s: READABLE_STRING_GENERAL;\n      start_pos, end_pos: like {READABLE_STRING_32}.count;\n      p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to the substring of `s',\n      -- interpreted as a UTF-32 sequence, starting at index `start_pos'\n      -- and ending at index `end_pos' to address `p + p_offset' and update the\n      -- size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is not zero-terminated.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    local\n      m: INTEGER\n    do\n      m := p.count\n      utf_32_substring_into_utf_16_0_pointer (s, start_pos, end_pos, p, p_offset, a_new_upper)\n      if m < p.count then\n          -- Remove the null terminating character.\n        p.resize (p.count - 2)\n        if a_new_upper /= Void then\n          a_new_upper.put (p.count - 2)\n        end\n      end\n    ensure\n      p_count_may_increase: p.count >= old p.count\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string_general (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string_general (s)\n    end\n\n  utf_32_substring_into_utf_16_0_pointer\n      (s: READABLE_STRING_GENERAL;\n      start_pos, end_pos: like {READABLE_STRING_32}.count;\n      p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to the substring of `s',\n      -- interpreted as a UTF-32 sequence, starting at index `start_pos'\n      -- and ending at index `end_pos' to address `p + p_offset' and update the\n      -- size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    local\n      i: like {READABLE_STRING_GENERAL}.count\n      c: NATURAL_32\n      m, l_count: like {MANAGED_POINTER}.count\n      l_resized: BOOLEAN\n    do\n        -- Write UTF-16 sequence.\n      from\n        i := end_pos - start_pos + 1\n        l_count := p.count\n          -- Check that there is at least `i * 2' bytes available plus the terminating null character.\n        if l_count - p_offset < (i + 1) * 2  then\n            -- Optimize resizing, once we have to resize, we actually perform the resizing\n            -- only once.\n          l_count := p_offset + utf_16_bytes_count (s, start_pos, end_pos) + 2\n          p.resize (l_count)\n          l_resized := True\n        end\n        i := start_pos - 1\n        m := p_offset\n      until\n        i >= end_pos\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          p.put_natural_16 (c.to_natural_16, m)\n          m := m + 2\n        else\n            -- Make sure there is sufficient room for all the remaining characters and\n            -- at least 3 code units of 2 bytes each, i.e. 2 code unit for the surrogate\n            -- pair, and one unit for the terminating null character. Note that we do not\n            -- take into account `p_offset' because `m' already includes it.\n            -- Note that `end_pos - i' represents the number of remaining characters\n            -- to process in the current string.\n          if not l_resized and then (m + 6 + (end_pos - i) * 2 > l_count) then\n              -- Optimize resizing, once we have to resize, we actually perform the resizing\n              -- only once.\n            l_count := m + utf_16_bytes_count (s, i, end_pos) + 2\n            p.resize (l_count)\n            l_resized := True\n          end\n\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          p.put_natural_16 ((0xD7C0 + (c |>> 10)).to_natural_16, m)\n          p.put_natural_16 ((0xDC00 + (c & 0x3FF)).to_natural_16, m + 2)\n          m := m + 4\n        end\n      end\n        -- Adjust number of written bytes and add terminating zero at the end.\n      if l_resized then\n          -- We had to add a code unit on 4 bytes. We adjust the size.\n        p.resize (m + 2)\n      end\n      p.put_natural_16 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      p_count_may_increase: p.count >= old p.count\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string_general (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string_general (s)\n    end\n\n  utf_32_string_to_utf_16le_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence\n    do\n        -- We would need at least 2-bytes per characters in `s'.\n      create Result.make (s.count * 2)\n      utf_32_string_into_utf_16le_string_8 (s, Result)\n    ensure\n      roundtrip: utf_16le_string_8_to_string_32 (Result).same_string_general (s)\n    end\n\n  utf_32_string_into_utf_16le_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence\n      -- appended into `a_result'.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n      l_nat16: NATURAL_16\n    do\n      from\n        n := s.count\n          -- We would need at least 2-bytes per characters in `s'.\n        a_result.grow (a_result.count + n * 2)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          a_result.extend ((c & 0x00FF).to_character_8)\n          a_result.extend (((c & 0xFF00) |>> 8).to_character_8)\n        else\n            -- Write the lead surrogate pair.\n          l_nat16 := (0xD7C0 + (c |>> 10)).to_natural_16\n          a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n          a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n\n            -- Write the trail surrogate pair.\n          l_nat16 := (0xDC00 + (c & 0x3FF)).to_natural_16\n          a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n          a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_16le_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\n  escaped_utf_32_substring_into_utf_16_0_pointer (\n        s: READABLE_STRING_GENERAL; start_pos, end_pos: like {READABLE_STRING_32}.count;\n        p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER]\n      )\n      -- Write UTF-16 sequence corresponding to the substring of `s',\n      -- interpreted as a UTF-32 sequence, starting at index `start_pos'\n      -- and ending at index `end_pos' to address `p + p_offset' and update the\n      -- size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is not zero-terminated.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    local\n      i, n, m, l_count: INTEGER\n      c: NATURAL_32\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded: BOOLEAN\n      l_resized: BOOLEAN\n    do\n      from\n        n := end_pos - start_pos + 1\n        l_count := p.count\n          -- Check that there is at least `i * 2' bytes available plus the terminating null character.\n        if l_count - p_offset < (n + 1) * 2  then\n            -- Optimize resizing, once we have to resize, we actually perform the resizing\n            -- only once.\n          l_count := p_offset + utf_16_bytes_count (s, start_pos, end_pos) + 2\n          p.resize (l_count)\n          l_resized := True\n        end\n        i := start_pos - 1\n        m := p_offset\n      until\n        i >= end_pos\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n          if i < n then\n            if s.item (i + 1) = escape_character then\n                -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n              i := i + 1\n            elseif s.item (i + 1) = 'u' then\n              if i + 4 < n then\n                l_encoded_value := s.substring (i + 2, i + 5)\n                if is_hexa_decimal (l_encoded_value) then\n                  c := to_natural_32 (l_encoded_value)\n                  if c < 0xD800 or c > 0xDFFF then\n                      -- Value was encoded when it should not have been\n                      -- do nothing, we leave the original content as is.\n                    c := escape_character.natural_32_code\n                  else\n                    l_decoded := True\n                    i := i + 5\n                  end\n                else\n                    -- Not an hexadecimal value, it was not escaped.\n                end\n              else\n                -- Not enough characters to make a 2-byte value, it was not escaped.\n              end\n            else\n              -- Value was most likely not encoded, because if it did, it would be the\n              -- hexadecimal representation of a byte which clearly did not need to\n              -- be escaped\n            end\n          else\n              -- Nothing more to read, clearly it was not encoded.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0xFFFF then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            p.put_natural_16 (c.to_natural_16, m)\n            m := m + 2\n          else\n              -- Make sure there is sufficient room for all the remaining characters and\n              -- at least 3 code units of 2 bytes each, i.e. 2 code unit for the surrogate\n              -- pair, and one unit for the terminating null character. Note that we do not\n              -- take into account `p_offset' because `m' already includes it.\n              -- Note that `end_pos - i' represents the number of remaining characters\n              -- to process in the current string.\n            if not l_resized and then (m + 6 + (end_pos - i) * 2 > l_count) then\n                -- Optimize resizing, once we have to resize, we actually perform the resizing\n                -- only once.\n              l_count := m + utf_16_bytes_count (s, i, end_pos) + 2\n              p.resize (l_count)\n              l_resized := True\n            end\n\n              -- Write the lead surrogate pair.\n            p.put_natural_16 ((0xD7C0 + (c |>> 10)).to_natural_16, m)\n\n              -- Write the trail surrogate pair.\n            p.put_natural_16 ((0xDC00 + (c & 0x3FF)).to_natural_16, m + 2)\n\n            m := m + 4\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          p.put_natural_16 (c.to_natural_16, m)\n          m := m + 2\n        end\n      end\n      if l_resized then\n          -- We had to add a code unit on 4 bytes. We adjust the size.\n        p.resize (m + 2)\n      end\n      p.put_natural_16 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      p_count_may_increase: p.count >= old p.count\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_escaped_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string_general (s.substring (start_pos, end_pos))\n      roundtrip: (a_new_upper = Void and then not s.substring (start_pos, end_pos).has ('%U')) implies\n        utf_16_0_subpointer_to_escaped_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string_general (s.substring (start_pos, end_pos))\n    end\n\n  escaped_utf_32_string_to_utf_16le_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence that could be escaped.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    do\n        -- We would need at least 2-bytes per characters in `s'.\n      create Result.make (s.count * 2)\n      escaped_utf_32_string_into_utf_16le_string_8 (s, Result)\n    ensure\n      roundtrip: utf_16le_string_8_to_escaped_string_32 (Result).same_string_general (s)\n    end\n\n  escaped_utf_32_string_into_utf_16le_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence that could be\n      -- escaped appended into `a_result'.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n      l_nat16: NATURAL_16\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded: BOOLEAN\n    do\n      from\n        n := s.count\n          -- We would need at least 2-bytes per characters in `s'.\n        a_result.grow (a_result.count + n * 2)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n          if i < n then\n            if s.item (i + 1) = escape_character then\n                -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n              i := i + 1\n            elseif s.item (i + 1) = 'u' then\n              if i + 4 < n then\n                l_encoded_value := s.substring (i + 2, i + 5)\n                if is_hexa_decimal (l_encoded_value) then\n                  c := to_natural_32 (l_encoded_value)\n                  if c < 0xD800 or c > 0xDFFF then\n                      -- Value was encoded when it should not have been\n                      -- do nothing, we leave the original content as is.\n                    c := escape_character.natural_32_code\n                  else\n                    l_decoded := True\n                    i := i + 5\n                  end\n                else\n                    -- Not an hexadecimal value, it was not escaped.\n                end\n              else\n                  -- Not enough characters to make a 2-byte value, it was not escaped.\n              end\n            else\n              -- Value was most likely not encoded, because if it did, it would be the\n              -- hexadecimal representation of a byte which clearly did not need to\n              -- be escaped\n            end\n          else\n              -- Nothing more to read, clearly it was not encoded.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0xFFFF then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            a_result.extend ((c & 0x00FF).to_character_8)\n            a_result.extend (((c & 0xFF00) |>> 8).to_character_8)\n          else\n              -- Write the lead surrogate pair.\n            l_nat16 := (0xD7C0 + (c |>> 10)).to_natural_16\n            a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n            a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n\n                -- Write the trail surrogate pair.\n            l_nat16 := (0xDC00 + (c & 0x3FF)).to_natural_16\n            a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n            a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          a_result.extend ((c & 0x00FF).to_character_8)\n          a_result.extend (((c & 0xFF00) |>> 8).to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_16le_string_8_to_escaped_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\nfeature -- UTF-16 to UTF-32\n\n  utf_16_0_pointer_to_string_32 (p: MANAGED_POINTER): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_16_0_pointer_into_string_32 (p, Result)\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, 0, p.count // 2, True) implies\n        across string_32_to_utf_16 (Result) as l_spec all l_spec.item = p.read_natural_16 (l_spec.cursor_index * 2) end\n    end\n\n  utf_16_0_pointer_into_string_32 (p: MANAGED_POINTER; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated\n      -- appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n      utf_16_0_subpointer_into_string_32 (p, 0, p.count // 2 - 1, True, a_result)\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, 0, p.count // 2, True) implies\n        across string_32_to_utf_16 (a_result.substring (old a_result.count + 1, a_result.count)) as l_spec all l_spec.item = p.read_natural_16 (l_spec.target_index * 2) end\n    end\n\n  utf_16_0_subpointer_to_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null'.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    do\n      create Result.make (p.count)\n      utf_16_0_subpointer_into_string_32 (p, start_pos, end_pos, a_stop_at_null, Result)\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, start_pos, end_pos, a_stop_at_null) implies\n        across string_32_to_utf_16 (Result) as l_spec all l_spec.item = p.read_natural_16 (l_spec.target_index * 2) end\n    end\n\n  utf_16_0_subpointer_into_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null' appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    local\n      i, n: INTEGER\n      c: NATURAL_32\n    do\n      from\n          -- Allocate Result with the same number of bytes as copied from `p'.\n        a_result.grow (a_result.count + end_pos - start_pos + 1)\n        i := start_pos * 2\n        n := end_pos * 2\n      until\n        i > n\n      loop\n        c := p.read_natural_16 (i)\n        if c = 0 and a_stop_at_null then\n            -- We hit our null terminating character, we can stop\n          i := n + 1\n        else\n          i := i + 2\n          if c < 0xD800 or c >= 0xE000 then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            a_result.extend (c.to_character_32)\n          else\n              -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n            if i <= n then\n              a_result.extend (((c.as_natural_32 |<< 10) + p.read_natural_16 (i) - 0x35FDC00).to_character_32)\n              i := i + 2\n            end\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, start_pos, end_pos, a_stop_at_null) implies\n        across string_32_to_utf_16 (a_result.substring (old a_result.count + 1, a_result.count)) as l_spec all l_spec.item = p.read_natural_16 (l_spec.target_index * 2) end\n    end\n\n  utf_16_0_pointer_to_escaped_string_32 (p: MANAGED_POINTER): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated,\n      -- where invalid UTF-16LE sequences are escaped.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_16_0_pointer_into_escaped_string_32 (p, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (Result) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_0_pointer_into_escaped_string_32 (p: MANAGED_POINTER; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated,\n      -- where invalid UTF-16LE sequences are escaped, appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n      utf_16_0_subpointer_into_escaped_string_32 (p, 0, p.count // 2 - 1, True, a_result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_0_subpointer_to_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-16LE sequences are escaped.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    do\n      create Result.make (end_pos - start_pos + 1)\n      utf_16_0_subpointer_into_escaped_string_32 (p, start_pos, end_pos, a_stop_at_null, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (Result) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (start_pos * 2 + l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_0_subpointer_into_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-16LE sequences are escaped, appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    local\n      i, n: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n          -- Allocate Result with the same number of bytes as copied from `p'.\n        a_result.grow (a_result.count + end_pos - start_pos + 1)\n        i := start_pos * 2\n        n := end_pos * 2\n      until\n        i > n\n      loop\n        c1 := p.read_natural_16 (i)\n        if c1 = 0 and a_stop_at_null then\n            -- We hit our null terminating character, we can stop\n          i := n + 1\n        else\n          i := i + 2\n          if c1 < 0xD800 or c1 >= 0xE000 then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            a_result.extend (c1.to_character_32)\n          elseif c1 <= 0xDBFF and then i <= n then\n              -- Check if a lead surrogate (value between 0xD800 and 0xDBFF) is followed by a trail surrogate.\n            c2 := p.read_natural_16 (i)\n            if c2 >= 0xDC00 and c2 <= 0xDFFF then\n                -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n              a_result.extend (((c1 |<< 10) + c2 - 0x35FDC00).to_character_32)\n              i := i + 2\n            else\n                -- Escape a lead surrogate not followed by a trail one.\n              escape_code_into (a_result, c1.as_natural_16)\n            end\n          else\n              -- Escape a trail surrogate not following a lead one or\n              -- a lead surrogate not followed by a trail one.\n            escape_code_into (a_result, c1.as_natural_16)\n          end\n        end\n      end\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (start_pos * 2 + l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_to_string_32 (s: SPECIAL [NATURAL_16]): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `s'.\n    do\n      create Result.make (s.count)\n      utf_16_into_string_32 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (Result).is_equal (s)\n    end\n\n  utf_16_into_string_32 (s: SPECIAL [NATURAL_16]; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `s'\n      -- appended into `a_result'.\n    local\n      i: like {SPECIAL [NATURAL_16]}.count\n      n: like {SPECIAL [NATURAL_16]}.count\n      c: NATURAL_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        c := s [i]\n        i := i + 1\n        if c < 0xD800 or c >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          a_result.extend (c.to_character_32)\n        else\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          if i < n then\n            a_result.extend (((c |<< 10) + s [i] - 0x35FDC00).to_character_32)\n            i := i + 1\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (a_result.substring (old a_result.count + 1, a_result.count)).is_equal (s)\n    end\n\n  utf_16le_string_8_to_string_32 (s: READABLE_STRING_8): STRING_32\n      -- {STRING_32} object corresponding to UTF-16LE sequence `s'.\n    do\n        -- There is at least half the characters of `s'.\n      create Result.make (s.count |>> 1)\n      utf_16le_string_8_into_string_32 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies escaped_utf_32_string_to_utf_16le_string_8 (Result).same_string (s)\n    end\n\n  utf_16le_string_8_into_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16LE sequence `s' appended into `a_result'.\n    local\n      i, nb: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n        nb := s.count\n          -- There is at least half the characters of `s'.\n        a_result.grow (a_result.count + (nb |>> 1))\n      until\n        i + 1 >= nb\n      loop\n        i := i + 2\n          -- Extract the first 2-bytes\n        c1 := s.code (i - 1) | (s.code (i) |<< 8)\n        if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n          a_result.extend (c1.to_character_32)\n        else\n          i := i + 2\n          if i <= nb then\n            c2 := s.code (i - 1) | (s.code (i) |<< 8)\n            a_result.extend (((c1 |<< 10) + c2 - 0x35FDC00).to_character_32)\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\n  utf_16le_string_8_to_escaped_string_32 (s: READABLE_STRING_8): STRING_32\n      -- {STRING_32} object corresponding to UTF-16LE sequence `s', where invalid UTF-16LE\n      -- sequences are escaped.\n    do\n        -- There is at least half the characters of `s'.\n      create Result.make (s.count |>> 1)\n      utf_16le_string_8_into_escaped_string_32 (s, Result)\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_16le_string_8 (Result).same_string (s)\n    end\n\n  utf_16le_string_8_into_escaped_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16LE sequence `s', where invalid UTF-16LE\n      -- sequences are escaped, appended into `a_result'.\n    local\n      i, nb: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n        nb := s.count\n          -- There is at least half the characters of `s'.\n        a_result.grow (a_result.count + (nb |>> 1))\n      until\n        i + 1 >= nb\n      loop\n        i := i + 2\n          -- Extract the first 2-bytes\n        c1 := s.code (i - 1) | (s.code (i) |<< 8)\n        if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          a_result.extend (c1.to_character_32)\n        elseif c1 <= 0xDBFF and i + 2 <= nb then\n            -- Check if a lead surrogate is followed by a trail surrogate.\n          c2 := s.code (i + 1) | (s.code (i + 2) |<< 8)\n          if c2 >= 0xDC00 and c2 <= 0xDFFF then\n              -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n            a_result.extend (((c1 |<< 10) + c2 - 0x35FDC00).to_character_32)\n            i := i + 2\n          else\n              -- Escape a lead surrogate not followed by a trail one.\n            escape_code_into (a_result, c1.as_natural_16)\n          end\n        else\n            -- Escape a trail surrogate not following a lead one or\n            -- a lead surrogate not followed by a trail one.\n          escape_code_into (a_result, c1.as_natural_16)\n        end\n      end\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\nfeature -- UTF-16 to UTF-8\n\n  utf_16_to_utf_8_string_8 (s: SPECIAL [NATURAL_16]): STRING_8\n      -- UTF-8 sequence corresponding to UTF-16 sequence `s'.\n    do\n      debug (\"to_implement\")\n        (create {REFACTORING_HELPER}).to_implement (\"Convert directly from UTF-16 to UTF-8.\")\n      end\n      Result := string_32_to_utf_8_string_8 (utf_16_to_string_32 (s))\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (utf_8_string_8_to_string_32 (Result)).is_equal (s)\n    end\n\n  utf_16_into_utf_8_string_8 (s: SPECIAL [NATURAL_16]; a_result: STRING_8)\n      -- Copy UTF-8 sequence corresponding to UTF-16 sequence `s' appended into `a_result'.\n    do\n      debug (\"to_implement\")\n        (create {REFACTORING_HELPER}).to_implement (\"Convert directly from UTF-16 to UTF-8.\")\n      end\n      string_32_into_utf_8_string_8 (utf_16_to_string_32 (s), a_result)\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count))).is_equal (s)\n    end\n\n  utf_16le_string_8_to_utf_8_string_8 (s: READABLE_STRING_8): STRING_8\n      -- UTF-8 sequence corresponding to UTF-16LE sequence `s'.\n    do\n      create Result.make (s.count)\n      utf_16le_string_8_into_utf_8_string_8 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies utf_32_string_to_utf_16le_string_8 (utf_8_string_8_to_string_32 (Result)).same_string (s)\n    end\n\n  utf_16le_string_8_into_utf_8_string_8 (s: READABLE_STRING_8; a_result: STRING_8)\n      -- Copy UTF-8 sequence corresponding to UTF-16LE sequence `s' appended into `a_result'.\n    require\n      even_count: (s.count & 1) = 0\n    local\n      v: SPECIAL [NATURAL_16]\n      i: like {STRING_8}.count\n      n: like {STRING_8}.count\n    do\n      from\n        n := s.count\n        create v.make_empty (n |>> 1)\n      until\n        i >= n\n      loop\n        i := i + 2\n        check\n          valid_index: 1 <= i - 1 and i <= s.count\n        end\n        v.extend (s [i - 1].code.as_natural_16 | (s [i].code.as_natural_16 |<< 8))\n      end\n      utf_16_into_utf_8_string_8 (v, a_result)\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies utf_32_string_to_utf_16le_string_8 (utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count))).same_string (s)\n    end\n\nfeature -- UTF-8 to UTF-16\n\n  utf_8_string_8_to_utf_16 (s: READABLE_STRING_8): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to UTF-8 sequence `s'.\n    do\n      debug (\"to_implement\")\n        (create {REFACTORING_HELPER}).to_implement (\"Convert directly from UTF-8 to UTF-16.\")\n      end\n      Result := string_32_to_utf_16 (utf_8_string_8_to_string_32 (s))\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_16_to_utf_8_string_8 (Result).same_string (s)\n    end\n\n  utf_8_string_8_to_utf_16_0 (s: READABLE_STRING_8): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to UTF-8 sequence `s' with terminating zero.\n    do\n      Result := utf_8_string_8_to_utf_16 (s)\n      Result := Result.aliased_resized_area_with_default (0, Result.count + 1)\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_16_to_utf_8_string_8 (Result).same_string (s)\n    end\n\nfeature -- Byte Order Mark (BOM)\n\n  utf_8_bom_to_string_8: STRING_8 = \"%/239/%/187/%/191/\"\n      -- UTF-8 BOM sequence.\n\n  utf_16be_bom_to_string_8: STRING_8 = \"%/254/%/255/\"\n      -- UTF-16BE BOM sequence.\n\n  utf_16le_bom_to_string_8: STRING_8 = \"%/255/%/254/\"\n      -- UTF-16LE BOM sequence.\n\n  utf_32be_bom_to_string_8: STRING_8 = \"%U%U%/254/%/255/\"\n      -- UTF-32BE BOM sequence.\n\n  utf_32le_bom_to_string_8: STRING_8 = \"%/255/%/254/%U%U\"\n      -- UTF-32LE BOM sequence.\n\nfeature {NONE} -- Implementation\n\n  escape_code_into (a_string: STRING_32; a_code: NATURAL_16)\n      -- Escape `a_code' as documented in the note clause of the class into `a_string'.\n      -- If `a_code' fits into a NATURAL_8, it will be just the `escape_character' followed\n      -- by the 2-digit hexadecimal representation, otherwise `escape_character' followed\n      -- by the letter `u' followed by the 4-digit hexadecimal representation.\n    do\n      a_string.append_character (escape_character)\n      if a_code <= {NATURAL_8}.max_value then\n        a_string.append_string_general (a_code.as_natural_8.to_hex_string)\n      else\n        a_string.append_character ('u')\n        a_string.append_string_general (a_code.to_hex_string)\n      end\n    end\n\n  is_hexa_decimal (a_string: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `a_string' a valid hexadecimal sequence?\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.reset ({NUMERIC_INFORMATION}.type_natural_32)\n      l_convertor.parse_string_with_type (a_string, {NUMERIC_INFORMATION}.type_natural_32)\n      Result := l_convertor.is_integral_integer\n    end\n\n  to_natural_32 (a_hex_string: READABLE_STRING_GENERAL): NATURAL_32\n      -- Convert hexadecimal value `a_hex_string' to its corresponding NATURAL_32 value.\n    require\n      is_hexa: is_hexa_decimal (a_hex_string)\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (a_hex_string, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_32\n    end\n\n  ctoi_convertor: HEXADECIMAL_STRING_TO_INTEGER_CONVERTER\n      -- Convertor used to convert string to integer or natural\n    once\n      create Result.make\n      Result.set_leading_separators_acceptable (False)\n      Result.set_trailing_separators_acceptable (False)\n    ensure\n      ctoi_convertor_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license: \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkNfU1RSSU5HLmUiLCJhYnN0cmFjdF9zcGVjaWFsLmUiLCJhY3RpdmUuZSIsImFueS5lIiwiYXJyYXkuZSIsImFycmF5ZWRfbGlzdC5lIiwiYmFnLmUiLCJiaWxpbmVhci5lIiwiYm9vbGVhbi5lIiwiYm9vbGVhbl9yZWYuZSIsImJvdW5kZWQuZSIsImJveC5lIiwiY2VsbC5lIiwiY2hhaW4uZSIsImNoYXJhY3Rlcl8zMi5lIiwiY2hhcmFjdGVyXzMyX3JlZi5lIiwiY2hhcmFjdGVyXzguZSIsImNoYXJhY3Rlcl84X3JlZi5lIiwiY29sbGVjdGlvbi5lIiwiY29tcGFyYWJsZS5lIiwiY29udGFpbmVyLmUiLCJjdXJzb3IuZSIsImN1cnNvcl9zdHJ1Y3R1cmUuZSIsImRlYnVnX291dHB1dC5lIiwiZGV2ZWxvcGVyX2V4Y2VwdGlvbi5lIiwiZGlzcG9zYWJsZS5lIiwiZHluYW1pY19jaGFpbi5lIiwiZHluYW1pY19saXN0LmUiLCJleGNlcF9jb25zdC5lIiwiZXhjZXB0aW9uLmUiLCJleGNlcHRpb25fbWFuYWdlci5lIiwiZXhjZXB0aW9uX21hbmFnZXJfZmFjdG9yeS5lIiwiZXhjZXB0aW9ucy5lIiwiZmluaXRlLmUiLCJmdW5jdGlvbi5lIiwiaGFzaF90YWJsZS5lIiwiaGFzaGFibGUuZSIsImltbXV0YWJsZV9zdHJpbmdfOC5lIiwiaW1tdXRhYmxlX3N0cmluZ19nZW5lcmFsLmUiLCJpbmRleGFibGUuZSIsImludGVnZXIuZSIsImludGVnZXJfMTYuZSIsImludGVnZXJfMTZfcmVmLmUiLCJpbnRlZ2VyXzMyX3JlZi5lIiwiaW50ZWdlcl82NC5lIiwiaW50ZWdlcl82NF9yZWYuZSIsImludGVnZXJfOC5lIiwiaW50ZWdlcl84X3JlZi5lIiwiaXRlcmFibGUuZSIsImxpbmVhci5lIiwibGlzdC5lIiwibWFuYWdlZF9wb2ludGVyLmUiLCJtaXNtYXRjaF9jb3JyZWN0b3IuZSIsIm5hdGl2ZV9hcnJheS5lIiwibmF0dXJhbF8xNi5lIiwibmF0dXJhbF8xNl9yZWYuZSIsIm5hdHVyYWxfMzIuZSIsIm5hdHVyYWxfMzJfcmVmLmUiLCJuYXR1cmFsXzY0LmUiLCJuYXR1cmFsXzY0X3JlZi5lIiwibmF0dXJhbF84LmUiLCJuYXR1cmFsXzhfcmVmLmUiLCJudW1lcmljLmUiLCJwYXJ0X2NvbXBhcmFibGUuZSIsInBsYXRmb3JtLmUiLCJwb2ludGVyLmUiLCJwb2ludGVyX3JlZi5lIiwicHJvY2VkdXJlLmUiLCJyZWFkYWJsZV9pbmRleGFibGUuZSIsInJlYWRhYmxlX3N0cmluZ18zMi5lIiwicmVhZGFibGVfc3RyaW5nXzguZSIsInJlYWRhYmxlX3N0cmluZ19nZW5lcmFsLmUiLCJyZWFsXzMyLmUiLCJyZWFsXzMyX3JlZi5lIiwicmVhbF82NC5lIiwicmVhbF82NF9yZWYuZSIsInJlZmFjdG9yaW5nX2hlbHBlci5lIiwicmVmbGVjdG9yLmUiLCJyZWZsZWN0b3JfY29uc3RhbnRzLmUiLCJyZWZsZWN0b3JfaGVscGVyLmUiLCJyZXNpemFibGUuZSIsInJvdXRpbmUuZSIsInNlcXVlbmNlLmUiLCJzcGVjaWFsLmUiLCJzdHJpbmcuZSIsInN0cmluZ18zMi5lIiwic3RyaW5nXzguZSIsInN0cmluZ19nZW5lcmFsLmUiLCJzdHJpbmdfaGFuZGxlci5lIiwic3RyaW5nX3RhYmxlLmUiLCJzeXN0ZW1fc3RyaW5nLmUiLCJ0YWJsZS5lIiwidGFibGVfaXRlcmFibGUuZSIsInRvX3NwZWNpYWwuZSIsInRyYXZlcnNhYmxlLmUiLCJ0dXBsZS5lIiwidHlwZS5lIiwidW5ib3VuZGVkLmUiLCJ1dGZfY29udmVydGVyLmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQ0RBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQSBsb3ctbGV2ZWwgc3RyaW5nIGNsYXNzIHRvIHNvbHZlIHNvbWUgZ2FyYmFnZSAlXG4gICAgJWNvbGxlY3RvciBwcm9ibGVtcyAobWFpbmx5IG9iamVjdHMgbW92aW5nIGFyb3VuZCkgd2hlbiAlXG4gICAgJWludGVyZmFjaW5nIHdpdGggQyBBUElzLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0yMCAxNjozNTowNyAtMDgwMCAoU3VuLCAyMCBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMjggJFwiXG5cbmNsYXNzXG4gIENfU1RSSU5HXG5cbmluaGVyaXRcbiAgU1RSSU5HX0hBTkRMRVJcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfYnlfcG9pbnRlcixcbiAgbWFrZV9ieV9wb2ludGVyX2FuZF9jb3VudCxcbiAgbWFrZV9zaGFyZWRfZnJvbV9wb2ludGVyLFxuICBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50LFxuICBvd25fZnJvbV9wb2ludGVyLFxuICBvd25fZnJvbV9wb2ludGVyX2FuZF9jb3VudFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2UgKGFfc3RyaW5nOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIE1ha2UgYSBDIHN0cmluZyBmcm9tIGBhX3N0cmluZycuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zdHJpbmdfbm90X3ZvaWQ6IGFfc3RyaW5nIC89IFZvaWRcbiAgICAgIGFfc3RyaW5nX2lzX3ZhbGlkX2FzX3N0cmluZ184OiBhX3N0cmluZy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGRvXG4gICAgICBtYWtlX2VtcHR5IChhX3N0cmluZy5jb3VudClcbiAgICAgIHNldF9zdHJpbmcgKGFfc3RyaW5nKVxuICAgIGVuZFxuXG4gIG1ha2VfZW1wdHkgKGFfbGVuZ3RoOiBJTlRFR0VSKVxuICAgICAgLS0gTWFrZSBhbiBlbXB0eSBDIHN0cmluZyBvZiBgYV9sZW5ndGgnIGNoYXJhY3RlcnMuXG4gICAgICAtLSBDIG1lbW9yeSBhcmVhIGlzIG5vdCBpbml0aWFsaXplZC5cbiAgICByZXF1aXJlXG4gICAgICBhX2xlbmd0aF9wb3NpdGl2ZTogYV9sZW5ndGggPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgbWFuYWdlZF9kYXRhLm1ha2UgKGFfbGVuZ3RoICsgMSlcbiAgICAgIGNvdW50IDo9IDBcbiAgICBlbmRcblxuICBtYWtlX2J5X3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSKVxuICAgICAgLS0gTWFrZSBhIGNvcHkgb2Ygc3RyaW5nIHBvaW50ZWQgYnkgYGFfcHRyJy5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG1ha2VfYnlfcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyLCBjX3N0cmxlbiAoYV9wdHIpKVxuICAgIGVuZFxuXG4gIG1ha2VfYnlfcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyOiBQT0lOVEVSOyBhX2xlbmd0aDogSU5URUdFUilcbiAgICAgIC0tIE1ha2UgYSBjb3B5IG9mIGZpcnN0IGBhX2xlbmd0aCcgYnl0ZSBvZiBzdHJpbmcgcG9pbnRlZCBieSBgYV9wdHInLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfcHRyX25vdF9udWxsOiBhX3B0ciAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIGFfbGVuZ3RoX25vbl9uZWdhdGl2ZTogYV9sZW5ndGggPj0gMFxuICAgIGRvXG4gICAgICBjb3VudCA6PSBhX2xlbmd0aFxuICAgICAgY3JlYXRlIG1hbmFnZWRfZGF0YS5tYWtlICgoYV9sZW5ndGggKyAxKSlcbiAgICAgIG1hbmFnZWRfZGF0YS5pdGVtLm1lbW9yeV9jb3B5IChhX3B0ciwgYV9sZW5ndGgpXG4gICAgZW5kXG5cbiAgbWFrZV9zaGFyZWRfZnJvbV9wb2ludGVyIChhX3B0cjogUE9JTlRFUilcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBzaGFyaW5nIGBhX3B0cicuXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfbm90X251bGw6IGFfcHRyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0ciwgY19zdHJsZW4gKGFfcHRyKSlcbiAgICBlbmRcblxuICBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0cjogUE9JTlRFUjsgYV9sZW5ndGg6IElOVEVHRVIpXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugc2hhcmluZyBgYV9wdHInIG9mIGBhX2xlbmd0aCcgYnl0ZS5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBhX2xlbmd0aF9ub25fbmVnYXRpdmU6IGFfbGVuZ3RoID49IDBcbiAgICBkb1xuICAgICAgY291bnQgOj0gYV9sZW5ndGhcbiAgICAgIGNyZWF0ZSBtYW5hZ2VkX2RhdGEuc2hhcmVfZnJvbV9wb2ludGVyIChhX3B0ciwgYV9sZW5ndGggKyAxKVxuICAgIGVuZFxuXG4gIG93bl9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSKVxuICAgICAgLS0gTmV3IGluc3RhbmNlIHVzaW5nIGBhX3B0cicgYXMgbWVtb3J5LiBDdXJyZW50IHdpbGwgZnJlZSBwb2ludGVkIG1lbW9yeVxuICAgICAgLS0gYnkgYGFfcHRyJyB3aGVuIGNvbGxlY3RlZC5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG93bl9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0ciwgY19zdHJsZW4gKGFfcHRyKSlcbiAgICBlbmRcblxuICBvd25fZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoYV9wdHI6IFBPSU5URVI7IGFfbGVuZ3RoOiBJTlRFR0VSKVxuICAgICAgLS0gTmV3IGluc3RhbmNlIHVzaW5nIGBhX3B0cicgYXMgbWVtb3J5LiBDdXJyZW50IHdpbGwgZnJlZSBwb2ludGVkIG1lbW9yeVxuICAgICAgLS0gYnkgYGFfcHRyJyB3aGVuIGNvbGxlY3RlZC5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBhX2xlbmd0aF9ub25fbmVnYXRpdmU6IGFfbGVuZ3RoID49IDBcbiAgICBkb1xuICAgICAgY291bnQgOj0gYV9sZW5ndGhcbiAgICAgIGNyZWF0ZSBtYW5hZ2VkX2RhdGEub3duX2Zyb21fcG9pbnRlciAoYV9wdHIsIGFfbGVuZ3RoKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSKVxuICAgICAgLS0gU2hhcmUgYGFfcHRyJy5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIHNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoYV9wdHIsIGNfc3RybGVuIChhX3B0cikpXG4gICAgZW5kXG5cbiAgc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0cjogUE9JTlRFUjsgYV9sZW5ndGg6IElOVEVHRVIpXG4gICAgICAtLSBTaGFyZSBgYV9wdHInIG9mIGBhX2xlbmd0aCcgYnl0ZS5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBhX2xlbmd0aF9ub25fbmVnYXRpdmU6IGFfbGVuZ3RoID49IDBcbiAgICBkb1xuICAgICAgY291bnQgOj0gYV9sZW5ndGhcbiAgICAgIGlmIG5vdCBtYW5hZ2VkX2RhdGEuaXNfc2hhcmVkIHRoZW5cbiAgICAgICAgY3JlYXRlIG1hbmFnZWRfZGF0YS5zaGFyZV9mcm9tX3BvaW50ZXIgKGFfcHRyLCBhX2xlbmd0aCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIG1hbmFnZWRfZGF0YS5zZXRfZnJvbV9wb2ludGVyIChhX3B0ciwgYV9sZW5ndGggKyAxKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2hhcmVfZnJvbV9wb2ludGVyIChhX3B0cjogUE9JTlRFUilcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBzaGFyaW5nIGBhX3B0cicuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXInIHRvIGNyZWF0ZSBvYmplY3QgYW5kIGBzZXRfc2hhcmVkX2Zyb21fcG9pbnRlcicgdG8gbW9kaWZ5IGl0LlwiXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfbm90X251bGw6IGFfcHRyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBzZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyLCBjX3N0cmxlbiAoYV9wdHIpKVxuICAgIGVuZFxuXG4gIHNoYXJlX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyOiBQT0lOVEVSOyBhX2xlbmd0aDogSU5URUdFUilcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBzaGFyaW5nIGBhX3B0cicgb2YgYGFfbGVuZ3RoJyBieXRlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZV9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCcgdG8gY3JlYXRlIG9iamVjdCBhbmQgYHNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCcgdG8gbW9kaWZ5IGl0LlwiXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfbm90X251bGw6IGFfcHRyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgYV9sZW5ndGhfbm9uX25lZ2F0aXZlOiBhX2xlbmd0aCA+PSAwXG4gICAgZG9cbiAgICAgIHNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoYV9wdHIsIGFfbGVuZ3RoKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIHN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogU1RSSU5HXG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc2l0aW9uX25vdF90b29fYmlnOiBlbmRfcG9zIDw9IGNhcGFjaXR5XG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsX2NvdW50KVxuICAgICAgUmVzdWx0LnNldF9jb3VudCAobF9jb3VudClcbiAgICAgIHJlYWRfc3Vic3RyaW5nX2ludG8gKFJlc3VsdCwgc3RhcnRfcG9zLCBlbmRfcG9zKVxuICAgIGVuc3VyZVxuICAgICAgc3VzYnN0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBzdHJpbmc6IFNUUklOR1xuICAgICAgLS0gRWlmZmVsIHN0cmluZywgaWdub3JpbmcgYGNvdW50Jy4gUmVhZHMgdW50aWwgYSBudWxsIGNoYXJhY3RlciBpcyBiZWluZyByZWFkLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3Vic3RyaW5nICgxLCBjX3N0cmxlbiAoaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBzdHJpbmdfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY29weV90b19zdHJpbmcgKGFfc3RyaW5nOiBTVFJJTkdfR0VORVJBTDsgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIENvcHkgYG4nIGNoYXJhY3RlcnMgb2YgYEN1cnJlbnQnIGZyb20gYHNvdXJjZV9pbmRleCcgcG9zaXRpb24gdG8gYGFfc3RyaW5nJyBhdFxuICAgICAgLS0gYGRlc3RpbmF0aW9uX2luZGV4Jy4gT3RoZXIgY2hhcmFjdGVycyBvZiBgYV9zdHJpbmcnIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zdHJpbmdfbm90X3ZvaWQ6IGFfc3RyaW5nIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9wb3NpdGl2ZTogc291cmNlX2luZGV4ID49IDFcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X3Bvc2l0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAxXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyAobiAtIDEpIDw9IGNhcGFjaXR5XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgKG4gLSAxKSA8PSBhX3N0cmluZy5jb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2RhdGE6IGxpa2UgbWFuYWdlZF9kYXRhXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc291cmNlX2luZGV4IC0gMVxuICAgICAgICBqIDo9IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIChuIC0gMSlcbiAgICAgICAgbF9kYXRhIDo9IG1hbmFnZWRfZGF0YVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFfc3RyaW5nLnB1dF9jb2RlIChsX2RhdGEucmVhZF9uYXR1cmFsXzggKGkpLCBqKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlYWRfc3Vic3RyaW5nX2ludG8gKGFfc3RyaW5nOiBTVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcycgaW50byBgYV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfc3RyaW5nX25vdF92b2lkOiBhX3N0cmluZyAvPSBWb2lkXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc2l0aW9uX25vdF90b29fYmlnOiBlbmRfcG9zIDw9IGNhcGFjaXR5XG4gICAgICBhX3N0cmluZ19sYXJnZV9lbm91Z2g6IGFfc3RyaW5nLmNvdW50ID49IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfZGF0YTogbGlrZSBtYW5hZ2VkX2RhdGFcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9wb3MgLSAxXG4gICAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3NcbiAgICAgICAgbF9kYXRhIDo9IG1hbmFnZWRfZGF0YVxuICAgICAgICBqIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhX3N0cmluZy5wdXRfY29kZSAobF9kYXRhLnJlYWRfbmF0dXJhbF84IChpKSwgailcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWFkX3N0cmluZ19pbnRvIChhX3N0cmluZzogU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJyBpbnRvIGBhX3N0cmluZycgcmVwbGFjaW5nIGFueVxuICAgICAgLS0gZXhpc3RpbmcgY2hhcmFjdGVycy5cbiAgICByZXF1aXJlXG4gICAgICBhX3N0cmluZ19ub3Rfdm9pZDogYV9zdHJpbmcgLz0gVm9pZFxuICAgICAgYV9zdHJpbmdfbGFyZ2VfZW5vdWdoOiBhX3N0cmluZy5jb3VudCA+PSBjb3VudFxuICAgIGRvXG4gICAgICByZWFkX3N1YnN0cmluZ19pbnRvIChhX3N0cmluZywgMSwgY291bnQpXG4gICAgZW5kXG5cbiAgcmVhZF9zdWJzdHJpbmdfaW50b19jaGFyYWN0ZXJfOF9hcmVhIChhX2FyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl84XTsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcycgaW50byBgYV9hcmVhJy5cbiAgICByZXF1aXJlXG4gICAgICBhX2FyZWFfbm90X3ZvaWQ6IGFfYXJlYSAvPSBWb2lkXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc2l0aW9uX25vdF90b29fYmlnOiBlbmRfcG9zIDw9IGNhcGFjaXR5XG4gICAgICBhX2FyZWFfbGFyZ2VfZW5vdWdoOiBhX2FyZWEuY291bnQgPj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9kYXRhOiBsaWtlIG1hbmFnZWRfZGF0YVxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3Bvc1xuICAgICAgICBsX2RhdGEgOj0gbWFuYWdlZF9kYXRhXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYV9hcmVhLnB1dCAobF9kYXRhLnJlYWRfbmF0dXJhbF84IChpKS50b19jaGFyYWN0ZXJfOCwgailcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvcGllZDogLS0gZm9yIGkgaW4gMC4uZW5kX3BvcyAtIHN0YXJ0X3BvcywgYV9hcmVhIFtpXSA9IEN1cnJlbnQgW2kgKyBzdGFydF9wb3NdXG4gICAgZW5kXG5cbiAgcmVhZF9zdWJzdHJpbmdfaW50b19jaGFyYWN0ZXJfMzJfYXJlYSAoYV9hcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJyBpbnRvIGBhX2FyZWEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfYXJlYV9ub3Rfdm9pZDogYV9hcmVhIC89IFZvaWRcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zaXRpb25fbm90X3Rvb19iaWc6IGVuZF9wb3MgPD0gY2FwYWNpdHlcbiAgICAgIGFfYXJlYV9sYXJnZV9lbm91Z2g6IGFfYXJlYS5jb3VudCA+PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2RhdGE6IGxpa2UgbWFuYWdlZF9kYXRhXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfcG9zIC0gMVxuICAgICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zXG4gICAgICAgIGxfZGF0YSA6PSBtYW5hZ2VkX2RhdGFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhX2FyZWEucHV0IChsX2RhdGEucmVhZF9uYXR1cmFsXzggKGkpLnRvX2NoYXJhY3Rlcl8zMiwgailcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvcGllZDogLS0gZm9yIGkgaW4gMC4uZW5kX3BvcyAtIHN0YXJ0X3BvcywgYV9hcmVhIFtpXSA9IEN1cnJlbnQgW2kgKyBzdGFydF9wb3NdXG4gICAgZW5kXG5cbiAgaXRlbTogUE9JTlRFUlxuICAgICAgLS0gR2V0IHBvaW50ZXIgdG8gYWxsb2NhdGVkIGFyZWEuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBtYW5hZ2VkX2RhdGEuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9ub3RfbnVsbDogUmVzdWx0IC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuZFxuXG4gIG1hbmFnZWRfZGF0YTogTUFOQUdFRF9QT0lOVEVSXG4gICAgICAtLSBIb2xkIGRhdGEgb2YgQ3VycmVudC5cblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbWFuYWdlZF9kYXRhLmNvdW50XG4gICAgZW5kXG5cbiAgYnl0ZXNfY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY291bnRcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gQ3VycmVudC5cblxuICBjaGFyYWN0ZXJfc2l6ZTogSU5URUdFUiA9IDFcbiAgICAgIC0tIFNpemUgb2YgYSBjaGFyYWN0ZXJcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9zdHJpbmcgKGFfc3RyaW5nOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFNldCBgc3RyaW5nJyB3aXRoIGBhX3N0cmluZycuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zdHJpbmdfbm90X3ZvaWQ6IGFfc3RyaW5nIC89IFZvaWRcbiAgICAgIGFfc3RyaW5nX2lzX3N0cmluZ184OiBhX3N0cmluZy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGRvXG4gICAgICBzZXRfc3Vic3RyaW5nIChhX3N0cmluZywgMSwgYV9zdHJpbmcuY291bnQpXG4gICAgZW5kXG5cbiAgc2V0X3N1YnN0cmluZyAoYV9zdHJpbmc6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYHN0cmluZycgd2l0aCBgYV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfc3RyaW5nX25vdF92b2lkOiBhX3N0cmluZyAvPSBWb2lkXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gYV9zdHJpbmcuY291bnRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjb3VudCA6PSBuYlxuXG4gICAgICBuZXdfc2l6ZSA6PSBuYiArIDFcblxuICAgICAgaWYgbWFuYWdlZF9kYXRhLmNvdW50IDwgbmV3X3NpemUgIHRoZW5cbiAgICAgICAgbWFuYWdlZF9kYXRhLnJlc2l6ZSAobmV3X3NpemUpXG4gICAgICBlbmRcblxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDBcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBtYW5hZ2VkX2RhdGEucHV0X25hdHVyYWxfOCAoYV9zdHJpbmcuY29kZSAoaSArIHN0YXJ0X3BvcykudG9fbmF0dXJhbF84LCBpKVxuICAgICAgICBpIDo9IGkgKyAgMVxuICAgICAgZW5kXG4gICAgICBtYW5hZ2VkX2RhdGEucHV0X25hdHVyYWxfOCAoMCwgbmIpXG4gICAgZW5kXG5cbiAgc2V0X2NvdW50IChhX2NvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBjb3VudCcgd2l0aCBgYV9jb3VudCcuXG4gICAgICAtLSBOb3RlOiBDdXJyZW50IGNvbnRlbnQgZnJvbSBpbmRleCBgMScgdG9cbiAgICAgIC0tIGBjb3VudC5taW4gKGFfY291bnQpJyBpcyB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV9jb3VudF9ub25fbmVnYXRpdmU6IGFfY291bnQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBuZXdfc2l6ZSA6PSBhX2NvdW50ICsgMVxuICAgICAgaWYgbWFuYWdlZF9kYXRhLmNvdW50IDwgbmV3X3NpemUgdGhlblxuICAgICAgICBtYW5hZ2VkX2RhdGEucmVzaXplIChuZXdfc2l6ZSlcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0gYV9jb3VudFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IGFfY291bnRcbiAgICBlbmRcblxuICBmaWxsX2JsYW5rXG4gICAgICAtLSBGaWxsIEN1cnJlbnQgd2l0aCB6ZXJvcy5cbiAgICBkb1xuICAgICAgZmlsbF92YWx1ZSAoMClcbiAgICBlbnN1cmVcbiAgICAgIC0tIGFsbF92YWx1ZXM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYDAnXG4gICAgZW5kXG5cbiAgZmlsbF92YWx1ZSAoYV92YWx1ZTogSU5URUdFUl84KVxuICAgICAgLS0gRmlsbCBDdXJyZW50IHdpdGggYGFfdmFsdWUnLlxuICAgIGRvXG4gICAgICBtYW5hZ2VkX2RhdGEuaXRlbS5tZW1vcnlfc2V0IChhX3ZhbHVlLCBtYW5hZ2VkX2RhdGEuY291bnQpXG4gICAgZW5zdXJlXG4gICAgICAtLSBhbGxfdmFsdWVzOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IGBhX3ZhbHVlJ1xuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGNfc3RybGVuIChwdHI6IFBPSU5URVIpOiBJTlRFR0VSXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBzaWduYXR1cmUgKGNoYXIgKik6IEVJRl9JTlRFR0VSIHVzZSA8c3RyaW5nLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJzdHJsZW5cIlxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgbWFuYWdlZF9kYXRhX25vdF92b2lkOiBtYW5hZ2VkX2RhdGEgLz0gVm9pZFxuICBjb3VudF9ub3RfbmVnYXRpdmU6IGNvdW50ID49IDBcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkFuY2VzdG9yIG9mIFNQRUNJQUwgdG8gcGVyZm9ybSBxdWVyaWVzIG9uIFNQRUNJQUwgd2l0aG91dCBrbm93aW5nIGl0cyBhY3R1YWwgZ2VuZXJpYyB0eXBlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wNC0xMiAxNjo1NDo1MCAtMDcwMCAoRnJpLCAxMiBBcHIgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI0NDAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIEFCU1RSQUNUX1NQRUNJQUxcblxuaW5oZXJpdFxuICBERUJVR19PVVRQVVRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBDb3VudCBvZiBzcGVjaWFsIGFyZWFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBDYXBhY2l0eSBvZiBzcGVjaWFsIGFyZWFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiBDdXJyZW50P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgZGVidWdfb3V0cHV0OiBTVFJJTkdcbiAgICAgIC0tIFN0cmluZyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGVidWdnZXIgdG8gcmVwcmVzZW50IGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMilcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nIChcImNvdW50PVwiKVxuICAgICAgUmVzdWx0LmFwcGVuZF9pbnRlZ2VyIChjb3VudClcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBgYEFjdGl2ZScnIGRhdGEgc3RydWN0dXJlcywgd2hpY2ggYXQgZXZlcnkgc3RhZ2UgaGF2ZVxuICAgIGEgcG9zc2libHkgdW5kZWZpbmVkIGBgY3VycmVudCBpdGVtJycuXG4gICAgQmFzaWMgYWNjZXNzIGFuZCBtb2RpZmljYXRpb24gb3BlcmF0aW9ucyBhcHBseSB0byB0aGUgY3VycmVudCBpdGVtLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBhY3RpdmUsIGFjY2Vzc1xuICBhY2Nlc3M6IG1lbWJlcnNoaXBcbiAgY29udGVudHM6IGdlbmVyaWNcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEFDVElWRSBbR10gaW5oZXJpdFxuXG4gIEJBRyBbR11cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBHXG4gICAgICAtLSBDdXJyZW50IGl0ZW1cbiAgICByZXF1aXJlXG4gICAgICByZWFkYWJsZTogcmVhZGFibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZWFkYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgYSBjdXJyZW50IGl0ZW0gdGhhdCBtYXkgYmUgcmVhZD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHdyaXRhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBhIGN1cnJlbnQgaXRlbSB0aGF0IG1heSBiZSBtb2RpZmllZD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHJlcGxhY2VhYmxlOiBCT09MRUFOXG4gICAgICAtLSBDYW4gY3VycmVudCBpdGVtIGJlIHJlcGxhY2VkP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcmVwbGFjZSAodjogRylcbiAgICAgIC0tIFJlcGxhY2UgY3VycmVudCBpdGVtIGJ5IGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICB3cml0YWJsZTogd3JpdGFibGVcbiAgICAgIHJlcGxhY2VhYmxlOiByZXBsYWNlYWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3JlcGxhY2VkOiBpdGVtID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmVcbiAgICAgIC0tIFJlbW92ZSBjdXJyZW50IGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgcHJ1bmFibGU6IHBydW5hYmxlXG4gICAgICB3cml0YWJsZTogd3JpdGFibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICB3cml0YWJsZV9jb25zdHJhaW50OiB3cml0YWJsZSBpbXBsaWVzIHJlYWRhYmxlXG4gIGVtcHR5X2NvbnN0cmFpbnQ6IGlzX2VtcHR5IGltcGxpZXMgKG5vdCByZWFkYWJsZSkgYW5kIChub3Qgd3JpdGFibGUpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgUHJvamVjdC13aWRlIHVuaXZlcnNhbCBwcm9wZXJ0aWVzLlxuICAgIFRoaXMgY2xhc3MgaXMgYW4gYW5jZXN0b3IgdG8gYWxsIGRldmVsb3Blci13cml0dGVuIGNsYXNzZXMuXG4gICAgQU5ZIG1heSBiZSBjdXN0b21pemVkIGZvciBpbmRpdmlkdWFsIHByb2plY3RzIG9yIHRlYW1zLlxuICAgIF1cIlxuXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0yNSAxMTo0OTowMCAtMDgwMCAoRnJpLCAyNSBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMzQgJFwiXG5cbmNsYXNzXG4gIEFOWVxuXG5mZWF0dXJlIC0tIEN1c3RvbWl6YXRpb25cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBnZW5lcmF0b3I6IFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiBjdXJyZW50IG9iamVjdCdzIGdlbmVyYXRpbmcgY2xhc3NcbiAgICAgIC0tIChiYXNlIGNsYXNzIG9mIHRoZSB0eXBlIG9mIHdoaWNoIGl0IGlzIGEgZGlyZWN0IGluc3RhbmNlKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGdlbmVyYXRvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGdlbmVyYXRvcl9ub3RfZW1wdHk6IG5vdCBSZXN1bHQuaXNfZW1wdHlcbiAgICBlbmRcblxuICBnZW5lcmF0aW5nX3R5cGU6IFRZUEUgW2RldGFjaGFibGUgbGlrZSBDdXJyZW50XVxuICAgICAgLS0gVHlwZSBvZiBjdXJyZW50IG9iamVjdFxuICAgICAgLS0gKHR5cGUgb2Ygd2hpY2ggaXQgaXMgYSBkaXJlY3QgaW5zdGFuY2UpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB7ZGV0YWNoYWJsZSBsaWtlIEN1cnJlbnR9XG4gICAgZW5zdXJlXG4gICAgICBnZW5lcmF0aW5nX3R5cGVfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGNvbmZvcm1zX3RvIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyB0eXBlIG9mIGN1cnJlbnQgb2JqZWN0IGNvbmZvcm0gdG8gdHlwZVxuICAgICAgLS0gb2YgYG90aGVyJyAoYXMgcGVyIEVpZmZlbDogVGhlIExhbmd1YWdlLCBjaGFwdGVyIDEzKT9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBzYW1lX3R5cGUgKG90aGVyOiBBTlkpOiBCT09MRUFOXG4gICAgICAtLSBJcyB0eXBlIG9mIGN1cnJlbnQgb2JqZWN0IGlkZW50aWNhbCB0byB0eXBlIG9mIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY29uZm9ybXNfdG8gKG90aGVyKSBhbmRcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuY29uZm9ybXNfdG8gKEN1cnJlbnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IGNvbnNpZGVyZWRcbiAgICAgIC0tIGVxdWFsIHRvIGN1cnJlbnQgb2JqZWN0P1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlciB+IEN1cnJlbnRcbiAgICAgIGNvbnNpc3RlbnQ6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBmcm96ZW4gc3RhbmRhcmRfaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCwgYW5kIGZpZWxkLWJ5LWZpZWxkIGlkZW50aWNhbCB0byBpdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuc3RhbmRhcmRfaXNfZXF1YWwgKEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgZnJvemVuIGVxdWFsIChhOiBkZXRhY2hhYmxlIEFOWTsgYjogbGlrZSBhKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBhJyBhbmQgYGInIGVpdGhlciBib3RoIHZvaWQgb3IgYXR0YWNoZWRcbiAgICAgIC0tIHRvIG9iamVjdHMgY29uc2lkZXJlZCBlcXVhbD9cbiAgICBkb1xuICAgICAgaWYgYSA9IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYiA9IFZvaWRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGIgLz0gVm9pZCBhbmQgdGhlblxuICAgICAgICAgICAgICBhLmlzX2VxdWFsIChiKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoYSA9IFZvaWQgYW5kIGIgPSBWb2lkKSBvciBlbHNlXG4gICAgICAgICAgICAoKGEgLz0gVm9pZCBhbmQgYiAvPSBWb2lkKSBhbmQgdGhlblxuICAgICAgICAgICAgYS5pc19lcXVhbCAoYikpXG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2VxdWFsIChhOiBkZXRhY2hhYmxlIEFOWTsgYjogbGlrZSBhKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBhJyBhbmQgYGInIGVpdGhlciBib3RoIHZvaWQgb3IgYXR0YWNoZWQgdG9cbiAgICAgIC0tIGZpZWxkLWJ5LWZpZWxkIGlkZW50aWNhbCBvYmplY3RzIG9mIHRoZSBzYW1lIHR5cGU/XG4gICAgICAtLSBBbHdheXMgdXNlcyBkZWZhdWx0IG9iamVjdCBjb21wYXJpc29uIGNyaXRlcmlvbi5cbiAgICBkb1xuICAgICAgaWYgYSA9IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYiA9IFZvaWRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGIgLz0gVm9pZCBhbmQgdGhlblxuICAgICAgICAgICAgICBhLnN0YW5kYXJkX2lzX2VxdWFsIChiKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoYSA9IFZvaWQgYW5kIGIgPSBWb2lkKSBvciBlbHNlXG4gICAgICAgICAgICAoKGEgLz0gVm9pZCBhbmQgYiAvPSBWb2lkKSBhbmQgdGhlblxuICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYikpXG4gICAgZW5kXG5cbiAgZnJvemVuIGlzX2RlZXBfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYEN1cnJlbnQnIGFuZCBgb3RoZXInIGF0dGFjaGVkIHRvIGlzb21vcnBoaWMgb2JqZWN0IHN0cnVjdHVyZXM/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzaGFsbG93X2ltcGxpZXNfZGVlcDogc3RhbmRhcmRfaXNfZXF1YWwgKG90aGVyKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgc2FtZV90eXBlOiBSZXN1bHQgaW1wbGllcyBzYW1lX3R5cGUgKG90aGVyKVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19kZWVwX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBkZWVwX2VxdWFsIChhOiBkZXRhY2hhYmxlIEFOWTsgYjogbGlrZSBhKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBhJyBhbmQgYGInIGVpdGhlciBib3RoIHZvaWRcbiAgICAgIC0tIG9yIGF0dGFjaGVkIHRvIGlzb21vcnBoaWMgb2JqZWN0IHN0cnVjdHVyZXM/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW4gYS5pc19kZWVwX2VxdWFsIChiKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzaGFsbG93X2ltcGxpZXNfZGVlcDogc3RhbmRhcmRfZXF1YWwgKGEsIGIpIGltcGxpZXMgUmVzdWx0XG4gICAgICBib3RoX29yX25vbmVfdm9pZDogKGEgPSBWb2lkKSBpbXBsaWVzIChSZXN1bHQgPSAoYiA9IFZvaWQpKVxuICAgICAgc2FtZV90eXBlOiAoUmVzdWx0IGFuZCAoYSAvPSBWb2lkKSkgaW1wbGllcyAoYiAvPSBWb2lkIGFuZCB0aGVuIGEuc2FtZV90eXBlIChiKSlcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgZGVlcF9lcXVhbCAoYiwgYSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGZyb3plbiB0d2luOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3QgZXF1YWwgdG8gYEN1cnJlbnQnXG4gICAgICAtLSBgdHdpbicgY2FsbHMgYGNvcHknOyB0byBjaGFuZ2UgY29weWluZy90d2lubmluZyBzZW1hbnRpY3MsIHJlZGVmaW5lIGBjb3B5Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICB0d2luX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgaXNfZXF1YWw6IFJlc3VsdCB+IEN1cnJlbnRcbiAgICBlbmRcblxuICBjb3B5IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gVXBkYXRlIGN1cnJlbnQgb2JqZWN0IHVzaW5nIGZpZWxkcyBvZiBvYmplY3QgYXR0YWNoZWRcbiAgICAgIC0tIHRvIGBvdGhlcicsIHNvIGFzIHRvIHlpZWxkIGVxdWFsIG9iamVjdHMuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHR5cGVfaWRlbnRpdHk6IHNhbWVfdHlwZSAob3RoZXIpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXNfZXF1YWw6IEN1cnJlbnQgfiBvdGhlclxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF9jb3B5IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gQ29weSBldmVyeSBmaWVsZCBvZiBgb3RoZXInIG9udG8gY29ycmVzcG9uZGluZyBmaWVsZFxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3QuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHR5cGVfaWRlbnRpdHk6IHNhbWVfdHlwZSAob3RoZXIpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXNfc3RhbmRhcmRfZXF1YWw6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcilcbiAgICBlbmRcblxuICBmcm96ZW4gY2xvbmUgKG90aGVyOiBkZXRhY2hhYmxlIEFOWSk6IGxpa2Ugb3RoZXJcbiAgICAgIC0tIFZvaWQgaWYgYG90aGVyJyBpcyB2b2lkOyBvdGhlcndpc2UgbmV3IG9iamVjdFxuICAgICAgLS0gZXF1YWwgdG8gYG90aGVyJ1xuICAgICAgLS1cbiAgICAgIC0tIEZvciBub24tdm9pZCBgb3RoZXInLCBgY2xvbmUnIGNhbGxzIGBjb3B5JztcbiAgICAgIC0tIHRvIGNoYW5nZSBjb3B5aW5nL2Nsb25pbmcgc2VtYW50aWNzLCByZWRlZmluZSBgY29weScuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0d2luJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gb3RoZXIudHdpblxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBlcXVhbDogUmVzdWx0IH4gb3RoZXJcbiAgICBlbmRcblxuICBmcm96ZW4gc3RhbmRhcmRfY2xvbmUgKG90aGVyOiBkZXRhY2hhYmxlIEFOWSk6IGxpa2Ugb3RoZXJcbiAgICAgIC0tIFZvaWQgaWYgYG90aGVyJyBpcyB2b2lkOyBvdGhlcndpc2UgbmV3IG9iamVjdFxuICAgICAgLS0gZmllbGQtYnktZmllbGQgaWRlbnRpY2FsIHRvIGBvdGhlcicuXG4gICAgICAtLSBBbHdheXMgdXNlcyBkZWZhdWx0IGNvcHlpbmcgc2VtYW50aWNzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgc3RhbmRhcmRfdHdpbicgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IG90aGVyLnN0YW5kYXJkX3R3aW5cbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXF1YWw6IHN0YW5kYXJkX2VxdWFsIChSZXN1bHQsIG90aGVyKVxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF90d2luOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3QgZmllbGQtYnktZmllbGQgaWRlbnRpY2FsIHRvIGBvdGhlcicuXG4gICAgICAtLSBBbHdheXMgdXNlcyBkZWZhdWx0IGNvcHlpbmcgc2VtYW50aWNzLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHN0YW5kYXJkX3R3aW5fbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBlcXVhbDogc3RhbmRhcmRfZXF1YWwgKFJlc3VsdCwgQ3VycmVudClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF90d2luOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgc3RydWN0dXJlIHJlY3Vyc2l2ZWx5IGR1cGxpY2F0ZWQgZnJvbSBDdXJyZW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGRlZXBfdHdpbl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGRlZXBfZXF1YWw6IGRlZXBfZXF1YWwgKEN1cnJlbnQsIFJlc3VsdClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF9jbG9uZSAob3RoZXI6IGRldGFjaGFibGUgQU5ZKTogbGlrZSBvdGhlclxuICAgICAgLS0gVm9pZCBpZiBgb3RoZXInIGlzIHZvaWQ6IG90aGVyd2lzZSwgbmV3IG9iamVjdCBzdHJ1Y3R1cmVcbiAgICAgIC0tIHJlY3Vyc2l2ZWx5IGR1cGxpY2F0ZWQgZnJvbSB0aGUgb25lIGF0dGFjaGVkIHRvIGBvdGhlcidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGRlZXBfdHdpbicgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IG90aGVyLmRlZXBfdHdpblxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWVwX2VxdWFsOiBkZWVwX2VxdWFsIChvdGhlciwgUmVzdWx0KVxuICAgIGVuZFxuXG4gIGZyb3plbiBkZWVwX2NvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBFZmZlY3QgZXF1aXZhbGVudCB0byB0aGF0IG9mOlxuICAgICAgLS0gICAgYGNvcHknIChgb3RoZXInIC4gYGRlZXBfdHdpbicpXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgY29weSAob3RoZXIuZGVlcF90d2luKVxuICAgIGVuc3VyZVxuICAgICAgZGVlcF9lcXVhbDogZGVlcF9lcXVhbCAoQ3VycmVudCwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIFJldHJpZXZhbFxuXG4gIGZyb3plbiBpbnRlcm5hbF9jb3JyZWN0X21pc21hdGNoXG4gICAgICAtLSBDYWxsZWQgZnJvbSBydW50aW1lIHRvIHBlcmZvcm0gYSBwcm9wZXIgZHluYW1pYyBkaXNwYXRjaCBvbiBgY29ycmVjdF9taXNtYXRjaCdcbiAgICAgIC0tIGZyb20gTUlTTUFUQ0hfQ09SUkVDVE9SLlxuICAgIGxvY2FsXG4gICAgICBsX21zZzogU1RSSU5HXG4gICAgICBsX2V4YzogRVhDRVBUSU9OU1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7TUlTTUFUQ0hfQ09SUkVDVE9SfSBDdXJyZW50IGFzIGxfY29ycmVjdG9yIHRoZW5cbiAgICAgICAgbF9jb3JyZWN0b3IuY29ycmVjdF9taXNtYXRjaFxuICAgICAgZWxzZVxuICAgICAgICBjcmVhdGUgbF9tc2cubWFrZV9mcm9tX3N0cmluZyAoXCJNaXNtYXRjaDogXCIpXG4gICAgICAgIGNyZWF0ZSBsX2V4Y1xuICAgICAgICBsX21zZy5hcHBlbmQgKGdlbmVyYXRpbmdfdHlwZS5uYW1lKVxuICAgICAgICBsX2V4Yy5yYWlzZV9yZXRyaWV2YWxfZXhjZXB0aW9uIChsX21zZylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIGlvOiBTVERfRklMRVNcbiAgICAgIC0tIEhhbmRsZSB0byBzdGFuZGFyZCBmaWxlIHNldHVwXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9vdXRwdXRfZGVmYXVsdFxuICAgIGVuc3VyZVxuICAgICAgaW9fbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIE5ldyBzdHJpbmcgY29udGFpbmluZyB0ZXJzZSBwcmludGFibGUgcmVwcmVzZW50YXRpb25cbiAgICAgIC0tIG9mIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0YWdnZWRfb3V0XG4gICAgZW5zdXJlXG4gICAgICBvdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRhZ2dlZF9vdXQ6IFNUUklOR1xuICAgICAgLS0gTmV3IHN0cmluZyBjb250YWluaW5nIHRlcnNlIHByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3RcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICB0YWdnZWRfb3V0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHByaW50IChvOiBkZXRhY2hhYmxlIEFOWSlcbiAgICAgIC0tIFdyaXRlIHRlcnNlIGV4dGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGBvJ1xuICAgICAgLS0gb24gc3RhbmRhcmQgb3V0cHV0LlxuICAgIGRvXG4gICAgICBpZiBvIC89IFZvaWQgdGhlblxuICAgICAgICBpby5wdXRfc3RyaW5nIChvLm91dClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFBsYXRmb3JtXG5cbiAgT3BlcmF0aW5nX2Vudmlyb25tZW50OiBPUEVSQVRJTkdfRU5WSVJPTk1FTlRcbiAgICAgIC0tIE9iamVjdHMgYXZhaWxhYmxlIGZyb20gdGhlIG9wZXJhdGluZyBzeXN0ZW1cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5zdXJlXG4gICAgICBvcGVyYXRpbmdfZW52aXJvbm1lbnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgZGVmYXVsdF9jcmVhdGVcbiAgICAgIC0tIFByb2Nlc3MgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBubyBjcmVhdGlvbiBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgZGVmYXVsdF9yZXNjdWVcbiAgICAgIC0tIFByb2Nlc3MgZXhjZXB0aW9uIGZvciByb3V0aW5lcyB3aXRoIG5vIFJlc2N1ZSBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuICBmcm96ZW4gZG9fbm90aGluZ1xuICAgICAgLS0gRXhlY3V0ZSBhIG51bGwgYWN0aW9uLlxuICAgIGRvXG4gICAgZW5kXG5cbiAgZnJvemVuIGRlZmF1bHQ6IGRldGFjaGFibGUgbGlrZSBDdXJyZW50XG4gICAgICAtLSBEZWZhdWx0IHZhbHVlIG9mIG9iamVjdCdzIHR5cGVcbiAgICBkb1xuICAgIGVuZFxuXG4gIGZyb3plbiBkZWZhdWx0X3BvaW50ZXI6IFBPSU5URVJcbiAgICAgIC0tIERlZmF1bHQgdmFsdWUgb2YgdHlwZSBgUE9JTlRFUidcbiAgICAgIC0tIChBdm9pZCB0aGUgbmVlZCB0byB3cml0ZSBgcCcuYGRlZmF1bHQnIGZvclxuICAgICAgLS0gc29tZSBgcCcgb2YgdHlwZSBgUE9JTlRFUicuKVxuICAgIGRvXG4gICAgZW5zdXJlXG4gICAgICAtLSBSZXN1bHQgPSBSZXN1bHQuZGVmYXVsdFxuICAgIGVuZFxuXG4gIGZyb3plbiBhc19hdHRhY2hlZDogYXR0YWNoZWQgbGlrZSBDdXJyZW50XG4gICAgICAtLSBBdHRhY2hlZCB2ZXJzaW9uIG9mIEN1cnJlbnRcbiAgICAgIC0tIChDYW4gYmUgdXNlZCBkdXJpbmcgdHJhbnNpdGlvbmFsIHBlcmlvZCB0byBjb252ZXJ0XG4gICAgICAtLSBub24tdm9pZC1zYWZlIGNsYXNzZXMgdG8gdm9pZC1zYWZlIG9uZXMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgcmVmbGV4aXZlX2VxdWFsaXR5OiBzdGFuZGFyZF9pc19lcXVhbCAoQ3VycmVudClcbiAgcmVmbGV4aXZlX2NvbmZvcm1hbmNlOiBjb25mb3Jtc190byAoQ3VycmVudClcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0yNSAxNDoxODoyMCAtMDgwMCAoRnJpLCAyNSBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMzggJFwiXG5cbmNsYXNzIEFSUkFZIFtHXSBpbmhlcml0XG5cbiAgUkVTSVpBQkxFIFtHXVxuICAgIHJlZGVmaW5lXG4gICAgICBmdWxsLCBjb3B5LCBpc19lcXVhbCwgcmVzaXphYmxlXG4gICAgZW5kXG5cbiAgSU5ERVhBQkxFIFtHLCBJTlRFR0VSXVxuICAgIHJlbmFtZVxuICAgICAgaXRlbSBhcyBpdGVtIGFsaWFzIFwiW11cIlxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0ddXG4gICAgZXhwb3J0XG4gICAgICB7QVJSQVl9IHNldF9hcmVhXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBpdGVtLCBwdXQsIGF0LCB2YWxpZF9pbmRleFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9hcnJheSxcbiAgbWFrZV9mcm9tX3NwZWNpYWwsXG4gIG1ha2VfZnJvbV9jaWxcblxuY29udmVydFxuICB0b19jaWw6IHtOQVRJVkVfQVJSQVkgW0ddfSxcbiAgdG9fc3BlY2lhbDoge1NQRUNJQUwgW0ddfSxcbiAgbWFrZV9mcm9tX2NpbCAoe05BVElWRV9BUlJBWSBbR119KVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9lbXB0eVxuICAgICAgLS0gQWxsb2NhdGUgZW1wdHkgYXJyYXkgc3RhcnRpbmcgYXQgYDEnLlxuICAgIGRvXG4gICAgICBsb3dlciA6PSAxXG4gICAgICB1cHBlciA6PSAwXG4gICAgICBtYWtlX2VtcHR5X2FyZWEgKDApXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gMVxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IDBcbiAgICAgIGl0ZW1zX3NldDogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBtYWtlX2ZpbGxlZCAoYV9kZWZhdWx0X3ZhbHVlOiBHOyBtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGFycmF5OyBzZXQgaW5kZXggaW50ZXJ2YWwgdG9cbiAgICAgIC0tIGBtaW5faW5kZXgnIC4uIGBtYXhfaW5kZXgnOyBzZXQgYWxsIHZhbHVlcyB0byBkZWZhdWx0LlxuICAgICAgLS0gKE1ha2UgYXJyYXkgZW1wdHkgaWYgYG1pbl9pbmRleCcgPSBgbWF4X2luZGV4JyArIDEpLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2JvdW5kczogbWluX2luZGV4IDw9IG1heF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbjogSU5URUdFUlxuICAgIGRvXG4gICAgICBsb3dlciA6PSBtaW5faW5kZXhcbiAgICAgIHVwcGVyIDo9IG1heF9pbmRleFxuICAgICAgaWYgbWluX2luZGV4IDw9IG1heF9pbmRleCB0aGVuXG4gICAgICAgIG4gOj0gbWF4X2luZGV4IC0gbWluX2luZGV4ICsgMVxuICAgICAgZW5kXG4gICAgICBtYWtlX2ZpbGxlZF9hcmVhIChhX2RlZmF1bHRfdmFsdWUsIG4pXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gbWluX2luZGV4XG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gbWF4X2luZGV4XG4gICAgICBpdGVtc19zZXQ6IGZpbGxlZF93aXRoIChhX2RlZmF1bHRfdmFsdWUpXG4gICAgZW5kXG5cbiAgbWFrZSAobWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBhcnJheTsgc2V0IGluZGV4IGludGVydmFsIHRvXG4gICAgICAtLSBgbWluX2luZGV4JyAuLiBgbWF4X2luZGV4Jzsgc2V0IGFsbCB2YWx1ZXMgdG8gZGVmYXVsdC5cbiAgICAgIC0tIChNYWtlIGFycmF5IGVtcHR5IGlmIGBtaW5faW5kZXgnID0gYG1heF9pbmRleCcgKyAxKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCIgYG1ha2UnIGlzIG5vdCB2b2lkLXNhZmUgc3RhdGljYWxseS4gVXNlIGBtYWtlX2VtcHR5JyBvciBgbWFrZV9maWxsZWQnIGluc3RlYWQuIFswNy0yMDEwXVwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfYm91bmRzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4ICsgMVxuICAgICAgaGFzX2RlZmF1bHQ6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXggaW1wbGllcyAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBsb3dlciA6PSBtaW5faW5kZXhcbiAgICAgIHVwcGVyIDo9IG1heF9pbmRleFxuICAgICAgaWYgbWluX2luZGV4IDw9IG1heF9pbmRleCB0aGVuXG4gICAgICAgIG1ha2VfZmlsbGVkX2FyZWEgKCh7R30pLmRlZmF1bHQsIG1heF9pbmRleCAtIG1pbl9pbmRleCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIG1ha2VfZW1wdHlfYXJlYSAoMClcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IG1pbl9pbmRleFxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IG1heF9pbmRleFxuICAgICAgaXRlbXNfc2V0OiBhbGxfZGVmYXVsdFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9hcnJheSAoYTogQVJSQVkgW0ddKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBpdGVtcyBvZiBgYScuXG4gICAgICAtLSAoVXNlZnVsIGluIHByb3BlciBkZXNjZW5kYW50cyBvZiBjbGFzcyBgQVJSQVknLFxuICAgICAgLS0gdG8gaW5pdGlhbGl6ZSBhbiBhcnJheS1saWtlIG9iamVjdCBmcm9tIGEgbWFuaWZlc3QgYXJyYXkuKVxuICAgIHJlcXVpcmVcbiAgICAgIGFycmF5X2V4aXN0czogYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9hcmVhIChhLmFyZWEpXG4gICAgICBsb3dlciA6PSBhLmxvd2VyXG4gICAgICB1cHBlciA6PSBhLnVwcGVyXG4gICAgZW5zdXJlXG4gICAgICBzaGFyZWQ6IGFyZWEgPSBhLmFyZWFcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBhLmxvd2VyXG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gYS51cHBlclxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9zcGVjaWFsIChhOiBTUEVDSUFMIFtHXSlcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCBmcm9tIGl0ZW1zIG9mIGBhJy5cbiAgICByZXF1aXJlXG4gICAgICBzcGVjaWFsX2F0dGFjaGVkOiBhIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2FyZWEgKGEpXG4gICAgICBsb3dlciA6PSAxXG4gICAgICB1cHBlciA6PSBhLmNvdW50XG4gICAgZW5zdXJlXG4gICAgICBzaGFyZWQ6IGFyZWEgPSBhXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gMVxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IGEuY291bnRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChuYTogTkFUSVZFX0FSUkFZIFtsaWtlIGl0ZW1dKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBhcnJheSBmcm9tIGBuYScuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgICAgbmFfbm90X3ZvaWQ6IG5hIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIGFyZWEubWFrZV9mcm9tX25hdGl2ZV9hcnJheSAobmEpXG4gICAgICBsb3dlciA6PSAxXG4gICAgICB1cHBlciA6PSBhcmVhLmNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogRyBhc3NpZ24gcHV0XG4gICAgICAtLSBFbnRyeSBhdCBpbmRleCBgaScsIGlmIGluIGluZGV4IGludGVydmFsXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBlbnRyeSAoaTogSU5URUdFUik6IEdcbiAgICAgIC0tIEVudHJ5IGF0IGluZGV4IGBpJywgaWYgaW4gaW5kZXggaW50ZXJ2YWxcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAoaSlcbiAgICBlbmRcblxuICBoYXMgKHY6IEcpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGB2JyBhcHBlYXIgaW4gYXJyYXk/XG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIG5iIDo9IHVwcGVyIC0gbG93ZXJcbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIGFuZCB2IC89IFZvaWQgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIFJlc3VsdFxuICAgICAgICBsb29wXG4gICAgICAgICAgUmVzdWx0IDo9IGxfYXJlYS5pdGVtIChpKSB+IHZcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIFJlc3VsdFxuICAgICAgICBsb29wXG4gICAgICAgICAgUmVzdWx0IDo9IGxfYXJlYS5pdGVtIChpKSA9IHZcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBsb3dlcjogSU5URUdFUlxuICAgICAgLS0gTWluaW11bSBpbmRleFxuXG4gIHVwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBNYXhpbXVtIGluZGV4XG5cbiAgY291bnQsIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgYXZhaWxhYmxlIGluZGljZXNcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHVwcGVyIC0gbG93ZXIgKyAxXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNvbnNpc3RlbnRfd2l0aF9ib3VuZHM6IFJlc3VsdCA9IHVwcGVyIC0gbG93ZXIgKyAxXG4gICAgZW5kXG5cbiAgb2NjdXJyZW5jZXMgKHY6IEcpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgdGltZXMgYHYnIGFwcGVhcnMgaW4gc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBsb3dlclxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiB1cHBlclxuICAgICAgICBsb29wXG4gICAgICAgICAgaWYgaXRlbSAoaSkgfiB2IHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gdXBwZXJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpID0gdiB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGxvd2VyLCB1cHBlcilcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfYm91bmRzOlxuICAgICAgICAoKFJlc3VsdC5sb3dlciA9IGxvd2VyKSBhbmQgKFJlc3VsdC51cHBlciA9IHVwcGVyKSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBhcnJheSBtYWRlIG9mIHRoZSBzYW1lIGl0ZW1zIGFzIGBvdGhlcic/XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VpZiBsb3dlciA9IG90aGVyLmxvd2VyIGFuZCB0aGVuIHVwcGVyID0gb3RoZXIudXBwZXIgYW5kIHRoZW5cbiAgICAgICAgb2JqZWN0X2NvbXBhcmlzb24gPSBvdGhlci5vYmplY3RfY29tcGFyaXNvblxuICAgICAgdGhlblxuICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgbm90IFJlc3VsdCBvciBpID4gdXBwZXJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBSZXN1bHQgOj0gaXRlbSAoaSkgfiBvdGhlci5pdGVtIChpKVxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGFsbF9kZWZhdWx0OiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIHNldCB0byBkZWZhdWx0IHZhbHVlcz9cbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh7R30pLmhhc19kZWZhdWx0IGFuZCB0aGVuIGFyZWEuZmlsbGVkX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIHVwcGVyIC0gbG93ZXIpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChjb3VudCA9IDAgb3IgZWxzZVxuICAgICAgICAoKG5vdCBhdHRhY2hlZCBpdGVtICh1cHBlcikgYXMgaSBvciBlbHNlIGkgPSAoe0d9KS5kZWZhdWx0KSBhbmRcbiAgICAgICAgc3ViYXJyYXkgKGxvd2VyLCB1cHBlciAtIDEpLmFsbF9kZWZhdWx0KSlcbiAgICBlbmRcblxuICBmaWxsZWRfd2l0aCAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgc2V0IHRvIGB2Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuZmlsbGVkX3dpdGggKHYsIDAsIHVwcGVyIC0gbG93ZXIpXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY291bnQgPSAwIG9yIGVsc2VcbiAgICAgICAgKGl0ZW0gKHVwcGVyKSA9IHYgYW5kIHN1YmFycmF5IChsb3dlciwgdXBwZXIgLSAxKS5maWxsZWRfd2l0aCAodikpKVxuICAgIGVuZFxuXG4gIGZ1bGw6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBmaWxsZWQgdG8gY2FwYWNpdHk/IChBbnN3ZXI6IHllcylcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBzYW1lX2l0ZW1zIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gRG8gYG90aGVyJyBhbmQgQ3VycmVudCBoYXZlIHNhbWUgaXRlbXM/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgaWYgY291bnQgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBhcmVhLnNhbWVfaXRlbXMgKG90aGVyLmFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoKGNvdW50ID0gb3RoZXIuY291bnQpIGFuZCB0aGVuXG4gICAgICAgIChjb3VudCA9IDAgb3IgZWxzZSAoaXRlbSAodXBwZXIpID0gb3RoZXIuaXRlbSAob3RoZXIudXBwZXIpXG4gICAgICAgIGFuZCBzdWJhcnJheSAobG93ZXIsIHVwcGVyIC0gMSkuc2FtZV9pdGVtc1xuICAgICAgICAob3RoZXIuc3ViYXJyYXkgKG90aGVyLmxvd2VyLCBvdGhlci51cHBlciAtIDEpKSkpKVxuICAgIGVuZFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBhcnJheT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChsb3dlciA8PSBpKSBhbmQgdGhlbiAoaSA8PSB1cHBlcilcbiAgICBlbmRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgYWRkZWQ/XG4gICAgICAtLSAoQW5zd2VyOiBubywgYWx0aG91Z2ggYXJyYXkgbWF5IGJlIHJlc2l6ZWQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICBlbmRcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IG5vLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgcmVzaXphYmxlOiBCT09MRUFOXG4gICAgICAtLSBDYW4gYXJyYXkgYmUgcmVzaXplZCBhdXRvbWF0aWNhbGx5P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleF9zZXQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGluZGV4X3NldC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQgKHY6IGxpa2UgaXRlbTsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYGknLXRoIGVudHJ5LCBpZiBpbiBpbmRleCBpbnRlcnZhbCwgYnkgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodiwgaSAtIGxvd2VyKVxuICAgIGVuZFxuXG4gIGVudGVyICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodiwgaSAtIGxvd2VyKVxuICAgIGVuZFxuXG4gIGZvcmNlICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBBc3NpZ24gaXRlbSBgdicgdG8gYGknLXRoIGVudHJ5LlxuICAgICAgLS0gUmVzaXplIHRoZSBhcnJheSBpZiBgaScgZmFsbHMgb3V0IG9mIGN1cnJlbnRseSBkZWZpbmVkIGJvdW5kczsgcHJlc2VydmUgZXhpc3RpbmcgaXRlbXMuXG4gICAgICAtLSBJbiB2b2lkLXNhZmUgbW9kZSwgaWYgKHtHfSkuaGFzX2RlZmF1bHQgZG9lcyBub3QgaG9sZCwgdGhlbiB5b3UgY2FuIG9ubHkgaW5zZXJ0IGJldHdlZW5cbiAgICAgIC0tIGBsb3dlciAtIDEnIG9yIGB1cHBlciArIDEnIHBvc2l0aW9uIGluIHRoZSBBUlJBWS5cbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdF9pZl90b29fbG93OlxuICAgICAgICAoaSA8IGxvd2VyIC0gMSBhbmQgbG93ZXIgLz0ge2xpa2UgbG93ZXJ9Lm1pbl92YWx1ZSkgaW1wbGllcyAoe0d9KS5oYXNfZGVmYXVsdFxuICAgICAgaGFzX2RlZmF1bHRfaWZfdG9vX2hpZ2g6XG4gICAgICAgIChpID4gdXBwZXIgKyAxIGFuZCB1cHBlciAvPSB7bGlrZSB1cHBlcn0ubWF4X3ZhbHVlKSBpbXBsaWVzICh7R30pLmhhc19kZWZhdWx0XG4gICAgbG9jYWxcbiAgICAgIG9sZF9zaXplLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbmV3X2xvd2VyLCBuZXdfdXBwZXI6IElOVEVHRVJcbiAgICAgIGxfY291bnQsIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgICBsX2luY3JlYXNlZF9ieV9vbmU6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgbmV3X2xvd2VyIDo9IGxvd2VyLm1pbiAoaSlcbiAgICAgIG5ld191cHBlciA6PSB1cHBlci5tYXggKGkpXG4gICAgICBuZXdfc2l6ZSA6PSBuZXdfdXBwZXIgLSBuZXdfbG93ZXIgKyAxXG4gICAgICBsX2luY3JlYXNlZF9ieV9vbmUgOj0gKGkgPSB1cHBlciArIDEpIG9yIChpID0gbG93ZXIgLSAxKVxuICAgICAgaWYgZW1wdHlfYXJlYSB0aGVuXG4gICAgICAgICAgLS0gTGlzdCBpcyBlbXB0eS4gRmlyc3Qgd2UgY3JlYXRlIGFuIGVtcHR5IFNQRUNJQUwgb2YgdGhlIHJpZ2h0IGNhcGFjaXR5LlxuICAgICAgICBtYWtlX2VtcHR5X2FyZWEgKG5ld19zaXplLm1heCAoYWRkaXRpb25hbF9zcGFjZSkpXG4gICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgdGhlblxuICAgICAgICAgICAgLS0gV2UgbmVlZCB0byBmaWxsIHRoZSBTUEVDSUFMIGZvciBgMCcgdG8gYG5ld19zaXplIC0gMicgd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgMCwgbmV3X3NpemUgLSAyKVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYS5leHRlbmQgKHYpXG4gICAgICBlbHNlXG4gICAgICAgIG9sZF9zaXplIDo9IGFyZWEuY2FwYWNpdHlcbiAgICAgICAgaWYgbmV3X3NpemUgPiBvbGRfc2l6ZSB0aGVuXG4gICAgICAgICAgc2V0X2FyZWEgKGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG5ld19zaXplLm1heCAob2xkX3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKSkpXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBuZXdfbG93ZXIgPCBsb3dlciB0aGVuXG4gICAgICAgICAgICAtLSBXZSBoYXZlIGluc2VydGVkIGJlbG93IHRoZSBwcmV2aW91cyBgbG93ZXInLiBXZSBuZWVkIHRvIHNoaWZ0IGVudHJpZXMgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAtLSBiZWZvcmUgd2UgY2FuIGluc2VydCBgdicuXG4gICAgICAgICAgbF9vZmZzZXQgOj0gbG93ZXIgLSBuZXdfbG93ZXJcbiAgICAgICAgICBsX2NvdW50IDo9IGNhcGFjaXR5XG4gICAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSBhbmQgbF9vZmZzZXQgPiBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgLS0gV2l0aCB0aGUgYG5ld19sb3dlcicgZ2l2ZW4sIHRoZSBkYXRhIGhhcyB0byBtb3ZlXG4gICAgICAgICAgICAgIC0tIGJleW9uZCB0aGUgYGFyZWEnJ3MgY291bnQgd2hpY2ggcmVxdWlyZXMgdXMgdG8gZmlsbFxuICAgICAgICAgICAgICAtLSB0aGUgZ2FwIGJldHdlZW4gdGhlIG9sZCBkYXRhJ3MgbG9jYXRpb24gYW5kIHRoZSBuZXcgb25lXG4gICAgICAgICAgICAgIC0tIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgbF9jb3VudCwgbF9vZmZzZXQgLSAxKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGFyZWEubW92ZV9kYXRhICgwLCBsX29mZnNldCwgbF9jb3VudClcbiAgICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIHRoZW5cbiAgICAgICAgICAgICAgLS0gV2Ugc3RhcnQgYXQgYDEnIGFuZCBub3QgYDAnIGJlY2F1c2UgbmV4dCBpbnN0cnVjdGlvblxuICAgICAgICAgICAgICAtLSB3aWxsIHVwZGF0ZSB0aGUgaXRlbSBhdCBwb3NpdGlvbiBgMCcuXG4gICAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgMSwgbF9vZmZzZXQgLSAxKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgICAgLS0gSW5zZXJ0IGB2JyBhdCB0aGUgbmV3IGxvd2VyIHBvc2l0aW9uLlxuICAgICAgICAgIGFyZWEucHV0ICh2LCAwKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgbmV3X3NpemUgPiBhcmVhLmNvdW50IHRoZW5cbiAgICAgICAgICAgICAgLS0gV2UgYXJlIGFkZGluZyB0byB0aGUgbmV3IGB1cHBlcicgcG9zaXRpb24uIEZpcnN0IHdlIGZpbGwgdGhlIG5vbi1pbml0aWFsaXplZFxuICAgICAgICAgICAgICAtLSBlbGVtZW50cyBpZiBhbnkgdXAgdG8gYG5ld19zaXplIC0gMicgKGkuZS4gdXAgdGhlIHRoZSBpdGVtIHByaW9yIHRvIGB1cHBlcicpLlxuICAgICAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSB0aGVuXG4gICAgICAgICAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCBhcmVhLmNvdW50LCBuZXdfc2l6ZSAtIDIpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgLS0gQWRkIGB2JyBhdCB1cHBlciBwb3NpdGlvbi5cbiAgICAgICAgICAgIGFyZWEuZXh0ZW5kICh2KVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSGVyZSBgbG93ZXInIGhhc24ndCBjaGFuZ2VkXG4gICAgICAgICAgICBhcmVhLnB1dCAodiwgaSAtIGxvd2VyKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgbG93ZXIgOj0gbmV3X2xvd2VyXG4gICAgICB1cHBlciA6PSBuZXdfdXBwZXJcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IHZcbiAgICAgIGhpZ2hlcl9jb3VudDogY291bnQgPj0gb2xkIGNvdW50XG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gKG9sZCBsb3dlcikubWluIChpKVxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IChvbGQgdXBwZXIpLm1heCAoaSlcbiAgICBlbmRcblxuICBmaWxsX3dpdGggKHY6IEcpXG4gICAgICAtLSBTZXQgaXRlbXMgYmV0d2VlbiBgbG93ZXInIGFuZCBgdXBwZXInIHdpdGggYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLmZpbGxfd2l0aCAodiwgMCwgdXBwZXIgLSBsb3dlcilcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBjb3VudF9kZWZpbml0aW9uOiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAodilcbiAgICBlbmRcblxuICBzdWJjb3B5IChvdGhlcjogQVJSQVkgW2xpa2UgaXRlbV07IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBpdGVtcyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gdG8gY3VycmVudCBhcnJheSBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBzdGFydF9wb3MgPj0gb3RoZXIubG93ZXJcbiAgICAgIHZhbGlkX2VuZF9wb3M6IGVuZF9wb3MgPD0gb3RoZXIudXBwZXJcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IGluZGV4X3BvcyA+PSBsb3dlclxuICAgICAgZW5vdWdoX3NwYWNlOiAodXBwZXIgLSBpbmRleF9wb3MpID49IChlbmRfcG9zIC0gc3RhcnRfcG9zKVxuICAgIGRvXG4gICAgICBhcmVhLmNvcHlfZGF0YSAob3RoZXIuYXJlYSwgc3RhcnRfcG9zIC0gb3RoZXIubG93ZXIsIGluZGV4X3BvcyAtIGxvd2VyLCBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICBlbnN1cmVcbiAgICAgIC0tIGNvcGllZDogZm9yYWxsIGBpJyBpbiAwIC4uIChgZW5kX3BvcyctYHN0YXJ0X3BvcycpLFxuICAgICAgLS0gICAgIGl0ZW0gKGluZGV4X3BvcyArIGkpID0gb3RoZXIuaXRlbSAoc3RhcnRfcG9zICsgaSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBJdGVyYXRpb25cblxuICBkb19hbGwgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYS5kb19hbGxfaW5fYm91bmRzIChhY3Rpb24sIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBkb19pZiAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0ddXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYS5kb19pZl9pbl9ib3VuZHMgKGFjdGlvbiwgdGVzdCwgMCwgY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIHRoZXJlX2V4aXN0cyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhdCBsZWFzdCBvbmUgaXRlbT9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEudGhlcmVfZXhpc3RzX2luX2JvdW5kcyAodGVzdCwgMCwgY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGZvcl9hbGwgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYWxsIGl0ZW1zP1xuICAgIHJlcXVpcmVcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5mb3JfYWxsX2luX2JvdW5kcyAodGVzdCwgMCwgY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGRvX2FsbF93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gYGFjdGlvbicgcmVjZWl2ZXMgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAwXG4gICAgICAgIGogOj0gbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYWN0aW9uLmNhbGwgKFtsX2FyZWEuaXRlbSAoaSksIGpdKVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2lmX3dpdGhfaW5kZXggKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHLCBJTlRFR0VSXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHLCBJTlRFR0VSXSwgQk9PTEVBTl0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gYGFjdGlvbicgYW5kIGB0ZXN0JyByZWNlaXZlIHRoZSBpdGVtIGFuZCBpdHMgaW5kZXguXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAwXG4gICAgICAgIGogOj0gbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaWYgdGVzdC5pdGVtIChbbF9hcmVhLml0ZW0gKGkpLCBqXSkgdGhlblxuICAgICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBNYWtlIGFycmF5IGVtcHR5LlxuICAgIG9ic29sZXRlXG4gICAgICBcIk5vdCBhcHBsaWNhYmxlIHNpbmNlIG5vdCBgcHJ1bmFibGUnLiBVc2UgYGRpc2NhcmRfaXRlbXMnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgZGlzY2FyZF9pdGVtc1xuICAgIGVuZFxuXG4gIGRpc2NhcmRfaXRlbXNcbiAgICAgIC0tIFJlc2V0IGFsbCBpdGVtcyB0byBkZWZhdWx0IHZhbHVlcyB3aXRoIHJlYWxsb2NhdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKCh7R30pLmRlZmF1bHQsIGNhcGFjaXR5KVxuICAgIGVuc3VyZVxuICAgICAgZGVmYXVsdF9pdGVtczogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBjbGVhcl9hbGxcbiAgICAgIC0tIFJlc2V0IGFsbCBpdGVtcyB0byBkZWZhdWx0IHZhbHVlcy5cbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIGFyZWEuY291bnQgLSAxKVxuICAgIGVuc3VyZVxuICAgICAgc3RhYmxlX2xvd2VyOiBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgc3RhYmxlX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgICAgZGVmYXVsdF9pdGVtczogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA8IGNvdW50IHRoZW5cbiAgICAgICAgdXBwZXIgOj0gbG93ZXIgKyBuIC0gMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAgc2FtZV9sb3dlcjogbG93ZXIgPSBvbGQgbG93ZXJcbiAgICBlbmRcblxuICBrZWVwX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbiA8IG5iIHRoZW5cbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYiAtIG4sIDAsIG4pXG4gICAgICAgIGxvd2VyIDo9IHVwcGVyIC0gbiArIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIHNhbWVfdXBwZXI6IHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3QgYG4nIGl0ZW1zO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyIC0gMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKDApXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCAtIG4pLm1heCAoMClcbiAgICAgIHNhbWVfdXBwZXI6IHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgbGFzdCBgbicgaXRlbXM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgdXBwZXIgOj0gbG93ZXIgLSAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAoMClcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF9oZWFkIChjb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSAob2xkIGNvdW50IC0gbikubWF4ICgwKVxuICAgICAgc2FtZV9sb3dlcjogbG93ZXIgPSBvbGQgbG93ZXJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGdyb3cgKGk6IElOVEVHRVIpXG4gICAgICAtLSBDaGFuZ2UgdGhlIGNhcGFjaXR5IHRvIGF0IGxlYXN0IGBpJy5cbiAgICBkb1xuICAgICAgaWYgaSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKCh7R30pLmRlZmF1bHQsIGxvd2VyLCB1cHBlciArIGkgLSBjYXBhY2l0eSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNvbnNlcnZhdGl2ZV9yZXNpemUgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIGFycmF5IHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBpbmRpY2VzIGRvd24gdG8gYG1pbl9pbmRleCcgYW5kIHVwIHRvIGBtYXhfaW5kZXgnLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBpdGVtLlxuICAgIG9ic29sZXRlXG4gICAgICBcIiBgY29uc2VydmF0aXZlX3Jlc2l6ZScgaXMgbm90IHZvaWQtc2FmZSBzdGF0aWNhbGx5LiBVc2UgYGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0JyBpbnN0ZWFkLiBbMDctMjAxMF1cIlxuICAgIHJlcXVpcmVcbiAgICAgIGdvb2RfaW5kaWNlczogbWluX2luZGV4IDw9IG1heF9pbmRleFxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0ICgoe0d9KS5kZWZhdWx0LCBtaW5faW5kZXgsIG1heF9pbmRleClcbiAgICBlbnN1cmVcbiAgICAgIG5vX2xvd19sb3N0OiBsb3dlciA9IG1pbl9pbmRleCBvciBlbHNlIGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBub19oaWdoX2xvc3Q6IHVwcGVyID0gbWF4X2luZGV4IG9yIGVsc2UgdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoYV9kZWZhdWx0X3ZhbHVlOiBHOyBtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBhcnJheSBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gaW5kaWNlcyBkb3duIHRvIGBtaW5faW5kZXgnIGFuZCB1cCB0byBgbWF4X2luZGV4Jy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgaXRlbS5cbiAgICByZXF1aXJlXG4gICAgICBnb29kX2luZGljZXM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXhcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIG5ld19sb3dlciwgbmV3X3VwcGVyOiBJTlRFR0VSXG4gICAgICBvZmZzZXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgZW1wdHlfYXJlYSB0aGVuXG4gICAgICAgIHNldF9hcmVhIChhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoYV9kZWZhdWx0X3ZhbHVlLCBtYXhfaW5kZXggLSBtaW5faW5kZXggKyAxKSlcbiAgICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICAgIHVwcGVyIDo9IG1heF9pbmRleFxuICAgICAgZWxzZVxuICAgICAgICBuZXdfbG93ZXIgOj0gbWluX2luZGV4Lm1pbiAobG93ZXIpXG4gICAgICAgIG5ld191cHBlciA6PSBtYXhfaW5kZXgubWF4ICh1cHBlcilcbiAgICAgICAgbmV3X3NpemUgOj0gbmV3X3VwcGVyIC0gbmV3X2xvd2VyICsgMVxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGFyZWEuY291bnQgdGhlblxuICAgICAgICAgIHNldF9hcmVhIChhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoYV9kZWZhdWx0X3ZhbHVlLCBuZXdfc2l6ZSkpXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBuZXdfbG93ZXIgPCBsb3dlciB0aGVuXG4gICAgICAgICAgb2Zmc2V0IDo9IGxvd2VyIC0gbmV3X2xvd2VyXG4gICAgICAgICAgYXJlYS5tb3ZlX2RhdGEgKDAsIG9mZnNldCwgdXBwZXIgLSBsb3dlciArIDEpXG4gICAgICAgICAgYXJlYS5maWxsX3dpdGggKGFfZGVmYXVsdF92YWx1ZSwgMCwgb2Zmc2V0IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGxvd2VyIDo9IG5ld19sb3dlclxuICAgICAgICB1cHBlciA6PSBuZXdfdXBwZXJcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbm9fbG93X2xvc3Q6IGxvd2VyID0gbWluX2luZGV4IG9yIGVsc2UgbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIG5vX2hpZ2hfbG9zdDogdXBwZXIgPSBtYXhfaW5kZXggb3IgZWxzZSB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2UgYXJyYXkgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGluZGljZXMgZG93biB0byBgbWluX2luZGV4JyBhbmQgdXAgdG8gYG1heF9pbmRleCcuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGl0ZW0uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCcgaW5zdGVhZCBhcyBmdXR1cmUgdmVyc2lvbnMgd2lsbCBpbXBsZW1lbnQgYHJlc2l6ZScgYXMgc3BlY2lmaWVkIGluIEVMS1MuXCJcbiAgICByZXF1aXJlXG4gICAgICBnb29kX2luZGljZXM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXhcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoKHtHfSkuZGVmYXVsdCwgbWluX2luZGV4LCBtYXhfaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBub19sb3dfbG9zdDogbG93ZXIgPSBtaW5faW5kZXggb3IgZWxzZSBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgbm9faGlnaF9sb3N0OiB1cHBlciA9IG1heF9pbmRleCBvciBlbHNlIHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuIDo9IGNvdW50XG4gICAgICBpZiBuIDwgYXJlYS5jYXBhY2l0eSB0aGVuXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYW1lX2l0ZW1zOiBzYW1lX2l0ZW1zIChvbGQgdHdpbilcbiAgICBlbmRcblxuICByZWJhc2UgKGFfbG93ZXI6IGxpa2UgbG93ZXIpXG4gICAgICAtLSBXaXRob3V0IGNoYW5naW5nIHRoZSBhY3R1YWwgY29udGVudCBvZiBgQ3VycmVudCcgd2Ugc2V0IGBsb3dlcicgdG8gYGFfbG93ZXInXG4gICAgICAtLSBhbmQgYHVwcGVyJyBhY2NvcmRpbmdseSB0byBgYV9sb3dlciArIGNvdW50IC0gMScuXG4gICAgbG9jYWxcbiAgICAgIGxfb2xkX2xvd2VyOiBsaWtlIGxvd2VyXG4gICAgZG9cbiAgICAgIGxfb2xkX2xvd2VyIDo9IGxvd2VyXG4gICAgICBsb3dlciA6PSBhX2xvd2VyXG4gICAgICB1cHBlciA6PSBhX2xvd2VyICsgKHVwcGVyIC0gbF9vbGRfbG93ZXIpXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gYV9sb3dlclxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IGFfbG93ZXIgKyBvbGQgY291bnQgLSAxXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX2M6IEFOWVxuICAgICAgLS0gQWRkcmVzcyBvZiBhY3R1YWwgc2VxdWVuY2Ugb2YgdmFsdWVzLFxuICAgICAgLS0gZm9yIHBhc3NpbmcgdG8gZXh0ZXJuYWwgKG5vbi1FaWZmZWwpIHJvdXRpbmVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYVxuICAgIGVuZFxuXG4gIHRvX2NpbDogTkFUSVZFX0FSUkFZIFtHXVxuICAgICAgLS0gQWRkcmVzcyBvZiBhY3R1YWwgc2VxdWVuY2Ugb2YgdmFsdWVzLFxuICAgICAgLS0gZm9yIHBhc3NpbmcgdG8gZXh0ZXJuYWwgKG5vbi1FaWZmZWwpIHJvdXRpbmVzLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEubmF0aXZlX2FycmF5XG4gICAgZW5zdXJlXG4gICAgICB0b19jaWxfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgdG9fc3BlY2lhbDogU1BFQ0lBTCBbR11cbiAgICAgIC0tICdhcmVhJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFcbiAgICBlbnN1cmVcbiAgICAgIHRvX3NwZWNpYWxfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0ddXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgdGVtcDogQVJSQVlFRF9MSVNUIFtHXVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBsb3dlclxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IHVwcGVyXG4gICAgICBsb29wXG4gICAgICAgIHRlbXAuZXh0ZW5kIChpdGVtIChpKSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gdGVtcFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIGFsbCB0aGUgaXRlbXMgb2YgYG90aGVyJy5cbiAgICAgIC0tIChUaGlzIGlzIGFsc28gdXNlZCBieSBgY2xvbmUnLilcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIHN0YW5kYXJkX2NvcHkgKG90aGVyKVxuICAgICAgICBzZXRfYXJlYSAob3RoZXIuYXJlYS50d2luKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGVxdWFsX2FyZWFzOiBhcmVhIH4gb3RoZXIuYXJlYVxuICAgIGVuZFxuXG4gIHN1YmFycmF5IChzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpOiBBUlJBWSBbR11cbiAgICAgIC0tIEFycmF5IG1hZGUgb2YgaXRlbXMgb2YgY3VycmVudCBhcnJheSB3aXRoaW5cbiAgICAgIC0tIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X3BvczogdmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IGVuZF9wb3MgPD0gdXBwZXJcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgZG9cbiAgICAgIGlmIHN0YXJ0X3BvcyA8PSBlbmRfcG9zIHRoZW5cbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoaXRlbSAoc3RhcnRfcG9zKSwgc3RhcnRfcG9zLCBlbmRfcG9zKVxuICAgICAgICAgIC0tIE9ubHkgY29weSBlbGVtZW50cyBpZiBuZWVkZWQuXG4gICAgICAgIFJlc3VsdC5zdWJjb3B5IChDdXJyZW50LCBzdGFydF9wb3MsIGVuZF9wb3MsIHN0YXJ0X3BvcylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBtYWtlIGVtcHR5XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eVxuICAgICAgICBSZXN1bHQucmViYXNlIChzdGFydF9wb3MpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyOiBSZXN1bHQubG93ZXIgPSBzdGFydF9wb3NcbiAgICAgIHVwcGVyOiBSZXN1bHQudXBwZXIgPSBlbmRfcG9zXG4gICAgICAtLSBjb3BpZWQ6IGZvcmFsbCBgaScgaW4gYHN0YXJ0X3BvcycgLi4gYGVuZF9wb3MnLFxuICAgICAgLS0gICAgIFJlc3VsdC5pdGVtIChpKSA9IGl0ZW0gKGkpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluYXBwbGljYWJsZVxuXG4gIHBydW5lICh2OiBHKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHYnIGlmIGFueS5cbiAgICAgIC0tIChQcmVjb25kaXRpb24gaXMgRmFsc2UuKVxuICAgIGRvXG4gICAgZW5kXG5cbiAgZXh0ZW5kICh2OiBHKVxuICAgICAgLS0gQWRkIGB2JyB0byBzdHJ1Y3R1cmUuXG4gICAgICAtLSAoUHJlY29uZGl0aW9uIGlzIEZhbHNlLilcbiAgICBkb1xuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVtcHR5X2FyZWE6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBhcmVhJyBlbXB0eT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEgPSBWb2lkIG9yIGVsc2UgYXJlYS5jYXBhY2l0eSA9IDBcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgYXJlYV9leGlzdHM6IGFyZWEgLz0gVm9pZFxuICBjb25zaXN0ZW50X3NpemU6IGNhcGFjaXR5ID0gdXBwZXIgLSBsb3dlciArIDFcbiAgbm9uX25lZ2F0aXZlX2NvdW50OiBjb3VudCA+PSAwXG4gIGluZGV4X3NldF9oYXNfc2FtZV9jb3VudDogdmFsaWRfaW5kZXhfc2V0XG4tLSBJbnRlcm5hbCBkaXNjdXNzaW9uIGhhdmVuJ3QgcmVhY2hlZCBhbiBhZ3JlZW1lbnQgb24gdGhpcyBpbnZhcmlhbnRcbi0tICBpbmRleF9zZXRfaGFzX3NhbWVfYm91bmRzOiAoKGluZGV4X3NldC5sb3dlciA9IGxvd2VyKSBhbmRcbi0tICAgICAgICAoaW5kZXhfc2V0LnVwcGVyID0gbG93ZXIgKyBjb3VudCAtIDEpKVxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiTGlzdHMgaW1wbGVtZW50ZWQgYnkgcmVzaXphYmxlIGFycmF5c1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHNlcXVlbmNlO1xuICByZXByZXNlbnRhdGlvbjogYXJyYXk7XG4gIGFjY2VzczogaW5kZXgsIGN1cnNvciwgbWVtYmVyc2hpcDtcbiAgc2l6ZTogZml4ZWQ7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3MgQVJSQVlFRF9MSVNUIFtHXSBpbmhlcml0XG5cbiAgVE9fU1BFQ0lBTCBbR11cbiAgICByZW5hbWVcbiAgICAgIHB1dCBhcyBhcnJheV9wdXQsXG4gICAgICBhdCBhcyBhcnJheV9hdCxcbiAgICAgIGl0ZW0gYXMgYXJyYXlfaXRlbSxcbiAgICAgIHZhbGlkX2luZGV4IGFzIGFycmF5X3ZhbGlkX2luZGV4LFxuICAgICAgYXJlYSBhcyBhcmVhX3YyXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBjb3B5XG4gICAgZW5kXG5cbiAgUkVTSVpBQkxFIFtHXVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbCwgY29weVxuICAgIGVuZFxuXG4gIERZTkFNSUNfTElTVCBbR11cbiAgICB1bmRlZmluZVxuICAgICAgcHV0X2lfdGgsXG4gICAgICBmb3JjZSwgaXNfaW5zZXJ0ZWQsIGNvcHlcbiAgICByZWRlZmluZVxuICAgICAgZmlyc3QsIGxhc3QsIHN3YXAsIHdpcGVfb3V0LCBpX3RoLCBhdCxcbiAgICAgIGdvX2lfdGgsIG1vdmUsIHBydW5hYmxlLCBzdGFydCwgZmluaXNoLFxuICAgICAgY291bnQsIHBydW5lLCByZW1vdmUsXG4gICAgICBwdXRfbGVmdCwgbWVyZ2VfbGVmdCxcbiAgICAgIG1lcmdlX3JpZ2h0LCBkdXBsaWNhdGUsIHBydW5lX2FsbCwgaGFzLCBzZWFyY2gsXG4gICAgICBhcHBlbmQsIHZhbGlkX2luZGV4LCBpc19lcXVhbCwgY29weSxcbiAgICAgIGZvcl9hbGwsIHRoZXJlX2V4aXN0cywgZG9fYWxsLCBkb19pZlxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbCwgY29weSwgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSwgbWFrZV9maWxsZWQsIG1ha2VfZnJvbV9hcnJheVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGxpc3Qgd2l0aCBgbicgaXRlbXMuXG4gICAgICAtLSAoYG4nIG1heSBiZSB6ZXJvIGZvciBlbXB0eSBsaXN0LilcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9udW1iZXJfb2ZfaXRlbXM6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpbmRleCA6PSAwXG4gICAgICBjcmVhdGUgYXJlYV92Mi5tYWtlX2VtcHR5IChuKVxuICAgIGVuc3VyZVxuICAgICAgY29ycmVjdF9wb3NpdGlvbjogYmVmb3JlXG4gICAgICBpc19lbXB0eTogaXNfZW1wdHlcbiAgICBlbmRcblxuICBtYWtlX2ZpbGxlZCAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGxpc3Qgd2l0aCBgbicgaXRlbXMuXG4gICAgICAtLSAoYG4nIG1heSBiZSB6ZXJvIGZvciBlbXB0eSBsaXN0LilcbiAgICAgIC0tIFRoaXMgbGlzdCB3aWxsIGJlIGZ1bGwuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfbnVtYmVyX29mX2l0ZW1zOiBuID49IDBcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBpbmRleCA6PSAwXG4gICAgICBtYWtlX2ZpbGxlZF9hcmVhICgoe0d9KS5kZWZhdWx0LCBuKVxuICAgIGVuc3VyZVxuICAgICAgY29ycmVjdF9wb3NpdGlvbjogYmVmb3JlXG4gICAgICBmaWxsZWQ6IGZ1bGxcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYXJyYXkgKGE6IEFSUkFZIFtHXSlcbiAgICAgIC0tIENyZWF0ZSBsaXN0IGZyb20gYXJyYXkgYGEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFycmF5X2V4aXN0czogYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IDBcbiAgICAgIGFyZWFfdjIgOj0gYS5hcmVhXG4gICAgZW5zdXJlXG4gICAgICBzaGFyZWQ6IGFyZWEgPSBhLmFyZWFcbiAgICAgIGNvcnJlY3RfcG9zaXRpb246IGJlZm9yZVxuICAgICAgZmlsbGVkOiBjb3VudCA9IGEuY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBhcmVhOiBTUEVDSUFMIFtHXVxuICAgICAgLS0gQWNjZXNzIHRvIGludGVybmFsIHN0b3JhZ2Ugb2YgQVJSQVlFRF9MSVNUXG4gICAgZG9cbiAgICAgICAgLS0gSW50ZXJuYWwgc3RvcmFnZSBpcyBjYWxsZWQgYGFyZWFfdjInIHNvIHRoYXQgaXQgdHJpZ2dlcnNcbiAgICAgICAgLS0gYSBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmFsLlxuICAgICAgUmVzdWx0IDo9IGFyZWFfdjJcbiAgICBlbmRcblxuICBpdGVtOiBHXG4gICAgICAtLSBDdXJyZW50IGl0ZW1cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIGluZGV4X2lzX3ZhbGlkOiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLml0ZW0gKGluZGV4IC0gMSlcbiAgICBlbmRcblxuICBpX3RoIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBsaWtlIGl0ZW0gYXNzaWduIHB1dF9pX3RoXG4gICAgICAtLSBJdGVtIGF0IGBpJy10aCBwb3NpdGlvblxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV92Mi5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBmaXJzdDogbGlrZSBpdGVtXG4gICAgICAtLSBJdGVtIGF0IGZpcnN0IHBvc2l0aW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLml0ZW0gKDApXG4gICAgZW5kXG5cbiAgbGFzdDogbGlrZSBmaXJzdFxuICAgICAgLS0gSXRlbSBhdCBsYXN0IHBvc2l0aW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLml0ZW0gKGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBpbmRleDogSU5URUdFUlxuICAgICAgLS0gSW5kZXggb2YgYGl0ZW0nLCBpZiB2YWxpZC5cblxuICBjdXJzb3I6IEFSUkFZRURfTElTVF9DVVJTT1JcbiAgICAgIC0tIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaW5kZXgpXG4gICAgZW5kXG5cbiAgaGFzICh2OiBsaWtlIGl0ZW0pOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgaW5jbHVkZSBgdic/XG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYV92MlxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9hcmVhIDo9IGFyZWFfdjJcbiAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gYW5kIHYgLz0gVm9pZCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBSZXN1bHQgOj0gdiB+IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBSZXN1bHQgOj0gdiA9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19hcnJheTogQVJSQVkgW0ddXG4gICAgICAtLSBTaGFyZSBjb250ZW50IHRvIGJlIHVzZWQgYXMgYW4gQVJSQVkuXG4gICAgICAtLSBOb3RlIHRoYXQgYWx0aG91Z2ggdGhlIGNvbnRlbnQgaXMgc2hhcmVkLCBpdCBtaWdodFxuICAgICAgLS0gbm90IGJlIHNoYXJlZCB3aGVuIGEgcmVzaXppbmcgb2NjdXIgaW4gZWl0aGVyIEFSUkFZIG9yIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3NwZWNpYWwgKGFyZWFfdjIpXG4gICAgZW5zdXJlXG4gICAgICB0b19hcnJheV9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGFycmF5X2xvd2VyX3NldDogUmVzdWx0Lmxvd2VyID0gMVxuICAgICAgYXJyYXlfdXBwZXJfc2V0OiBSZXN1bHQudXBwZXIgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IFJlc3VsdC5hcmVhID0gYXJlYVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEl0ZXJhdGlvblxuXG4gIGRvX2FsbCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0ddXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgZG9cbiAgICAgIGFyZWFfdjIuZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uLCAwLCBhcmVhX3YyLmNvdW50IC0gMSlcbiAgICBlbmRcblxuICBkb19pZiAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0ddXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICBkb1xuICAgICAgYXJlYV92Mi5kb19pZl9pbl9ib3VuZHMgKGFjdGlvbiwgdGVzdCwgMCwgYXJlYV92Mi5jb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgdGhlcmVfZXhpc3RzICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGF0IGxlYXN0IG9uZSBpdGVtP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV92Mi50aGVyZV9leGlzdHNfaW5fYm91bmRzICh0ZXN0LCAwLCBhcmVhX3YyLmNvdW50IC0gMSlcbiAgICBlbmRcblxuICBmb3JfYWxsICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGFsbCBpdGVtcz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuZm9yX2FsbF9pbl9ib3VuZHMgKHRlc3QsIDAsIGFyZWFfdjIuY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGRvX2FsbF93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gYGFjdGlvbicgcmVjZWl2ZXMgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYV92MlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYV92MlxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl0sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIGFuZCBgdGVzdCcgcmVjZWl2ZSB0aGUgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYV92MlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYV92MlxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2xfYXJlYS5pdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2xfYXJlYS5pdGVtIChpKSwgal0pXG4gICAgICAgIGVuZFxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgbG93ZXI6IElOVEVHRVIgPSAxXG4gICAgICAtLSBMb3dlciBib3VuZCBmb3IgYWNjZXNzaW5nIGxpc3QgaXRlbXMgdmlhIGluZGV4ZXNcblxuICB1cHBlcjogSU5URUdFUlxuICAgICAgLS0gVXBwZXIgYm91bmQgZm9yIGFjY2Vzc2luZyBsaXN0IGl0ZW1zIHZpYSBpbmRleGVzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLmNvdW50XG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBpdGVtc1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV92Mi5jb3VudFxuICAgIGVuZFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLmNhcGFjaXR5XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYXJyYXkgbWFkZSBvZiB0aGUgc2FtZSBpdGVtcyBhcyBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlaWYgY291bnQgPSBvdGhlci5jb3VudCBhbmQgdGhlbiBvYmplY3RfY29tcGFyaXNvbiA9IG90aGVyLm9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIG5vdCBSZXN1bHQgb3IgaSA+IHVwcGVyXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgUmVzdWx0IDo9IGlfdGggKGkpIH4gb3RoZXIuaV90aCAoaSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLnNhbWVfaXRlbXMgKG90aGVyLmFyZWFfdjIsIDAsIDAsIGNvdW50KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgdmFsaWRfY3Vyc29yIChwOiBDVVJTT1IpOiBCT09MRUFOXG4gICAgICAtLSBDYW4gdGhlIGN1cnNvciBiZSBtb3ZlZCB0byBwb3NpdGlvbiBgcCc/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtBUlJBWUVEX0xJU1RfQ1VSU09SfSBwIGFzIGFsX2MgdGhlblxuICAgICAgICBSZXN1bHQgOj0gdmFsaWRfY3Vyc29yX2luZGV4IChhbF9jLmluZGV4KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgYSB2YWxpZCBpbmRleD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9ICgxIDw9IGkpIGFuZCAoaSA8PSBjb3VudClcbiAgICBlbmRcblxuICBpc19pbnNlcnRlZCAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIEhhcyBgdicgYmVlbiBpbnNlcnRlZCBhdCB0aGUgZW5kIGJ5IHRoZSBtb3N0IHJlY2VudCBgcHV0JyBvclxuICAgICAgLS0gYGV4dGVuZCc/XG4gICAgZG9cbiAgICAgIGlmIG5vdCBpc19lbXB0eSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodiA9IGxhc3QpIG9yIGVsc2UgKG5vdCBvZmYgYW5kIHRoZW4gKHYgPSBpdGVtKSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFsbF9kZWZhdWx0OiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIHNldCB0byBkZWZhdWx0IHZhbHVlcz9cbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuZmlsbGVkX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIGFyZWFfdjIudXBwZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgbW92ZSAoaTogSU5URUdFUilcbiAgICAgIC0tIE1vdmUgY3Vyc29yIGBpJyBwb3NpdGlvbnMuXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IGluZGV4ICsgaVxuICAgICAgaWYgKGluZGV4ID4gY291bnQgKyAxKSB0aGVuXG4gICAgICAgIGluZGV4IDo9IGNvdW50ICsgMVxuICAgICAgZWxzZWlmIChpbmRleCA8IDApIHRoZW5cbiAgICAgICAgaW5kZXggOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc3RhcnRcbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIGZpcnN0IHBvc2l0aW9uIGlmIGFueS5cbiAgICBkb1xuICAgICAgaW5kZXggOj0gMVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBhZnRlcl93aGVuX2VtcHR5OiBpc19lbXB0eSBpbXBsaWVzIGFmdGVyXG4gICAgZW5kXG5cbiAgZmluaXNoXG4gICAgICAtLSBNb3ZlIGN1cnNvciB0byBsYXN0IHBvc2l0aW9uIGlmIGFueS5cbiAgICBkb1xuICAgICAgaW5kZXggOj0gY291bnRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgYmVmb3JlX3doZW5fZW1wdHk6IGlzX2VtcHR5IGltcGxpZXMgYmVmb3JlXG4gICAgZW5kXG5cbiAgZm9ydGhcbiAgICAgIC0tIE1vdmUgY3Vyc29yIG9uZSBwb3NpdGlvbiBmb3J3YXJkLlxuICAgIGRvXG4gICAgICBpbmRleCA6PSBpbmRleCArIDFcbiAgICBlbmRcblxuICBiYWNrXG4gICAgICAtLSBNb3ZlIGN1cnNvciBvbmUgcG9zaXRpb24gYmFja3dhcmQuXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IGluZGV4IC0gMVxuICAgIGVuZFxuXG4gIGdvX2lfdGggKGk6IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGN1cnNvciB0byBgaSctdGggcG9zaXRpb24uXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IGlcbiAgICBlbmRcblxuICBnb190byAocDogQ1VSU09SKVxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gcG9zaXRpb24gYHAnLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7QVJSQVlFRF9MSVNUX0NVUlNPUn0gcCBhcyBhbF9jIHRoZW5cbiAgICAgICAgaW5kZXggOj0gYWxfYy5pbmRleFxuICAgICAgZWxzZVxuICAgICAgICBjaGVja1xuICAgICAgICAgIGNvcnJlY3RfY3Vyc29yX3R5cGU6IEZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2VhcmNoICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBNb3ZlIHRvIGZpcnN0IHBvc2l0aW9uIChhdCBvciBhZnRlciBjdXJyZW50XG4gICAgICAtLSBwb3NpdGlvbikgd2hlcmUgYGl0ZW0nIGFuZCBgdicgYXJlIGVxdWFsLlxuICAgICAgLS0gSWYgc3RydWN0dXJlIGRvZXMgbm90IGluY2x1ZGUgYHYnIGVuc3VyZSB0aGF0XG4gICAgICAtLSBgZXhoYXVzdGVkJyB3aWxsIGJlIHRydWUuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYV92MlxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfZm91bmQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgbF9hcmVhIDo9IGFyZWFfdjJcbiAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICAtLSBJZiB3ZSBhcmUgYmVmb3JlIHdlIG5lZWQgdG8gYmUgc3VyZVxuICAgICAgICAtLSB0aGF0IGkgaXMgcG9zaXRpdmUuXG4gICAgICBpIDo9IChpbmRleCAtIDEpLm1heCAoMClcbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIGFuZCB2IC89IFZvaWQgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIGxfZm91bmRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfZm91bmQgOj0gdiB+IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgbF9mb3VuZFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9mb3VuZCA6PSB2ID0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgICAtLSBTZXQgcG9zaXRpb24gb2YgYGluZGV4JyB0byBgaScsIGxvY2F0aW9uIG9mIGl0ZW0gd2hlblxuICAgICAgICAtLSBmb3VuZCwgb3RoZXJ3aXNlIHRvIGBpICsgMScgd2hpY2ggY29ycmVzcG9uZHMgdG8gYGFmdGVyJy5cbiAgICAgIGlmIGxfZm91bmQgdGhlblxuICAgICAgICBpbmRleCA6PSBpXG4gICAgICBlbHNlXG4gICAgICAgIGluZGV4IDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dF9mcm9udCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byB0aGUgYmVnaW5uaW5nLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGRvXG4gICAgICBpZiBpc19lbXB0eSB0aGVuXG4gICAgICAgIGV4dGVuZCAodilcbiAgICAgIGVsc2VcbiAgICAgICAgaW5zZXJ0ICh2LCAxKVxuICAgICAgZW5kXG4gICAgICBpbmRleCA6PSBpbmRleCArIDFcbiAgICBlbmRcblxuICBwdXRfaV90aCAodjogbGlrZSBpX3RoOyBpOiBJTlRFR0VSXzMyKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgZG9cbiAgICAgIGFyZWFfdjIucHV0ICh2LCBpIC0gMSlcbiAgICBlbmRcblxuICBmb3JjZSwgZXh0ZW5kICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIGVuZC5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFfdjJcbiAgICBkb1xuICAgICAgaSA6PSBjb3VudCArIDFcbiAgICAgIGxfYXJlYSA6PSBhcmVhX3YyXG4gICAgICBpZiBpID4gbF9hcmVhLmNhcGFjaXR5IHRoZW5cbiAgICAgICAgbF9hcmVhIDo9IGxfYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAoaSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGFyZWFfdjIgOj0gbF9hcmVhXG4gICAgICBlbmRcbiAgICAgIGxfYXJlYS5leHRlbmQgKHYpXG4gICAgZW5kXG5cbiAgcHV0X2xlZnQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIEFkZCBgdicgdG8gdGhlIGxlZnQgb2YgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBkb1xuICAgICAgaWYgYWZ0ZXIgb3IgaXNfZW1wdHkgdGhlblxuICAgICAgICBleHRlbmQgKHYpXG4gICAgICBlbHNlXG4gICAgICAgIGluc2VydCAodiwgaW5kZXgpXG4gICAgICBlbmRcbiAgICAgIGluZGV4IDo9IGluZGV4ICsgMVxuICAgIGVuZFxuXG4gIHB1dF9yaWdodCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byB0aGUgcmlnaHQgb2YgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBkb1xuICAgICAgaWYgaW5kZXggPSBjb3VudCB0aGVuXG4gICAgICAgIGV4dGVuZCAodilcbiAgICAgIGVsc2VcbiAgICAgICAgaW5zZXJ0ICh2LCBpbmRleCArIDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXBsYWNlICh2OiBsaWtlIGZpcnN0KVxuICAgICAgLS0gUmVwbGFjZSBjdXJyZW50IGl0ZW0gYnkgYHYnLlxuICAgIGRvXG4gICAgICBwdXRfaV90aCAodiwgaW5kZXgpXG4gICAgZW5kXG5cbiAgbWVyZ2VfbGVmdCAob3RoZXI6IEFSUkFZRURfTElTVCBbR10pXG4gICAgICAtLSBNZXJnZSBgb3RoZXInIGludG8gY3VycmVudCBzdHJ1Y3R1cmUgYmVmb3JlIGN1cnNvci5cbiAgICBsb2NhbFxuICAgICAgb2xkX2luZGV4OiBJTlRFR0VSXG4gICAgICBvbGRfb3RoZXJfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgb2xkX2luZGV4IDo9IGluZGV4XG4gICAgICBvbGRfb3RoZXJfY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgIGluZGV4IDo9IGluZGV4IC0gMVxuICAgICAgbWVyZ2VfcmlnaHQgKG90aGVyKVxuICAgICAgaW5kZXggOj0gb2xkX2luZGV4ICsgb2xkX290aGVyX2NvdW50XG4gICAgZW5kXG5cbiAgbWVyZ2VfcmlnaHQgKG90aGVyOiBBUlJBWUVEX0xJU1QgW0ddKVxuICAgICAgLS0gTWVyZ2UgYG90aGVyJyBpbnRvIGN1cnJlbnQgc3RydWN0dXJlIGFmdGVyIGN1cnNvci5cbiAgICBsb2NhbFxuICAgICAgbF9uZXdfY291bnQsIGxfb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG5vdCBvdGhlci5pc19lbXB0eSB0aGVuXG4gICAgICAgIGxfb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X2NvdW50IDo9IGxfb2xkX2NvdW50ICsgb3RoZXIuY291bnRcbiAgICAgICAgaWYgbF9uZXdfY291bnQgPiBhcmVhX3YyLmNhcGFjaXR5IHRoZW5cbiAgICAgICAgICBhcmVhX3YyIDo9IGFyZWFfdjIuYWxpYXNlZF9yZXNpemVkX2FyZWEgKGxfbmV3X2NvdW50KVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYV92Mi5pbnNlcnRfZGF0YSAob3RoZXIuYXJlYV92MiwgMCwgaW5kZXgsIG90aGVyLmNvdW50KVxuICAgICAgICBvdGhlci53aXBlX291dFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kIChzOiBTRVFVRU5DRSBbR10pXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJy5cbiAgICBsb2NhbFxuICAgICAgYywgb2xkX2NvdW50LCBuZXdfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0FSUkFZRURfTElTVCBbR119IHMgYXMgYWwgdGhlbiAtLSBPcHRpbWl6YXRpb24gZm9yIGFycmF5ZWQgbGlzdHNcbiAgICAgICAgYyA6PSBhbC5jb3VudFxuICAgICAgICAgIC0tIElmIGBzJyBpcyBlbXB0eSBub3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgICBvbGRfY291bnQgOj0gY291bnRcbiAgICAgICAgICBuZXdfY291bnQgOj0gb2xkX2NvdW50ICsgYWwuY291bnRcbiAgICAgICAgICBpZiBuZXdfY291bnQgPiBhcmVhX3YyLmNhcGFjaXR5IHRoZW5cbiAgICAgICAgICAgIGFyZWFfdjIgOj0gYXJlYV92Mi5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobmV3X2NvdW50KVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGFyZWFfdjIuY29weV9kYXRhIChhbC5hcmVhX3YyLCAwLCBvbGRfY291bnQsIGMpXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige0RZTkFNSUNfTElTVH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGdyb3cgKGk6IElOVEVHRVIpXG4gICAgICAtLSBDaGFuZ2UgdGhlIGNhcGFjaXR5IHRvIGF0IGxlYXN0IGBpJy5cbiAgICBkb1xuICAgICAgaWYgaSA+IGFyZWFfdjIuY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhX3YyIDo9IGFyZWFfdjIuYWxpYXNlZF9yZXNpemVkX2FyZWEgKGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXNpemUgKG5ld19jYXBhY2l0eTogSU5URUdFUilcbiAgICAgIC0tIFJlc2l6ZSBsaXN0IHNvIHRoYXQgaXQgY2FuIGNvbnRhaW5cbiAgICAgIC0tIGF0IGxlYXN0IGBuJyBpdGVtcy4gRG8gbm90IGxvc2UgYW55IGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgcmVzaXphYmxlOiByZXNpemFibGVcbiAgICAgIG5ld19jYXBhY2l0eV9sYXJnZV9lbm91Z2g6IG5ld19jYXBhY2l0eSA+PSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBncm93IChuZXdfY2FwYWNpdHkpXG4gICAgZW5zdXJlXG4gICAgICBjYXBhY2l0eV9zZXQ6IGNhcGFjaXR5ID49IG5ld19jYXBhY2l0eVxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGFyZWFfdjIuY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhX3YyIDo9IGFyZWFfdjIuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9pdGVtczogdG9fYXJyYXkuc2FtZV9pdGVtcyAob2xkIHRvX2FycmF5KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIGFsbCB0aGUgaXRlbXMgb2YgYG90aGVyJy5cbiAgICAgIC0tIChUaGlzIGlzIGFsc28gdXNlZCBieSBgY2xvbmUnLilcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIHN0YW5kYXJkX2NvcHkgKG90aGVyKVxuICAgICAgICBzZXRfYXJlYSAob3RoZXIuYXJlYV92Mi50d2luKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGVxdWFsX2FyZWFzOiBhcmVhX3YyIH4gb3RoZXIuYXJlYV92MlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICBwcnVuZSAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHYnLCBpZiBhbnksXG4gICAgICAtLSBhZnRlciBjdXJzb3IgcG9zaXRpb24uXG4gICAgICAtLSBNb3ZlIGN1cnNvciB0byByaWdodCBuZWlnaGJvci5cbiAgICAgIC0tIChvciBgYWZ0ZXInIGlmIG5vIHJpZ2h0IG5laWdoYm9yIG9yIGB2JyBkb2VzIG5vdCBvY2N1cilcbiAgICBkb1xuICAgICAgaWYgYmVmb3JlIHRoZW5cbiAgICAgICAgaW5kZXggOj0gMVxuICAgICAgZW5kXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBhZnRlciBvciBlbHNlIGl0ZW0gfiB2XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBmb3J0aFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGFmdGVyIG9yIGVsc2UgaXRlbSA9IHZcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGZvcnRoXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiBub3QgYWZ0ZXIgdGhlblxuICAgICAgICByZW1vdmVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlbW92ZVxuICAgICAgLS0gUmVtb3ZlIGN1cnJlbnQgaXRlbS5cbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIHJpZ2h0IG5laWdoYm9yXG4gICAgICAtLSAob3IgYGFmdGVyJyBpZiBubyByaWdodCBuZWlnaGJvcilcbiAgICBkb1xuICAgICAgaWYgaW5kZXggPCBjb3VudCB0aGVuXG4gICAgICAgIGFyZWFfdjIubW92ZV9kYXRhIChpbmRleCwgaW5kZXggLSAxLCBjb3VudCAtIGluZGV4KVxuICAgICAgZW5kXG4gICAgICBhcmVhX3YyLnJlbW92ZV90YWlsICgxKVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpbmRleDogaW5kZXggPSBvbGQgaW5kZXhcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIFJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgYHYnLlxuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG9mZnNldDogSU5URUdFUlxuICAgICAgcmVzOiBCT09MRUFOXG4gICAgICBvYmpfY21wOiBCT09MRUFOXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYV92MlxuICAgIGRvXG4gICAgICBvYmpfY21wIDo9IG9iamVjdF9jb21wYXJpc29uXG4gICAgICBmcm9tXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhX3YyXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IGNvdW50XG4gICAgICBsb29wXG4gICAgICAgIGlmIGkgPCBuYiAtIG9mZnNldCB0aGVuXG4gICAgICAgICAgaWYgb2Zmc2V0ID4gMCB0aGVuXG4gICAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAoaSArIG9mZnNldCksIGkpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaWYgb2JqX2NtcCB0aGVuXG4gICAgICAgICAgICByZXMgOj0gdiB+IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlcyA6PSB2ID0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaWYgcmVzIHRoZW5cbiAgICAgICAgICAgIG9mZnNldCA6PSBvZmZzZXQgKyAxXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhLnJlbW92ZV90YWlsIChvZmZzZXQpXG4gICAgICBpbmRleCA6PSBjb3VudCArIDFcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXNfYWZ0ZXI6IGFmdGVyXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2xlZnRcbiAgICAgIC0tIFJlbW92ZSBpdGVtIHRvIHRoZSBsZWZ0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBkb1xuICAgICAgaW5kZXggOj0gaW5kZXggLSAxXG4gICAgICByZW1vdmVcbiAgICBlbmRcblxuICByZW1vdmVfcmlnaHRcbiAgICAgIC0tIFJlbW92ZSBpdGVtIHRvIHRoZSByaWdodCBvZiBjdXJzb3IgcG9zaXRpb25cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvclxuICAgIGRvXG4gICAgICBpbmRleCA6PSBpbmRleCArIDFcbiAgICAgIHJlbW92ZVxuICAgICAgaW5kZXggOj0gaW5kZXggLSAxXG4gICAgZW5kXG5cbiAgd2lwZV9vdXRcbiAgICAgIC0tIFJlbW92ZSBhbGwgaXRlbXMuXG4gICAgZG9cbiAgICAgIGFyZWFfdjIud2lwZV9vdXRcbiAgICAgIGluZGV4IDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBUcmFuc2Zvcm1hdGlvblxuXG4gIHN3YXAgKGk6IElOVEVHRVIpXG4gICAgICAtLSBFeGNoYW5nZSBpdGVtIGF0IGBpJy10aCBwb3NpdGlvbiB3aXRoIGl0ZW1cbiAgICAgIC0tIGF0IGN1cnNvciBwb3NpdGlvbi5cbiAgICBsb2NhbFxuICAgICAgb2xkX2l0ZW06IGxpa2UgaXRlbVxuICAgIGRvXG4gICAgICBvbGRfaXRlbSA6PSBpdGVtXG4gICAgICByZXBsYWNlIChhcmVhX3YyLml0ZW0gKGkgLSAxKSlcbiAgICAgIGFyZWFfdjIucHV0IChvbGRfaXRlbSwgaSAtIDEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmV0cmlldmFsXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmXG4gICAgICAgIG5vdCBtaXNtYXRjaF9pbmZvcm1hdGlvbi5oYXMgKFwiYXJlYV92MlwiKSBhbmQgdGhlblxuICAgICAgICBhdHRhY2hlZCB7U1BFQ0lBTCBbR119IG1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKFwiYXJlYVwiKSBhcyBsX2FyZWEgYW5kIHRoZW5cbiAgICAgICAgYXR0YWNoZWQge0lOVEVHRVJ9IG1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKFwiY291bnRcIikgYXMgbF9jb3VudCBhbmQgdGhlblxuICAgICAgICBhdHRhY2hlZCB7Qk9PTEVBTn0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJvYmplY3RfY29tcGFyaXNvblwiKSBhcyBsX2NvbXAgYW5kIHRoZW5cbiAgICAgICAgYXR0YWNoZWQge0lOVEVHRVJ9IG1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKFwiaW5kZXhcIikgYXMgbF9pbmRleFxuICAgICAgdGhlblxuICAgICAgICBjcmVhdGUgYXJlYV92Mi5tYWtlX2VtcHR5IChsX2NvdW50KVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAwXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IGxfY291bnRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFyZWFfdjIuZXh0ZW5kIChsX2FyZWEuaXRlbSAoaSkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gbF9jb21wXG4gICAgICAgIGluZGV4IDo9IGxfaW5kZXhcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGR1cGxpY2F0ZSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWItbGlzdCBiZWdpbm5pbmcgYXQgY3VycmVudCBwb3NpdGlvblxuICAgICAgLS0gYW5kIGhhdmluZyBtaW4gKGBuJywgYGNvdW50JyAtIGBpbmRleCcgKyAxKSBpdGVtcy5cbiAgICBsb2NhbFxuICAgICAgZW5kX3BvczogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhZnRlciB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfZmlsbGVkX2xpc3QgKDApXG4gICAgICBlbHNlXG4gICAgICAgIGVuZF9wb3MgOj0gY291bnQubWluIChpbmRleCArIG4gLSAxKVxuICAgICAgICBSZXN1bHQgOj0gbmV3X2ZpbGxlZF9saXN0IChlbmRfcG9zIC0gaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuYXJlYV92Mi5jb3B5X2RhdGEgKGFyZWFfdjIsIGluZGV4IC0gMSwgMCwgZW5kX3BvcyAtIGluZGV4ICsgMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBuZXdfY2hhaW46IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW51c2VkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZm9yY2VfaV90aCAodjogbGlrZSBpX3RoOyBwb3M6IElOVEVHRVIpXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ICsgMSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgZ3JvdyAoY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBhcmVhX3YyLmZvcmNlICh2LCBwb3MpXG4gICAgZW5kXG5cbiAgaW5zZXJ0ICh2OiBsaWtlIGl0ZW07IHBvczogSU5URUdFUilcbiAgICAgIC0tIEFkZCBgdicgYXQgYHBvcycsIG1vdmluZyBzdWJzZXF1ZW50IGl0ZW1zXG4gICAgICAtLSB0byB0aGUgcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBwb3MgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogcG9zID49IDFcbiAgICBkb1xuICAgICAgaWYgY291bnQgKyAxID4gY2FwYWNpdHkgdGhlblxuICAgICAgICBncm93IChjb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWFfdjIubW92ZV9kYXRhIChwb3MgLSAxLCBwb3MsIGNvdW50IC0gcG9zICsgMSlcbiAgICAgIHB1dF9pX3RoICh2LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaW5kZXhfdW5jaGFuZ2VkOiBpbmRleCA9IG9sZCBpbmRleFxuICAgICAgaW5zZXJ0aW9uX2RvbmU6IGlfdGggKHBvcykgPSB2XG4gICAgZW5kXG5cbiAgbmV3X2ZpbGxlZF9saXN0IChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgbGlzdCB3aXRoIGBuJyBlbGVtZW50cy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PTBcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2ZpbGxlZF9saXN0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbmV3X2ZpbGxlZF9saXN0X2NvdW50X3NldDogUmVzdWx0LmNvdW50ID0gMFxuICAgICAgbmV3X2ZpbGxlZF9saXN0X2JlZm9yZTogUmVzdWx0LmJlZm9yZVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgcHJ1bmFibGU6IHBydW5hYmxlXG4gIHN0YXJ0c19mcm9tX29uZTogbG93ZXIgPSAxXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBiYWcsIGFjY2VzcztcbiAgYWNjZXNzOiBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEJBRyBbR10gaW5oZXJpdFxuXG4gIENPTExFQ1RJT04gW0ddXG4gICAgcmVkZWZpbmVcbiAgICAgIGV4dGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgb2NjdXJyZW5jZXMgKHY6IEcpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgdGltZXMgYHYnIGFwcGVhcnMgaW4gc3RydWN0dXJlXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmVfb2NjdXJyZW5jZXM6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBleHRlbmQgKHY6IEcpXG4gICAgICAtLSBBZGQgYSBuZXcgb2NjdXJyZW5jZSBvZiBgdicuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgICAtLSBDb21tZW50ZWQgZHVlIHRvIHRoZSBleHBlbnNpdmUgbmF0dXJlIG9mIHRoZSBjaGVjayB3aGVuIGluc2VydGluZyBhIG5ldyBpdGVtXG4gICAgICAgIC0tIGluIGEgY29udGFpbmVycyB3aXRoIG1hbnkgaXRlbXMuXG4gICAgICAtLSBvbmVfbW9yZV9vY2N1cnJlbmNlOiBvY2N1cnJlbmNlcyAodikgPSBvbGQgKG9jY3VycmVuY2VzICh2KSkgKyAxXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVzIHRoYXQgbWF5IGJlIHRyYXZlcnNlZCBmb3J3YXJkIGFuZCBiYWNrd2FyZFwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGJpZGlyZWN0aW9uYWwsIHRyYXZlcnNpbmc7XG4gIGFjY2VzczogY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEJJTElORUFSIFtHXSBpbmhlcml0XG5cbiAgTElORUFSIFtHXVxuICAgIHJlbmFtZVxuICAgICAgc2VhcmNoIGFzIHNlcXVlbnRpYWxfc2VhcmNoXG4gICAgZXhwb3J0XG4gICAgICB7Tk9ORX1cbiAgICAgICAgc2VxdWVudGlhbF9zZWFyY2hcbiAgICByZWRlZmluZVxuICAgICAgb2ZmXG4gICAgZW5kXG5cbiAgTElORUFSIFtHXVxuICAgIHJlZGVmaW5lXG4gICAgICBzZWFyY2gsIG9mZlxuICAgIHNlbGVjdFxuICAgICAgc2VhcmNoXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgb2ZmOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyBjdXJyZW50IGl0ZW0/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBiZWZvcmUgb3IgYWZ0ZXJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDdXJzb3IgbW92ZW1lbnRcblxuICBiZWZvcmU6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIHZhbGlkIHBvc2l0aW9uIHRvIHRoZSBsZWZ0IG9mIGN1cnJlbnQgb25lP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgYmFja1xuICAgICAgLS0gTW92ZSB0byBwcmV2aW91cyBwb3NpdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBub3RfYmVmb3JlOiBub3QgYmVmb3JlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgLS0gbW92ZWRfZm9ydGhfYWZ0ZXJfc3RhcnQ6IChub3QgYmVmb3JlKSBpbXBsaWVzIGluZGV4ID0gb2xkIGluZGV4IC0gMVxuICAgIGVuZFxuXG4gIHNlYXJjaCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gTW92ZSB0byBmaXJzdCBwb3NpdGlvbiAoYXQgb3IgYWZ0ZXIgY3VycmVudFxuICAgICAgLS0gcG9zaXRpb24pIHdoZXJlIGBpdGVtJyBhbmQgYHYnIGFyZSBlcXVhbC5cbiAgICAgIC0tIElmIHN0cnVjdHVyZSBkb2VzIG5vdCBpbmNsdWRlIGB2JyBlbnN1cmUgdGhhdFxuICAgICAgLS0gYGV4aGF1c3RlZCcgd2lsbCBiZSB0cnVlLlxuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBkb1xuICAgICAgaWYgYmVmb3JlIGFuZCBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBmb3J0aFxuICAgICAgZW5kXG4gICAgICBzZXF1ZW50aWFsX3NlYXJjaCAodilcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgbm90X2JvdGg6IG5vdCAoYWZ0ZXIgYW5kIGJlZm9yZSlcbiAgYmVmb3JlX2NvbnN0cmFpbnQ6IGJlZm9yZSBpbXBsaWVzIG9mZlxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiVHJ1dGggdmFsdWVzLCB3aXRoIHRoZSBib29sZWFuIG9wZXJhdGlvbnNcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5Cb29sZWFuXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgQk9PTEVBTlxuXG5pbmhlcml0XG4gIEJPT0xFQU5fUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvbmp1bmN0ZWQsXG4gICAgICBjb25qdW5jdGVkX3NlbWlzdHJpY3QsXG4gICAgICBkaXNqdW5jdGVkLFxuICAgICAgZGlzanVuY3RlZF9zZW1pc3RyaWN0LFxuICAgICAgZGlzanVuY3RlZF9leGNsdXNpdmUsXG4gICAgICBpbXBsaWNhdGlvbixcbiAgICAgIG5lZ2F0ZWRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0JPT0xFQU5fUkVGfSlcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgY29uanVuY3RlZCBhbGlhcyBcImFuZFwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGNvbmp1bmN0ZWRfc2VtaXN0cmljdCBhbGlhcyBcImFuZCB0aGVuXCIgKG90aGVyOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBzZW1pLXN0cmljdCBjb25qdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW1wbGljYXRpb24gYWxpYXMgXCJpbXBsaWVzXCIgKG90aGVyOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBpbXBsaWNhdGlvbiBvZiBgb3RoZXInXG4gICAgICAtLSAoc2VtaS1zdHJpY3QpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG5lZ2F0ZWQgYWxpYXMgXCJub3RcIjogQk9PTEVBTlxuICAgICAgLS0gTmVnYXRpb25cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZCBhbGlhcyBcIm9yXCIgKG90aGVyOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBkaXNqdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZF9zZW1pc3RyaWN0IGFsaWFzIFwib3IgZWxzZVwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gc2VtaS1zdHJpY3QgZGlzanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWRfZXhjbHVzaXZlIGFsaWFzIFwieG9yXCIgKG90aGVyOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBleGNsdXNpdmUgb3Igd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGEgYm9vbGVhbiB2YWx1ZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzIEJPT0xFQU5fUkVGIGluaGVyaXRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogQk9PTEVBTl9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBCT09MRUFOX1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2l0ZW06IFJlc3VsdC5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXI6IElOVEVHRVJcbiAgICAgIC0tIDEgaWYgYFRydWUnXG4gICAgICAtLSAwIGlmIGBGYWxzZSdcbiAgICBkb1xuICAgICAgaWYgaXRlbSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9pdGVtX2ltcGxpZXNfemVybzogbm90IGl0ZW0gaW1wbGllcyBSZXN1bHQgPSAwXG4gICAgICBpdGVtX2ltcGxpZXNfb25lOiBpdGVtIGltcGxpZXMgUmVzdWx0ID0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBNYWtlIGBiJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgY29uanVuY3RlZCBhbGlhcyBcImFuZFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBjb25qdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gYW5kIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlX21vcmdhbjogUmVzdWx0ID0gbm90IChub3QgQ3VycmVudCBvciBub3Qgb3RoZXIpXG4gICAgICBjb21tdXRhdGl2ZTogUmVzdWx0ID0gKG90aGVyIGFuZCBDdXJyZW50KVxuICAgICAgY29uc2lzdGVudF93aXRoX3NlbWlfc3RyaWN0OiBSZXN1bHQgaW1wbGllcyAoQ3VycmVudCBhbmQgdGhlbiBvdGhlcilcbiAgICBlbmRcblxuICBjb25qdW5jdGVkX3NlbWlzdHJpY3QgYWxpYXMgXCJhbmQgdGhlblwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBzZW1pLXN0cmljdCBjb25qdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gYW5kIHRoZW4gb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVfbW9yZ2FuOiBSZXN1bHQgPSBub3QgKG5vdCBDdXJyZW50IG9yIGVsc2Ugbm90IG90aGVyKVxuICAgIGVuZFxuXG4gIGltcGxpY2F0aW9uIGFsaWFzIFwiaW1wbGllc1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBpbXBsaWNhdGlvbiBvZiBgb3RoZXInXG4gICAgICAtLSAoc2VtaS1zdHJpY3QpXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIGltcGxpZXMgb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKG5vdCBDdXJyZW50IG9yIGVsc2Ugb3RoZXIpXG4gICAgZW5kXG5cbiAgbmVnYXRlZCBhbGlhcyBcIm5vdFwiOiBCT09MRUFOXG4gICAgICAtLSBOZWdhdGlvblxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbm90IGl0ZW1cbiAgICBlbmRcblxuICBkaXNqdW5jdGVkIGFsaWFzIFwib3JcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZGlzanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIG9yIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlX21vcmdhbjogUmVzdWx0ID0gbm90IChub3QgQ3VycmVudCBhbmQgbm90IG90aGVyKVxuICAgICAgY29tbXV0YXRpdmU6IFJlc3VsdCA9IChvdGhlciBvciBDdXJyZW50KVxuICAgICAgY29uc2lzdGVudF93aXRoX3NlbWlfc3RyaWN0OiBSZXN1bHQgaW1wbGllcyAoQ3VycmVudCBvciBlbHNlIG90aGVyKVxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWRfc2VtaXN0cmljdCBhbGlhcyBcIm9yIGVsc2VcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gc2VtaS1zdHJpY3QgZGlzanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIG9yIGVsc2Ugb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVfbW9yZ2FuOiBSZXN1bHQgPSBub3QgKG5vdCBDdXJyZW50IGFuZCB0aGVuIG5vdCBvdGhlcilcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkX2V4Y2x1c2l2ZSBhbGlhcyBcInhvclwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBleGNsdXNpdmUgb3Igd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIHhvciBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoKEN1cnJlbnQgb3Igb3RoZXIpIGFuZCBub3QgKEN1cnJlbnQgYW5kIG90aGVyKSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGJvb2xlYW5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFwiRmFsc2VcIlxuICAgICAgaWYgaXRlbSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBcIlRydWVcIlxuICAgICAgZW5kXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBpbnZvbHV0aXZlX25lZ2F0aW9uOiAobm90IChub3QgQ3VycmVudCkpLml0ZW0gPSBpdGVtXG4gIG5vbl9jb250cmFkaWN0aW9uOiBub3QgKChub3QgQ3VycmVudCkgYW5kIEN1cnJlbnQpXG4gIGNvbXBsZXRlbmVzczogKG5vdCBDdXJyZW50KSBvciBDdXJyZW50XG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkJvdW5kZWQgZGF0YSBzdHJ1Y3R1cmVzLCB3aXRoIGEgbm90aW9uIG9mIGNhcGFjaXR5LlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGJvdW5kZWQsIHN0b3JhZ2U7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBCT1VOREVEIFtHXSBpbmhlcml0XG5cbiAgRklOSVRFIFtHXVxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBpdGVtcyB0aGF0IG1heSBiZSBzdG9yZWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY2FwYWNpdHlfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBmdWxsOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZnVsbD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjb3VudCA9IGNhcGFjaXR5KVxuICAgIGVuZFxuXG4gIHJlc2l6YWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGBjYXBhY2l0eScgYmUgY2hhbmdlZD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICB2YWxpZF9jb3VudDogY291bnQgPD0gY2FwYWNpdHlcbiAgZnVsbF9kZWZpbml0aW9uOiBmdWxsID0gKGNvdW50ID0gY2FwYWNpdHkpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBzdG9yYWdlO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQk9YIFtHXSBpbmhlcml0XG5cbiAgQ09OVEFJTkVSIFtHXVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBmdWxsOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZmlsbGVkIHRvIGNhcGFjaXR5P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ2VsbHMgY29udGFpbmluZyBhbiBpdGVtXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogY2VsbDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5jbGFzcyBDRUxMIFtHXVxuXG5jcmVhdGVcbiAgcHV0XG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogR1xuICAgICAgLS0gQ29udGVudCBvZiBjZWxsLlxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0LCByZXBsYWNlICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBNYWtlIGB2JyB0aGUgY2VsbCdzIGBpdGVtJy5cbiAgICBkb1xuICAgICAgaXRlbSA6PSB2XG4gICAgZW5zdXJlXG4gICAgICBpdGVtX2luc2VydGVkOiBpdGVtID0gdlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIFBvc3NpYmx5IGNpcmN1bGFyIHNlcXVlbmNlcyBvZiBpdGVtcyxcbiAgICB3aXRob3V0IGNvbW1pdG1lbnQgdG8gYSBwYXJ0aWN1bGFyIHJlcHJlc2VudGF0aW9uXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGNoYWluLCBzZXF1ZW5jZTtcbiAgYWNjZXNzOiBpbmRleCwgY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0xNSAxMzo0MToyMiAtMDgwMCAoVHVlLCAxNSBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMjIgJFwiXG5cbmRlZmVycmVkIGNsYXNzIENIQUlOIFtHXSBpbmhlcml0XG5cbiAgQ1VSU09SX1NUUlVDVFVSRSBbR11cbiAgICByZW5hbWVcbiAgICAgIHB1dCBhcyBzZXF1ZW5jZV9wdXRcbiAgICB1bmRlZmluZVxuICAgICAgcHJ1bmVfYWxsXG4gICAgcmVkZWZpbmVcbiAgICAgIGZpbGxcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0csIElOVEVHRVJdXG4gICAgcmVuYW1lXG4gICAgICBpdGVtIGFzIGlfdGggYWxpYXMgXCJbXVwiLFxuICAgICAgcHV0IGFzIHB1dF9pX3RoLFxuICAgICAgYmFnX3B1dCBhcyBzZXF1ZW5jZV9wdXRcbiAgICB1bmRlZmluZVxuICAgICAgcHJ1bmVfYWxsLCBzZXF1ZW5jZV9wdXRcbiAgICByZWRlZmluZVxuICAgICAgZmlsbFxuICAgIGVuZFxuXG4gIFNFUVVFTkNFIFtHXVxuICAgIHJlbmFtZVxuICAgICAgcHV0IGFzIHNlcXVlbmNlX3B1dFxuICAgIGV4cG9ydFxuICAgICAge05PTkV9IHNlcXVlbmNlX3B1dFxuICAgIHJlZGVmaW5lXG4gICAgICBpbmRleF9vZiwgaGFzLCBvZmYsIG9jY3VycmVuY2VzLCBmaWxsLCBhcHBlbmRcbiAgICBzZWxlY3RcbiAgICAgIGluZGV4X29mLCBoYXMsIG9jY3VycmVuY2VzXG4gICAgZW5kXG5cbiAgU0VRVUVOQ0UgW0ddXG4gICAgcmVuYW1lXG4gICAgICBwdXQgYXMgc2VxdWVuY2VfcHV0LFxuICAgICAgaW5kZXhfb2YgYXMgc2VxdWVudGlhbF9pbmRleF9vZixcbiAgICAgIGhhcyBhcyBzZXF1ZW50aWFsX2hhcyxcbiAgICAgIG9jY3VycmVuY2VzIGFzIHNlcXVlbnRpYWxfb2NjdXJyZW5jZXNcbiAgICBleHBvcnRcbiAgICAgIHtOT05FfVxuICAgICAgICBzZXF1ZW50aWFsX2luZGV4X29mLCBzZXF1ZW50aWFsX2hhcyxcbiAgICAgICAgc2VxdWVuY2VfcHV0LCBzZXF1ZW50aWFsX29jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIG9mZiwgZmlsbCwgYXBwZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgZmlyc3Q6IGxpa2UgaXRlbVxuICAgICAgLS0gSXRlbSBhdCBmaXJzdCBwb3NpdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9lbXB0eTogbm90IGlzX2VtcHR5XG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIHN0YXJ0XG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgICAgZ29fdG8gKHBvcylcbiAgICBlbmRcblxuICBsYXN0OiBsaWtlIGl0ZW1cbiAgICAgIC0tIEl0ZW0gYXQgbGFzdCBwb3NpdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9lbXB0eTogbm90IGlzX2VtcHR5XG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIGZpbmlzaFxuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGdvX3RvIChwb3MpXG4gICAgZW5kXG5cbiAgaGFzICh2OiBsaWtlIGl0ZW0pOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGNoYWluIGluY2x1ZGUgYHYnP1xuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcblxuICAgIGxvY2FsXG4gICAgICBwb3M6IENVUlNPUlxuICAgIGRvXG4gICAgICBwb3MgOj0gY3Vyc29yXG4gICAgICBSZXN1bHQgOj0gc2VxdWVudGlhbF9oYXMgKHYpXG4gICAgICBnb190byAocG9zKVxuICAgIGVuZFxuXG4gIGluZGV4X29mICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBgaSctdGggb2NjdXJyZW5jZSBvZiBpdGVtIGlkZW50aWNhbCB0byBgdicuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgICAgLS0gMCBpZiBub25lLlxuICAgIGxvY2FsXG4gICAgICBwb3M6IENVUlNPUlxuICAgIGRvXG4gICAgICBwb3MgOj0gY3Vyc29yXG4gICAgICBSZXN1bHQgOj0gc2VxdWVudGlhbF9pbmRleF9vZiAodiwgaSlcbiAgICAgIGdvX3RvIChwb3MpXG4gICAgZW5kXG5cbiAgaV90aCBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogbGlrZSBpdGVtIGFzc2lnbiBwdXRfaV90aFxuICAgICAgLS0gSXRlbSBhdCBgaSctdGggcG9zaXRpb25cbiAgICBsb2NhbFxuICAgICAgcG9zOiBDVVJTT1JcbiAgICBkb1xuICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgZ29faV90aCAoaSlcbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgICBnb190byAocG9zKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgb2NjdXJyZW5jZXMgKHY6IGxpa2UgaXRlbSk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIFJlc3VsdCA6PSBzZXF1ZW50aWFsX29jY3VycmVuY2VzICh2KVxuICAgICAgZ29fdG8gKHBvcylcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEsIGNvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjb3VudF9kZWZpbml0aW9uOiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEN1cnNvciBtb3ZlbWVudFxuXG4gIHN0YXJ0XG4gICAgICAtLSBNb3ZlIGN1cnNvciB0byBmaXJzdCBwb3NpdGlvbi5cbiAgICAgIC0tIChObyBlZmZlY3QgaWYgZW1wdHkpXG4gICAgZG9cbiAgICAgIGlmIG5vdCBpc19lbXB0eSB0aGVuXG4gICAgICAgIGdvX2lfdGggKDEpXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgYXRfZmlyc3Q6IG5vdCBpc19lbXB0eSBpbXBsaWVzIGlzZmlyc3RcbiAgICBlbmRcblxuICBmaW5pc2hcbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIGxhc3QgcG9zaXRpb24uXG4gICAgICAtLSAoTm8gZWZmZWN0IGlmIGVtcHR5KVxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBnb19pX3RoIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBhdF9sYXN0OiBub3QgaXNfZW1wdHkgaW1wbGllcyBpc2xhc3RcbiAgICBlbmRcblxuICBtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBjdXJzb3IgYGknIHBvc2l0aW9ucy4gVGhlIGN1cnNvclxuICAgICAgLS0gbWF5IGVuZCB1cCBgb2ZmJyBpZiB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYGknXG4gICAgICAtLSBpcyB0b28gYmlnLlxuICAgIGxvY2FsXG4gICAgICBjb3VudGVyLCBwb3MsIGZpbmFsOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGkgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIChjb3VudGVyID0gaSkgb3IgZWxzZSBhZnRlclxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgICBjb3VudGVyIDo9IGNvdW50ZXIgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZWxzZWlmIGkgPCAwIHRoZW5cbiAgICAgICAgZmluYWwgOj0gaW5kZXggKyBpXG4gICAgICAgIGlmIGZpbmFsIDw9IDAgdGhlblxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgYmFja1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgc3RhcnRcbiAgICAgICAgICAgIHBvcyA6PSAxXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIHBvcyA9IGZpbmFsXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgZm9ydGhcbiAgICAgICAgICAgIHBvcyA6PSBwb3MgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0b29fZmFyX3JpZ2h0OiAob2xkIGluZGV4ICsgaSA+IGNvdW50KSBpbXBsaWVzIGV4aGF1c3RlZFxuICAgICAgdG9vX2Zhcl9sZWZ0OiAob2xkIGluZGV4ICsgaSA8IDEpIGltcGxpZXMgZXhoYXVzdGVkXG4gICAgICBleHBlY3RlZF9pbmRleDogKG5vdCBleGhhdXN0ZWQpIGltcGxpZXMgKGluZGV4ID0gb2xkIGluZGV4ICsgaSlcbiAgICBlbmRcblxuICBnb19pX3RoIChpOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gYGknLXRoIHBvc2l0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2N1cnNvcl9pbmRleDogdmFsaWRfY3Vyc29yX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBtb3ZlIChpIC0gaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBwb3NpdGlvbl9leHBlY3RlZDogaW5kZXggPSBpXG4gICAgZW5kXG5cbiBmZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gYWxsb3dhYmxlIGJvdW5kcz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpID49IDEpIGFuZCAoaSA8PSBjb3VudClcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsaWRfaW5kZXhfZGVmaW5pdGlvbjogUmVzdWx0ID0gKChpID49IDEpIGFuZCAoaSA8PSBjb3VudCkpXG4gICAgZW5kXG5cblxuICBpc2ZpcnN0OiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJzb3IgYXQgZmlyc3QgcG9zaXRpb24/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBub3QgaXNfZW1wdHkgYW5kIChpbmRleCA9IDEpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9wb3NpdGlvbjogUmVzdWx0IGltcGxpZXMgbm90IGlzX2VtcHR5XG4gICAgZW5kXG5cbiAgaXNsYXN0OiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJzb3IgYXQgbGFzdCBwb3NpdGlvbj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBpc19lbXB0eSBhbmQgKGluZGV4ID0gY291bnQpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9wb3NpdGlvbjogUmVzdWx0IGltcGxpZXMgbm90IGlzX2VtcHR5XG4gICAgZW5kXG5cbiAgb2ZmOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyBjdXJyZW50IGl0ZW0/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoaW5kZXggPSAwKSBvciAoaW5kZXggPSBjb3VudCArIDEpXG4gICAgZW5kXG5cblxuICB2YWxpZF9jdXJzb3JfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgY29ycmVjdGx5IGJvdW5kZWQgZm9yIGN1cnNvciBtb3ZlbWVudD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpID49IDApIGFuZCAoaSA8PSBjb3VudCArIDEpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jdXJzb3JfaW5kZXhfZGVmaW5pdGlvbjogUmVzdWx0ID0gKChpID49IDApIGFuZCAoaSA8PSBjb3VudCArIDEpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBSZXBsYWNlIGN1cnJlbnQgaXRlbSBieSBgdicuXG4gICAgICAtLSAoU3lub255bSBmb3IgYHJlcGxhY2UnKVxuICAgIHJlcXVpcmVcbiAgICAgIHdyaXRlYWJsZTogd3JpdGFibGVcbiAgICAgIHJlcGxhY2VhYmxlOiByZXBsYWNlYWJsZVxuICAgIGRvXG4gICAgICByZXBsYWNlICh2KVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGlzX2luc2VydGVkOiBpc19pbnNlcnRlZCAodilcbiAgICBlbmRcblxuICBwdXRfaV90aCAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBgaSctdGggcG9zaXRpb24uXG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIGdvX2lfdGggKGkpXG4gICAgICByZXBsYWNlICh2KVxuICAgICAgZ29fdG8gKHBvcylcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFNFUVVFTkNFIFtHXSlcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLlxuICAgIGxvY2FsXG4gICAgICBsOiBTRVFVRU5DRSBbR11cbiAgICAgIGxfY3Vyc29yOiBDVVJTT1JcbiAgICBkb1xuICAgICAgbCA6PSBzXG4gICAgICBpZiBzID0gQ3VycmVudCB0aGVuXG4gICAgICAgIGwgOj0gdHdpblxuICAgICAgZW5kXG4gICAgICBmcm9tXG4gICAgICAgIGxfY3Vyc29yIDo9IGN1cnNvclxuICAgICAgICBsLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBsLmV4aGF1c3RlZFxuICAgICAgbG9vcFxuICAgICAgICBleHRlbmQgKGwuaXRlbSlcbiAgICAgICAgZmluaXNoXG4gICAgICAgIGwuZm9ydGhcbiAgICAgIGVuZFxuICAgICAgZ29fdG8gKGxfY3Vyc29yKVxuICAgIGVuZFxuXG4gIGZpbGwgKG90aGVyOiBDT05UQUlORVIgW0ddKVxuICAgICAgLS0gRmlsbCB3aXRoIGFzIG1hbnkgaXRlbXMgb2YgYG90aGVyJyBhcyBwb3NzaWJsZS5cbiAgICAgIC0tIFRoZSByZXByZXNlbnRhdGlvbnMgb2YgYG90aGVyJyBhbmQgY3VycmVudCBzdHJ1Y3R1cmVcbiAgICAgIC0tIG5lZWQgbm90IGJlIHRoZSBzYW1lLlxuICAgIGxvY2FsXG4gICAgICBsaW5fcmVwOiBMSU5FQVIgW0ddXG4gICAgICBsX2N1cnNvcjogQ1VSU09SXG4gICAgZG9cbiAgICAgIGxpbl9yZXAgOj0gb3RoZXIubGluZWFyX3JlcHJlc2VudGF0aW9uXG4gICAgICBmcm9tXG4gICAgICAgIGxfY3Vyc29yIDo9IGN1cnNvclxuICAgICAgICBsaW5fcmVwLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBub3QgZXh0ZW5kaWJsZSBvciBlbHNlIGxpbl9yZXAub2ZmXG4gICAgICBsb29wXG4gICAgICAgIGV4dGVuZCAobGluX3JlcC5pdGVtKVxuICAgICAgICBmaW5pc2hcbiAgICAgICAgbGluX3JlcC5mb3J0aFxuICAgICAgZW5kXG4gICAgICBnb190byAobF9jdXJzb3IpXG4gICAgZW5kXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgc3dhcCAoaTogSU5URUdFUilcbiAgICAgIC0tIEV4Y2hhbmdlIGl0ZW0gYXQgYGknLXRoIHBvc2l0aW9uIHdpdGggaXRlbVxuICAgICAgLS0gYXQgY3Vyc29yIHBvc2l0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9vZmY6IG5vdCBvZmZcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBsb2NhbFxuICAgICAgb2xkX2l0ZW0sIG5ld19pdGVtOiBsaWtlIGl0ZW1cbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIG9sZF9pdGVtIDo9IGl0ZW1cbiAgICAgIGdvX2lfdGggKGkpXG4gICAgICBuZXdfaXRlbSA6PSBpdGVtXG4gICAgICByZXBsYWNlIChvbGRfaXRlbSlcbiAgICAgIGdvX3RvIChwb3MpXG4gICAgICByZXBsYWNlIChuZXdfaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHN3YXBwZWRfdG9faXRlbTogaXRlbSA9IG9sZCBpX3RoIChpKVxuICAgICAgc3dhcHBlZF9mcm9tX2l0ZW06IGlfdGggKGkpID0gb2xkIGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGR1cGxpY2F0ZSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWItY2hhaW4gYmVnaW5uaW5nIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgIC0tIGFuZCBoYXZpbmcgbWluIChgbicsIGBmcm9tX2hlcmUnKSBpdGVtcyxcbiAgICAgIC0tIHdoZXJlIGBmcm9tX2hlcmUnIGlzIHRoZSBudW1iZXIgb2YgaXRlbXNcbiAgICAgIC0tIGF0IG9yIHRvIHRoZSByaWdodCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9vZmZfdW5sZXNzX2FmdGVyOiBvZmYgaW1wbGllcyBhZnRlclxuICAgICAgdmFsaWRfc3ViY2hhaW46IG4gPj0gMFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluYXBwbGljYWJsZVxuXG4gIHJlbW92ZVxuICAgICAgLS0gUmVtb3ZlIGN1cnJlbnQgaXRlbS5cbiAgICBkb1xuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBub25fbmVnYXRpdmVfaW5kZXg6IGluZGV4ID49IDBcbiAgaW5kZXhfc21hbGxfZW5vdWdoOiBpbmRleCA8PSBjb3VudCArIDFcbiAgb2ZmX2RlZmluaXRpb246IG9mZiA9ICgoaW5kZXggPSAwKSBvciAoaW5kZXggPSBjb3VudCArIDEpKVxuICBpc2ZpcnN0X2RlZmluaXRpb246IGlzZmlyc3QgPSAoKG5vdCBpc19lbXB0eSkgYW5kIChpbmRleCA9IDEpKVxuICBpc2xhc3RfZGVmaW5pdGlvbjogaXNsYXN0ID0gKChub3QgaXNfZW1wdHkpIGFuZCAoaW5kZXggPSBjb3VudCkpXG4gIGl0ZW1fY29ycmVzcG9uZHNfdG9faW5kZXg6IChub3Qgb2ZmKSBpbXBsaWVzIChpdGVtID0gaV90aCAoaW5kZXgpKVxuICBpbmRleF9zZXRfaGFzX3NhbWVfY291bnQ6IGluZGV4X3NldC5jb3VudCA9IGNvdW50XG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJVbmljb2RlIGNoYXJhY3RlcnMsIHdpdGggY29tcGFyaXNvbiBvcGVyYXRpb25zXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5VSW50MzJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTAtMzAgMDg6MzI6NDYgLTA3MDAgKFR1ZSwgMzAgT2N0IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDIyICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3NcbiAgQ0hBUkFDVEVSXzMyXG5cbmluaGVyaXRcbiAgQ0hBUkFDVEVSXzMyX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBjb2RlLFxuICAgICAgbmF0dXJhbF8zMl9jb2RlLFxuICAgICAgdG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0NIQVJBQ1RFUl8zMl9SRUZ9KVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGNvZGU6IElOVEVHRVJcbiAgICAgIC0tIEFzc29jaWF0ZWQgaW50ZWdlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBuYXR1cmFsXzMyX2NvZGU6IE5BVFVSQUxfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgbmF0dXJhbCB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBDb252ZXJ0IGN1cnJlbnQgdG8gQ0hBUkFDVEVSXzhcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYSB1bmljb2RlIGNoYXJhY3RlciB2YWx1ZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xOSAxNDoyNjoxNCAtMDcwMCAoTW9uLCAxOSBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUxMTcgJFwiXG5cbmNsYXNzXG4gIENIQVJBQ1RFUl8zMl9SRUZcblxuaW5oZXJpdFxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBVbmljb2RlIGNoYXJhY3RlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG5hdHVyYWxfMzJfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlLmhhc2hfY29kZVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLm5hdHVyYWxfMzJfY29kZVxuICAgIGVuc3VyZVxuICAgICAgbmF0dXJhbF8zMl9jb2RlX2luX3JhbmdlOiBSZXN1bHQgPj0gbWluX3ZhbHVlIGFuZCBSZXN1bHQgPD0gbWF4X3ZhbHVlXG4gICAgZW5kXG5cbiAgbWluX3ZhbHVlOiBOQVRVUkFMXzMyID0gMFxuICBtYXhfdmFsdWU6IE5BVFVSQUxfMzIgPSA0Mjk0OTY3Mjk1XG4gICAgICAtLSBCb3VuZHMgZm9yIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgQ0hBUkFDVEVSXzMyXG5cbiAgbWF4X3VuaWNvZGVfdmFsdWU6IE5BVFVSQUxfMzIgPSAweDEwRkZGRFxuICAgICAgLS0gTWF4aW11bSBVbmljb2RlIGNoYXJhY3RlcnMuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGNoYXJhY3Rlcj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5hdHVyYWxfMzJfY29kZSA8IG90aGVyLm5hdHVyYWxfMzJfY29kZVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAobmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgcm91dGluZXNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChpbmNyOiBOQVRVUkFMXzMyKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBZGQgYGluY3InIHRvIHRoZSBjb2RlIG9mIGBpdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmNyZW1lbnQ6IChpdGVtLm5hdHVyYWxfMzJfY29kZS50b19uYXR1cmFsXzY0ICsgaW5jcikuaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpdGVtLm5hdHVyYWxfMzJfY29kZSArIGluY3IpLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgfC18IGl0ZW0gPSBpbmNyXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKGRlY3I6IE5BVFVSQUxfMzIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFN1YnRyYWN0IGBkZWNyJyBmcm9tIHRoZSBjb2RlIG9mIGBpdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9kZWNyZW1lbnQ6IChpdGVtLm5hdHVyYWxfMzJfY29kZS50b19pbnRlZ2VyXzY0IC0gZGVjcikuaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpdGVtLm5hdHVyYWxfMzJfY29kZSAtIGRlY3IpLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBpdGVtIHwtfCBSZXN1bHQgPSBkZWNyXG4gICAgZW5kXG5cbiAgZGlmZmVyZW5jZSBhbGlhcyBcInwtfFwiIChvdGhlcjogQ0hBUkFDVEVSXzMyKTogSU5URUdFUl82NFxuICAgICAgLS0gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb2RlcyBvZiBgaXRlbScgYW5kIGBvdGhlcicuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLm5hdHVyYWxfMzJfY29kZS50b19pbnRlZ2VyXzY0IC0gb3RoZXIubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX25vbl9uZWdhdGl2ZV9yZXN1bHQ6IFJlc3VsdCA+PSAwIGltcGxpZXMgKChvdGhlciArIFJlc3VsdC50b19uYXR1cmFsXzMyKSA9IGl0ZW0pXG4gICAgICB2YWxpZF9uZWdhdGl2ZV9yZXN1bHQ6IFJlc3VsdCA8IDAgaW1wbGllcyAob3RoZXIgPSAoaXRlbSArIFJlc3VsdC50b19uYXR1cmFsXzMyKSlcbiAgICBlbmRcblxuICBuZXh0OiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIE5leHQgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgKyAxKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSArIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gMVxuICAgIGVuZFxuXG4gIHByZXZpb3VzOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFByZXZpb3VzIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChpdGVtLm5hdHVyYWxfMzJfY29kZS50b19uYXR1cmFsXzY0IC0gMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLSAxXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IC0xXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gTWFrZSBgYycgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiB3aWRlIGNoYXJhY3Rlci5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICg2KVxuICAgICAgUmVzdWx0LmFwcGVuZF9jaGFyYWN0ZXIgKCdVJylcbiAgICAgIFJlc3VsdC5hcHBlbmRfY2hhcmFjdGVyICgnKycpXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZyAobmF0dXJhbF8zMl9jb2RlLnRvX2hleF9zdHJpbmcpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogQ0hBUkFDVEVSXzMyX1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IENIQVJBQ1RFUl8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfOC5cbiAgICByZXF1aXJlXG4gICAgICBpc19jaGFyYWN0ZXJfOF9jb21wYXRpYmxlOiBpc19jaGFyYWN0ZXJfOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBDb252ZXJ0IGN1cnJlbnQgdG8gQ0hBUkFDVEVSXzMyLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIGFzX3VwcGVyLCB1cHBlcjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBVcHBlcmNhc2UgdmFsdWUgb2YgYGl0ZW0nLlxuICAgICAgLS0gUmV0dXJucyBgaXRlbScgaWYgbm90IGBpc19sb3dlcicuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLnRvX3VwcGVyIChpdGVtKVxuICAgIGVuZFxuXG4gIGFzX2xvd2VyLCBsb3dlcjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBMb3dlcmNhc2UgdmFsdWUgb2YgYGl0ZW0nLlxuICAgICAgLS0gUmV0dXJucyBgaXRlbScgaWYgbm90IGBpc191cHBlcicuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLnRvX2xvd2VyIChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19jaGFyYWN0ZXJfODogQk9PTEVBTlxuICAgICAgLS0gQ2FuIGN1cnJlbnQgYmUgcmVwcmVzZW50ZWQgb24gYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5hdHVyYWxfMzJfY29kZSA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXNfYWxwaGE6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhbHBoYWJldGljP1xuICAgICAgLS0gQWxwaGFiZXRpYyBpcyBgaXNfdXBwZXInIG9yIGBpc19sb3dlcicuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2FscGhhIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX3VwcGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgdXBwZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc191cHBlciAoaXRlbSlcbiAgICBlbmRcblxuICBpc19sb3dlcjogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGxvd2VyY2FzZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfbG93ZXIgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfZGlnaXQ6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIGRlY2ltYWwgZGlnaXQgYXMgZXhwZWN0ZWQgZm9yIEFTQ0lJIGNoYXJhY3RlcnM/XG4gICAgICAtLSBBIGRpZ2l0IGlzIG9uZSBvZiAwMTIzNDU2Nzg5LlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gJzAnIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gJzknXG4gICAgZW5kXG5cbiAgaXNfdW5pY29kZV9kaWdpdDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgZGVjaW1hbCBkaWdpdCBhcyBleHBlY3RlZCBmb3IgVW5pY29kZSBjaGFyYWN0ZXJzP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc19kaWdpdCAoaXRlbSlcbiAgICBlbmRcblxuICBpc19oZXhhX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBoZXhhZGVjaW1hbCBkaWdpdCBhcyBleHBlY3RlZCBmb3IgQVNDSUkgY2hhcmFjdGVycz9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODlBQkNERUZhYmNlZGYuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2hleGFfZGlnaXQgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfc3BhY2U6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHdoaXRlIHNwYWNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc19zcGFjZSAoaXRlbSlcbiAgICBlbmRcblxuICBpc19wdW5jdHVhdGlvbjogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgcHVuY3R1YXRpb24/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3B1bmN0dWF0aW9uIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2FscGhhX251bWVyaWM6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhbHBoYWJldGljIG9yIGEgZGlnaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2FscGhhIChpdGVtKSBvciBwcm9wZXJ0aWVzLmlzX2RpZ2l0IChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2NvbnRyb2w6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIGNvbnRyb2wgY2hhcmFjdGVyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc19jb250cm9sIChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHByb3BlcnRpZXM6IENIQVJBQ1RFUl9QUk9QRVJUWVxuICAgICAgLS0gUHJvcGVydHkgZm9yIFVuaWNvZGUgY2hhcmFjdGVycy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkNoYXJhY3RlcnMsIHdpdGggY29tcGFyaXNvbiBvcGVyYXRpb25zIGFuZCBhbiBBU0NJSSBjb2RlXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uQ2hhclwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTEwLTMwIDA4OjMyOjQ2IC0wNzAwIChUdWUsIDMwIE9jdCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjAyMiAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzXG4gIENIQVJBQ1RFUl84XG5cbmluaGVyaXRcbiAgQ0hBUkFDVEVSXzhfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvZGUsXG4gICAgICB0b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0NIQVJBQ1RFUl84X1JFRn0pLFxuICB0b19jaGFyYWN0ZXJfMzI6IHtDSEFSQUNURVJfMzJ9XG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZTogSU5URUdFUlxuICAgICAgLS0gQXNzb2NpYXRlZCBpbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb25cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhIGNoYXJhY3RlciB2YWx1ZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xOSAxNDoyNjoxNCAtMDcwMCAoTW9uLCAxOSBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUxMTcgJFwiXG5cbmNsYXNzIENIQVJBQ1RFUl84X1JFRiBpbmhlcml0XG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IENIQVJBQ1RFUl84XG4gICAgICAtLSBDaGFyYWN0ZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgY29kZTogSU5URUdFUlxuICAgICAgLS0gQXNzb2NpYXRlZCBpbnRlZ2VyIHZhbHVlXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBuYXR1cmFsXzMyX2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uY29kZVxuICAgIGVuc3VyZVxuICAgICAgY29kZV9ub25fbmVnYXRpZjogUmVzdWx0ID49IDBcbiAgICAgIGNvZGVfaW5fcmFuZ2U6IFJlc3VsdCA+PSBtaW5fdmFsdWUgYW5kIFJlc3VsdCA8PSBtYXhfdmFsdWVcbiAgICBlbmRcblxuICBuYXR1cmFsXzMyX2NvZGU6IE5BVFVSQUxfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgbmF0dXJhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlLmhhc2hfY29kZVxuICAgIGVuZFxuXG4gIG1pbl92YWx1ZTogSU5URUdFUiA9IDBcbiAgbWF4X3ZhbHVlOiBJTlRFR0VSID0gMjU1XG4gIG1heF9hc2NpaV92YWx1ZTogSU5URUdFUiA9IDEyN1xuICAgICAgLS0gQm91bmRzIGZvciBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uIG9mIGNoYXJhY3RlcnMgKEFTQ0lJKVxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUgPCBvdGhlci5uYXR1cmFsXzMyX2NvZGVcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKG5hdHVyYWxfMzJfY29kZSA8IG90aGVyLm5hdHVyYWxfMzJfY29kZSlcbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIHJvdXRpbmVzXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoaW5jcjogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBZGQgYGluY3InIHRvIHRoZSBjb2RlIG9mIGBpdGVtJ1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luY3JlbWVudDogKGl0ZW0uY29kZSArIGluY3IpLmlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgKyBpbmNyKS50b19jaGFyYWN0ZXJfOFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgfC18IGl0ZW0gPSBpbmNyXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKGRlY3I6IElOVEVHRVIpOiBDSEFSQUNURVJfOFxuICAgICAgLS0gU3VidHJhY3QgYGRlY3InIGZyb20gdGhlIGNvZGUgb2YgYGl0ZW0nXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfZGVjcmVtZW50OiAoaXRlbS5jb2RlIC0gZGVjcikuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0uY29kZSAtIGRlY3IpLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IGl0ZW0gfC18IFJlc3VsdCA9IGRlY3JcbiAgICBlbmRcblxuICBkaWZmZXJlbmNlIGFsaWFzIFwifC18XCIgKG90aGVyOiBDSEFSQUNURVJfOCk6IElOVEVHRVJcbiAgICAgIC0tIERpZmZlcmVuY2UgYmV0d2VlbiB0aGUgY29kZXMgb2YgYGl0ZW0nIGFuZCBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmNvZGUgLSBvdGhlci5jb2RlXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IG90aGVyICsgUmVzdWx0ID0gaXRlbVxuICAgIGVuZFxuXG4gIG5leHQ6IENIQVJBQ1RFUl84XG4gICAgICAtLSBOZXh0IGNoYXJhY3RlclxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKGl0ZW0uY29kZSArIDEpLmlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gKyAxXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IDFcbiAgICBlbmRcblxuICBwcmV2aW91czogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFByZXZpb3VzIGNoYXJhY3RlclxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKGl0ZW0uY29kZSAtIDEpLmlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLSAxXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IC0xXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBNYWtlIGBjJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGNoYXJhY3RlclxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEpXG4gICAgICBSZXN1bHQuYXBwZW5kX2NoYXJhY3RlciAoaXRlbSlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBDSEFSQUNURVJfOF9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBDSEFSQUNURVJfOF9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvblxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvblxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuICBhc191cHBlciwgdXBwZXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBVcHBlcmNhc2UgdmFsdWUgb2YgYGl0ZW0nXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX2xvd2VyJ1xuICAgIGRvXG4gICAgICBpZiBpc19sb3dlciB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAoaXRlbS5jb2RlIC0gKCdhJykuY29kZSArICgnQScpLmNvZGUpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhc19sb3dlciwgbG93ZXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBMb3dlcmNhc2UgdmFsdWUgb2YgYGl0ZW0nXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX3VwcGVyJ1xuICAgIGRvXG4gICAgICBpZiBpc191cHBlciB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAoaXRlbS5jb2RlIC0gKCdBJykuY29kZSArICgnYScpLmNvZGUpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfYWxwaGE6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhbHBoYWJldGljP1xuICAgICAgLS0gQWxwaGFiZXRpYyBpcyBgaXNfdXBwZXInIG9yIGBpc19sb3dlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiAoaXNfdXBwZXJfZmxhZyB8IGlzX2xvd2VyX2ZsYWcpKSA+IDBcbiAgICBlbmRcblxuICBpc191cHBlcjogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIHVwcGVyY2FzZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiBpc191cHBlcl9mbGFnKSA+IDBcbiAgICBlbmRcblxuICBpc19sb3dlcjogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGxvd2VyY2FzZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiBpc19sb3dlcl9mbGFnKSA+IDBcbiAgICBlbmRcblxuICBpc19kaWdpdDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgZGlnaXQ/XG4gICAgICAtLSBBIGRpZ2l0IGlzIG9uZSBvZiAwMTIzNDU2Nzg5XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfZGlnaXRfZmxhZykgPiAwXG4gICAgZW5kXG5cbiAgaXNfaGV4YV9kaWdpdDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFuIGhleGFkZWNpbWFsIGRpZ2l0P1xuICAgICAgLS0gQSBkaWdpdCBpcyBvbmUgb2YgMDEyMzQ1Njc4OUFCQ0RFRmFiY2VkZlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIChpc19oZXhhX2RpZ2l0X2ZsYWcgfCBpc19kaWdpdF9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfc3BhY2U6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHdoaXRlIHNwYWNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3doaXRlX3NwYWNlX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX3B1bmN0dWF0aW9uOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBwdW5jdHVhdGlvbj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiBpc19wdW5jdHVhdGlvbl9mbGFnKSA+IDBcbiAgICBlbmRcblxuICBpc19hbHBoYV9udW1lcmljOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYWxwaGFiZXRpYyBvciBhIGRpZ2l0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcpKSA+IDBcbiAgICBlbmRcblxuICBpc19wcmludGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHByaW50YWJsZSBjaGFyYWN0ZXIgaW5jbHVkaW5nIHNwYWNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmXG4gICAgICAgIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcgfCBpc19wdW5jdHVhdGlvbl9mbGFnIHwgaXNfc3BhY2VfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX2dyYXBoOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBwcmludGFibGUgY2hhcmFjdGVyIGV4Y2VwdCBzcGFjZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJlxuICAgICAgICAoaXNfdXBwZXJfZmxhZyB8IGlzX2xvd2VyX2ZsYWcgfCBpc19kaWdpdF9mbGFnIHwgaXNfcHVuY3R1YXRpb25fZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX2NvbnRyb2w6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIGNvbnRyb2wgY2hhcmFjdGVyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX2NvbnRyb2xfZmxhZykgPiAwXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgY2hhcmFjdGVyX3R5cGVzIChhX2NvZGU6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgdHlwZSBmb3IgY2hhcmFjdGVyIG9mIGNvZGUgYGFfY29kZSdcbiAgICBkb1xuICAgICAgICAtLSBGb3IgY2hhcmFjdGVyIHdob3NlIGNvZGUgaXMgYWJvdmUgMjU2LCBpdCBpcyBhcyBpZlxuICAgICAgICAtLSB3ZSBoYWQgbm8gaW5mb3JtYXRpb24gYWJvdXQgaXQuXG4gICAgICBpZiBhX2NvZGUgPCAyNTYgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfY2hhcmFjdGVyX3R5cGVzLml0ZW0gKGFfY29kZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGludGVybmFsX2NoYXJhY3Rlcl90eXBlczogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgICAgLS0gQXJyYXkgd2hpY2ggc3RvcmVzIHRoZSB2YXJpb3VzIHR5cGUgZm9yIHRoZSBBU0NJSSBjaGFyYWN0ZXJzXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5ICgyNTYpXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgIC0tIDAgIG51bGxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMSAgc3RhcnQgb2YgaGVhZGluZ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyICBzdGFydCBvZiB0ZXh0XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDMgIGVuZCBvZiB0ZXh0XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDQgIGVuZCBvZiB0cmFuc21pc3Npb25cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNSAgZW5xdWlyeVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSA2ICBhY2tub3dsZWRnZVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3ICBiZWxsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDggIGJhY2tzcGFjZVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnIHwgaXNfd2hpdGVfc3BhY2VfZmxhZykgICAtLSA5ICBob3Jpem9udGFsIHRhYlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnIHwgaXNfd2hpdGVfc3BhY2VfZmxhZykgICAtLSAxMCBOTCBsaW5lIGZlZWQsIG5ldyBsaW5lXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDExIHZlcnRpY2FsIHRhYlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnIHwgaXNfd2hpdGVfc3BhY2VfZmxhZykgICAtLSAxMiBOUCBmb3JtIGZlZWQsIG5ldyBwYWdlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEzIGNhcnJpYWdlIHJldHVybj1DUlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNCBzaGlmdCBvdXRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTUgc2hpZnQgaW5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMThcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTlcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjBcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjNcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjcgRXNjYXBlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDI4IGZpbGUgc2VwYXJhdG9yXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDI5IGdyb3VwIHNlcGFyYXRvclxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAzMCByZWNvcmQgc2VwYXJhdG9yXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDMxIHVuaXQgc2VwYXJhdG9yXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc193aGl0ZV9zcGFjZV9mbGFnIHwgaXNfc3BhY2VfZmxhZykgICAgIC0tIDMyIFNwYWNlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDMzICFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzQgXCJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzUgI1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNiAkXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM3ICVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzggJlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzOSAnXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQwIChcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDEgKVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0MiAqXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQzICtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDQgLFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NSAtXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQ2IC5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDcgL1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA0OCAwXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDQ5IDFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTAgMlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MSAzXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDUyIDRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTMgNVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1NCA2XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU1IDdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTYgOFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1NyA5XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDU4IDpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNTkgO1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA2MCA8XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYxID1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjIgPlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA2MyA/XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDY0IEBcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNjUgQVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2NiBCXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY3IENcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNjggRFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2OSBFXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDcwIEZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzEgR1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3MiBIXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDczIElcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzQgSlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NSBLXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc2IExcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzcgTVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3OCBOXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc5IE9cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODAgUFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MSBRXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDgyIFJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODMgU1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4NCBUXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg1IFVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODYgVlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4NyBXXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg4IFhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODkgWVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA5MCBaXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDkxIFtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTIgXFxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTMgXVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5NCBeXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDk1IF9cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTYgYFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA5NyBhXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDk4IGJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gOTkgY1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSAxMDAgIGRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gMTAxICBlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDEwMiAgZlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDMgIGdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA0ICBoXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwNSAgaVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDYgIGpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA3ICBrXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwOCAgbFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDkgIG1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTEwICBuXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExMSAgb1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTIgIHBcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTEzICBxXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExNCAgclxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTUgIHNcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE2ICB0XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExNyAgdVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTggIHZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE5ICB3XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyMCAgeFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMjEgIHlcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTIyICB6XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDEyMyAge1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAxMjQgIHxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTI1ICB9XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDEyNiAgflxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMjcgIERFTFxuICAgICAgUmVzdWx0LmZpbGxfd2l0aCAoMCwgMTI4LCAyNTUpICAgICAgICAgICAgICAtLSBleHRlbmRlZCBBU0NJSVxuICAgIGVuc3VyZVxuICAgICAgaW50ZXJuYWxfY2hhcmFjdGVyX3R5cGVzX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGlzX3VwcGVyX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MDFcblxuICBpc19sb3dlcl9mbGFnOiBOQVRVUkFMXzggPSAweDAyXG5cbiAgaXNfZGlnaXRfZmxhZzogTkFUVVJBTF84ID0gMHgwNFxuXG4gIGlzX3doaXRlX3NwYWNlX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MDhcblxuICBpc19wdW5jdHVhdGlvbl9mbGFnOiBOQVRVUkFMXzggPSAweDEwXG5cbiAgaXNfY29udHJvbF9mbGFnOiBOQVRVUkFMXzggPSAweDIwXG5cbiAgaXNfaGV4YV9kaWdpdF9mbGFnOiBOQVRVUkFMXzggPSAweDQwXG5cbiAgaXNfc3BhY2VfZmxhZzogTkFUVVJBTF84ID0gMHg4MDtcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBjb2xsZWN0aW9uLCBhY2Nlc3M7XG4gIGFjY2VzczogbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBDT0xMRUNUSU9OIFtHXSBpbmhlcml0XG5cbiAgQ09OVEFJTkVSIFtHXVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfaW5zZXJ0ZWQgKHY6IEcpOiBCT09MRUFOXG4gICAgICAtLSBIYXMgYHYnIGJlZW4gaW5zZXJ0ZWQgYnkgdGhlIG1vc3QgcmVjZW50IGluc2VydGlvbj9cbiAgICAgIC0tIChCeSBkZWZhdWx0LCB0aGUgdmFsdWUgcmV0dXJuZWQgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nXG4gICAgICAtLSBgaGFzICh2KScuIEhvd2V2ZXIsIGRlc2NlbmRhbnRzIG1pZ2h0IGJlIGFibGUgdG8gcHJvdmlkZSBtb3JlXG4gICAgICAtLSBlZmZpY2llbnQgaW1wbGVtZW50YXRpb25zLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGhhcyAodilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCwgZXh0ZW5kICh2OiBHKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgc3RydWN0dXJlIGluY2x1ZGVzIGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGlzX2luc2VydGVkICh2KVxuICAgIGVuZFxuXG4gIGZpbGwgKG90aGVyOiBDT05UQUlORVIgW0ddKVxuICAgICAgLS0gRmlsbCB3aXRoIGFzIG1hbnkgaXRlbXMgb2YgYG90aGVyJyBhcyBwb3NzaWJsZS5cbiAgICAgIC0tIFRoZSByZXByZXNlbnRhdGlvbnMgb2YgYG90aGVyJyBhbmQgY3VycmVudCBzdHJ1Y3R1cmVcbiAgICAgIC0tIG5lZWQgbm90IGJlIHRoZSBzYW1lLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gICAgbG9jYWxcbiAgICAgIGxpbl9yZXA6IExJTkVBUiBbR11cbiAgICBkb1xuICAgICAgbGluX3JlcCA6PSBvdGhlci5saW5lYXJfcmVwcmVzZW50YXRpb25cbiAgICAgIGZyb21cbiAgICAgICAgbGluX3JlcC5zdGFydFxuICAgICAgdW50aWxcbiAgICAgICAgbm90IGV4dGVuZGlibGUgb3IgZWxzZSBsaW5fcmVwLm9mZlxuICAgICAgbG9vcFxuICAgICAgICBleHRlbmQgKGxpbl9yZXAuaXRlbSlcbiAgICAgICAgbGluX3JlcC5mb3J0aFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHBydW5lICh2OiBHKVxuICAgICAgLS0gUmVtb3ZlIG9uZSBvY2N1cnJlbmNlIG9mIGB2JyBpZiBhbnkuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsICh2OiBHKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiBgdicuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgICAgLS18RGVmYXVsdCBpbXBsZW1lbnRhdGlvbiwgdXN1YWxseSBpbmVmZmljaWVudC5cbiAgICByZXF1aXJlXG4gICAgICBwcnVuYWJsZTogcHJ1bmFibGVcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWwgbm90IGhhcyAodikgbG9vcFxuICAgICAgICBwcnVuZSAodilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbm9fbW9yZV9vY2N1cnJlbmNlczogbm90IGhhcyAodilcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcy5cbiAgICByZXF1aXJlXG4gICAgICBwcnVuYWJsZTogcHJ1bmFibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgd2lwZWRfb3V0OiBpc19lbXB0eVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQ09NUEFSQUJMRSBpbmhlcml0XG5cbiAgUEFSVF9DT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsIGlzX2xlc3NfZXF1YWwsXG4gICAgICBpc19ncmVhdGVyLCBpc19ncmVhdGVyX2VxdWFsLFxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgb2JqZWN0IGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGFzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG5vdCAob3RoZXIgPCBDdXJyZW50KVxuICAgIGVuZFxuXG4gIGlzX2xlc3NfZXF1YWwgYWxpYXMgXCI8PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBub3QgKG90aGVyIDwgQ3VycmVudClcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChDdXJyZW50IDwgb3RoZXIpIG9yIChDdXJyZW50IH4gb3RoZXIpKVxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXIgYWxpYXMgXCI+XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyIDwgQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAob3RoZXIgPCBDdXJyZW50KVxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXJfZXF1YWwgYWxpYXMgXCI+PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBub3QgKEN1cnJlbnQgPCBvdGhlcilcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKG90aGVyIDw9IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKG5vdCAoQ3VycmVudCA8IG90aGVyKSBhbmQgbm90IChvdGhlciA8IEN1cnJlbnQpKVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB0cmljaG90b215OiBSZXN1bHQgPSAobm90IChDdXJyZW50IDwgb3RoZXIpIGFuZCBub3QgKG90aGVyIDwgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgdGhyZWVfd2F5X2NvbXBhcmlzb24gKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBJTlRFR0VSXG4gICAgICAtLSBJZiBjdXJyZW50IG9iamVjdCBlcXVhbCB0byBgb3RoZXInLCAwO1xuICAgICAgLS0gaWYgc21hbGxlciwgLTE7IGlmIGdyZWF0ZXIsIDFcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA8IG90aGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbHNlaWYgb3RoZXIgPCBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXF1YWxfemVybzogKFJlc3VsdCA9IDApID0gKEN1cnJlbnQgfiBvdGhlcilcbiAgICAgIHNtYWxsZXJfbmVnYXRpdmU6IChSZXN1bHQgPSAtMSkgPSAoQ3VycmVudCA8IG90aGVyKVxuICAgICAgZ3JlYXRlcl9wb3NpdGl2ZTogKFJlc3VsdCA9IDEpID0gKEN1cnJlbnQgPiBvdGhlcilcbiAgICBlbmRcblxuICBtYXggKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRoZSBncmVhdGVyIG9mIGN1cnJlbnQgb2JqZWN0IGFuZCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPj0gb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gb3RoZXJcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY3VycmVudF9pZl9ub3Rfc21hbGxlcjogQ3VycmVudCA+PSBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IEN1cnJlbnRcbiAgICAgIG90aGVyX2lmX3NtYWxsZXI6IEN1cnJlbnQgPCBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IG90aGVyXG4gICAgZW5kXG5cbiAgbWluIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBUaGUgc21hbGxlciBvZiBjdXJyZW50IG9iamVjdCBhbmQgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50IDw9IG90aGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG90aGVyXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGN1cnJlbnRfaWZfbm90X2dyZWF0ZXI6IEN1cnJlbnQgPD0gb3RoZXIgaW1wbGllcyBSZXN1bHQgPSBDdXJyZW50XG4gICAgICBvdGhlcl9pZl9ncmVhdGVyOiBDdXJyZW50ID4gb3RoZXIgaW1wbGllcyBSZXN1bHQgPSBvdGhlclxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBpcnJlZmxleGl2ZV9jb21wYXJpc29uOiBub3QgKEN1cnJlbnQgPCBDdXJyZW50KVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogYWNjZXNzO1xuICBhY2Nlc3M6IG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgQ09OVEFJTkVSIFtHXVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGhhcyAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RydWN0dXJlIGluY2x1ZGUgYHYnP1xuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbm90X2ZvdW5kX2luX2VtcHR5OiBSZXN1bHQgaW1wbGllcyBub3QgaXNfZW1wdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfZW1wdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIGVsZW1lbnQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBlbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gZWxlbWVudD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDA6IFVzZSBgaXNfZW1wdHknIGluc3RlYWRcIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfZW1wdHlcbiAgICBlbmRcblxuICBvYmplY3RfY29tcGFyaXNvbjogQk9PTEVBTlxuICAgICAgLS0gTXVzdCBzZWFyY2ggb3BlcmF0aW9ucyB1c2UgYGVxdWFsJyByYXRoZXIgdGhhbiBgPSdcbiAgICAgIC0tIGZvciBjb21wYXJpbmcgcmVmZXJlbmNlcz8gKERlZmF1bHQ6IG5vLCB1c2UgYD0nLilcblxuICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBCT09MRUFOXG4gICAgICAtLSBNYXkgYG9iamVjdF9jb21wYXJpc29uJyBiZSBjaGFuZ2VkP1xuICAgICAgLS0gKEFuc3dlcjogeWVzIGJ5IGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyBzZXR0aW5nXG5cbiAgY29tcGFyZV9vYmplY3RzXG4gICAgICAtLSBFbnN1cmUgdGhhdCBmdXR1cmUgc2VhcmNoIG9wZXJhdGlvbnMgd2lsbCB1c2UgYGVxdWFsJ1xuICAgICAgLS0gcmF0aGVyIHRoYW4gYD0nIGZvciBjb21wYXJpbmcgcmVmZXJlbmNlcy5cbiAgICByZXF1aXJlXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZG9cbiAgICAgIG9iamVjdF9jb21wYXJpc29uIDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIG9iamVjdF9jb21wYXJpc29uXG4gICAgZW5kXG5cbiAgY29tcGFyZV9yZWZlcmVuY2VzXG4gICAgICAtLSBFbnN1cmUgdGhhdCBmdXR1cmUgc2VhcmNoIG9wZXJhdGlvbnMgd2lsbCB1c2UgYD0nXG4gICAgICAtLSByYXRoZXIgdGhhbiBgZXF1YWwnIGZvciBjb21wYXJpbmcgcmVmZXJlbmNlcy5cbiAgICByZXF1aXJlXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZG9cbiAgICAgIG9iamVjdF9jb21wYXJpc29uIDo9IEZhbHNlXG4gICAgZW5zdXJlXG4gICAgICByZWZlcmVuY2VfY29tcGFyaXNvbjogbm90IG9iamVjdF9jb21wYXJpc29uXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtHXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDdXJzb3JzIGZvciByZW1lbWJlcmluZyBwb3NpdGlvbnMgaW4gYXJiaXRyYXJ5IGRhdGEgc3RydWN0dXJlc1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGN1cnNvcjtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmNsYXNzXG4gIENVUlNPUlxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogY3Vyc29yX3N0cnVjdHVyZSwgYWNjZXNzO1xuICBhY2Nlc3M6IGN1cnNvciwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBDVVJTT1JfU1RSVUNUVVJFIFtHXSBpbmhlcml0XG5cbiAgQUNUSVZFIFtHXVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGN1cnNvcjogQ1VSU09SXG4gICAgICAtLSBDdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjdXJzb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHZhbGlkX2N1cnNvciAocDogQ1VSU09SKTogQk9PTEVBTlxuICAgICAgLS0gQ2FuIHRoZSBjdXJzb3IgYmUgbW92ZWQgdG8gcG9zaXRpb24gYHAnP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgZ29fdG8gKHA6IENVUlNPUilcbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIHBvc2l0aW9uIGBwJy5cbiAgICByZXF1aXJlXG4gICAgICBjdXJzb3JfcG9zaXRpb25fdmFsaWQ6IHZhbGlkX2N1cnNvciAocClcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiT2JqZWN0cyB0aGF0IHByb3ZpZGUgYW4gb3V0cHV0IGluIGRlYnVnZ2VyXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTAxLTE3IDExOjQ2OjE1IC0wODAwIChUaHUsIDE3IEphbiAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjEyNCAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgREVCVUdfT1VUUFVUXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRlYnVnX291dHB1dDogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUxcbiAgICAgIC0tIFN0cmluZyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGVidWdnZXIgdG8gcmVwcmVzZW50IGBDdXJyZW50Jy5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTEyLTI2IDE4OjU3OjUwIC0wODAwIChXZWQsIDI2IERlYyAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjA5NiAkXCJcblxuY2xhc3NcbiAgREVWRUxPUEVSX0VYQ0VQVElPTlxuXG5pbmhlcml0XG4gIEVYQ0VQVElPTlxuICAgIHJlZGVmaW5lXG4gICAgICBjb2RlLFxuICAgICAgdGFnXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgZnJvemVuIGNvZGU6IElOVEVHRVJcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB7RVhDRVBfQ09OU1R9LmRldmVsb3Blcl9leGNlcHRpb25cbiAgICBlbmRcblxuICB0YWc6IElNTVVUQUJMRV9TVFJJTkdfMzJcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9zdHJpbmdfOCAoXCJEZXZlbG9wZXIgZXhjZXB0aW9uLlwiKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUGVyZm9ybSBjbGVhbnVwIG9wZXJhdGlvbnMgYmVmb3JlIGN1cnJlbnQgaW5zdGFuY2UgaXMgcmVjbGFpbWVkIGJ5IGdhcmJhZ2UgY29sbGVjdGlvbi5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBESVNQT1NBQkxFXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIGRpc3Bvc2VcbiAgICAgIC0tIEFjdGlvbiB0byBiZSBleGVjdXRlZCBqdXN0IGJlZm9yZSBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgIC0tIHJlY2xhaW1zIGFuIG9iamVjdC5cbiAgICAgIC0tIEVmZmVjdCBpdCBpbiBkZXNjZW5kYW50cyB0byBwZXJmb3JtIHNwZWNpZmljIGRpc3Bvc2VcbiAgICAgIC0tIGFjdGlvbnMuIFRob3NlIGFjdGlvbnMgc2hvdWxkIG9ubHkgdGFrZSBjYXJlIG9mIGZyZWVpbmdcbiAgICAgIC0tIGV4dGVybmFsIHJlc291cmNlczsgdGhleSBzaG91bGQgbm90IHBlcmZvcm0gcmVtb3RlIGNhbGxzXG4gICAgICAtLSBvbiBvdGhlciBvYmplY3RzIHNpbmNlIHRoZXNlIG1heSBhbHNvIGJlIGRlYWQgYW5kIHJlY2xhaW1lZC5cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaW5fZmluYWxfY29sbGVjdDogQk9PTEVBTlxuICAgICAgLS0gSXMgR0MgY3VycmVudGx5IHBlcmZvcm1pbmcgZmluYWwgY29sbGVjdGlvblxuICAgICAgLS0gYWZ0ZXIgZXhlY3V0aW9uIG9mIGN1cnJlbnQgcHJvZ3JhbT9cbiAgICAgIC0tIFNhZmUgdG8gdXNlIGluIGBkaXNwb3NlJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIGlubGluZSB1c2UgJVwiZWlmX21lbW9yeS5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJyZXR1cm4gZWlmX2lzX2luX2ZpbmFsX2NvbGxlY3Q7XCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkR5bmFtaWNhbGx5IG1vZGlmaWFibGUgY2hhaW5zXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogZHluYW1pY19jaGFpbiwgc2VxdWVuY2U7XG4gIGFjY2VzczogaW5kZXgsIGN1cnNvciwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBEWU5BTUlDX0NIQUlOIFtHXSBpbmhlcml0XG5cbiAgQ0hBSU4gW0ddXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSByZW1vdmUsIHBydW5lX2FsbCwgcHJ1bmVcbiAgICB1bmRlZmluZVxuICAgICAgcmVtb3ZlLCBwcnVuZV9hbGwsIHBydW5lXG4gICAgZW5kXG5cbiAgVU5CT1VOREVEIFtHXVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkPyAoQW5zd2VyOiB5ZXMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dF9mcm9udCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyBhdCBiZWdpbm5pbmcuXG4gICAgICAtLSBEbyBub3QgbW92ZSBjdXJzb3IuXG4gICAgcmVxdWlyZVxuICAgICAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaXRlbV9pbnNlcnRlZDogZmlyc3QgPSB2XG4gICAgZW5kXG5cbiAgcHV0X2xlZnQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIEFkZCBgdicgdG8gdGhlIGxlZnQgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIHJlcXVpcmVcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICAgIG5vdF9iZWZvcmU6IG5vdCBiZWZvcmVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIG5ld19pbmRleDogaW5kZXggPSBvbGQgaW5kZXggKyAxXG4gICAgZW5kXG5cbiAgcHV0X3JpZ2h0ICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIHRoZSByaWdodCBvZiBjdXJzb3IgcG9zaXRpb24uXG4gICAgICAtLSBEbyBub3QgbW92ZSBjdXJzb3IuXG4gICAgcmVxdWlyZVxuICAgICAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICAgICAgbm90X2FmdGVyOiBub3QgYWZ0ZXJcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHNhbWVfaW5kZXg6IGluZGV4ID0gb2xkIGluZGV4XG4gICAgZW5kXG5cbiAgbWVyZ2VfbGVmdCAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIE1lcmdlIGBvdGhlcicgaW50byBjdXJyZW50IHN0cnVjdHVyZSBiZWZvcmUgY3Vyc29yXG4gICAgICAtLSBwb3NpdGlvbi4gRG8gbm90IG1vdmUgY3Vyc29yLiBFbXB0eSBgb3RoZXInLlxuICAgIHJlcXVpcmVcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICAgIG5vdF9iZWZvcmU6IG5vdCBiZWZvcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgbm90X2N1cnJlbnQ6IG90aGVyIC89IEN1cnJlbnRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBvdGhlci5jb3VudFxuICAgICAgbmV3X2luZGV4OiBpbmRleCA9IG9sZCBpbmRleCArIG9sZCBvdGhlci5jb3VudFxuICAgICAgb3RoZXJfaXNfZW1wdHk6IG90aGVyLmlzX2VtcHR5XG4gICAgZW5kXG5cbiAgbWVyZ2VfcmlnaHQgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBNZXJnZSBgb3RoZXInIGludG8gY3VycmVudCBzdHJ1Y3R1cmUgYWZ0ZXIgY3Vyc29yXG4gICAgICAtLSBwb3NpdGlvbi4gRG8gbm90IG1vdmUgY3Vyc29yLiBFbXB0eSBgb3RoZXInLlxuICAgIHJlcXVpcmVcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICAgIG5vdF9hZnRlcjogbm90IGFmdGVyXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIG5vdF9jdXJyZW50OiBvdGhlciAvPSBDdXJyZW50XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgb3RoZXIuY291bnRcbiAgICAgIHNhbWVfaW5kZXg6IGluZGV4ID0gb2xkIGluZGV4XG4gICAgICBvdGhlcl9pc19lbXB0eTogb3RoZXIuaXNfZW1wdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcHJ1bmUgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2JywgaWYgYW55LFxuICAgICAgLS0gYWZ0ZXIgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gSWYgZm91bmQsIG1vdmUgY3Vyc29yIHRvIHJpZ2h0IG5laWdoYm9yO1xuICAgICAgLS0gaWYgbm90LCBtYWtlIHN0cnVjdHVyZSBgZXhoYXVzdGVkJy5cbiAgICBkb1xuICAgICAgc2VhcmNoICh2KVxuICAgICAgaWYgbm90IGV4aGF1c3RlZCB0aGVuXG4gICAgICAgIHJlbW92ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2xlZnRcbiAgICAgIC0tIFJlbW92ZSBpdGVtIHRvIHRoZSBsZWZ0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICByZXF1aXJlXG4gICAgICBsZWZ0X2V4aXN0czogaW5kZXggPiAxXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgLSAxXG4gICAgICBuZXdfaW5kZXg6IGluZGV4ID0gb2xkIGluZGV4IC0gMVxuICAgIGVuZFxuXG4gIHJlbW92ZV9yaWdodFxuICAgICAgLS0gUmVtb3ZlIGl0ZW0gdG8gdGhlIHJpZ2h0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICByZXF1aXJlXG4gICAgICByaWdodF9leGlzdHM6IGluZGV4IDwgY291bnRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCAtIDFcbiAgICAgIHNhbWVfaW5kZXg6IGluZGV4ID0gb2xkIGluZGV4XG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGB2Jy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgICAtLSBMZWF2ZSBzdHJ1Y3R1cmUgYGV4aGF1c3RlZCcuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgICAgc2VhcmNoICh2KVxuICAgICAgdW50aWxcbiAgICAgICAgZXhoYXVzdGVkXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZVxuICAgICAgICBzZWFyY2ggKHYpXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXNfZXhoYXVzdGVkOiBleGhhdXN0ZWRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBzdGFydFxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHlcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGR1cGxpY2F0ZSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWItY2hhaW4gYmVnaW5uaW5nIGF0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgIC0tIGFuZCBoYXZpbmcgbWluIChgbicsIGBmcm9tX2hlcmUnKSBpdGVtcyxcbiAgICAgIC0tIHdoZXJlIGBmcm9tX2hlcmUnIGlzIHRoZSBudW1iZXIgb2YgaXRlbXNcbiAgICAgIC0tIGF0IG9yIHRvIHRoZSByaWdodCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgIGxvY2FsXG4gICAgICBwb3M6IENVUlNPUlxuICAgICAgY291bnRlcjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfY2hhaW5cbiAgICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIFJlc3VsdC5jb21wYXJlX29iamVjdHNcbiAgICAgICAgZW5kXG4gICAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIHVudGlsXG4gICAgICAgIChjb3VudGVyID0gbikgb3IgZWxzZSBleGhhdXN0ZWRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LmV4dGVuZCAoaXRlbSlcbiAgICAgICAgZm9ydGhcbiAgICAgICAgY291bnRlciA6PSBjb3VudGVyICsgMVxuICAgICAgZW5kXG4gICAgICBnb190byAocG9zKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtEWU5BTUlDX0NIQUlOfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIG5ld19jaGFpbjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBBIG5ld2x5IGNyZWF0ZWQgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBtYXkgYmUgcmVkZWZpbmVkIGluIGRlc2NlbmRhbnRzIHNvIGFzIHRvXG4gICAgICAtLSBwcm9kdWNlIGFuIGFkZXF1YXRlbHkgYWxsb2NhdGVkIGFuZCBpbml0aWFsaXplZCBvYmplY3QuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgU2VxdWVudGlhbCwgZHluYW1pY2FsbHkgbW9kaWZpYWJsZSBsaXN0cyxcbiAgICB3aXRob3V0IGNvbW1pdG1lbnQgdG8gYSBwYXJ0aWN1bGFyIHJlcHJlc2VudGF0aW9uXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGR5bmFtaWNfbGlzdCwgc2VxdWVuY2U7XG4gIGFjY2VzczogaW5kZXgsIGN1cnNvciwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBEWU5BTUlDX0xJU1QgW0ddIGluaGVyaXRcblxuICBMSVNUIFtHXVxuICAgIHVuZGVmaW5lXG4gICAgICBwcnVuZSxcbiAgICAgIHNlcXVlbnRpYWxfaW5kZXhfb2YsIHNlcXVlbnRpYWxfaGFzLFxuICAgICAgcmVtb3ZlLCBwcnVuZV9hbGxcbiAgICBlbmRcblxuICBEWU5BTUlDX0NIQUlOIFtHXVxuICAgIHJlbmFtZVxuICAgICAgd2lwZV9vdXQgYXMgY2hhaW5fd2lwZV9vdXRcbiAgICBleHBvcnRcbiAgICAgIHtOT05FfSBjaGFpbl93aXBlX291dFxuICAgIHVuZGVmaW5lXG4gICAgICBpc19lcXVhbFxuICAgIHJlZGVmaW5lXG4gICAgICBwdXRfbGVmdCwgcHV0X3JpZ2h0LFxuICAgICAgcmVtb3ZlX2xlZnQsIHJlbW92ZV9yaWdodFxuICAgIGVuZFxuXG4gIERZTkFNSUNfQ0hBSU4gW0ddXG4gICAgdW5kZWZpbmVcbiAgICAgIGlzX2VxdWFsXG4gICAgcmVkZWZpbmVcbiAgICAgIHB1dF9sZWZ0LCBwdXRfcmlnaHQsXG4gICAgICByZW1vdmVfbGVmdCwgcmVtb3ZlX3JpZ2h0LCB3aXBlX291dFxuICAgIHNlbGVjdFxuICAgICAgd2lwZV9vdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dF9sZWZ0ICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIHRoZSBsZWZ0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBsb2NhbFxuICAgICAgdGVtcDogbGlrZSBpdGVtXG4gICAgZG9cbiAgICAgIGlmIGlzX2VtcHR5IHRoZW5cbiAgICAgICAgcHV0X2Zyb250ICh2KVxuICAgICAgZWxzZWlmIGFmdGVyIHRoZW5cbiAgICAgICAgYmFja1xuICAgICAgICBwdXRfcmlnaHQgKHYpXG4gICAgICAgIG1vdmUgKDIpXG4gICAgICBlbHNlXG4gICAgICAgIHRlbXAgOj0gaXRlbVxuICAgICAgICByZXBsYWNlICh2KVxuICAgICAgICBwdXRfcmlnaHQgKHRlbXApXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwdXRfcmlnaHQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIEFkZCBgdicgdG8gdGhlIHJpZ2h0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIG1lcmdlX2xlZnQgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBNZXJnZSBgb3RoZXInIGludG8gY3VycmVudCBzdHJ1Y3R1cmUgYmVmb3JlIGN1cnNvclxuICAgICAgLS0gcG9zaXRpb24uIERvIG5vdCBtb3ZlIGN1cnNvci4gRW1wdHkgYG90aGVyJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBvdGhlci5zdGFydFxuICAgICAgdW50aWxcbiAgICAgICAgb3RoZXIuaXNfZW1wdHlcbiAgICAgIGxvb3BcbiAgICAgICAgcHV0X2xlZnQgKG90aGVyLml0ZW0pXG4gICAgICAgIG90aGVyLnJlbW92ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWVyZ2VfcmlnaHQgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBNZXJnZSBgb3RoZXInIGludG8gY3VycmVudCBzdHJ1Y3R1cmUgYWZ0ZXIgY3Vyc29yXG4gICAgICAtLSBwb3NpdGlvbi4gRG8gbm90IG1vdmUgY3Vyc29yLiBFbXB0eSBgb3RoZXInLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG90aGVyLmZpbmlzaFxuICAgICAgdW50aWxcbiAgICAgICAgb3RoZXIuaXNfZW1wdHlcbiAgICAgIGxvb3BcbiAgICAgICAgcHV0X3JpZ2h0IChvdGhlci5pdGVtKVxuICAgICAgICBvdGhlci5iYWNrXG4gICAgICAgIG90aGVyLnJlbW92ZV9yaWdodFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlbW92ZVxuICAgICAgLS0gUmVtb3ZlIGN1cnJlbnQgaXRlbS5cbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIHJpZ2h0IG5laWdoYm9yXG4gICAgICAtLSAob3IgYGFmdGVyJyBpZiBubyByaWdodCBuZWlnaGJvcikuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgYWZ0ZXJfd2hlbl9lbXB0eTogaXNfZW1wdHkgaW1wbGllcyBhZnRlclxuICAgIGVuZFxuXG4gIHJlbW92ZV9sZWZ0XG4gICAgICAtLSBSZW1vdmUgaXRlbSB0byB0aGUgbGVmdCBvZiBjdXJzb3IgcG9zaXRpb24uXG4gICAgICAtLSBEbyBub3QgbW92ZSBjdXJzb3IuXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICByZW1vdmVfcmlnaHRcbiAgICAgIC0tIFJlbW92ZSBpdGVtIHRvIHRoZSByaWdodCBvZiBjdXJzb3IgcG9zaXRpb24uXG4gICAgICAtLSBEbyBub3QgbW92ZSBjdXJzb3IuXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcy5cbiAgICBkb1xuICAgICAgY2hhaW5fd2lwZV9vdXRcbiAgICAgIGJhY2tcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXNfYmVmb3JlOiBiZWZvcmVcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBDb25zdGFudHMgdXNlZCBmb3IgZXhjZXB0aW9uIGhhbmRsaW5nLlxuICAgIFRoaXMgY2xhc3MgbWF5IGJlIHVzZWQgYXMgYW5jZXN0b3IgYnkgY2xhc3NlcyBuZWVkaW5nIGl0cyBmYWNpbGl0aWVzLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzc1xuICBFWENFUF9DT05TVFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIFZvaWRfY2FsbF90YXJnZXQ6IElOVEVHRVIgPSAxXG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgZmVhdHVyZSBhcHBsaWVkIHRvIHZvaWQgcmVmZXJlbmNlXG5cbiAgTm9fbW9yZV9tZW1vcnk6IElOVEVHRVIgPSAyXG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgZmFpbGVkIG1lbW9yeSBhbGxvY2F0aW9uXG5cbiAgUHJlY29uZGl0aW9uOiBJTlRFR0VSID0gM1xuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIHZpb2xhdGVkIHByZWNvbmRpdGlvblxuXG4gIFBvc3Rjb25kaXRpb246IElOVEVHRVIgPSA0XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgdmlvbGF0ZWQgcG9zdGNvbmRpdGlvblxuXG4gIEZsb2F0aW5nX3BvaW50X2V4Y2VwdGlvbjogSU5URUdFUiA9IDVcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBmbG9hdGluZyBwb2ludCBleGNlcHRpb25cblxuICBDbGFzc19pbnZhcmlhbnQ6IElOVEVHRVIgPSA2XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgdmlvbGF0ZWQgY2xhc3MgaW52YXJpYW50XG5cbiAgQ2hlY2tfaW5zdHJ1Y3Rpb246IElOVEVHRVIgPSA3XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgdmlvbGF0ZWQgY2hlY2tcblxuICBSb3V0aW5lX2ZhaWx1cmU6IElOVEVHRVIgPSA4XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgZmFpbGVkIHJvdXRpbmVcblxuICBJbmNvcnJlY3RfaW5zcGVjdF92YWx1ZTogSU5URUdFUiA9ICA5XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgaW5zcGVjdCB2YWx1ZSB3aGljaCBpcyBub3Qgb25lXG4gICAgICAtLSBvZiB0aGUgaW5zcGVjdCBjb25zdGFudHMsIGlmIHRoZXJlIGlzIG5vIEVsc2VfcGFydFxuXG4gIExvb3BfdmFyaWFudDogSU5URUdFUiA9IDEwXG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3Igbm9uLWRlY3JlYXNlZCBsb29wIHZhcmlhbnRcblxuICBMb29wX2ludmFyaWFudDogSU5URUdFUiA9IDExXG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgdmlvbGF0ZWQgbG9vcCBpbnZhcmlhbnRcblxuICBTaWduYWxfZXhjZXB0aW9uOiBJTlRFR0VSID0gMTJcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBvcGVyYXRpbmcgc3lzdGVtIHNpZ25hbFxuXG4gIEVpZmZlbF9ydW50aW1lX3BhbmljOiBJTlRFR0VSID0gMTNcbiAgICAgIC0tIEVpZmZlbCBydW4tdGltZSBwYW5pY1xuXG4gIFJlc2N1ZV9leGNlcHRpb246IElOVEVHRVIgPSAxNFxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIGV4Y2VwdGlvbiBpbiByZXNjdWUgY2xhdXNlXG5cbiAgT3V0X29mX21lbW9yeTogSU5URUdFUiA9IDE1XG4gICAgICAtLSBPdXQgb2YgbWVtb3J5IChjYW5ub3QgYmUgaWdub3JlZClcblxuICBSZXN1bXB0aW9uX2ZhaWxlZDogSU5URUdFUiA9IDE2XG4gICAgICAtLSBSZXN1bXB0aW9uIGZhaWxlZCAocmV0cnkgZGlkIG5vdCBzdWNjZWVkKVxuXG4gIENyZWF0ZV9vbl9kZWZlcnJlZDogSU5URUdFUiA9IDE3XG4gICAgICAtLSBDcmVhdGUgb24gZGVmZXJyZWRcblxuICBFeHRlcm5hbF9leGNlcHRpb246IElOVEVHRVIgPSAxOFxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIG9wZXJhdGluZyBzeXN0ZW0gZXJyb3JcbiAgICAgIC0tIHdoaWNoIGRvZXMgbm90IHNldCB0aGUgYGVycm5vJyB2YXJpYWJsZVxuICAgICAgLS0gKFVuaXgtc3BlY2lmaWMpXG5cbiAgVm9pZF9hc3NpZ25lZF90b19leHBhbmRlZDogSU5URUdFUiA9IDE5XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgYXNzaWdubWVudCBvZiB2b2lkIHZhbHVlXG4gICAgICAtLSB0byBleHBhbmRlZCBlbnRpdHlcblxuICBFeGNlcHRpb25faW5fc2lnbmFsX2hhbmRsZXI6IElOVEVHRVIgPSAyMFxuICAgICAgLS0gRXhjZXB0aW9uIGluIHNpZ25hbCBoYW5kbGVyXG5cbiAgSW9fZXhjZXB0aW9uOiBJTlRFR0VSID0gMjFcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBJL08gZXJyb3JcblxuICBPcGVyYXRpbmdfc3lzdGVtX2V4Y2VwdGlvbjogSU5URUdFUiA9IDIyXG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3Igb3BlcmF0aW5nIHN5c3RlbSBlcnJvclxuICAgICAgLS0gd2hpY2ggc2V0cyB0aGUgYGVycm5vJyB2YXJpYWJsZVxuICAgICAgLS0gKFVuaXgtc3BlY2lmaWMpXG5cbiAgUmV0cmlldmVfZXhjZXB0aW9uOiBJTlRFR0VSID0gMjNcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciByZXRyaWV2YWwgZXJyb3JcbiAgICAgIC0tIG1heSBiZSByYWlzZWQgYnkgYHJldHJpZXZlZCcgaW4gYElPX01FRElVTScuXG5cbiAgRGV2ZWxvcGVyX2V4Y2VwdGlvbjogSU5URUdFUiA9IDI0XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgZGV2ZWxvcGVyIGV4Y2VwdGlvblxuXG4gIEVpZmZlbF9ydW50aW1lX2ZhdGFsX2Vycm9yOiBJTlRFR0VSID0gMjVcbiAgICAgIC0tIEVpZmZlbCBydW4tdGltZSBmYXRhbCBlcnJvclxuXG4gIERvbGxhcl9hcHBsaWVkX3RvX21lbHRlZF9mZWF0dXJlOiBJTlRFR0VSID0gMjZcbiAgICAgIC0tICQgYXBwbGllZCB0byBtZWx0ZWQgZmVhdHVyZVxuXG4gIFJ1bnRpbWVfaW9fZXhjZXB0aW9uOiBJTlRFR0VSID0gMjdcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBJL08gZXJyb3IgcmFpc2VkIGJ5IHJ1bnRpbWUgZnVuY3Rpb25zXG4gICAgICAtLSBzdWNoIGFzIHN0b3JlL3JldHJpZXZlLCBmaWxlIGFjY2Vzcy4uLlxuXG4gIENvbV9leGNlcHRpb246IElOVEVHRVIgPSAyOFxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIGEgQ09NIGVycm9yLlxuXG4gIFJ1bnRpbWVfY2hlY2tfZXhjZXB0aW9uOiBJTlRFR0VSID0gMjlcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBydW50aW1lIGNoZWNrIGJlaW5nIHZpb2xhdGVkLlxuXG4gIG9sZF9leGNlcHRpb246IElOVEVHRVIgPSAzMFxuICAgICAgLS0gT2xkIGV4Y2VwdGlvbiBjb2RlLlxuXG4gIHNlcmlhbGl6YXRpb25fZXhjZXB0aW9uOiBJTlRFR0VSID0gMzFcbiAgICAgIC0tIFNlcmlhbGl6YXRpb24gZXhjZXB0aW9uIGNvZGUuXG5cbiAgbnVtYmVyX29mX2NvZGVzOiBJTlRFR0VSID0gMzFcbiAgICAgIC0tIEhvdyBtYW55IGNvZGVzIGFyZSB0aGVyZSB0byByZXByZXNlbnQgZXhjZXB0aW9ucz9cblxuICB2YWxpZF9jb2RlIChjOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGMnIGEgdmFsaWQgY29kZSB0byByZXByZXNlbnQgc29tZSBraW5kIG9mIGV4Y2VwdGlvbnM/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjID49IDEgYW5kIGMgPD0gbnVtYmVyX29mX2NvZGVzXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgQW5jZXN0b3Igb2YgYWxsIGV4Y2VwdGlvbiBjbGFzc2VzLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTItMjggMDY6MDc6MDMgLTA4MDAgKEZyaSwgMjggRGVjIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDk4ICRcIlxuXG5jbGFzc1xuICBFWENFUFRJT05cblxuaW5oZXJpdFxuICBFWENFUFRJT05fTUFOQUdFUl9GQUNUT1JZXG4gICAgdW5kZWZpbmVcbiAgICAgIG91dFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2Vfd2l0aF90YWdfYW5kX3RyYWNlXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV93aXRoX3RhZ19hbmRfdHJhY2UgKGFfdGFnLCBhX3RyYWNlX3N0cmluZzogU1RSSU5HKVxuICAgICAgLS0gTWFrZSBgQ3VycmVudCcgd2l0aCBgZGVzY3JpcHRpb24nIHNldCB0byBgYV90YWcnLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgZGVmYXVsdF9jcmVhdGUnIGFuZCBgc2V0X2Rlc2NyaXB0aW9uJyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdGFnX25vdF92b2lkOiBhX3RhZyAvPSBWb2lkXG4gICAgICB0cmFjZV9zdHJpbmdfbm90X3ZvaWQ6IGFfdHJhY2Vfc3RyaW5nIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2Rlc2NyaXB0aW9uIChhX3RhZylcbiAgICBlbnN1cmVcbiAgICAgIGRlc2NyaXB0aW9uX3NldDogYXR0YWNoZWQgZGVzY3JpcHRpb24gYXMgbF9kZXMgYW5kIHRoZW4gYV90YWcuc2FtZV9zdHJpbmdfZ2VuZXJhbCAobF9kZXMpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmFpc2VcblxuICByYWlzZVxuICAgICAgLS0gUmFpc2UgY3VycmVudCBleGNlcHRpb25cbiAgICByZXF1aXJlXG4gICAgICBpc19yYWlzYWJsZTogaXNfcmFpc2FibGVcbiAgICBkb1xuICAgICAgZXhjZXB0aW9uX21hbmFnZXIucmFpc2UgKEN1cnJlbnQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbWVhbmluZzogU1RSSU5HXG4gICAgICAtLSBBIHNob3J0IG1lc3NhZ2UgZGVzY3JpYmluZyB3aGF0IGN1cnJlbnQgZXhjZXB0aW9uIGlzXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0YWcnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRhZy5hc19zdHJpbmdfOFxuICAgIGVuZFxuXG4gIHRhZzogSU1NVVRBQkxFX1NUUklOR18zMlxuICAgICAgLS0gQSBzaG9ydCBtZXNzYWdlIGRlc2NyaWJpbmcgd2hhdCBjdXJyZW50IGV4Y2VwdGlvbiBpc1xuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZ184IChcIkdlbmVyYWwgZXhjZXB0aW9uXCIpXG4gICAgZW5kXG5cbiAgbWVzc2FnZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE1lc3NhZ2Ugb2YgY3VycmVudCBleGNlcHRpb25cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGRlc2NyaXB0aW9uJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGNfZGVzY3JpcHRpb24gYXMgbF9tIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfbS5zdWJzdHJpbmcgKDEsIGxfbS5jb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRlc2NyaXB0aW9uOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICAtLSBEZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiBjdXJyZW50IGV4Y2VwdGlvblxuICAgIGxvY2FsXG4gICAgICB1OiBVVEZfQ09OVkVSVEVSXG4gICAgICBsX3JlczogU1RSSU5HXzMyXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGNfZGVzY3JpcHRpb24gYXMgbF9tIHRoZW5cbiAgICAgICAgICAtLSBEZXNjcmlwdGlvbiBpcyBlbmNvZGVkIGluIFVURi04IGJ5IHRoZSBydW50aW1lLlxuICAgICAgICBjcmVhdGUgbF9yZXMubWFrZSAobF9tLmNvdW50KVxuICAgICAgICB1LnV0Zl84XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChsX20ubWFuYWdlZF9kYXRhLCAwLCBsX20uY291bnQgLSAxLCBGYWxzZSwgbF9yZXMpXG4gICAgICAgIFJlc3VsdCA6PSBsX3Jlc1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZXhjZXB0aW9uX3RyYWNlOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgZXhjZXB0aW9uIHRyYWNlXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0cmFjZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfdHJhY2VcbiAgICBlbmRcblxuICB0cmFjZTogZGV0YWNoYWJsZSBTVFJJTkdfMzJcbiAgICAgIC0tIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBjdXJyZW50IGV4Y2VwdGlvbiB0cmFjZVxuICAgIGxvY2FsXG4gICAgICB1OiBVVEZfQ09OVkVSVEVSXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGludGVybmFsX3RyYWNlIGFzIGxfdHJhY2UgdGhlblxuICAgICAgICBSZXN1bHQgOj0gdS51dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKGxfdHJhY2UpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBDb2RlIG9mIHRoZSBleGNlcHRpb24uXG4gICAgZG9cbiAgICBlbmRcblxuICBmcm96ZW4gb3JpZ2luYWw6IEVYQ0VQVElPTlxuICAgICAgLS0gVGhlIG9yaWdpbmFsIGV4Y2VwdGlvbiBkaXJlY3RseSB0cmlnZ2VyZWQgY3VycmVudCBleGNlcHRpb25cbiAgICBsb2NhbFxuICAgICAgdDogbGlrZSB0aHJvd2luZ19leGNlcHRpb25cbiAgICBkb1xuICAgICAgdCA6PSB0aHJvd2luZ19leGNlcHRpb25cbiAgICAgIGlmIHQgPSBDdXJyZW50IG9yIGVsc2UgdCA9IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZWlmIChhdHRhY2hlZCB7Uk9VVElORV9GQUlMVVJFfSBDdXJyZW50KSBvciBlbHNlIChhdHRhY2hlZCB7T0xEX1ZJT0xBVElPTn0gQ3VycmVudCkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gdC5vcmlnaW5hbFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBvcmlnaW5hbF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gY2F1c2U6IEVYQ0VQVElPTlxuICAgICAgLS0gVGhlIGNhdXNlIG9mIGN1cnJlbnQgZXhjZXB0aW9uIHJhaXNlZCBkdXJpbmcgcmVzY3VlIHByb2Nlc3NpbmdcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgb3JpZ2luYWwudGhyb3dpbmdfZXhjZXB0aW9uIGFzIGUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjYXVzZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gcmVjaXBpZW50X25hbWU6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBOYW1lIG9mIHRoZSByb3V0aW5lIHdob3NlIGV4ZWN1dGlvbiB3YXNcbiAgICAgIC0tIGludGVycnVwdGVkIGJ5IGN1cnJlbnQgZXhjZXB0aW9uXG5cbiAgZnJvemVuIHR5cGVfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgdGhlIGNsYXNzIHRoYXQgaW5jbHVkZXMgdGhlIHJlY2lwaWVudFxuICAgICAgLS0gb2Ygb3JpZ2luYWwgZm9ybSBvZiBjdXJyZW50IGV4Y2VwdGlvblxuXG4gIGZyb3plbiBsaW5lX251bWJlcjogSU5URUdFUlxuICAgICAgLS0gTGluZSBudW1iZXJcblxuZmVhdHVyZSAtLSBBY2Nlc3Mgb2JzZWxldGVcblxuICB0cmFjZV9hc19zdHJpbmc6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBFeGNlcHRpb24gdHJhY2UgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmdcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRyYWNlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBleGNlcHRpb25fdHJhY2VcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgc2V0dGluZ3NcblxuICBzZXRfbWVzc2FnZSAoYV9tZXNzYWdlOiBsaWtlIG1lc3NhZ2UpXG4gICAgICAtLSBTZXQgYG1lc3NhZ2UnIHdpdGggYGFfbWVzc2FnZScuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBzZXRfZGVzY3JpcHRpb24nIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgc2V0X2Rlc2NyaXB0aW9uIChhX21lc3NhZ2UpXG4gICAgZW5zdXJlXG4gICAgICBtZXNzYWdlX3NldDogbWVzc2FnZSB+IGFfbWVzc2FnZVxuICAgIGVuZFxuXG4gIHNldF9kZXNjcmlwdGlvbiAoYV9kZXNjcmlwdGlvbjogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFNldCBgZGVzY3JpcHRpb24nIHdpdGggYGFfZGVzY3JpcHRpb24nLlxuICAgIGxvY2FsXG4gICAgICB1OiBVVEZfQ09OVkVSVEVSXG4gICAgICBsX3VwcGVyOiBDRUxMIFtJTlRFR0VSXVxuICAgICAgbF9jOiBsaWtlIGNfZGVzY3JpcHRpb25cbiAgICBkb1xuICAgICAgaWYgYV9kZXNjcmlwdGlvbiAvPSBWb2lkIHRoZW5cbiAgICAgICAgY3JlYXRlIGxfYy5tYWtlX2VtcHR5IChhX2Rlc2NyaXB0aW9uLmNvdW50KVxuICAgICAgICBjcmVhdGUgbF91cHBlci5wdXQgKDApXG4gICAgICAgIHUudXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84XzBfcG9pbnRlciAoYV9kZXNjcmlwdGlvbiwgbF9jLm1hbmFnZWRfZGF0YSwgMCwgbF91cHBlcilcbiAgICAgICAgbF9jLnNldF9jb3VudCAobF91cHBlci5pdGVtKVxuICAgICAgICBjX2Rlc2NyaXB0aW9uIDo9IGxfY1xuICAgICAgZWxzZVxuICAgICAgICBjX2Rlc2NyaXB0aW9uIDo9IFZvaWRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVzY3JpcHRpb25fc2V0OiAoYXR0YWNoZWQgYV9kZXNjcmlwdGlvbiBhcyBhX2RlcyBhbmQgdGhlbiBhdHRhY2hlZCBkZXNjcmlwdGlvbiBhcyBsX2RlcyBhbmQgdGhlbiBsX2Rlcy5zYW1lX3N0cmluZyAobF9kZXMpKSBvciBlbHNlXG4gICAgICAgICAgICAgIChhX2Rlc2NyaXB0aW9uID0gVm9pZCBhbmQgdGhlbiBkZXNjcmlwdGlvbiA9IFZvaWQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGZyb3plbiBpc19pZ25vcmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgZXhjZXB0aW9uIGlnbm9yYWJsZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGV4Y2VwdGlvbl9tYW5hZ2VyLmlzX2lnbm9yYWJsZSAoZ2VuZXJhdGluZ190eXBlKVxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19yYWlzYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBleGNlcHRpb24gcmFpc2FibGUgYnkgYHJhaXNlJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGV4Y2VwdGlvbl9tYW5hZ2VyLmlzX3JhaXNhYmxlIChnZW5lcmF0aW5nX3R5cGUpXG4gICAgZW5kXG5cbiAgZnJvemVuIGlzX2lnbm9yZWQ6IEJPT0xFQU5cbiAgICAgIC0tIElmIHNldCwgY3VycmVudCBleGNlcHRpb24gaXMgbm90IHJhaXNlZC5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGV4Y2VwdGlvbl9tYW5hZ2VyLmlzX2lnbm9yZWQgKGdlbmVyYXRpbmdfdHlwZSlcbiAgICBlbnN1cmVcbiAgICAgIGlzX2lnbm9yZWRfaW1wbGllc19pc19pZ25vcmFibGU6IFJlc3VsdCBpbXBsaWVzIGlzX2lnbm9yYWJsZVxuICAgICAgbm90X2lzX2NhdWdodDogUmVzdWx0ID0gbm90IGlzX2NhdWdodFxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19jYXVnaHQ6IEJPT0xFQU5cbiAgICAgIC0tIElmIHNldCwgY3VycmVudCBleGNlcHRpb24gaXMgcmFpc2VkLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbm90IGlzX2lnbm9yZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9pc19jYXVnaHRfaW1wbGllc19pc19pZ25vcmFibGU6IG5vdCBSZXN1bHQgaW1wbGllcyBpc19pZ25vcmFibGVcbiAgICAgIG5vdF9pc19pZ25vcmVkOiBSZXN1bHQgPSBub3QgaXNfaWdub3JlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGxvY2FsXG4gICAgICB0OiBkZXRhY2hhYmxlIFNUUklOR18zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZ2VuZXJhdGluZ190eXBlXG4gICAgICB0IDo9IHRyYWNlXG4gICAgICBpZiB0IC89IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQuYXBwZW5kX2NoYXJhY3RlciAoJyVOJylcbiAgICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmcgKHQuYXNfc3RyaW5nXzgpXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7RVhDRVBUSU9OfSAtLSBBY2Nlc3NcblxuICBmcm96ZW4gdGhyb3dpbmdfZXhjZXB0aW9uOiBkZXRhY2hhYmxlIEVYQ0VQVElPTlxuICAgICAgLS0gVGhlIGV4Y2VwdGlvbiB0aHJvd2luZyBjdXJyZW50IGV4Y2VwdGlvblxuXG5mZWF0dXJlIHtFWENFUFRJT05fTUFOQUdFUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmcm96ZW4gc2V0X3Rocm93aW5nX2V4Y2VwdGlvbiAoYV9leGNlcHRpb246IGRldGFjaGFibGUgRVhDRVBUSU9OKVxuICAgICAgLS0gU2V0IGB0aHJvd2luZ19leGNlcHRpb24nIHdpdGggYGFfZXhjZXB0aW9uJy5cbiAgICBkb1xuICAgICAgdGhyb3dpbmdfZXhjZXB0aW9uIDo9IGFfZXhjZXB0aW9uXG4gICAgZW5zdXJlXG4gICAgICB0aHJvd2luZ19leGNlcHRpb25fc2V0OiB0aHJvd2luZ19leGNlcHRpb24gPSBhX2V4Y2VwdGlvblxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfcmVjaXBpZW50X25hbWUgKGFfbmFtZTogbGlrZSByZWNpcGllbnRfbmFtZSlcbiAgICAgIC0tIFNldCBgcmVjaXBpZW50X25hbWUnIHdpdGggYGFfbmFtZSdcbiAgICBkb1xuICAgICAgcmVjaXBpZW50X25hbWUgOj0gYV9uYW1lXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9saW5lX251bWJlciAoYV9udW1iZXI6IGxpa2UgbGluZV9udW1iZXIpXG4gICAgICAtLSBTZXQgYGxpbmVfbnVtYmVyJyB3aXRoIGBhX251bWJlcicuXG4gICAgZG9cbiAgICAgIGxpbmVfbnVtYmVyIDo9IGFfbnVtYmVyXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9jX2Rlc2NyaXB0aW9uIChhX2RlczogZGV0YWNoYWJsZSBTVFJJTkdfOClcbiAgICAgIC0tIFNldCBgY19kZXNjcmlwdGlvbicgd2l0aCBgYV9kZXMnLiBgYV9kZXMnIGlzIGluIFVURi04LlxuICAgIGRvXG4gICAgICBpZiBhX2RlcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgY3JlYXRlIGNfZGVzY3JpcHRpb24ubWFrZSAoYV9kZXMpXG4gICAgICBlbHNlXG4gICAgICAgIGNfZGVzY3JpcHRpb24gOj0gVm9pZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY19kZXNjcmlwdGlvbjogZGV0YWNoYWJsZSBDX1NUUklOR1xuICAgICAgLS0gTWVzc2FnZSwgc3RvcmVkIGFzIEMgc3RyaW5nIHRvIGtlZXAgaXQgYWxpdmUgYW5kIHVzYWJsZSBieSB0aGUgcnVudGltZSB0cmFjZSBwcmludGluZy5cblxuICBmcm96ZW4gc2V0X3R5cGVfbmFtZSAoYV90eXBlOiBsaWtlIHR5cGVfbmFtZSlcbiAgICAgIC0tIFNldCBgdHlwZV9uYW1lJyB3aXRoIGBhX3R5cGUnXG4gICAgZG9cbiAgICAgIHR5cGVfbmFtZSA6PSBhX3R5cGVcbiAgICBlbmRcblxuICBmcm96ZW4gaW50ZXJuYWxfaXNfaWdub3JhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJbnRlcm5hbCBgaXNfaWdub3JhYmxlJ1xuXG4gIGZyb3plbiBzZXRfZXhjZXB0aW9uX3RyYWNlIChhX3RyYWNlOiBsaWtlIGV4Y2VwdGlvbl90cmFjZSlcbiAgICAgIC0tIFNldCBgZXhjZXB0aW9uX3RyYWNlJyB3aXRoIGBhX3RyYWNlJy5cbiAgICBkb1xuICAgICAgaW50ZXJuYWxfdHJhY2UgOj0gYV90cmFjZVxuICAgIGVuZFxuXG4gIGludGVybmFsX3RyYWNlOiBkZXRhY2hhYmxlIFNUUklORztcbiAgICAgIC0tIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXhjZXB0aW9uIHRyYWNlXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgQ29tbW9uIGV4Y2VwdGlvbiBvcGVyYXRpb25zIGFuZCBtYW5hZ2VtZW50LlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzc1xuICBFWENFUFRJT05fTUFOQUdFUlxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGxhc3RfZXhjZXB0aW9uOiBkZXRhY2hhYmxlIEVYQ0VQVElPTlxuICAgICAgLS0gTGFzdCBleGNlcHRpb25cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmFpc2VcblxuICByYWlzZSAoYV9leGNlcHRpb246IEVYQ0VQVElPTilcbiAgICAgIC0tIFJhaXNlIGBhX2V4Y2VwdGlvbicuXG4gICAgcmVxdWlyZVxuICAgICAgYV9leGNlcHRpb25fbm90X3ZvaWQ6IGFfZXhjZXB0aW9uIC89IFZvaWRcbiAgICAgIGFfZXhjZXB0aW9uX2lzX3JhaXNhYmxlOiBhX2V4Y2VwdGlvbi5pc19yYWlzYWJsZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgc2V0dGluZ1xuXG4gIGlnbm9yZSAoYV9leGNlcHRpb246IFRZUEUgW2RldGFjaGFibGUgRVhDRVBUSU9OXSlcbiAgICAgIC0tIElnbm9yZSB0eXBlIG9mIGBhX2V4Y2VwdGlvbicuXG4gICAgcmVxdWlyZVxuICAgICAgYV9leGNlcHRpb25fbm90X3ZvaWQ6IGFfZXhjZXB0aW9uIC89IFZvaWRcbiAgICAgIGlzX2lnbm9yYWJsZTogaXNfaWdub3JhYmxlIChhX2V4Y2VwdGlvbilcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpc19jYXVnaHQ6IGlzX2lnbm9yZWQgKGFfZXhjZXB0aW9uKVxuICAgIGVuZFxuXG4gIGNhdGNoIChhX2V4Y2VwdGlvbjogVFlQRSBbZGV0YWNoYWJsZSBFWENFUFRJT05dKVxuICAgICAgLS0gU2V0IHR5cGUgb2YgYGFfZXhjZXB0aW9uJyBgaXNfY2F1Z2h0Jy5cbiAgICByZXF1aXJlXG4gICAgICBhX2V4Y2VwdGlvbl9ub3Rfdm9pZDogYV9leGNlcHRpb24gLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGlzX2lnbm9yZWQ6IG5vdCBpc19pZ25vcmVkIChhX2V4Y2VwdGlvbilcbiAgICBlbmRcblxuICBzZXRfaXNfaWdub3JlZCAoYV9leGNlcHRpb246IFRZUEUgW2RldGFjaGFibGUgRVhDRVBUSU9OXTsgYV9pZ25vcmVkOiBCT09MRUFOKVxuICAgICAgLS0gU2V0IHR5cGUgb2YgYGFfZXhjZXB0aW9uJyB0byBiZSBgYV9pZ25vcmVkJy5cbiAgICByZXF1aXJlXG4gICAgICBhX2V4Y2VwdGlvbl9ub3Rfdm9pZDogYV9leGNlcHRpb24gLz0gVm9pZFxuICAgICAgYV9pZ25vcmVkX2ltcGxpZXNfaXNfaWdub3JhYmxlOiBhX2lnbm9yZWQgaW1wbGllcyBpc19pZ25vcmFibGUgKGFfZXhjZXB0aW9uKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGlzX2lnbm9yZWRfc2V0OiBpc19pZ25vcmVkIChhX2V4Y2VwdGlvbikgPSBhX2lnbm9yZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaWdub3JhYmxlIChhX2V4Y2VwdGlvbjogVFlQRSBbZGV0YWNoYWJsZSBFWENFUFRJT05dKTogQk9PTEVBTlxuICAgICAgLS0gSWYgc2V0LCB0eXBlIG9mIGBhX2V4Y2VwdGlvbicgaXMgaWdub3JhYmxlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpc19yYWlzYWJsZSAoYV9leGNlcHRpb246IFRZUEUgW2RldGFjaGFibGUgRVhDRVBUSU9OXSk6IEJPT0xFQU5cbiAgICAgIC0tIElmIHNldCwgdHlwZSBvZiBgYV9leGNlcHRpb24nIGlzIHJhaXNhYmxlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpc19pZ25vcmVkIChhX2V4Y2VwdGlvbjogVFlQRSBbZGV0YWNoYWJsZSBFWENFUFRJT05dKTogQk9PTEVBTlxuICAgICAgLS0gSWYgc2V0LCB0eXBlIG9mIGBhX2V4Y2VwdGlvbicgaXMgbm90IHJhaXNlZC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBub3RfaXNfY2F1Z2h0OiBSZXN1bHQgPSBub3QgaXNfY2F1Z2h0IChhX2V4Y2VwdGlvbilcbiAgICBlbmRcblxuICBpc19jYXVnaHQgKGFfZXhjZXB0aW9uOiBUWVBFIFtkZXRhY2hhYmxlIEVYQ0VQVElPTl0pOiBCT09MRUFOXG4gICAgICAtLSBJZiBzZXQsIHR5cGUgb2YgYGFfZXhjZXB0aW9uJyBpcyByYWlzZWQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgbm90X2lzX2lnbm9yZWQ6IFJlc3VsdCA9IG5vdCBpc19pZ25vcmVkIChhX2V4Y2VwdGlvbilcbiAgICBlbmRcblxuZmVhdHVyZSB7RVhDRVBUSU9OU30gLS0gQmFja3dhcmQgY29tcGF0aWJpbGl0eSBzdXBwb3J0XG5cbiAgdHlwZV9vZl9jb2RlIChhX2NvZGU6IElOVEVHRVIpOiBkZXRhY2hhYmxlIFRZUEUgW0VYQ0VQVElPTl1cbiAgICAgIC0tIEV4Y2VwdGlvbiB0eXBlIG9mIGBhX2NvZGUnXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGV4Y2VwdGlvbl9mcm9tX2NvZGUgKGFfY29kZTogSU5URUdFUik6IGRldGFjaGFibGUgRVhDRVBUSU9OXG4gICAgICAtLSBDcmVhdGUgZXhjZXB0aW9uIG9iamVjdCBmcm9tIGBhX2NvZGUnXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIEV4Y2VwdGlvbiBtYW5hZ2VyIGZhY3RvcnkuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIEVYQ0VQVElPTl9NQU5BR0VSX0ZBQ1RPUllcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBleGNlcHRpb25fbWFuYWdlcjogRVhDRVBUSU9OX01BTkFHRVJcbiAgICAgIC0tIEV4Y2VwdGlvbiBtYW5hZ2VyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZXhjZXB0aW9uX21hbmFnZXJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDEtMTggMTE6NTA6MzEgLTA4MDAgKEZyaSwgMTggSmFuIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTI2ICRcIlxuXG5jbGFzcyBFWENFUFRJT05TXG5cbmluaGVyaXRcbiAgRVhDRVBfQ09OU1RcblxuICBFWENFUFRJT05fTUFOQUdFUl9GQUNUT1JZXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIG1lYW5pbmcgKGV4Y2VwdDogSU5URUdFUik6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBBIG1lc3NhZ2UgaW4gRW5nbGlzaCBkZXNjcmliaW5nIHdoYXQgYGV4Y2VwdCcgaXNcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIuZXhjZXB0aW9uX2Zyb21fY29kZSAoZXhjZXB0KSBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi50YWcuYXNfc3RyaW5nXzhcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFzc2VydGlvbl92aW9sYXRpb246IEJPT0xFQU5cbiAgICAgIC0tIElzIGxhc3QgZXhjZXB0aW9uIG9yaWdpbmFsbHkgZHVlIHRvIGEgdmlvbGF0ZWRcbiAgICAgIC0tIGFzc2VydGlvbiBvciBub24tZGVjcmVhc2luZyB2YXJpYW50P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gYW5kIHRoZW5cbiAgICAgICAgICAgIGF0dGFjaGVkIHtBU1NFUlRJT05fVklPTEFUSU9OfSBsX2V4Y2VwdGlvbi5vcmlnaW5hbFxuICAgIGVuZFxuXG4gIGlzX2RldmVsb3Blcl9leGNlcHRpb246IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZSBsYXN0IGV4Y2VwdGlvbiBvcmlnaW5hbGx5IGR1ZSB0b1xuICAgICAgLS0gYSBkZXZlbG9wZXIgZXhjZXB0aW9uP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gYW5kIHRoZW5cbiAgICAgICAgICAgIGF0dGFjaGVkIHtERVZFTE9QRVJfRVhDRVBUSU9OfSBsX2V4Y2VwdGlvbi5vcmlnaW5hbFxuICAgIGVuZFxuXG4gIGlzX2RldmVsb3Blcl9leGNlcHRpb25fb2ZfbmFtZSAobmFtZTogZGV0YWNoYWJsZSBTVFJJTkcpOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGUgbGFzdCBleGNlcHRpb24gb3JpZ2luYWxseSBkdWUgdG8gYSBkZXZlbG9wZXJcbiAgICAgIC0tIGV4Y2VwdGlvbiBvZiBuYW1lIGBuYW1lJz9cbiAgICBkb1xuICAgICAgaWYgaXNfZGV2ZWxvcGVyX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkZXZlbG9wZXJfZXhjZXB0aW9uX25hbWUgfiBuYW1lXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkZXZlbG9wZXJfZXhjZXB0aW9uX25hbWU6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBOYW1lIG9mIGxhc3QgZGV2ZWxvcGVyLXJhaXNlZCBleGNlcHRpb25cbiAgICByZXF1aXJlXG4gICAgICBhcHBsaWNhYmxlOiBpc19kZXZlbG9wZXJfZXhjZXB0aW9uXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIGFuZCB0aGVuIGF0dGFjaGVkIGxfZXhjZXB0aW9uLm9yaWdpbmFsLmRlc2NyaXB0aW9uIGFzIGxfZGVzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZGVzLmFzX3N0cmluZ184XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19zaWduYWw6IEJPT0xFQU5cbiAgICAgIC0tIElzIGxhc3QgZXhjZXB0aW9uIG9yaWdpbmFsbHkgZHVlIHRvIGFuIGV4dGVybmFsXG4gICAgICAtLSBldmVudCAob3BlcmF0aW5nIHN5c3RlbSBzaWduYWwpP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gYW5kIHRoZW5cbiAgICAgICAgICAgIGF0dGFjaGVkIHtPUEVSQVRJTkdfU1lTVEVNX1NJR05BTF9GQUlMVVJFfSBsX2V4Y2VwdGlvbi5vcmlnaW5hbFxuICAgIGVuZFxuXG4gIGlzX3N5c3RlbV9leGNlcHRpb246IEJPT0xFQU5cbiAgICAgIC0tIElzIGxhc3QgZXhjZXB0aW9uIG9yaWdpbmFsbHkgZHVlIHRvIGFuXG4gICAgICAtLSBleHRlcm5hbCBldmVudCAob3BlcmF0aW5nIHN5c3RlbSBlcnJvcik/XG4gICAgZG9cbiAgICAgIGlmXG4gICAgICAgIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIGFuZFxuICAgICAgICBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5leGNlcHRpb25fZnJvbV9jb2RlIChleHRlcm5hbF9leGNlcHRpb24pIGFzIGxfZXh0ZXJuYWxcbiAgICAgIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZXhjZXB0aW9uLm9yaWdpbmFsLmNvbmZvcm1zX3RvIChsX2V4dGVybmFsKSBvciBlbHNlXG4gICAgICAgICAgICBhdHRhY2hlZCB7T1BFUkFUSU5HX1NZU1RFTV9GQUlMVVJFfSBsX2V4Y2VwdGlvbi5vcmlnaW5hbFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdGFnX25hbWU6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBUYWcgb2YgbGFzdCB2aW9sYXRlZCBhc3NlcnRpb24gY2xhdXNlXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIGFuZCB0aGVuIGF0dGFjaGVkIGxfZXhjZXB0aW9uLmRlc2NyaXB0aW9uIGFzIGxfZGVzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZGVzLmFzX3N0cmluZ184XG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWNpcGllbnRfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgdGhlIHJvdXRpbmUgd2hvc2UgZXhlY3V0aW9uIHdhc1xuICAgICAgLS0gaW50ZXJydXB0ZWQgYnkgbGFzdCBleGNlcHRpb25cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9leGNlcHRpb24ucmVjaXBpZW50X25hbWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNsYXNzX25hbWU6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBOYW1lIG9mIHRoZSBjbGFzcyB0aGF0IGluY2x1ZGVzIHRoZSByZWNpcGllbnRcbiAgICAgIC0tIG9mIG9yaWdpbmFsIGZvcm0gb2YgbGFzdCBleGNlcHRpb25cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9leGNlcHRpb24udHlwZV9uYW1lXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBleGNlcHRpb246IElOVEVHRVJcbiAgICAgIC0tIENvZGUgb2YgbGFzdCBleGNlcHRpb24gdGhhdCBvY2N1cnJlZFxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi5jb2RlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBleGNlcHRpb25fdHJhY2U6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGV4Y2VwdGlvbiB0cmFjZVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiBhbmQgdGhlbiBhdHRhY2hlZCBsX2V4Y2VwdGlvbi5vcmlnaW5hbC50cmFjZSBhcyBsX3RyYWNlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfdHJhY2UuYXNfc3RyaW5nXzhcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG9yaWdpbmFsX3RhZ19uYW1lOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gQXNzZXJ0aW9uIHRhZyBmb3Igb3JpZ2luYWwgZm9ybSBvZiBsYXN0XG4gICAgICAtLSBhc3NlcnRpb24gdmlvbGF0aW9uLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiBhbmQgdGhlbiBhdHRhY2hlZCBsX2V4Y2VwdGlvbi5jYXVzZS5vcmlnaW5hbC5kZXNjcmlwdGlvbiBhcyBsX2RlcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2Rlcy5hc19zdHJpbmdfOFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgb3JpZ2luYWxfZXhjZXB0aW9uOiBJTlRFR0VSXG4gICAgICAtLSBPcmlnaW5hbCBjb2RlIG9mIGxhc3QgZXhjZXB0aW9uIHRoYXQgdHJpZ2dlcmVkXG4gICAgICAtLSBjdXJyZW50IGV4Y2VwdGlvblxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi5jYXVzZS5vcmlnaW5hbC5jb2RlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBvcmlnaW5hbF9yZWNpcGllbnRfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgdGhlIHJvdXRpbmUgd2hvc2UgZXhlY3V0aW9uIHdhc1xuICAgICAgLS0gaW50ZXJydXB0ZWQgYnkgb3JpZ2luYWwgZm9ybSBvZiBsYXN0IGV4Y2VwdGlvblxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi5jYXVzZS5vcmlnaW5hbC5yZWNpcGllbnRfbmFtZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgb3JpZ2luYWxfY2xhc3NfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgdGhlIGNsYXNzIHRoYXQgaW5jbHVkZXMgdGhlIHJlY2lwaWVudFxuICAgICAgLS0gb2Ygb3JpZ2luYWwgZm9ybSBvZiBsYXN0IGV4Y2VwdGlvblxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi5jYXVzZS5vcmlnaW5hbC50eXBlX25hbWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyBzZXR0aW5nXG5cbiAgY2F0Y2ggKGNvZGU6IElOVEVHRVIpXG4gICAgICAtLSBNYWtlIHN1cmUgdGhhdCBhbnkgZXhjZXB0aW9uIG9mIGNvZGUgYGNvZGUnIHdpbGwgYmVcbiAgICAgIC0tIGNhdWdodC4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIudHlwZV9vZl9jb2RlIChjb2RlKSBhcyBsX3R5cGUgdGhlblxuICAgICAgICBleGNlcHRpb25fbWFuYWdlci5jYXRjaCAobF90eXBlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaWdub3JlIChjb2RlOiBJTlRFR0VSKVxuICAgICAgLS0gTWFrZSBzdXJlIHRoYXQgYW55IGV4Y2VwdGlvbiBvZiBjb2RlIGBjb2RlJyB3aWxsIGJlXG4gICAgICAtLSBpZ25vcmVkLiBUaGlzIGlzIG5vdCB0aGUgZGVmYXVsdC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIudHlwZV9vZl9jb2RlIChjb2RlKSBhcyBsX3R5cGUgdGhlblxuICAgICAgICBleGNlcHRpb25fbWFuYWdlci5pZ25vcmUgKGxfdHlwZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJhaXNlIChuYW1lOiBkZXRhY2hhYmxlIFNUUklORylcbiAgICAgIC0tIFJhaXNlIGEgZGV2ZWxvcGVyIGV4Y2VwdGlvbiBvZiBuYW1lIGBuYW1lJy5cbiAgICBsb2NhbFxuICAgICAgbF9leGNlcHRpb246IERFVkVMT1BFUl9FWENFUFRJT05cbiAgICBkb1xuICAgICAgY3JlYXRlIGxfZXhjZXB0aW9uXG4gICAgICBsX2V4Y2VwdGlvbi5zZXRfZGVzY3JpcHRpb24gKG5hbWUpXG4gICAgICBsX2V4Y2VwdGlvbi5yYWlzZVxuICAgIGVuZFxuXG4gIHJhaXNlX3JldHJpZXZhbF9leGNlcHRpb24gKG5hbWU6IGRldGFjaGFibGUgU1RSSU5HKVxuICAgICAgLS0gUmFpc2UgYSByZXRyaWV2YWwgZXhjZXB0aW9uIG9mIG5hbWUgYG5hbWUnLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5leGNlcHRpb25fZnJvbV9jb2RlIChzZXJpYWxpemF0aW9uX2V4Y2VwdGlvbikgYXMgbF9leGNlcHRpb24gdGhlblxuICAgICAgICBsX2V4Y2VwdGlvbi5zZXRfZGVzY3JpcHRpb24gKG5hbWUpXG4gICAgICAgIGxfZXhjZXB0aW9uLnJhaXNlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkaWUgKGNvZGU6IElOVEVHRVIpXG4gICAgICAtLSBUZXJtaW5hdGUgZXhlY3V0aW9uIHdpdGggZXhpdCBzdGF0dXMgYGNvZGUnLFxuICAgICAgLS0gd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV4Y2VwdGlvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHVzZSAlXCJlaWZfZXhjZXB0LmglXCJcIlxuICAgIGFsaWFzXG4gICAgICBcImVzZGllXCJcbiAgICBlbnN1cmVcbiAgICAgIEZhbHNlXG4gICAgZW5kXG5cbiAgbmV3X2RpZSAoY29kZTogSU5URUdFUikgb2Jzb2xldGUgXCJVc2UgYGBkaWUnJ1wiXG4gICAgICAtLSBUZXJtaW5hdGUgZXhlY3V0aW9uIHdpdGggZXhpdCBzdGF0dXMgYGNvZGUnLFxuICAgICAgLS0gd2l0aG91dCB0cmlnZ2VyaW5nIGFuIGV4Y2VwdGlvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHVzZSAlXCJlaWZfZXhjZXB0LmglXCJcIlxuICAgIGFsaWFzXG4gICAgICBcImVzZGllXCJcbiAgICBlbnN1cmVcbiAgICAgIEZhbHNlXG4gICAgZW5kXG5cbiAgbWVzc2FnZV9vbl9mYWlsdXJlXG4gICAgICAtLSBQcmludCBhbiBleGNlcHRpb24gaGlzdG9yeSB0YWJsZVxuICAgICAgLS0gaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgICAgLS0gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAgICBkb1xuICAgICAgY190cmFjZV9leGNlcHRpb24gKFRydWUpXG4gICAgZW5kXG5cbiAgbm9fbWVzc2FnZV9vbl9mYWlsdXJlXG4gICAgICAtLSBEbyBub3QgcHJpbnQgYW4gZXhjZXB0aW9uIGhpc3RvcnkgdGFibGVcbiAgICAgIC0tIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICBkb1xuICAgICAgY190cmFjZV9leGNlcHRpb24gKEZhbHNlKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGNfdHJhY2VfZXhjZXB0aW9uIChiOiBCT09MRUFOKVxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgdXNlICVcImVpZl9leGNlcHQuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZWV0cmFjZVwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVzIHdpdGggYSBmaW5pdGUgaXRlbSBjb3VudFwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGZpbml0ZSwgc3RvcmFnZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEZJTklURSBbR10gaW5oZXJpdFxuXG4gIEJPWCBbR11cblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgaXRlbXNcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGVtcHR5P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNvdW50ID0gMClcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGVtcHR5X2RlZmluaXRpb246IGlzX2VtcHR5ID0gKGNvdW50ID0gMClcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBPYmplY3RzIHJlcHJlc2VudGluZyBkZWxheWVkIGNhbGxzIHRvIGEgZnVuY3Rpb24sXG4gICAgd2l0aCBzb21lIGFyZ3VtZW50cyBwb3NzaWJseSBzdGlsbCBvcGVuLlxuXG4gICAgTm90ZTogRmVhdHVyZXMgYXJlIHRoZSBzYW1lIGFzIHRob3NlIG9mIFJPVVRJTkUsXG4gICAgICB3aXRoIGBhcHBseScgbWFkZSBlZmZlY3RpdmUsIGFuZCB0aGUgYWRkaXRpb25cbiAgICAgIG9mIGBsYXN0X3Jlc3VsdCcgYW5kIGBpdGVtJy5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTI4IDE0OjM1OjIzIC0wODAwIChUdWUsIDI4IEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDEwOSAkXCJcblxuY2xhc3NcbiAgRlVOQ1RJT04gW0JBU0VfVFlQRSAtPiBkZXRhY2hhYmxlIEFOWSwgT1BFTl9BUkdTIC0+IGRldGFjaGFibGUgVFVQTEUgY3JlYXRlIGRlZmF1bHRfY3JlYXRlIGVuZCwgUkVTVUxUX1RZUEVdXG5cbmluaGVyaXRcbiAgUk9VVElORSBbQkFTRV9UWVBFLCBPUEVOX0FSR1NdXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBjb3B5XG4gICAgZW5kXG5cbmNyZWF0ZSB7Tk9ORX1cbiAgc2V0X3JvdXRfZGlzcFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGxhc3RfcmVzdWx0OiBkZXRhY2hhYmxlIFJFU1VMVF9UWVBFXG4gICAgICAtLSBSZXN1bHQgb2YgbGFzdCBjYWxsLCBpZiBhbnlcblxuICBjYWxsIChhcmdzOiBkZXRhY2hhYmxlIHNlcGFyYXRlIE9QRU5fQVJHUylcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIGxhc3RfcmVzdWx0IDo9IGl0ZW0gKGFyZ3MpXG4gICAgZW5kXG5cbiAgaXRlbSBhbGlhcyBcIigpXCIgKGFyZ3M6IGRldGFjaGFibGUgc2VwYXJhdGUgT1BFTl9BUkdTKTogUkVTVUxUX1RZUEVcbiAgICAgIC0tIFJlc3VsdCBvZiBjYWxsaW5nIGZ1bmN0aW9uIHdpdGggYGFyZ3MnIGFzIG9wZXJhbmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX29wZXJhbmRzOiB2YWxpZF9vcGVyYW5kcyAoYXJncylcbiAgICBsb2NhbFxuICAgICAgbF9jbG9zZWRfY291bnQ6IElOVEVHRVJcbiAgICAgIGM6IGxpa2UgY2xvc2VkX29wZXJhbmRzXG4gICAgZG9cbiAgICAgIGMgOj0gY2xvc2VkX29wZXJhbmRzXG4gICAgICBpZiBjLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY2xvc2VkX2NvdW50IDo9ICBjLmNvdW50XG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSBmYXN0X2l0ZW0gKGVuY2Fwc19yb3V0X2Rpc3AsIGNhbGNfcm91dF9hZGRyLCAkY2xvc2VkX29wZXJhbmRzLCAkYXJncywgcm91dGluZV9pZCxcbiAgICAgICAgaXNfYmFzaWMsIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQsIGxfY2xvc2VkX2NvdW50LCBvcGVuX2NvdW50LCAkb3Blbl9tYXApXG4gICAgZW5kXG5cbiAgYXBwbHlcbiAgICAgIC0tIENhbGwgZnVuY3Rpb24gd2l0aCBgb3BlcmFuZHMnIGFzIGxhc3Qgc2V0LlxuICAgIGRvXG4gICAgICBsYXN0X3Jlc3VsdCA6PSBpdGVtIChvcGVyYW5kcylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBhc3NvY2lhdGVkIGZ1bmN0aW9uIHRoZSBzYW1lIGFzIHRoZSBvbmVcbiAgICAgIC0tIGFzc29jaWF0ZWQgd2l0aCBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gUHJlY3Vyc29yIChvdGhlcikgYW5kIHRoZW4gKGxhc3RfcmVzdWx0IH4gb3RoZXIubGFzdF9yZXN1bHQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBjb3B5IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gVXNlIHNhbWUgZnVuY3Rpb24gYXMgYG90aGVyJy5cbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIFByZWN1cnNvciAob3RoZXIpXG4gICAgICAgIGxhc3RfcmVzdWx0IDo9IG90aGVyLmxhc3RfcmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPYnNvbGV0ZVxuXG4gIGV2YWwgKGFyZ3M6IGRldGFjaGFibGUgT1BFTl9BUkdTKTogUkVTVUxUX1RZUEVcbiAgICAgIC0tIFJlc3VsdCBvZiBldmFsdWF0aW5nIGZ1bmN0aW9uIGZvciBgYXJncycuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiUGxlYXNlIHVzZSBgaXRlbScgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfb3BlcmFuZHM6IHZhbGlkX29wZXJhbmRzIChhcmdzKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAoYXJncylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgY2xlYXJfbGFzdF9yZXN1bHRcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnQgb2YgYGxhc3RfcmVzdWx0JyB0byBpdHMgZGVmYXVsdCB2YWx1ZS5cbiAgICBsb2NhbFxuICAgICAgbF9yZXN1bHQ6IGRldGFjaGFibGUgUkVTVUxUX1RZUEVcbiAgICBkb1xuICAgICAgbGFzdF9yZXN1bHQgOj0gbF9yZXN1bHRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFeHRlbmRlZCBvcGVyYXRpb25zXG5cbiAgZmxleGlibGVfaXRlbSAoYTogZGV0YWNoYWJsZSBzZXBhcmF0ZSBUVVBMRSk6IFJFU1VMVF9UWVBFXG4gICAgICAtLSBSZXN1bHQgb2YgY2FsbGluZyBmdW5jdGlvbiB3aXRoIGBhJyBhcyBhcmd1bWVudHMuXG4gICAgICAtLSBDb21wYXJlZCB0byBgaXRlbScgdGhlIHR5cGUgb2YgYGEnIG1heSBiZSBkaWZmZXJlbnQgZnJvbSBge09QRU5fQVJHU30nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX29wZXJhbmRzOiB2YWxpZF9vcGVyYW5kcyAoYSlcbiAgICBsb2NhbFxuICAgICAgZGVmYXVsdF9hcmd1bWVudHM6IGRldGFjaGFibGUgT1BFTl9BUkdTXG4gICAgZG9cbiAgICAgIGlmIG5vdCBhdHRhY2hlZCBhIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGRlZmF1bHRfYXJndW1lbnRzKVxuICAgICAgZWxzZVxuICAgICAgICAtLSBUT0RPOiBJbXBsZW1lbnQgaW4gSmF2YVNjcmlwdFxuICAgICAgICAtLSBjaGVja1xuICAgICAgICAtLSAgIGZyb21fcHJlY29uZGl0aW9uOiBhdHRhY2hlZCB7T1BFTl9BUkdTfSBuZXdfdHVwbGVfZnJvbV90dXBsZSAoKHtPUEVOX0FSR1N9KS50eXBlX2lkLCBhKSBhcyB4XG4gICAgICAgIC0tIHRoZW5cbiAgICAgICAgLS0gICBSZXN1bHQgOj0gaXRlbSAoeClcbiAgICAgICAgLS0gZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmYXN0X2l0ZW0gKGFfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSXG4gICAgICAgICAgIGFfY2xvc2VkX29wZXJhbmRzOiBQT0lOVEVSOyBhX29wZXJhbmRzOiBQT0lOVEVSXG4gICAgICAgICBhX3JvdXRpbmVfaWQ6IElOVEVHRVI7IGFfaXNfYmFzaWM6IEJPT0xFQU47IGFfY2xhc3NfaWRfaW5saW5lX2FnZW50OiBJTlRFR0VSO1xuICAgICAgICAgYV9jbG9zZWRfY291bnQsIGFfb3Blbl9jb3VudDogSU5URUdFUjsgYV9vcGVuX21hcDogUE9JTlRFUik6IFJFU1VMVF9UWVBFXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBpbmxpbmUgdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJbXG4gICAgICAjaWZkZWYgV09SS0JFTkNIXG4gICAgICAgICQkX3Jlc3VsdF90eXBlIHJlc3VsdDtcbiAgICAgICAgaWYgKCRhX3JvdXRfZGlzcCAhPSAwKSB7XG4gICAgICAgICAgcmV0dXJuIChGVU5DVElPTl9DQVNUKEVJRl9UWVBFRF9WQUxVRSwgKEVJRl9QT0lOVEVSLCBFSUZfUkVGRVJFTkNFLCBFSUZfUkVGRVJFTkNFKSkgJGFfcm91dF9kaXNwKShcbiAgICAgICAgICAgICRhX2NhbGNfcm91dF9hZGRyLCAkYV9jbG9zZWRfb3BlcmFuZHMsICRhX29wZXJhbmRzKS4kJF9yZXN1bHRfdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dF9vYmpfY2FsbF9mdW5jdGlvbl9keW5hbWljIChcbiAgICAgICAgICAgICRhX3JvdXRpbmVfaWQsXG4gICAgICAgICAgICAkYV9pc19iYXNpYyxcbiAgICAgICAgICAgICRhX2NsYXNzX2lkX2lubGluZV9hZ2VudCxcbiAgICAgICAgICAgICRhX2Nsb3NlZF9vcGVyYW5kcyxcbiAgICAgICAgICAgICRhX2Nsb3NlZF9jb3VudCxcbiAgICAgICAgICAgICRhX29wZXJhbmRzLFxuICAgICAgICAgICAgJGFfb3Blbl9jb3VudCxcbiAgICAgICAgICAgICRhX29wZW5fbWFwLFxuICAgICAgICAgICAgJnJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgI2Vsc2VcbiAgICAgICAgcmV0dXJuIChGVU5DVElPTl9DQVNUKCQkX3Jlc3VsdF90eXBlLCAoRUlGX1BPSU5URVIsIEVJRl9SRUZFUkVOQ0UsIEVJRl9SRUZFUkVOQ0UpKSAkYV9yb3V0X2Rpc3ApKFxuICAgICAgICAgICRhX2NhbGNfcm91dF9hZGRyLCAkYV9jbG9zZWRfb3BlcmFuZHMsICRhX29wZXJhbmRzKTtcbiAgICAgICNlbmRpZlxuICAgICAgXVwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJIYXNoIHRhYmxlcywgdXNlZCB0byBzdG9yZSBpdGVtcyBpZGVudGlmaWVkIGJ5IGhhc2hhYmxlIGtleXNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgaW5zdHJ1Y3Rpb25zOiBcIlNlZSBpbnN0cnVjdGlvbnMgYXQgdGhlIGVuZCBvZiB0aGUgY2xhc3MuXCJcbiAgd2FybmluZzogXCJbXG4gICAgTW9kaWZ5aW5nIGFuIG9iamVjdCB1c2VkIGFzIGEga2V5IGJ5IGFuIGl0ZW0gcHJlc2VudCBpbiBhIHRhYmxlIHdpbGxcbiAgICBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIElmIHlvdSB3aWxsIGJlIG1vZGlmeWluZyBrZXkgb2JqZWN0cyxcbiAgICBwYXNzIGEgY2xvbmUsIG5vdCB0aGUgb2JqZWN0IGl0c2VsZiwgYXMga2V5IGFyZ3VtZW50IHRvXG4gICAgYHB1dCcgYW5kIGByZXBsYWNlX2tleScuXG4gICAgXVwiXG5cbmNsYXNzIEhBU0hfVEFCTEUgW0csIEsgLT4gZGV0YWNoYWJsZSBIQVNIQUJMRV0gaW5oZXJpdFxuXG4gIFVOQk9VTkRFRCBbZGV0YWNoYWJsZSBHXVxuICAgIHJlbmFtZVxuICAgICAgaGFzIGFzIGhhc19pdGVtXG4gICAgcmVkZWZpbmVcbiAgICAgIGhhc19pdGVtLCBjb3B5LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFRBQkxFIFtkZXRhY2hhYmxlIEcsIEtdXG4gICAgcmVuYW1lXG4gICAgICBoYXMgYXMgaGFzX2l0ZW0sXG4gICAgICBleHRlbmQgYXMgY29sbGVjdGlvbl9leHRlbmRcbiAgICBleHBvcnRcbiAgICAgIHtOT05FfSBwcnVuZV9hbGxcbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIHdpcGVfb3V0LCBoYXNfaXRlbVxuICAgIGVuZFxuXG4gIFRBQkxFX0lURVJBQkxFIFtHLCBLXVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbR11cbiAgICByZW5hbWVcbiAgICAgIGl0ZW0gYXMgaXRlcmF0aW9uX2l0ZW0sXG4gICAgICB2YWxpZF9pbmRleCBhcyB2YWxpZF9pdGVyYXRpb25faW5kZXgsXG4gICAgICBpbmRleF9zZXQgYXMgaXRlcmF0aW9uX2luZGV4X3NldFxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgbmV3X2N1cnNvclxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIGV4cG9ydFxuICAgICAge05PTkV9IGFsbFxuICAgICAge0FOWX0gbWlzbWF0Y2hfaW5mb3JtYXRpb25cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWxcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lcXVhbFxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGhhc2ggdGFibGUgZm9yIGF0IGxlYXN0IGBuJyBpdGVtcy5cbiAgICAgIC0tIFRoZSB0YWJsZSB3aWxsIGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseVxuICAgICAgLS0gaWYgbW9yZSB0aGFuIGBuJyBpdGVtcyBhcmUgaW5zZXJ0ZWQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBjbGV2ZXI6IFBSSU1FU1xuICAgICAgbF9kZWZhdWx0X3ZhbHVlOiBkZXRhY2hhYmxlIEdcbiAgICAgIGxfZGVmYXVsdF9rZXk6IGRldGFjaGFibGUgS1xuICAgICAgbF9zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBjbGV2ZXJcbiAgICAgIGxfc2l6ZSA6PSBuLk1heCAobWluaW11bV9jYXBhY2l0eSlcbiAgICAgIGxfc2l6ZSA6PSBsX3NpemUgKyBsX3NpemUgLy8gMiArIDFcbiAgICAgIGxfc2l6ZSA6PSBjbGV2ZXIuaGlnaGVyX3ByaW1lIChsX3NpemUpXG4gICAgICBjYXBhY2l0eSA6PSBsX3NpemVcbiAgICAgICAgICAtLSBQb3NpdGlvbiBgY2FwYWNpdHknIGlnbm9yZWQgYnkgaGFzaCBzZXF1ZW5jZXMsXG4gICAgICAgICAgLS0gdXNlZCB0byBzdG9yZSB2YWx1ZSBmb3IgZGVmYXVsdCBrZXkuXG4gICAgICBjcmVhdGUgY29udGVudC5tYWtlX2VtcHR5IChuICsgMSlcbiAgICAgIGNyZWF0ZSBrZXlzLm1ha2VfZW1wdHkgKG4gKyAxKVxuICAgICAgY3JlYXRlIGRlbGV0ZWRfbWFya3MubWFrZV9maWxsZWQgKEZhbHNlLCBuICsgMSlcbiAgICAgIGNyZWF0ZSBpbmRleGVzX21hcC5tYWtlX2ZpbGxlZCAoaHRfaW1wb3NzaWJsZV9wb3NpdGlvbiwgbF9zaXplICsgMSlcbiAgICAgIGl0ZXJhdGlvbl9wb3NpdGlvbiA6PSBuICsgMVxuICAgICAgY291bnQgOj0gMFxuICAgICAgZGVsZXRlZF9pdGVtX3Bvc2l0aW9uIDo9IGh0X2ltcG9zc2libGVfcG9zaXRpb25cbiAgICAgIGNvbnRyb2wgOj0gMFxuICAgICAgZm91bmRfaXRlbSA6PSBsX2RlZmF1bHRfdmFsdWVcbiAgICAgIGhhc19kZWZhdWx0IDo9IEZhbHNlXG4gICAgICBpdGVtX3Bvc2l0aW9uIDo9IDBcbiAgICAgIGh0X2xvd2VzdF9kZWxldGVkX3Bvc2l0aW9uIDo9IGh0X21heF9wb3NpdGlvblxuICAgICAgaHRfZGVsZXRlZF9pdGVtIDo9IGxfZGVmYXVsdF92YWx1ZVxuICAgICAgaHRfZGVsZXRlZF9rZXkgOj0gbF9kZWZhdWx0X2tleVxuICAgIGVuc3VyZVxuICAgICAgYnJlYXRoaW5nX3NwYWNlOiBuIDwgY2FwYWNpdHlcbiAgICAgIG1vcmVfdGhhbl9taW5pbXVtOiBjYXBhY2l0eSA+IG1pbmltdW1fY2FwYWNpdHlcbiAgICAgIG5vX3N0YXR1czogbm90IHNwZWNpYWxfc3RhdHVzXG4gICAgZW5kXG5cbiAgbWFrZV9lcXVhbCAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGhhc2ggdGFibGUgZm9yIGF0IGxlYXN0IGBuJyBpdGVtcy5cbiAgICAgIC0tIFRoZSB0YWJsZSB3aWxsIGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseVxuICAgICAgLS0gaWYgbW9yZSB0aGFuIGBuJyBpdGVtcyBhcmUgaW5zZXJ0ZWQuXG4gICAgICAtLSBVc2UgYH4nIHRvIGNvbXBhcmUgaXRlbXMuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgICAgY29tcGFyZV9vYmplY3RzXG4gICAgZW5zdXJlXG4gICAgICBicmVhdGhpbmdfc3BhY2U6IG4gPCBjYXBhY2l0eVxuICAgICAgbW9yZV90aGFuX21pbmltdW06IGNhcGFjaXR5ID4gbWluaW11bV9jYXBhY2l0eVxuICAgICAgbm9fc3RhdHVzOiBub3Qgc3BlY2lhbF9zdGF0dXNcbiAgICAgIGNvbXBhcmVfb2JqZWN0czogb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuICBhY2NvbW1vZGF0ZSAobjogSU5URUdFUilcbiAgICAgIC0tIFJlYWxsb2NhdGUgdGFibGUgd2l0aCBlbm91Z2ggc3BhY2UgZm9yIGBuJyBpdGVtcztcbiAgICAgIC0tIGtlZXAgYWxsIGN1cnJlbnQgaXRlbXMuXG4gICAgcmVxdWlyZVxuICAgICAgbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuZXdfdGFibGU6IGxpa2UgQ3VycmVudFxuICAgICAgbF9jb250ZW50OiBsaWtlIGNvbnRlbnRcbiAgICAgIGxfa2V5czogbGlrZSBrZXlzXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbmV3X3RhYmxlIDo9IGVtcHR5X2R1cGxpY2F0ZSAoa2V5cy5jb3VudC5tYXggKG4pKVxuICAgICAgICBsX2NvbnRlbnQgOj0gY29udGVudFxuICAgICAgICBsX2tleXMgOj0ga2V5c1xuICAgICAgICBuYiA6PSBsX2tleXMuY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiBvY2N1cGllZCAoaSkgdGhlblxuICAgICAgICAgIG5ld190YWJsZS5wdXQgKGxfY29udGVudC5pdGVtIChpKSwgbF9rZXlzLml0ZW0gKGkpKVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBpZiBoYXNfZGVmYXVsdCB0aGVuXG4gICAgICAgIGkgOj0gaW5kZXhlc19tYXAuaXRlbSAoY2FwYWNpdHkpXG4gICAgICAgIG5ld190YWJsZS5wdXQgKGxfY29udGVudC5pdGVtIChpKSwga2V5cy5pdGVtIChpKSlcbiAgICAgIGVuZFxuXG4gICAgICBzZXRfY29udGVudCAobmV3X3RhYmxlLmNvbnRlbnQpXG4gICAgICBzZXRfa2V5cyAobmV3X3RhYmxlLmtleXMpXG4gICAgICBzZXRfZGVsZXRlZF9tYXJrcyAobmV3X3RhYmxlLmRlbGV0ZWRfbWFya3MpXG4gICAgICBzZXRfaW5kZXhlc19tYXAgKG5ld190YWJsZS5pbmRleGVzX21hcClcbiAgICAgIGNhcGFjaXR5IDo9IG5ld190YWJsZS5jYXBhY2l0eVxuICAgICAgaXRlcmF0aW9uX3Bvc2l0aW9uIDo9IG5ld190YWJsZS5pdGVyYXRpb25fcG9zaXRpb25cbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X25vdF9jaGFuZ2VkOiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgYnJlYXRoaW5nX3NwYWNlOiBjb3VudCA8IGNhcGFjaXR5XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgZm91bmRfaXRlbTogZGV0YWNoYWJsZSBHXG4gICAgICAtLSBJdGVtLCBpZiBhbnksIHlpZWxkZWQgYnkgbGFzdCBzZWFyY2ggb3BlcmF0aW9uXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChrZXk6IEspOiBkZXRhY2hhYmxlIEcgYXNzaWduIGZvcmNlXG4gICAgICAtLSBJdGVtIGFzc29jaWF0ZWQgd2l0aCBga2V5JywgaWYgcHJlc2VudFxuICAgICAgLS0gb3RoZXJ3aXNlIGRlZmF1bHQgdmFsdWUgb2YgdHlwZSBgRycuXG4gICAgbG9jYWxcbiAgICAgIGxfZGVmYXVsdF9rZXk6IGRldGFjaGFibGUgS1xuICAgICAgaGFzaF92YWx1ZSwgaW5jcmVtZW50LCBsX3BvcywgbF9pdGVtX3BvcywgbF9jYXBhY2l0eTogSU5URUdFUlxuICAgICAgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uOiBJTlRFR0VSXG4gICAgICBzdG9wOiBJTlRFR0VSXG4gICAgICBsX2tleXM6IGxpa2Uga2V5c1xuICAgICAgbF9pbmRleGVzOiBsaWtlIGluZGV4ZXNfbWFwXG4gICAgICBsX2RlbGV0ZWRfbWFya3M6IGxpa2UgZGVsZXRlZF9tYXJrc1xuICAgICAgbF9rZXk6IEtcbiAgICBkb1xuICAgICAgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uIDo9IGh0X2ltcG9zc2libGVfcG9zaXRpb25cbiAgICAgIGlmIGtleSA9IGxfZGVmYXVsdF9rZXkgb3Iga2V5ID0gVm9pZCB0aGVuXG4gICAgICAgIGlmIGhhc19kZWZhdWx0IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gY29udGVudC5pdGVtIChpbmRleGVzX21hcC5pdGVtIChjYXBhY2l0eSkpXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9rZXlzIDo9IGtleXNcbiAgICAgICAgICBsX2luZGV4ZXMgOj0gaW5kZXhlc19tYXBcbiAgICAgICAgICBsX2RlbGV0ZWRfbWFya3MgOj0gZGVsZXRlZF9tYXJrc1xuICAgICAgICAgIGxfY2FwYWNpdHkgOj0gY2FwYWNpdHlcbiAgICAgICAgICBzdG9wIDo9IGxfY2FwYWNpdHlcbiAgICAgICAgICBoYXNoX3ZhbHVlIDo9IGhhc2hfY29kZV9vZiAoa2V5KVxuICAgICAgICAgIGluY3JlbWVudCA6PSAxICsgaGFzaF92YWx1ZSBcXFxcIChsX2NhcGFjaXR5IC0gMSlcbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChoYXNoX3ZhbHVlIFxcXFwgbF9jYXBhY2l0eSkgLSBpbmNyZW1lbnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBzdG9wID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgICAtLSBHbyB0byBuZXh0IGluY3JlbWVudC5cbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChsX2l0ZW1fcG9zICsgaW5jcmVtZW50KSBcXFxcIGxfY2FwYWNpdHlcbiAgICAgICAgICBsX3BvcyA6PSBsX2luZGV4ZXMgW2xfaXRlbV9wb3NdXG4gICAgICAgICAgaWYgbF9wb3MgPj0gMCB0aGVuXG4gICAgICAgICAgICBsX2tleSA6PSBsX2tleXMuaXRlbSAobF9wb3MpXG4gICAgICAgICAgICBkZWJ1ZyAoXCJkZXRlY3RfaGFzaF90YWJsZV9jYXRjYWxsXCIpXG4gICAgICAgICAgICAgIGNoZWNrXG4gICAgICAgICAgICAgICAgY2F0Y2FsbF9kZXRlY3RlZDogbF9rZXkgLz0gVm9pZCBhbmQgdGhlbiBsX2tleS5zYW1lX3R5cGUgKGtleSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGlmIHNhbWVfa2V5cyAobF9rZXksIGtleSkgdGhlblxuICAgICAgICAgICAgICAgIC0tIFdlIGZvdW5kIG91ciBpdGVtXG4gICAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgICAgICBSZXN1bHQgOj0gY29udGVudC5pdGVtIChsX3BvcylcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VpZiBsX3BvcyA9IGh0X2ltcG9zc2libGVfcG9zaXRpb24gdGhlblxuICAgICAgICAgICAgc3RvcCA6PSAxXG4gICAgICAgICAgZWxzZWlmIGxfZmlyc3RfZGVsZXRlZF9wb3NpdGlvbiA9IGh0X2ltcG9zc2libGVfcG9zaXRpb24gdGhlblxuICAgICAgICAgICAgbF9wb3MgOj0gLWxfcG9zICsgaHRfZGVsZXRlZF9wb3NpdGlvblxuICAgICAgICAgICAgY2hlY2sgbF9wb3NfdmFsaWQ6IGxfcG9zIDwgbF9kZWxldGVkX21hcmtzLmNvdW50IGVuZFxuICAgICAgICAgICAgaWYgbm90IGxfZGVsZXRlZF9tYXJrcyBbbF9wb3NdIHRoZW5cbiAgICAgICAgICAgICAgc3RvcCA6PSAxXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfZmlyc3RfZGVsZXRlZF9wb3NpdGlvbiA6PSBsX2l0ZW1fcG9zXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBzdG9wIDo9IHN0b3AgLSAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmF1bHRfdmFsdWVfaWZfbm90X3ByZXNlbnQ6XG4gICAgICAgIChub3QgKGhhcyAoa2V5KSkpIGltcGxpZXMgKFJlc3VsdCA9IGNvbXB1dGVkX2RlZmF1bHRfdmFsdWUpXG4gICAgZW5kXG5cbiAgaGFzIChrZXk6IEspOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBhbiBpdGVtIGluIHRoZSB0YWJsZSB3aXRoIGtleSBga2V5Jz9cbiAgICBsb2NhbFxuICAgICAgbF9kZWZhdWx0X2tleTogZGV0YWNoYWJsZSBLXG4gICAgICBoYXNoX3ZhbHVlLCBpbmNyZW1lbnQsIGxfcG9zLCBsX2l0ZW1fcG9zLCBsX2NhcGFjaXR5OiBJTlRFR0VSXG4gICAgICBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb246IElOVEVHRVJcbiAgICAgIHN0b3A6IElOVEVHRVJcbiAgICAgIGxfa2V5czogbGlrZSBrZXlzXG4gICAgICBsX2luZGV4ZXM6IGxpa2UgaW5kZXhlc19tYXBcbiAgICAgIGxfZGVsZXRlZF9tYXJrczogbGlrZSBkZWxldGVkX21hcmtzXG4gICAgICBsX2tleTogS1xuICAgIGRvXG4gICAgICBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb24gOj0gaHRfaW1wb3NzaWJsZV9wb3NpdGlvblxuICAgICAgaWYga2V5ID0gbF9kZWZhdWx0X2tleSBvciBrZXkgPSBWb2lkIHRoZW5cbiAgICAgICAgaWYgaGFzX2RlZmF1bHQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9rZXlzIDo9IGtleXNcbiAgICAgICAgICBsX2luZGV4ZXMgOj0gaW5kZXhlc19tYXBcbiAgICAgICAgICBsX2RlbGV0ZWRfbWFya3MgOj0gZGVsZXRlZF9tYXJrc1xuICAgICAgICAgIGxfY2FwYWNpdHkgOj0gY2FwYWNpdHlcbiAgICAgICAgICBzdG9wIDo9IGxfY2FwYWNpdHlcbiAgICAgICAgICBoYXNoX3ZhbHVlIDo9IGhhc2hfY29kZV9vZiAoa2V5KVxuICAgICAgICAgIGluY3JlbWVudCA6PSAxICsgaGFzaF92YWx1ZSBcXFxcIChsX2NhcGFjaXR5IC0gMSlcbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChoYXNoX3ZhbHVlIFxcXFwgbF9jYXBhY2l0eSkgLSBpbmNyZW1lbnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBzdG9wID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgICAtLSBHbyB0byBuZXh0IGluY3JlbWVudC5cbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChsX2l0ZW1fcG9zICsgaW5jcmVtZW50KSBcXFxcIGxfY2FwYWNpdHlcbiAgICAgICAgICBsX3BvcyA6PSBsX2luZGV4ZXMgW2xfaXRlbV9wb3NdXG4gICAgICAgICAgaWYgbF9wb3MgPj0gMCB0aGVuXG4gICAgICAgICAgICBsX2tleSA6PSBsX2tleXMuaXRlbSAobF9wb3MpXG4gICAgICAgICAgICBkZWJ1ZyAoXCJkZXRlY3RfaGFzaF90YWJsZV9jYXRjYWxsXCIpXG4gICAgICAgICAgICAgIGNoZWNrXG4gICAgICAgICAgICAgICAgY2F0Y2FsbF9kZXRlY3RlZDogbF9rZXkgLz0gVm9pZCBhbmQgdGhlbiBsX2tleS5zYW1lX3R5cGUgKGtleSlcbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGlmIHNhbWVfa2V5cyAobF9rZXksIGtleSkgdGhlblxuICAgICAgICAgICAgICAgIC0tIFdlIGZvdW5kIG91ciBpdGVtXG4gICAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZWlmIGxfcG9zID0gaHRfaW1wb3NzaWJsZV9wb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICBzdG9wIDo9IDFcbiAgICAgICAgICBlbHNlaWYgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uID0gaHRfaW1wb3NzaWJsZV9wb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICBsX3BvcyA6PSAtbF9wb3MgKyBodF9kZWxldGVkX3Bvc2l0aW9uXG4gICAgICAgICAgICBjaGVjayBsX3Bvc192YWxpZDogbF9wb3MgPCBsX2RlbGV0ZWRfbWFya3MuY291bnQgZW5kXG4gICAgICAgICAgICBpZiBub3QgbF9kZWxldGVkX21hcmtzIFtsX3Bvc10gdGhlblxuICAgICAgICAgICAgICBzdG9wIDo9IDFcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uIDo9IGxfaXRlbV9wb3NcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHN0b3AgOj0gc3RvcCAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZGVmYXVsdF9jYXNlOiAoa2V5ID0gY29tcHV0ZWRfZGVmYXVsdF9rZXkpIGltcGxpZXMgKFJlc3VsdCA9IGhhc19kZWZhdWx0KVxuICAgIGVuZFxuXG4gIGhhc19rZXkgKGtleTogSyk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIGFuIGl0ZW0gaW4gdGhlIHRhYmxlIHdpdGgga2V5IGBrZXknPyBTZXQgYGZvdW5kX2l0ZW0nIHRvIHRoZSBmb3VuZCBpdGVtLlxuICAgIGxvY2FsXG4gICAgICBvbGRfcG9zaXRpb246IElOVEVHRVJcbiAgICAgIGxfZGVmYXVsdF92YWx1ZTogZGV0YWNoYWJsZSBHXG4gICAgZG9cbiAgICAgIG9sZF9wb3NpdGlvbiA6PSBpdGVtX3Bvc2l0aW9uXG4gICAgICBpbnRlcm5hbF9zZWFyY2ggKGtleSlcbiAgICAgIFJlc3VsdCA6PSBmb3VuZFxuICAgICAgaWYgUmVzdWx0IHRoZW5cbiAgICAgICAgZm91bmRfaXRlbSA6PSBjb250ZW50Lml0ZW0gKHBvc2l0aW9uKVxuICAgICAgZWxzZVxuICAgICAgICBmb3VuZF9pdGVtIDo9IGxfZGVmYXVsdF92YWx1ZVxuICAgICAgZW5kXG4gICAgICBpdGVtX3Bvc2l0aW9uIDo9IG9sZF9wb3NpdGlvblxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZhdWx0X2Nhc2U6IChrZXkgPSBjb21wdXRlZF9kZWZhdWx0X2tleSkgaW1wbGllcyAoUmVzdWx0ID0gaGFzX2RlZmF1bHQpXG4gICAgICBmb3VuZDogUmVzdWx0ID0gZm91bmRcbiAgICAgIGl0ZW1faWZfZm91bmQ6IGZvdW5kIGltcGxpZXMgKGZvdW5kX2l0ZW0gPSBpdGVtIChrZXkpKVxuICAgIGVuZFxuXG4gIGhhc19pdGVtICh2OiBkZXRhY2hhYmxlIEcpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cnVjdHVyZSBpbmNsdWRlIGB2Jz9cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvbnRlbnQ6IGxpa2UgY29udGVudFxuICAgIGRvXG4gICAgICBpZiBoYXNfZGVmYXVsdCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodiA9IGNvbnRlbnQuaXRlbSAoaW5kZXhlc19tYXAuaXRlbSAoY2FwYWNpdHkpKSlcbiAgICAgIGVuZFxuICAgICAgaWYgbm90IFJlc3VsdCB0aGVuXG4gICAgICAgIGxfY29udGVudCA6PSBjb250ZW50XG4gICAgICAgIG5iIDo9IGxfY29udGVudC5jb3VudFxuICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmIgb3IgZWxzZSBSZXN1bHRcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBSZXN1bHQgOj0gb2NjdXBpZWQgKGkpIGFuZCB0aGVuICh2IH4gbF9jb250ZW50Lml0ZW0gKGkpKVxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmIgb3IgZWxzZSBSZXN1bHRcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBSZXN1bHQgOj0gb2NjdXBpZWQgKGkpIGFuZCB0aGVuICh2ID0gbF9jb250ZW50Lml0ZW0gKGkpKVxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGN1cnJlbnRfa2V5czogQVJSQVkgW0tdXG4gICAgICAtLSBOZXcgYXJyYXkgY29udGFpbmluZyBhY3R1YWxseSB1c2VkIGtleXMsIGZyb20gMSB0byBgY291bnQnXG4gICAgbG9jYWxcbiAgICAgIGo6IElOVEVHRVJcbiAgICAgIG9sZF9pdGVyYXRpb25fcG9zaXRpb246IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgaXNfZW1wdHkgdGhlblxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHlcbiAgICAgIGVsc2VcbiAgICAgICAgb2xkX2l0ZXJhdGlvbl9wb3NpdGlvbiA6PSBpdGVyYXRpb25fcG9zaXRpb25cbiAgICAgICAgZnJvbVxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoa2V5X2Zvcl9pdGVyYXRpb24sIDEsIGNvdW50KVxuICAgICAgICAgIGogOj0gMVxuICAgICAgICAgIGZvcnRoXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgb2ZmXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgICAgUmVzdWx0LnB1dCAoa2V5X2Zvcl9pdGVyYXRpb24sIGopXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICAgIGl0ZXJhdGlvbl9wb3NpdGlvbiA6PSBvbGRfaXRlcmF0aW9uX3Bvc2l0aW9uXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGdvb2RfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbiAgaXRlbV9mb3JfaXRlcmF0aW9uOiBHXG4gICAgICAtLSBFbGVtZW50IGF0IGN1cnJlbnQgaXRlcmF0aW9uIHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZjogbm90IG9mZlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY29udGVudC5pdGVtIChpdGVyYXRpb25fcG9zaXRpb24pXG4gICAgZW5kXG5cbiAga2V5X2Zvcl9pdGVyYXRpb246IEtcbiAgICAgIC0tIEtleSBhdCBjdXJyZW50IGl0ZXJhdGlvbiBwb3NpdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9vZmY6IG5vdCBvZmZcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGtleXMuaXRlbSAoaXRlcmF0aW9uX3Bvc2l0aW9uKVxuICAgIGVuZFxuXG4gIGN1cnNvcjogQ1VSU09SXG4gICAgICAtLSBDdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgIGRvXG4gICAgICBjcmVhdGUge0hBU0hfVEFCTEVfQ1VSU09SfSBSZXN1bHQubWFrZSAoaXRlcmF0aW9uX3Bvc2l0aW9uKVxuICAgIGVuc3VyZVxuICAgICAgY3Vyc29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIG5ld19jdXJzb3I6IEhBU0hfVEFCTEVfSVRFUkFUSU9OX0NVUlNPUiBbRywgS11cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoQ3VycmVudClcbiAgICAgIFJlc3VsdC5zdGFydFxuICAgIGVuZFxuXG4gIGl0ZXJhdGlvbl9pdGVtIChpOiBJTlRFR0VSKTogR1xuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNvbnRlbnQuaXRlbSAoaSlcbiAgICBlbmRcblxuICBoYXNoX2NvZGVfb2YgKGFfa2V5OiBhdHRhY2hlZCBLKTogSU5URUdFUlxuICAgICAgLS0gSGFzaF9jb2RlIHZhbHVlIGFzc29jaWF0ZWQgdG8gYGFfa2V5Jy5cbiAgICBkb1xuICAgICAgICAtLSBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHVzZXMgYHtIQVNIQUJMRX0uaGFzaF9jb2RlJy5cbiAgICAgIFJlc3VsdCA6PSBhX2tleS5oYXNoX2NvZGVcbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgaXRlbXMgaW4gdGFibGVcblxuICBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGl0ZW1zIHRoYXQgbWF5IGJlIHN0b3JlZC5cblxuICBvY2N1cnJlbmNlcyAodjogZGV0YWNoYWJsZSBHKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRhYmxlIGl0ZW1zIGVxdWFsIHRvIGB2Jy5cbiAgICBsb2NhbFxuICAgICAgb2xkX2l0ZXJhdGlvbl9wb3NpdGlvbjogSU5URUdFUlxuICAgIGRvXG4gICAgICBvbGRfaXRlcmF0aW9uX3Bvc2l0aW9uIDo9IGl0ZXJhdGlvbl9wb3NpdGlvblxuICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgc3RhcnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBvZmZcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW1fZm9yX2l0ZXJhdGlvbiB+IHYgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBmb3J0aFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgIHVudGlsXG4gICAgICAgICAgb2ZmXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtX2Zvcl9pdGVyYXRpb24gPSB2IHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGl0ZXJhdGlvbl9wb3NpdGlvbiA6PSBvbGRfaXRlcmF0aW9uX3Bvc2l0aW9uXG4gICAgZW5kXG5cbiAgaXRlcmF0aW9uX2luZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuZXh0X2l0ZXJhdGlvbl9wb3NpdGlvbiAoLTEpLCBwcmV2aW91c19pdGVyYXRpb25fcG9zaXRpb24gKGtleXMuY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdGFibGUgY29udGFpbiB0aGUgc2FtZSBpbmZvcm1hdGlvbiBhcyBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZlxuICAgICAgICBjb3VudCA9IG90aGVyLmNvdW50IGFuZCB0aGVuXG4gICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb24gYW5kIHRoZW5cbiAgICAgICAgaGFzX2RlZmF1bHQgPSBvdGhlci5oYXNfZGVmYXVsdFxuICAgICAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBhY3Jvc3NcbiAgICAgICAgICBDdXJyZW50IGFzIGxfY1xuICAgICAgICB1bnRpbFxuICAgICAgICAgIG5vdCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG90aGVyLnNlYXJjaCAobF9jLmtleSlcbiAgICAgICAgICBpZiBvdGhlci5mb3VuZCB0aGVuXG4gICAgICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBsX2MuaXRlbSB+IG90aGVyLmZvdW5kX2l0ZW1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IGxfYy5pdGVtID0gb3RoZXIuZm91bmRfaXRlbVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2FtZV9rZXlzIChhX3NlYXJjaF9rZXksIGFfa2V5OiBLKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgYV9zZWFyY2hfa2V5JyBlcXVhbCB0byBgYV9rZXknP1xuICAgICAgLS18IERlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMgdXNpbmcgfi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zZWFyY2hfa2V5OiB2YWxpZF9rZXkgKGFfc2VhcmNoX2tleSlcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfa2V5IChhX2tleSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFfc2VhcmNoX2tleSB+IGFfa2V5XG4gICAgZW5kXG5cbiAgZGlzam9pbnQgKG90aGVyOiBIQVNIX1RBQkxFIFtHLCBLXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhbmQgYG90aGVyJyBkaXNqb2ludCBvbiB0aGVpciBrZXlzP1xuICAgICAgLS0gVXNlIGBzYW1lX2tleXMnIGZvciBjb21wYXJpc29uLlxuICAgIGRvXG4gICAgICAgIC0tIElmIGFueSBvZiB0aGUgdGFibGVzIGFyZSBlbXB0eSwgaXQgaXMgY2xlYXJseSBkaXNqb2ludCxcbiAgICAgICAgLS0gb3RoZXJ3aXNlIHdlIGNoZWNrIHRoYXQgbm8gZWxlbWVudHMgb2YgYG90aGVyJyBhcHBlYXJzIGluIEN1cnJlbnQuXG4gICAgICBSZXN1bHQgOj0gaXNfZW1wdHkgb3IgZWxzZSBvdGhlci5pc19lbXB0eSBvciBlbHNlXG4gICAgICAgIG5vdCBhY3Jvc3Mgb3RoZXIgYXMgbyBzb21lIGhhcyAoby5rZXkpIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBmdWxsOiBCT09MRUFOID0gRmFsc2VcbiAgICAgIC0tIElzIHN0cnVjdHVyZSBmaWxsZWQgdG8gY2FwYWNpdHk/XG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkP1xuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBjb25mbGljdDogQk9PTEVBTlxuICAgICAgLS0gRGlkIGxhc3Qgb3BlcmF0aW9uIGNhdXNlIGEgY29uZmxpY3Q/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY29udHJvbCA9IGNvbmZsaWN0X2NvbnN0YW50KVxuICAgIGVuZFxuXG4gIGluc2VydGVkOiBCT09MRUFOXG4gICAgICAtLSBEaWQgbGFzdCBvcGVyYXRpb24gaW5zZXJ0IGFuIGl0ZW0/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY29udHJvbCA9IGluc2VydGVkX2NvbnN0YW50KVxuICAgIGVuZFxuXG4gIHJlcGxhY2VkOiBCT09MRUFOXG4gICAgICAtLSBEaWQgbGFzdCBvcGVyYXRpb24gcmVwbGFjZSBhbiBpdGVtP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNvbnRyb2wgPSByZXBsYWNlZF9jb25zdGFudClcbiAgICBlbmRcblxuICByZW1vdmVkOiBCT09MRUFOXG4gICAgICAtLSBEaWQgbGFzdCBvcGVyYXRpb24gcmVtb3ZlIGFuIGl0ZW0/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY29udHJvbCA9IHJlbW92ZWRfY29uc3RhbnQpXG4gICAgZW5kXG5cbiAgZm91bmQ6IEJPT0xFQU5cbiAgICAgIC0tIERpZCBsYXN0IG9wZXJhdGlvbiBmaW5kIHRoZSBpdGVtIHNvdWdodD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjb250cm9sID0gZm91bmRfY29uc3RhbnQpXG4gICAgZW5kXG5cbiAgbm90X2ZvdW5kOiBCT09MRUFOXG4gICAgICAtLSBEaWQgbGFzdCBvcGVyYXRpb24gZmFpbCB0byBmaW5kIHRoZSBpdGVtIHNvdWdodD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjb250cm9sID0gbm90X2ZvdW5kX2NvbnN0YW50KVxuICAgIGVuZFxuXG4gIGFmdGVyLCBvZmY6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnNvciBwYXN0IGxhc3QgaXRlbT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX29mZl9wb3NpdGlvbiAoaXRlcmF0aW9uX3Bvc2l0aW9uKVxuICAgIGVuZFxuXG4gIHZhbGlkX2N1cnNvciAoYzogQ1VSU09SKTogQk9PTEVBTlxuICAgICAgLS0gQ2FuIGN1cnNvciBiZSBtb3ZlZCB0byBwb3NpdGlvbiBgYyc/XG4gICAgcmVxdWlyZVxuICAgICAgY19ub3Rfdm9pZDogYyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0hBU0hfVEFCTEVfQ1VSU09SfSBjIGFzIGh0X2N1cnNvciB0aGVuXG4gICAgICAgIGkgOj0gaHRfY3Vyc29yLnBvc2l0aW9uXG4gICAgICAgIFJlc3VsdCA6PSBpc19vZmZfcG9zaXRpb24gKGkpIG9yIGVsc2UgdHJ1bHlfb2NjdXBpZWQgKGkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB2YWxpZF9rZXkgKGs6IEspOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaycgYSB2YWxpZCBrZXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBkZWJ1ZyAoXCJwcmV2ZW50X2hhc2hfdGFibGVfY2F0Y2FsbFwiKVxuICAgICAgICAgIC0tIElmIGBLJyBpcyBleHBhbmRlZCB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gY2F0Y2FsbC5cbiAgICAgICAgICAtLSBJZiBgSycgaXMgYSByZWZlcmVuY2UsIHdlIG1ha2Ugc3VyZSB0aGF0IHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYGsnXG4gICAgICAgICAgLS0gaXMgdGhlIGRldGFjaGFibGUgdmVyc2lvbiBvZiBgSycgYXMgb2JqZWN0cyBoYXZlIHRoZSBkZXRhY2hhYmxlIHR5cGUgYnkgZGVmYXVsdC5cbiAgICAgICAgaWYgbm90ICh7S30pLmlzX2V4cGFuZGVkIGFuZCB0aGVuIGF0dGFjaGVkIGsgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBrLmdlbmVyYXRpbmdfdHlwZSB+IHtkZXRhY2hhYmxlIEt9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdmFsaWRfaXRlcmF0aW9uX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRydWx5X29jY3VwaWVkIChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEN1cnNvciBtb3ZlbWVudFxuXG4gIHN0YXJ0XG4gICAgICAtLSBCcmluZyBjdXJzb3IgdG8gZmlyc3QgcG9zaXRpb24uXG4gICAgZG9cbiAgICAgICAgLS0gR2V0IGxvd2VyIGJvdW5kIG9mIGl0ZXJhdGlvbiBpZiBhbnkuXG4gICAgICBpdGVyYXRpb25fcG9zaXRpb24gOj0gbmV4dF9pdGVyYXRpb25fcG9zaXRpb24gKC0xKVxuICAgIGVuZFxuXG4gIGZvcnRoXG4gICAgICAtLSBBZHZhbmNlIGN1cnNvciB0byBuZXh0IG9jY3VwaWVkIHBvc2l0aW9uLFxuICAgICAgLS0gb3IgYG9mZicgaWYgbm8gc3VjaCBwb3NpdGlvbiByZW1haW5zLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9vZmY6IG5vdCBvZmZcbiAgICBkb1xuICAgICAgaXRlcmF0aW9uX3Bvc2l0aW9uIDo9IG5leHRfaXRlcmF0aW9uX3Bvc2l0aW9uIChpdGVyYXRpb25fcG9zaXRpb24pXG4gICAgZW5kXG5cbiAgZ29fdG8gKGM6IENVUlNPUilcbiAgICAgIC0tIE1vdmUgdG8gcG9zaXRpb24gYGMnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfbm90X3ZvaWQ6IGMgLz0gVm9pZFxuICAgICAgdmFsaWRfY3Vyc29yOiB2YWxpZF9jdXJzb3IgKGMpXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtIQVNIX1RBQkxFX0NVUlNPUn0gYyBhcyBodF9jdXJzb3IgdGhlblxuICAgICAgICBpdGVyYXRpb25fcG9zaXRpb24gOj0gaHRfY3Vyc29yLnBvc2l0aW9uXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzZWFyY2ggKGtleTogSylcbiAgICAgIC0tIFNlYXJjaCBmb3IgaXRlbSBvZiBrZXkgYGtleScuXG4gICAgICAtLSBJZiBmb3VuZCwgc2V0IGBmb3VuZCcgdG8gdHJ1ZSwgYW5kIHNldFxuICAgICAgLS0gYGZvdW5kX2l0ZW0nIHRvIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGBrZXknLlxuICAgIGxvY2FsXG4gICAgICBvbGRfcG9zaXRpb246IElOVEVHRVJcbiAgICAgIGxfZGVmYXVsdF92YWx1ZTogZGV0YWNoYWJsZSBHXG4gICAgZG9cbiAgICAgIG9sZF9wb3NpdGlvbiA6PSBpdGVtX3Bvc2l0aW9uXG4gICAgICBpbnRlcm5hbF9zZWFyY2ggKGtleSlcbiAgICAgIGlmIGZvdW5kIHRoZW5cbiAgICAgICAgZm91bmRfaXRlbSA6PSBjb250ZW50Lml0ZW0gKHBvc2l0aW9uKVxuICAgICAgZWxzZVxuICAgICAgICBmb3VuZF9pdGVtIDo9IGxfZGVmYXVsdF92YWx1ZVxuICAgICAgZW5kXG4gICAgICBpdGVtX3Bvc2l0aW9uIDo9IG9sZF9wb3NpdGlvblxuICAgIGVuc3VyZVxuICAgICAgZm91bmRfb3Jfbm90X2ZvdW5kOiBmb3VuZCBvciBub3RfZm91bmRcbiAgICAgIGl0ZW1faWZfZm91bmQ6IGZvdW5kIGltcGxpZXMgKGZvdW5kX2l0ZW0gPSBpdGVtIChrZXkpKVxuICAgIGVuZFxuXG4gIHNlYXJjaF9pdGVtOiBkZXRhY2hhYmxlIEdcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgZm91bmRfaXRlbSBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBmb3VuZF9pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUge0hBU0hfVEFCTEVfSVRFUkFUSU9OX0NVUlNPUn0gLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgbmV4dF9pdGVyYXRpb25fcG9zaXRpb24gKGFfcG9zaXRpb246IGxpa2UgaXRlcmF0aW9uX3Bvc2l0aW9uKTogbGlrZSBpdGVyYXRpb25fcG9zaXRpb25cbiAgICAgIC0tIEdpdmVuIGFuIGl0ZXJhdGlvbiBwb3NpdGlvbiwgYWR2YW5jZWQgdG8gdGhlIG5leHQgb25lIHRha2luZyBpbnRvIGFjY291bnQgZGVsZXRlZFxuICAgICAgLS0gc2xvdHMgaW4gdGhlIGBjb250ZW50JyBhbmQgYGtleXMnIHN0cnVjdHVyZXMuXG4gICAgcmVxdWlyZVxuICAgICAgYV9wb3NpdGlvbl9iaWdfZW5vdWdoOiBhX3Bvc2l0aW9uID49IC0xXG4gICAgICBhX3Bvc2l0aW9uX3NtYWxsX2Vub3VnaDogYV9wb3NpdGlvbiA8IGtleXMuY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9kZWxldGVkX21hcmtzOiBsaWtlIGRlbGV0ZWRfbWFya3NcbiAgICAgIGxfdGFibGVfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYV9wb3NpdGlvbiArIDFcbiAgICAgIGxfZGVsZXRlZF9tYXJrcyA6PSBkZWxldGVkX21hcmtzXG4gICAgICBsX3RhYmxlX3NpemUgOj0gY29udGVudC5jb3VudFxuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgUmVzdWx0ID49IGxfdGFibGVfc2l6ZSBvciBlbHNlIG5vdCBsX2RlbGV0ZWRfbWFya3MuaXRlbSAoUmVzdWx0KVxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJldmlvdXNfaXRlcmF0aW9uX3Bvc2l0aW9uIChhX3Bvc2l0aW9uOiBsaWtlIGl0ZXJhdGlvbl9wb3NpdGlvbik6IGxpa2UgaXRlcmF0aW9uX3Bvc2l0aW9uXG4gICAgICAtLSBHaXZlbiBhbiBpdGVyYXRpb24gcG9zaXRpb24sIGdvIHRvIHRoZSBwcmV2aW91cyBvbmUgdGFraW5nIGludG8gYWNjb3VudCBkZWxldGVkXG4gICAgICAtLSBzbG90cyBpbiB0aGUgYGNvbnRlbnQnIGFuZCBga2V5cycgc3RydWN0dXJlcy5cbiAgICByZXF1aXJlXG4gICAgICBhX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IGFfcG9zaXRpb24gPj0gMFxuICAgICAgYV9wb3NpdGlvbl9zbWFsbF9lbm91Z2g6IGFfcG9zaXRpb24gPD0ga2V5cy5jb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2RlbGV0ZWRfbWFya3M6IGxpa2UgZGVsZXRlZF9tYXJrc1xuICAgIGRvXG4gICAgICBsX2RlbGV0ZWRfbWFya3MgOj0gZGVsZXRlZF9tYXJrc1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gYV9wb3NpdGlvbiAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2Ugbm90IGxfZGVsZXRlZF9tYXJrcy5pdGVtIChSZXN1bHQpXG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgLSAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAobmV3OiBHOyBrZXk6IEspXG4gICAgICAtLSBJbnNlcnQgYG5ldycgd2l0aCBga2V5JyBpZiB0aGVyZSBpcyBubyBvdGhlciBpdGVtXG4gICAgICAtLSBhc3NvY2lhdGVkIHdpdGggdGhlIHNhbWUga2V5LlxuICAgICAgLS0gU2V0IGBpbnNlcnRlZCcgaWYgYW5kIG9ubHkgaWYgYW4gaW5zZXJ0aW9uIGhhc1xuICAgICAgLS0gYmVlbiBtYWRlIChpLmUuIGBrZXknIHdhcyBub3QgcHJlc2VudCkuXG4gICAgICAtLSBJZiBzbywgc2V0IGBwb3NpdGlvbicgdG8gdGhlIGluc2VydGlvbiBwb3NpdGlvbi5cbiAgICAgIC0tIElmIG5vdCwgc2V0IGBjb25mbGljdCcuXG4gICAgICAtLSBJbiBlaXRoZXIgY2FzZSwgc2V0IGBmb3VuZF9pdGVtJyB0byB0aGUgaXRlbVxuICAgICAgLS0gbm93IGFzc29jaWF0ZWQgd2l0aCBga2V5JyAocHJldmlvdXMgaXRlbSBpZlxuICAgICAgLS0gdGhlcmUgd2FzIG9uZSwgYG5ldycgb3RoZXJ3aXNlKS5cbiAgICAgIC0tXG4gICAgICAtLSBUbyBjaG9vc2UgYmV0d2VlbiB2YXJpb3VzIGluc2VydC9yZXBsYWNlIHByb2NlZHVyZXMsXG4gICAgICAtLSBzZWUgYGluc3RydWN0aW9ucycgaW4gdGhlIEluZGV4aW5nIGNsYXVzZS5cbiAgICBsb2NhbFxuICAgICAgbF9kZWZhdWx0X2tleTogZGV0YWNoYWJsZSBLXG4gICAgICBsX25ld19wb3MsIGxfbmV3X2luZGV4X3BvczogbGlrZSBwb3NpdGlvblxuICAgIGRvXG4gICAgICBpbnRlcm5hbF9zZWFyY2ggKGtleSlcbiAgICAgIGlmIGZvdW5kIHRoZW5cbiAgICAgICAgc2V0X2NvbmZsaWN0XG4gICAgICAgIGZvdW5kX2l0ZW0gOj0gY29udGVudC5pdGVtIChwb3NpdGlvbilcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgc29vbl9mdWxsIHRoZW5cbiAgICAgICAgICBhZGRfc3BhY2VcbiAgICAgICAgICBpbnRlcm5hbF9zZWFyY2ggKGtleSlcbiAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgICAtLSBUaGUga2V5IGRpZG4ndCBtYWdpY2FsbHkgaW5zZXJ0IGl0c2VsZi5cbiAgICAgICAgICAgIG5vdF9wcmVzZW50OiBub3QgZm91bmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGRlbGV0ZWRfaXRlbV9wb3NpdGlvbiAvPSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uIHRoZW5cbiAgICAgICAgICBsX25ld19wb3MgOj0gZGVsZXRlZF9wb3NpdGlvbiAoZGVsZXRlZF9pdGVtX3Bvc2l0aW9uKVxuICAgICAgICAgIGxfbmV3X2luZGV4X3BvcyA6PSBkZWxldGVkX2l0ZW1fcG9zaXRpb25cbiAgICAgICAgICBkZWxldGVkX21hcmtzLmZvcmNlIChGYWxzZSwgbF9uZXdfcG9zKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbF9uZXdfcG9zIDo9IGtleXMuY291bnRcbiAgICAgICAgICBsX25ld19pbmRleF9wb3MgOj0gaXRlbV9wb3NpdGlvblxuICAgICAgICBlbmRcbiAgICAgICAgaW5kZXhlc19tYXAucHV0IChsX25ld19wb3MsIGxfbmV3X2luZGV4X3BvcylcbiAgICAgICAgY29udGVudC5mb3JjZSAobmV3LCBsX25ld19wb3MpXG4gICAgICAgIGtleXMuZm9yY2UgKGtleSwgbF9uZXdfcG9zKVxuICAgICAgICBpZiBrZXkgPSBsX2RlZmF1bHRfa2V5IHRoZW5cbiAgICAgICAgICBoYXNfZGVmYXVsdCA6PSBUcnVlXG4gICAgICAgIGVuZFxuICAgICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgICAgZm91bmRfaXRlbSA6PSBuZXdcbiAgICAgICAgY29udHJvbCA6PSBpbnNlcnRlZF9jb25zdGFudFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNvbmZsaWN0X29yX2luc2VydGVkOiBjb25mbGljdCBvciBpbnNlcnRlZFxuICAgICAgaW5zZXJ0aW9uX2RvbmU6IGluc2VydGVkIGltcGxpZXMgaXRlbSAoa2V5KSA9IG5ld1xuICAgICAgbm93X3ByZXNlbnQ6IGluc2VydGVkIGltcGxpZXMgaGFzIChrZXkpXG4gICAgICBvbmVfbW9yZV9pZl9pbnNlcnRlZDogaW5zZXJ0ZWQgaW1wbGllcyAoY291bnQgPSBvbGQgY291bnQgKyAxKVxuICAgICAgdW5jaGFuZ2VkX2lmX2NvbmZsaWN0OiBjb25mbGljdCBpbXBsaWVzIChjb3VudCA9IG9sZCBjb3VudClcbiAgICAgIHNhbWVfaXRlbV9pZl9jb25mbGljdDogY29uZmxpY3QgaW1wbGllcyAoaXRlbSAoa2V5KSA9IG9sZCAoaXRlbSAoa2V5KSkpXG4gICAgICBmb3VuZF9pdGVtX2Fzc29jaWF0ZWRfd2l0aF9rZXk6IGZvdW5kX2l0ZW0gPSBpdGVtIChrZXkpXG4gICAgICBuZXdfaXRlbV9pZl9pbnNlcnRlZDogaW5zZXJ0ZWQgaW1wbGllcyAoZm91bmRfaXRlbSA9IG5ldylcbiAgICAgIG9sZF9pdGVtX2lmX2NvbmZsaWN0OiBjb25mbGljdCBpbXBsaWVzIChmb3VuZF9pdGVtID0gb2xkIChpdGVtIChrZXkpKSlcbiAgICAgIGRlZmF1bHRfcHJvcGVydHk6XG4gICAgICAgIGhhc19kZWZhdWx0ID1cbiAgICAgICAgICAoKGluc2VydGVkIGFuZCAoa2V5ID0gY29tcHV0ZWRfZGVmYXVsdF9rZXkpKSBvclxuICAgICAgICAgICAgKChjb25mbGljdCBvciAoa2V5IC89IGNvbXB1dGVkX2RlZmF1bHRfa2V5KSlcbiAgICAgICAgICAgICAgYW5kIChvbGQgaGFzX2RlZmF1bHQpKSlcbiAgICBlbmRcblxuICBmb3JjZSAobmV3OiBHOyBrZXk6IEspXG4gICAgICAtLSBVcGRhdGUgdGFibGUgc28gdGhhdCBgbmV3JyB3aWxsIGJlIHRoZSBpdGVtIGFzc29jaWF0ZWRcbiAgICAgIC0tIHdpdGggYGtleScuXG4gICAgICAtLSBJZiB0aGVyZSB3YXMgYW4gaXRlbSBmb3IgdGhhdCBrZXksIHNldCBgZm91bmQnXG4gICAgICAtLSBhbmQgc2V0IGBmb3VuZF9pdGVtJyB0byB0aGF0IGl0ZW0uXG4gICAgICAtLSBJZiB0aGVyZSB3YXMgbm9uZSwgc2V0IGBub3RfZm91bmQnIGFuZCBzZXRcbiAgICAgIC0tIGBmb3VuZF9pdGVtJyB0byB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC0tXG4gICAgICAtLSBUbyBjaG9vc2UgYmV0d2VlbiB2YXJpb3VzIGluc2VydC9yZXBsYWNlIHByb2NlZHVyZXMsXG4gICAgICAtLSBzZWUgYGluc3RydWN0aW9ucycgaW4gdGhlIEluZGV4aW5nIGNsYXVzZS5cbiAgICBsb2NhbFxuICAgICAgbF9kZWZhdWx0X2tleTogZGV0YWNoYWJsZSBLXG4gICAgICBsX2RlZmF1bHRfdmFsdWU6IGRldGFjaGFibGUgR1xuICAgICAgbF9uZXdfcG9zLCBsX25ld19pbmRleF9wb3M6IGxpa2UgcG9zaXRpb25cbiAgICBkb1xuICAgICAgaW50ZXJuYWxfc2VhcmNoIChrZXkpXG4gICAgICBpZiBub3RfZm91bmQgdGhlblxuICAgICAgICBpZiBzb29uX2Z1bGwgdGhlblxuICAgICAgICAgIGFkZF9zcGFjZVxuICAgICAgICAgIGludGVybmFsX3NlYXJjaCAoa2V5KVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgZGVsZXRlZF9pdGVtX3Bvc2l0aW9uIC89IGh0X2ltcG9zc2libGVfcG9zaXRpb24gdGhlblxuICAgICAgICAgIGxfbmV3X3BvcyA6PSBkZWxldGVkX3Bvc2l0aW9uIChkZWxldGVkX2l0ZW1fcG9zaXRpb24pXG4gICAgICAgICAgbF9uZXdfaW5kZXhfcG9zIDo9IGRlbGV0ZWRfaXRlbV9wb3NpdGlvblxuICAgICAgICAgIGRlbGV0ZWRfbWFya3MuZm9yY2UgKEZhbHNlLCBsX25ld19wb3MpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX25ld19wb3MgOj0ga2V5cy5jb3VudFxuICAgICAgICAgIGxfbmV3X2luZGV4X3BvcyA6PSBpdGVtX3Bvc2l0aW9uXG4gICAgICAgIGVuZFxuICAgICAgICBpbmRleGVzX21hcC5wdXQgKGxfbmV3X3BvcywgbF9uZXdfaW5kZXhfcG9zKVxuICAgICAgICBrZXlzLmZvcmNlIChrZXksIGxfbmV3X3BvcylcbiAgICAgICAgaWYga2V5ID0gbF9kZWZhdWx0X2tleSB0aGVuXG4gICAgICAgICAgaGFzX2RlZmF1bHQgOj0gVHJ1ZVxuICAgICAgICBlbmRcbiAgICAgICAgY291bnQgOj0gY291bnQgKyAxXG4gICAgICAgIGZvdW5kX2l0ZW0gOj0gbF9kZWZhdWx0X3ZhbHVlXG4gICAgICBlbHNlXG4gICAgICAgIGxfbmV3X3BvcyA6PSBwb3NpdGlvblxuICAgICAgICBmb3VuZF9pdGVtIDo9IGNvbnRlbnQuaXRlbSAobF9uZXdfcG9zKVxuICAgICAgZW5kXG4gICAgICBjb250ZW50LmZvcmNlIChuZXcsIGxfbmV3X3BvcylcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaW5zZXJ0aW9uX2RvbmU6IGl0ZW0gKGtleSkgPSBuZXdcbiAgICAgIG5vd19wcmVzZW50OiBoYXMgKGtleSlcbiAgICAgIGZvdW5kX29yX25vdF9mb3VuZDogZm91bmQgb3Igbm90X2ZvdW5kXG4gICAgICBub3RfZm91bmRfaWZfd2FzX25vdF9wcmVzZW50OiBub3RfZm91bmQgPSBub3QgKG9sZCBoYXMgKGtleSkpXG4gICAgICBzYW1lX2NvdW50X29yX29uZV9tb3JlOiAoY291bnQgPSBvbGQgY291bnQpIG9yIChjb3VudCA9IG9sZCBjb3VudCArIDEpXG4gICAgICBmb3VuZF9pdGVtX2lzX29sZF9pdGVtOiBmb3VuZCBpbXBsaWVzIChmb3VuZF9pdGVtID0gb2xkIChpdGVtIChrZXkpKSlcbiAgICAgIGRlZmF1bHRfdmFsdWVfaWZfbm90X2ZvdW5kOlxuICAgICAgICBub3RfZm91bmQgaW1wbGllcyAoZm91bmRfaXRlbSA9IGNvbXB1dGVkX2RlZmF1bHRfdmFsdWUpXG4gICAgICAgICAgLS0gVGhlIHJldmVyc2UgaXMgbm90IHRydWUsIGFzIHdlIGNhbiBhbHdheXMgaW5zZXJ0XG4gICAgICAgICAgLS0gYW4gaXRlbSB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLCBmb3IgYW55IGtleS5cblxuICAgICAgZGVmYXVsdF9wcm9wZXJ0eTpcbiAgICAgICAgaGFzX2RlZmF1bHQgPVxuICAgICAgICAgICgoa2V5ID0gY29tcHV0ZWRfZGVmYXVsdF9rZXkpIG9yXG4gICAgICAgICAgICAoKGtleSAvPSBjb21wdXRlZF9kZWZhdWx0X2tleSkgYW5kIChvbGQgaGFzX2RlZmF1bHQpKSlcbiAgICBlbmRcblxuICBleHRlbmQgKG5ldzogRzsga2V5OiBLKVxuICAgICAgLS0gQXNzdW1pbmcgdGhlcmUgaXMgbm8gaXRlbSBvZiBrZXkgYGtleScsXG4gICAgICAtLSBpbnNlcnQgYG5ldycgd2l0aCBga2V5Jy5cbiAgICAgIC0tIFNldCBgaW5zZXJ0ZWQnLlxuICAgICAgLS1cbiAgICAgIC0tIFRvIGNob29zZSBiZXR3ZWVuIHZhcmlvdXMgaW5zZXJ0L3JlcGxhY2UgcHJvY2VkdXJlcyxcbiAgICAgIC0tIHNlZSBgaW5zdHJ1Y3Rpb25zJyBpbiB0aGUgSW5kZXhpbmcgY2xhdXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9wcmVzZW50OiBub3QgaGFzIChrZXkpXG4gICAgbG9jYWxcbiAgICAgIGxfZGVmYXVsdF9rZXk6IGRldGFjaGFibGUgS1xuICAgICAgbF9uZXdfcG9zLCBsX25ld19pbmRleF9wb3M6IGxpa2UgcG9zaXRpb25cbiAgICBkb1xuICAgICAgc2VhcmNoX2Zvcl9pbnNlcnRpb24gKGtleSlcbiAgICAgIGlmIHNvb25fZnVsbCB0aGVuXG4gICAgICAgIGFkZF9zcGFjZVxuICAgICAgICBzZWFyY2hfZm9yX2luc2VydGlvbiAoa2V5KVxuICAgICAgZW5kXG4gICAgICBpZiBkZWxldGVkX2l0ZW1fcG9zaXRpb24gLz0gaHRfaW1wb3NzaWJsZV9wb3NpdGlvbiB0aGVuXG4gICAgICAgIGxfbmV3X3BvcyA6PSBkZWxldGVkX3Bvc2l0aW9uIChkZWxldGVkX2l0ZW1fcG9zaXRpb24pXG4gICAgICAgIGxfbmV3X2luZGV4X3BvcyA6PSBkZWxldGVkX2l0ZW1fcG9zaXRpb25cbiAgICAgICAgZGVsZXRlZF9tYXJrcy5mb3JjZSAoRmFsc2UsIGxfbmV3X3BvcylcbiAgICAgIGVsc2VcbiAgICAgICAgbF9uZXdfcG9zIDo9IGtleXMuY291bnRcbiAgICAgICAgbF9uZXdfaW5kZXhfcG9zIDo9IGl0ZW1fcG9zaXRpb25cbiAgICAgIGVuZFxuICAgICAgaW5kZXhlc19tYXAucHV0IChsX25ld19wb3MsIGxfbmV3X2luZGV4X3BvcylcbiAgICAgIGNvbnRlbnQuZm9yY2UgKG5ldywgbF9uZXdfcG9zKVxuICAgICAga2V5cy5mb3JjZSAoa2V5LCBsX25ld19wb3MpXG4gICAgICBpZiBrZXkgPSBsX2RlZmF1bHRfa2V5IHRoZW5cbiAgICAgICAgaGFzX2RlZmF1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGNvbnRyb2wgOj0gaW5zZXJ0ZWRfY29uc3RhbnRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpbnNlcnRlZFxuICAgICAgaW5zZXJ0aW9uX2RvbmU6IGl0ZW0gKGtleSkgPSBuZXdcbiAgICAgIG9uZV9tb3JlOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGRlZmF1bHRfcHJvcGVydHk6XG4gICAgICAgIGhhc19kZWZhdWx0ID1cbiAgICAgICAgICAoKGtleSA9IGNvbXB1dGVkX2RlZmF1bHRfa2V5KSBvciAob2xkIGhhc19kZWZhdWx0KSlcbiAgICBlbmRcblxuICByZXBsYWNlIChuZXc6IEc7IGtleTogSylcbiAgICAgIC0tIFJlcGxhY2UgaXRlbSBhdCBga2V5JywgaWYgcHJlc2VudCxcbiAgICAgIC0tIHdpdGggYG5ldyc7IGRvIG5vdCBjaGFuZ2UgYXNzb2NpYXRlZCBrZXkuXG4gICAgICAtLSBTZXQgYHJlcGxhY2VkJyBpZiBhbmQgb25seSBpZiBhIHJlcGxhY2VtZW50IGhhcyBiZWVuIG1hZGVcbiAgICAgIC0tIChpLmUuIGBrZXknIHdhcyBwcmVzZW50KTsgb3RoZXJ3aXNlIHNldCBgbm90X2ZvdW5kJy5cbiAgICAgIC0tIFNldCBgZm91bmRfaXRlbScgdG8gdGhlIGl0ZW0gcHJldmlvdXNseSBhc3NvY2lhdGVkXG4gICAgICAtLSB3aXRoIGBrZXknIChkZWZhdWx0IHZhbHVlIGlmIHRoZXJlIHdhcyBub25lKS5cbiAgICAgIC0tXG4gICAgICAtLSBUbyBjaG9vc2UgYmV0d2VlbiB2YXJpb3VzIGluc2VydC9yZXBsYWNlIHByb2NlZHVyZXMsXG4gICAgICAtLSBzZWUgYGluc3RydWN0aW9ucycgaW4gdGhlIEluZGV4aW5nIGNsYXVzZS5cbiAgICBsb2NhbFxuICAgICAgbF9kZWZhdWx0X2l0ZW06IGRldGFjaGFibGUgR1xuICAgIGRvXG4gICAgICBpbnRlcm5hbF9zZWFyY2ggKGtleSlcbiAgICAgIGlmIGZvdW5kIHRoZW5cbiAgICAgICAgZm91bmRfaXRlbSA6PSBjb250ZW50Lml0ZW0gKHBvc2l0aW9uKVxuICAgICAgICBjb250ZW50LnB1dCAobmV3LCBwb3NpdGlvbilcbiAgICAgICAgY29udHJvbCA6PSByZXBsYWNlZF9jb25zdGFudFxuICAgICAgZWxzZVxuICAgICAgICBmb3VuZF9pdGVtIDo9IGxfZGVmYXVsdF9pdGVtXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlcGxhY2VkX29yX25vdF9mb3VuZDogcmVwbGFjZWQgb3Igbm90X2ZvdW5kXG4gICAgICBpbnNlcnRpb25fZG9uZTogcmVwbGFjZWQgaW1wbGllcyBpdGVtIChrZXkpID0gbmV3XG4gICAgICBub19jaGFuZ2VfaWZfbm90X2ZvdW5kOiBub3RfZm91bmQgaW1wbGllc1xuICAgICAgICAgICAgaXRlbSAoa2V5KSA9IG9sZCAoaXRlbSAoa2V5KSlcbiAgICAgIGZvdW5kX2l0ZW1faXNfb2xkX2l0ZW06IGZvdW5kX2l0ZW0gPSBvbGQgKGl0ZW0gKGtleSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9rZXkgKG5ld19rZXk6IEs7IG9sZF9rZXk6IEspXG4gICAgICAtLSBJZiB0aGVyZSBpcyBhbiBpdGVtIG9mIGtleSBgb2xkX2tleScgYW5kIG5vIGl0ZW0gb2Yga2V5XG4gICAgICAtLSBgbmV3X2tleScsIHJlcGxhY2UgdGhlIGZvcm1lcidzIGtleSBieSBgbmV3X2tleScsXG4gICAgICAtLSBzZXQgYHJlcGxhY2VkJywgYW5kIHNldCBgZm91bmRfaXRlbScgdG8gdGhlIGl0ZW1cbiAgICAgIC0tIHByZXZpb3VzbHkgYXNzb2NpYXRlZCB3aXRoIGBvbGRfa2V5Jy5cbiAgICAgIC0tIE90aGVyd2lzZSBzZXQgYG5vdF9mb3VuZCcgb3IgYGNvbmZsaWN0JyByZXNwZWN0aXZlbHkuXG4gICAgICAtLSBJZiBgY29uZmxpY3QnLCBzZXQgYGZvdW5kX2l0ZW0nIHRvIHRoZSBpdGVtIHByZXZpb3VzbHlcbiAgICAgIC0tIGFzc29jaWF0ZWQgd2l0aCBgbmV3X2tleScuXG4gICAgICAtLVxuICAgICAgLS0gVG8gY2hvb3NlIGJldHdlZW4gdmFyaW91cyBpbnNlcnQvcmVwbGFjZSBwcm9jZWR1cmVzLFxuICAgICAgLS0gc2VlIGBpbnN0cnVjdGlvbnMnIGluIHRoZSBJbmRleGluZyBjbGF1c2UuXG4gICAgbG9jYWxcbiAgICAgIGxfaXRlbTogR1xuICAgIGRvXG4gICAgICBpbnRlcm5hbF9zZWFyY2ggKG5ld19rZXkpXG4gICAgICBpZiBub3QgZm91bmQgdGhlblxuICAgICAgICBpbnRlcm5hbF9zZWFyY2ggKG9sZF9rZXkpXG4gICAgICAgIGlmIGZvdW5kIHRoZW5cbiAgICAgICAgICBsX2l0ZW0gOj0gY29udGVudC5pdGVtIChwb3NpdGlvbilcbiAgICAgICAgICByZW1vdmUgKG9sZF9rZXkpXG4gICAgICAgICAgcHV0IChsX2l0ZW0sIG5ld19rZXkpXG4gICAgICAgICAgY29udHJvbCA6PSByZXBsYWNlZF9jb25zdGFudFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgc2V0X2NvbmZsaWN0XG4gICAgICAgIGZvdW5kX2l0ZW0gOj0gY29udGVudC5pdGVtIChwb3NpdGlvbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHJlcGxhY2VkX29yX2NvbmZsaWN0X29yX25vdF9mb3VuZDogcmVwbGFjZWQgb3IgY29uZmxpY3Qgb3Igbm90X2ZvdW5kXG4gICAgICBvbGRfYWJzZW50OiAocmVwbGFjZWQgYW5kIG5vdCBzYW1lX2tleXMgKG5ld19rZXksIG9sZF9rZXkpKSBpbXBsaWVzIChub3QgaGFzIChvbGRfa2V5KSlcbiAgICAgIG5ld19wcmVzZW50OiAocmVwbGFjZWQgb3IgY29uZmxpY3QpID0gaGFzIChuZXdfa2V5KVxuICAgICAgbmV3X2l0ZW06IHJlcGxhY2VkIGltcGxpZXMgKGl0ZW0gKG5ld19rZXkpID0gb2xkIChpdGVtIChvbGRfa2V5KSkpXG4gICAgICBub3RfZm91bmRfaW1wbGllc19ub19vbGRfa2V5OiBub3RfZm91bmQgaW1wbGllcyBvbGQgKG5vdCBoYXMgKG9sZF9rZXkpKVxuICAgICAgY29uZmxpY3RfaWZmX2FscmVhZHlfcHJlc2VudDogY29uZmxpY3QgPSBvbGQgKGhhcyAobmV3X2tleSkpXG4gICAgICBub3RfaW5zZXJ0ZWRfaWZfY29uZmxpY3Q6IGNvbmZsaWN0IGltcGxpZXNcbiAgICAgICAgICAgIChpdGVtIChuZXdfa2V5KSA9IG9sZCAoaXRlbSAobmV3X2tleSkpKVxuICAgIGVuZFxuXG4gIG1lcmdlIChvdGhlcjogSEFTSF9UQUJMRSBbRywgS10pXG4gICAgICAtLSBNZXJnZSBgb3RoZXInIGludG8gQ3VycmVudC4gSWYgYG90aGVyJyBoYXMgc29tZSBlbGVtZW50c1xuICAgICAgLS0gd2l0aCBzYW1lIGtleSBhcyBpbiBgQ3VycmVudCcsIHJlcGxhY2UgdGhlbSBieSBvbmUgZnJvbVxuICAgICAgLS0gYG90aGVyJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG90aGVyLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBvdGhlci5hZnRlclxuICAgICAgbG9vcFxuICAgICAgICBmb3JjZSAob3RoZXIuaXRlbV9mb3JfaXRlcmF0aW9uLCBvdGhlci5rZXlfZm9yX2l0ZXJhdGlvbilcbiAgICAgICAgb3RoZXIuZm9ydGhcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IG90aGVyLmN1cnJlbnRfa2V5cy5saW5lYXJfcmVwcmVzZW50YXRpb24uZm9yX2FsbCAoYWdlbnQgaGFzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmUgKGtleTogSylcbiAgICAgIC0tIFJlbW92ZSBpdGVtIGFzc29jaWF0ZWQgd2l0aCBga2V5JywgaWYgcHJlc2VudC5cbiAgICAgIC0tIFNldCBgcmVtb3ZlZCcgaWYgYW5kIG9ubHkgaWYgYW4gaXRlbSBoYXMgYmVlblxuICAgICAgLS0gcmVtb3ZlZCAoaS5lLiBga2V5JyB3YXMgcHJlc2VudCk7XG4gICAgICAtLSBpZiBzbywgc2V0IGBwb3NpdGlvbicgdG8gaW5kZXggb2YgcmVtb3ZlZCBlbGVtZW50LlxuICAgICAgLS0gSWYgbm90LCBzZXQgYG5vdF9mb3VuZCcuXG4gICAgICAtLSBSZXNldCBgZm91bmRfaXRlbScgdG8gaXRzIGRlZmF1bHQgdmFsdWUgaWYgYHJlbW92ZWQnLlxuICAgIGxvY2FsXG4gICAgICBsX2RlZmF1bHRfa2V5OiBkZXRhY2hhYmxlIEtcbiAgICAgIGxfZGVmYXVsdF92YWx1ZTogZGV0YWNoYWJsZSBHXG4gICAgICBsX3BvczogbGlrZSBwb3NpdGlvblxuICAgICAgbF9uYl9yZW1vdmVkX2l0ZW1zOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGludGVybmFsX3NlYXJjaCAoa2V5KVxuICAgICAgaWYgZm91bmQgdGhlblxuICAgICAgICBsX3BvcyA6PSBwb3NpdGlvblxuICAgICAgICBpZiBrZXkgPSBsX2RlZmF1bHRfa2V5IHRoZW5cbiAgICAgICAgICBoYXNfZGVmYXVsdCA6PSBGYWxzZVxuICAgICAgICBlbmRcbiAgICAgICAgZGVsZXRlZF9tYXJrcy5wdXQgKFRydWUsIGxfcG9zKVxuICAgICAgICBpbmRleGVzX21hcC5wdXQgKC1sX3BvcyArIGh0X2RlbGV0ZWRfcG9zaXRpb24sIGl0ZW1fcG9zaXRpb24pXG4gICAgICAgIGlmIGl0ZXJhdGlvbl9wb3NpdGlvbiA9IGxfcG9zIHRoZW5cbiAgICAgICAgICBmb3J0aFxuICAgICAgICBlbmRcbiAgICAgICAgY291bnQgOj0gY291bnQgLSAxXG4gICAgICAgICAgLS0gRm9yIHZvaWQtc2FmZXR5IGNvbmNlcm5zIGFuZCB0byBhdm9pZCBsZWFraW5nIHRvbyBtYW55IG9iamVjdHMsXG4gICAgICAgICAgLS0gd2Ugc2V0IGFsbCBkZWxldGVkIHBvc2l0aW9ucyB0byB0aGUgc2FtZSBpdGVtIGFuZCBrZXkgd2hlbiByZW1vdmluZ1xuICAgICAgICAgIC0tIG9uIHRoZSBpbnNpZGUgb2YgdGhlIFNQRUNJQUxzLCBvdGhlcndpc2Ugd2Ugc2ltcGx5IHNocmluayB0aGUgU1BFQ0lBTHMuXG4gICAgICAgIGh0X2xvd2VzdF9kZWxldGVkX3Bvc2l0aW9uIDo9IGxfcG9zLm1pbiAoaHRfbG93ZXN0X2RlbGV0ZWRfcG9zaXRpb24pXG4gICAgICAgIGlmIChodF9sb3dlc3RfZGVsZXRlZF9wb3NpdGlvbiA9IGNvdW50KSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBoYXZlIHJlbW92ZWQgYWxsIGVsZW1lbnRzIGFib3ZlIGBodF9sb3dlc3RfZGVsZXRlZF9wb3NpdGlvbicsIHdlIGNhblxuICAgICAgICAgICAgLS0gc2hyaW5rIG91ciBTUEVDSUFMcy5cbiAgICAgICAgICBsX25iX3JlbW92ZWRfaXRlbXMgOj0gY29udGVudC5jb3VudCAtIGh0X2xvd2VzdF9kZWxldGVkX3Bvc2l0aW9uXG4gICAgICAgICAgY29udGVudC5yZW1vdmVfdGFpbCAobF9uYl9yZW1vdmVkX2l0ZW1zKVxuICAgICAgICAgIGtleXMucmVtb3ZlX3RhaWwgKGxfbmJfcmVtb3ZlZF9pdGVtcylcbiAgICAgICAgICAgIC0tIEFsbCBlbGVtZW50cyBhYm92ZSBgaHRfbG93ZXN0X2RlbGV0ZWRfcG9zaXRpb24nIG9mIGBkZWxldGVkX21hcmtzJyBhcmUgcmVzZXRcbiAgICAgICAgICAgIC0tIHRvIEZhbHNlLiBUbyBiZSBjb3JyZWN0LCB3ZSBzaG91bGQgYWxzbyByZXNldCB0aGVpciBjb3JyZXNwb25kaW5nIGluZGV4ZXNcbiAgICAgICAgICAgIC0tIGluIGBpbmRleGVzX21hcCcgdG8gYGh0X2ltcG9zc2libGVfcG9zaXRpb24nIGhvd2V2ZXIgdGhhdCB3b3VsZCBiZSB0b29cbiAgICAgICAgICAgIC0tIGV4cGVuc2l2ZSB0byB0cmF2ZXJzZSB0aGUgc3RydWN0dXJlLiBJbnN0ZWFkIHdlIGxlYXZlIGl0ZW1zIGFzIHRoZXkgYXJlIGJ1dFxuICAgICAgICAgICAgLS0gd2UgY29wZSB3aXRoIHRoZW0gaW4gYGludGVybmFsX3NlYXJjaCcuXG4gICAgICAgICAgZGVsZXRlZF9tYXJrcy5maWxsX3dpdGggKEZhbHNlLCBodF9sb3dlc3RfZGVsZXRlZF9wb3NpdGlvbiwgZGVsZXRlZF9tYXJrcy5jb3VudCAtIDEpXG4gICAgICAgICAgaHRfZGVsZXRlZF9pdGVtIDo9IGxfZGVmYXVsdF92YWx1ZVxuICAgICAgICAgIGh0X2RlbGV0ZWRfa2V5IDo9IGxfZGVmYXVsdF9rZXlcbiAgICAgICAgICBodF9sb3dlc3RfZGVsZXRlZF9wb3NpdGlvbiA6PSBodF9tYXhfcG9zaXRpb25cbiAgICAgICAgZWxzZWlmIGF0dGFjaGVkIGh0X2RlbGV0ZWRfaXRlbSBhcyBsX2l0ZW0gYW5kIGF0dGFjaGVkIGh0X2RlbGV0ZWRfa2V5IGFzIGxfa2V5IHRoZW5cbiAgICAgICAgICBjb250ZW50LnB1dCAobF9pdGVtLCBsX3BvcylcbiAgICAgICAgICBrZXlzLnB1dCAobF9rZXksIGxfcG9zKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIHRhYmxlLlxuICAgICAgICAgIGh0X2RlbGV0ZWRfaXRlbSA6PSBjb250ZW50Lml0ZW0gKGxfcG9zKVxuICAgICAgICAgIGh0X2RlbGV0ZWRfa2V5IDo9IGtleXMuaXRlbSAobF9wb3MpXG4gICAgICAgIGVuZFxuICAgICAgICBjb250cm9sIDo9IHJlbW92ZWRfY29uc3RhbnRcbiAgICAgICAgZm91bmRfaXRlbSA6PSBsX2RlZmF1bHRfdmFsdWVcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZF9vcl9ub3RfZm91bmQ6IHJlbW92ZWQgb3Igbm90X2ZvdW5kXG4gICAgICBub3RfcHJlc2VudDogbm90IGhhcyAoa2V5KVxuICAgICAgb25lX2xlc3M6IGZvdW5kIGltcGxpZXMgKGNvdW50ID0gb2xkIGNvdW50IC0gMSlcbiAgICAgIGRlZmF1bHRfY2FzZTpcbiAgICAgICAgKGtleSA9IGNvbXB1dGVkX2RlZmF1bHRfa2V5KSBpbXBsaWVzIChub3QgaGFzX2RlZmF1bHQpXG4gICAgICBub25fZGVmYXVsdF9jYXNlOlxuICAgICAgICAoa2V5IC89IGNvbXB1dGVkX2RlZmF1bHRfa2V5KSBpbXBsaWVzXG4gICAgICAgICAgKGhhc19kZWZhdWx0ID0gb2xkIGhhc19kZWZhdWx0KVxuICAgIGVuZFxuXG4gIHBydW5lICh2OiBkZXRhY2hhYmxlIEcpXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdicsIGlmIGFueSxcbiAgICAgIC0tIGFmdGVyIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIHJpZ2h0IG5laWdoYm9yLlxuICAgICAgLS0gKG9yIGFmdGVyIGlmIG5vIHJpZ2h0IG5laWdoYm9yIG9yIGB2JyBkb2VzIG5vdCBvY2N1cilcbiAgICBkb1xuICAgICAgICAtLSBObyBuZWVkIHRvIGNoZWNrIGlmIHdlIGFyZSBiZWZvcmUgYmVjYXVzZSBgaXRlcmF0aW9uX3Bvc2l0aW9uJyBpcyBlaXRoZXJcbiAgICAgICAgLS0gYSB2YWxpZCBwb3NpdGlvbiBvciBgb2ZmJyAoc2VlIGludmFyaWFudCBgdmFsaWRfaXRlcmF0aW9uX3Bvc2l0aW9uJykuXG4gICAgICAgIC0tIFRodXMgd2UgY2FuIHN0YXJ0IGl0ZXJhdGluZyByaWdodCBhd2F5LlxuICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgYWZ0ZXIgb3IgZWxzZSBpdGVtX2Zvcl9pdGVyYXRpb24gfiB2XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBmb3J0aFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGFmdGVyIG9yIGVsc2UgaXRlbV9mb3JfaXRlcmF0aW9uID0gdlxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIG5vdCBhZnRlciB0aGVuXG4gICAgICAgIHJlbW92ZSAoa2V5X2Zvcl9pdGVyYXRpb24pXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVzZXQgYWxsIGl0ZW1zIHRvIGRlZmF1bHQgdmFsdWVzOyByZXNldCBzdGF0dXMuXG4gICAgbG9jYWxcbiAgICAgIGxfZGVmYXVsdF92YWx1ZTogZGV0YWNoYWJsZSBHXG4gICAgZG9cbiAgICAgIGNvbnRlbnQud2lwZV9vdXRcbiAgICAgIGtleXMud2lwZV9vdXRcbiAgICAgIGRlbGV0ZWRfbWFya3MuZmlsbF93aXRoIChGYWxzZSwgMCwgZGVsZXRlZF9tYXJrcy51cHBlcilcbiAgICAgIGluZGV4ZXNfbWFwLmZpbGxfd2l0aCAoaHRfaW1wb3NzaWJsZV9wb3NpdGlvbiwgMCwgY2FwYWNpdHkpXG4gICAgICBmb3VuZF9pdGVtIDo9IGxfZGVmYXVsdF92YWx1ZVxuICAgICAgY291bnQgOj0gMFxuICAgICAgaXRlbV9wb3NpdGlvbiA6PSAwXG4gICAgICBpdGVyYXRpb25fcG9zaXRpb24gOj0ga2V5cy5jb3VudFxuICAgICAgY29udHJvbCA6PSAwXG4gICAgICBoYXNfZGVmYXVsdCA6PSBGYWxzZVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBwb3NpdGlvbl9lcXVhbF90b196ZXJvOiBpdGVtX3Bvc2l0aW9uID0gMFxuICAgICAgY291bnRfZXF1YWxfdG9femVybzogY291bnQgPSAwXG4gICAgICBoYXNfZGVmYXVsdF9zZXQ6IG5vdCBoYXNfZGVmYXVsdFxuICAgICAgbm9fc3RhdHVzOiBub3Qgc3BlY2lhbF9zdGF0dXNcbiAgICBlbmRcblxuICBjbGVhcl9hbGxcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIHdpcGVfb3V0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogQVJSQVlFRF9MSVNUIFtHXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIG9sZF9pdGVyYXRpb25fcG9zaXRpb246IElOVEVHRVJcbiAgICBkb1xuICAgICAgb2xkX2l0ZXJhdGlvbl9wb3NpdGlvbiA6PSBpdGVyYXRpb25fcG9zaXRpb25cbiAgICAgIGZyb21cbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChjb3VudClcbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIG9mZlxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQuZXh0ZW5kIChpdGVtX2Zvcl9pdGVyYXRpb24pXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcbiAgICAgIGl0ZXJhdGlvbl9wb3NpdGlvbiA6PSBvbGRfaXRlcmF0aW9uX3Bvc2l0aW9uXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIFJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBnb29kX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlLWluaXRpYWxpemUgZnJvbSBgb3RoZXInLlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgc3RhbmRhcmRfY29weSAob3RoZXIpXG4gICAgICAgIHNldF9jb250ZW50IChvdGhlci5jb250ZW50LnR3aW4pXG4gICAgICAgIHNldF9rZXlzIChvdGhlci5rZXlzLnR3aW4pXG4gICAgICAgIHNldF9kZWxldGVkX21hcmtzIChvdGhlci5kZWxldGVkX21hcmtzLnR3aW4pXG4gICAgICAgIHNldF9pbmRleGVzX21hcCAob3RoZXIuaW5kZXhlc19tYXAudHdpbilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBEdXBsaWNhdGlvblxuXG4gIGVtcHR5X2R1cGxpY2F0ZSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ3JlYXRlIGFuIGVtcHR5IGNvcHkgb2YgQ3VycmVudCB0aGF0IGNhbiBhY2NvbW1vZGF0ZSBgbicgaXRlbXNcbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobilcbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgUmVzdWx0LmNvbXBhcmVfb2JqZWN0c1xuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9kdXBsaWNhdGVfYXR0YWNoZWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBsb2NhbFxuICAgICAgbF9vbGRfZGVsZXRlZF9tYXJrczogZGV0YWNoYWJsZSBTUEVDSUFMIFtCT09MRUFOXVxuICAgICAgaSwgbF9jYXBhY2l0eSwgbF9jb3VudDogSU5URUdFUlxuICAgICAgbF9uZXdfdGFibGU6IGxpa2UgQ3VycmVudFxuICAgICAgbF9kZWZhdWx0X2l0ZW06IGxpa2UgaHRfZGVsZXRlZF9pdGVtXG4gICAgICBsX2RlZmF1bHRfa2V5OiBsaWtlIGh0X2RlbGV0ZWRfa2V5XG4gICAgZG9cbiAgICAgIGlmIG5vdCBtaXNtYXRjaF9pbmZvcm1hdGlvbi5oYXMgKFwiaGFzaF90YWJsZV92ZXJzaW9uXzY0XCIpIHRoZW5cbiAgICAgICAgICAtLSBJbiB2ZXJzaW9uIDUuMSBhbmQgZWFybGllciwgYGNvbnRlbnQnLCBga2V5cycgYW5kIGBkZWxldGVkX21hcmtzJ1xuICAgICAgICAgIC0tIHdoZXJlIG9mIGJhc2UgY2xhc3MgQVJSQVkuIEluIDUuMiB3ZSBjaGFuZ2VkIGl0IHRvIGJlIGEgU1BFQ0lBTCBmb3JcbiAgICAgICAgICAtLSBlZmZpY2llbmN5IHJlYXNvbnMuIEluIG9yZGVyIHRvIHJldHJpZXZlIGFuIG9sZCBIQVNIX1RBQkxFIHdlXG4gICAgICAgICAgLS0gbmVlZCB0byBjb252ZXJ0IHRob3NlIEFSUkFZIGluc3RhbmNlcyBpbnRvIFNQRUNJQUwgaW5zdGFuY2VzLlxuXG4gICAgICAgICAgLS0gQ29udmVydCBgY29udGVudCcgZnJvbSBBUlJBWSB0byBTUEVDSUFMXG4gICAgICAgIGlmIGF0dGFjaGVkIHtBUlJBWSBbR119IG1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKFwiY29udGVudFwiKSBhcyBhcnJheV9jb250ZW50IHRoZW5cbiAgICAgICAgICBjb250ZW50IDo9IGFycmF5X2NvbnRlbnQuYXJlYVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIENvbnZlcnQgYGtleXMnIGZyb20gQVJSQVkgdG8gU1BFQ0lBTFxuICAgICAgICBpZiBhdHRhY2hlZCB7QVJSQVkgW0tdfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcImtleXNcIikgYXMgYXJyYXlfa2V5cyB0aGVuXG4gICAgICAgICAga2V5cyA6PSBhcnJheV9rZXlzLmFyZWFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBDb252ZXJ0IGBkZWxldGVkX21hcmtzJyBmcm9tIEFSUkFZIHRvIFNQRUNJQUxcbiAgICAgICAgaWYgYXR0YWNoZWQge0FSUkFZIFtCT09MRUFOXX0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJkZWxldGVkX21hcmtzXCIpIGFzIGFycmF5X21hcmtzIHRoZW5cbiAgICAgICAgICBkZWxldGVkX21hcmtzIDo9IGFycmF5X21hcmtzLmFyZWFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBJbiB2ZXJzaW9uIDUuNSBhbmQgbGF0ZXIsIGBkZWxldGVkX21hcmtzJyBoYWQgaXRzIHNpemUgaW5jcmVhc2VkIGJ5IDEgdG8gdGFrZVxuICAgICAgICAgIC0tIGludG8gYWNjb3VudCByZW1vdmFsIG9mIGRlZmF1bHQga2V5LCBhbmQgdGhlcmVmb3JlIGlmIHdlIGhpdCBhIDUuNCBvciBlYXJsaWVyXG4gICAgICAgICAgLS0gdmVyc2lvbiwgd2UgbmVlZCB0byByZXNpemUgYGRlbGV0ZWRfbWFya3MnIHRvIHRoZSBuZXcgZXhwZWN0ZWQgc2l6ZS5cbiAgICAgICAgaWYgZGVsZXRlZF9tYXJrcyAvPSBWb2lkIGFuZCBrZXlzIC89IFZvaWQgdGhlblxuICAgICAgICAgIGlmIG5vdCBtaXNtYXRjaF9pbmZvcm1hdGlvbi5oYXMgKFwiaGFzaF90YWJsZV92ZXJzaW9uXzU3XCIpIHRoZW5cbiAgICAgICAgICAgICAgLS0gVW5mb3J0dW5hdGVseSB0aGlzIGhhbmRsaW5nIG9mIHRoZSBtaXNtYXRjaCB3YXMgYWRkZWQgaW4gNS43IGFuZFxuICAgICAgICAgICAgICAtLSB0aGVyZWZvcmUgd2UgbWlnaHQgaGF2ZSBzdG9yZWQgYSB2YWxpZCBIQVNIX1RBQkxFIHVzaW5nIDUuNSBvciA1LjYuXG4gICAgICAgICAgICAgIC0tIEZvcnR1bmF0ZWx5IGVub3VnaCB3ZSBjYW4gc2ltcGx5IGNvbXBhcmUgdGhlIGNvdW50cyBvZlxuICAgICAgICAgICAgICAtLSBgZGVsZXRlZF9tYXJrcycgYW5kIGBrZXlzJy4gSWYgdGhleSBhcmUgdGhlIHNhbWUgaXQgaXMgNS41IG9yIDUuNixcbiAgICAgICAgICAgICAgLS0gb3RoZXJ3aXNlIGl0IGlzIDUuNCBvciBvbGRlci5cbiAgICAgICAgICAgIGlmIGRlbGV0ZWRfbWFya3MuY291bnQgLz0ga2V5cy5jb3VudCB0aGVuXG4gICAgICAgICAgICAgIGxfb2xkX2RlbGV0ZWRfbWFya3MgOj0gZGVsZXRlZF9tYXJrc1xuICAgICAgICAgICAgICBjcmVhdGUgZGVsZXRlZF9tYXJrcy5tYWtlX2VtcHR5IChrZXlzLmNvdW50KVxuICAgICAgICAgICAgICBkZWxldGVkX21hcmtzLmNvcHlfZGF0YSAobF9vbGRfZGVsZXRlZF9tYXJrcywgMCwgMCwgbF9vbGRfZGVsZXRlZF9tYXJrcy5jb3VudClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUn0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJjb3VudFwiKSBhcyBsX3JldHJpZXZlZF9jb3VudCB0aGVuXG4gICAgICAgICAgbF9jb3VudCA6PSBsX3JldHJpZXZlZF9jb3VudFxuICAgICAgICBlbmRcblxuICAgICAgICBpZiBjb250ZW50ID0gVm9pZCBvciBrZXlzID0gVm9pZCBvciBkZWxldGVkX21hcmtzID0gVm9pZCB0aGVuXG4gICAgICAgICAgICAtLSBDb3VsZCBub3QgcmV0cmlldmUgb2xkIHZlcnNpb24gb2YgSEFTSF9UQUJMRS4gV2UgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgIFByZWN1cnNvciB7TUlTTUFUQ0hfQ09SUkVDVE9SfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBOb3cgd2UgYnVpbGQgdGhlIG5ldyBIQVNIX1RBQkxFIGZyb20gdGhlIG9sZCBvbmUuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9jYXBhY2l0eSA6PSBrZXlzLmNvdW50XG4gICAgICAgICAgICBsX25ld190YWJsZSA6PSBlbXB0eV9kdXBsaWNhdGUgKGxfY291bnQpXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBsX2NhcGFjaXR5XG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaWYgYXR0YWNoZWQga2V5cy5pdGVtIChpKSBhcyBsX2tleV9pdGVtIGFuZCB0aGVuIGxfa2V5X2l0ZW0gLz0gbF9kZWZhdWx0X2tleSB0aGVuXG4gICAgICAgICAgICAgIGxfbmV3X3RhYmxlLnB1dCAoY29udGVudC5pdGVtIChpKSwgbF9rZXlfaXRlbSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGlmIGF0dGFjaGVkIHtCT09MRUFOfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcImhhc19kZWZhdWx0XCIpIGFzIGxfYm9vbCBhbmQgdGhlbiBsX2Jvb2wgdGhlblxuICAgICAgICAgICAgbF9uZXdfdGFibGUucHV0IChjb250ZW50Lml0ZW0gKGNvbnRlbnQuY2FwYWNpdHkgLSAxKSwga2V5cy5pdGVtIChsX2NhcGFjaXR5IC0gMSkpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICBzZXRfY29udGVudCAobF9uZXdfdGFibGUuY29udGVudClcbiAgICAgICAgICBzZXRfa2V5cyAobF9uZXdfdGFibGUua2V5cylcbiAgICAgICAgICBzZXRfZGVsZXRlZF9tYXJrcyAobF9uZXdfdGFibGUuZGVsZXRlZF9tYXJrcylcbiAgICAgICAgICBzZXRfaW5kZXhlc19tYXAgKGxfbmV3X3RhYmxlLmluZGV4ZXNfbWFwKVxuICAgICAgICAgIGNhcGFjaXR5IDo9IGxfbmV3X3RhYmxlLmNhcGFjaXR5XG4gICAgICAgICAgaXRlcmF0aW9uX3Bvc2l0aW9uIDo9IGxfbmV3X3RhYmxlLml0ZXJhdGlvbl9wb3NpdGlvblxuICAgICAgICAgIGRlbGV0ZWRfaXRlbV9wb3NpdGlvbiA6PSBsX25ld190YWJsZS5kZWxldGVkX2l0ZW1fcG9zaXRpb25cbiAgICAgICAgICBpdGVtX3Bvc2l0aW9uIDo9IGxfbmV3X3RhYmxlLml0ZW1fcG9zaXRpb25cbiAgICAgICAgICAgIC0tIFdlIHJlc2V0IHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyB0byB0aGVpciBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgaHRfbG93ZXN0X2RlbGV0ZWRfcG9zaXRpb24gOj0gaHRfbWF4X3Bvc2l0aW9uXG4gICAgICAgICAgaHRfZGVsZXRlZF9pdGVtIDo9IGxfZGVmYXVsdF9pdGVtXG4gICAgICAgICAgaHRfZGVsZXRlZF9rZXkgOj0gbF9kZWZhdWx0X2tleVxuICAgICAgICAgICAgLS0gV2UgZG9uJ3QgY2hhbmdlIGBvYmplY3RfY29tcGFyaXNvbicgZnJvbSB0aGUgdmFsdWUgaXQgd2FzIHJldHJpZXZlZCBmcm9tLlxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFJlc2V0IGBjb250cm9sJyB0byBhbiBhY2NlcHRhYmxlIHZhbHVlLlxuICAgICAgICBjb250cm9sIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGhhc2hfdGFibGVfdmVyc2lvbl82NDogQk9PTEVBTlxuICAgICAgLS0gRmFrZSBhdHRyaWJ1dGUgZm9yIHZlcnNpb25pbmcgcHVycG9zZXMuIFVzZWQgaW4gYGNvcnJlY3RfbWlzbWF0Y2gnLlxuXG5mZWF0dXJlIHtIQVNIX1RBQkxFLCBIQVNIX1RBQkxFX0lURVJBVElPTl9DVVJTT1J9IC0tIEltcGxlbWVudGF0aW9uOiBjb250ZW50IGF0dHJpYnV0ZXMgYW5kIHByZXNlcnZhdGlvblxuXG4gIGNvbnRlbnQ6IFNQRUNJQUwgW0ddXG4gICAgICAtLSBBcnJheSBvZiBjb250ZW50c1xuXG4gIGtleXM6IFNQRUNJQUwgW0tdXG4gICAgICAtLSBBcnJheSBvZiBrZXlzXG5cbmZlYXR1cmUge0hBU0hfVEFCTEV9IC0tIEltcGxlbWVudGF0aW9uOiBjb250ZW50IGF0dHJpYnV0ZXMgYW5kIHByZXNlcnZhdGlvblxuXG4gIGluZGV4ZXNfbWFwOiBTUEVDSUFMIFtJTlRFR0VSXVxuICAgICAgLS0gSW5kZXhlcyBvZiBpdGVtcyBpbiBgY29udGVudCcsIGFuZCBga2V5cycuXG4gICAgICAtLSBJZiBpdGVtIGlzIG5vdCBwcmVzZW50LCB0aGVuIGl0IGhhcyBgaHRfaW1wb3NzaWJsZV9wb3NpdGlvbicuXG4gICAgICAtLSBJZiBpdGVtIGlzIGRlbGV0ZWQsIHRoZW4gaXQgaGFzIGBodF9kZWxldGVkX3Bvc2l0aW9uJy5cblxuICBkZWxldGVkX21hcmtzOiBTUEVDSUFMIFtCT09MRUFOXVxuICAgICAgLS0gSW5kZXhlcyBvZiBkZWxldGVkIHBvc2l0aW9ucyBpbiBgY29udGVudCcgYW5kIGBrZXlzJy5cblxuICBpdGVtX3Bvc2l0aW9uOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBpbiBgaW5kZXhlc19tYXAnIGZvciBpdGVtIGF0IHBvc2l0aW9uIGBwb3NpdGlvbicuIFNldCBieSBgaW50ZXJuYWxfc2VhcmNoJy5cblxuICBoYXNfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlIGRlZmF1bHQga2V5IHByZXNlbnQ/XG5cbmZlYXR1cmUge0hBU0hfVEFCTEV9IC0tIEltcGxlbWVudGF0aW9uOiBzZWFyY2ggYXR0cmlidXRlc1xuXG4gIGl0ZXJhdGlvbl9wb3NpdGlvbjogSU5URUdFUlxuICAgICAgLS0gQ3Vyc29yIGZvciBpdGVyYXRpb24gcHJpbWl0aXZlc1xuXG4gIHBvc2l0aW9uOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIHRhYmxlIGN1cnNvciwgdXBkYXRlZCBhZnRlciBlYWNoIG9wZXJhdGlvbjpcbiAgICAgIC0tIHB1dCwgcmVtb3ZlLCBoYXMsIHJlcGxhY2UsIGZvcmNlLCBjaGFuZ2Vfa2V5Li4uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpbmRleGVzX21hcC5pdGVtIChpdGVtX3Bvc2l0aW9uKVxuICAgIGVuZFxuXG4gIHNvb25fZnVsbDogQk9PTEVBTlxuICAgICAgLS0gSXMgdGFibGUgY2xvc2UgdG8gYmVpbmcgZmlsbGVkIHRvIGN1cnJlbnQgY2FwYWNpdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBrZXlzLmNvdW50ID0ga2V5cy5jYXBhY2l0eVxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0ID0gKGtleXMuY291bnQgPSBrZXlzLmNhcGFjaXR5KVxuICAgIGVuZFxuXG4gIGNvbnRyb2w6IElOVEVHRVJcbiAgICAgIC0tIENvbnRyb2wgY29kZSBzZXQgYnkgb3BlcmF0aW9ucyB0aGF0IG1heSBwcm9kdWNlXG4gICAgICAtLSBzZXZlcmFsIHBvc3NpYmxlIGNvbmRpdGlvbnMuXG5cbiAgZGVsZXRlZF9pdGVtX3Bvc2l0aW9uOiBJTlRFR0VSXG4gICAgICAtLSBQbGFjZSB3aGVyZSBhIGRlbGV0ZWQgZWxlbWVudCB3YXMgZm91bmQgZHVyaW5nIGEgc2VhcmNoXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgaHRfbWF4X3Bvc2l0aW9uOiBJTlRFR0VSID0gMHg3RkZGRkZGRFxuICAgICAgLS0gTWF4aW11bSBwb3NzaWJsZSBwb3NpdGlvblxuXG4gIGh0X2ltcG9zc2libGVfcG9zaXRpb246IElOVEVHRVIgPSAtMVxuICAgICAgLS0gUG9zaXRpb24gb3V0c2lkZSB0aGUgYXJyYXkgaW5kaWNlcy5cblxuICBodF9kZWxldGVkX3Bvc2l0aW9uOiBJTlRFR0VSID0gLTJcbiAgICAgIC0tIE1hcmtlZCBhIGRlbGV0ZWQgcG9zaXRpb24uXG5cbiAgaHRfbG93ZXN0X2RlbGV0ZWRfcG9zaXRpb246IElOVEVHRVJcbiAgICAgIC0tIEluZGV4IG9mIHRoZSBsb3dlc3QgZGVsZXRlZCBwb3NpdGlvbiB0aHVzIGZhci5cblxuICBodF9kZWxldGVkX2l0ZW06IGRldGFjaGFibGUgR1xuICBodF9kZWxldGVkX2tleTogZGV0YWNoYWJsZSBLXG4gICAgICAtLSBTdG9yZSB0aGUgaXRlbSBhbmQga2V5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcGxhY2UgYW4gZWxlbWVudCBvZiB0aGUgSEFTSF9UQUJMRVxuICAgICAgLS0gdGhhdCB3aWxsIGJlIHJlbW92ZWQuIElmIGVsZW1lbnRzIGJlaW5nIHJlbW92ZWQgYXJlIGF0IHRoZSBlbmQgb2YgYGNvbnRlbnQnIG9yIGBrZXlzJ1xuICAgICAgLS0gdGhlbiB0aGV5IGFyZSBib3RoIFZvaWQuIEl0IGlzIG9ubHkgdXNlZCB3aGVuIHJlbW92aW5nIGFuIGVsZW1lbnQgYXQgYSBwb3NpdGlvbiBzdHJpY3RseVxuICAgICAgLS0gbGVzcyB0aGFuIGBjb3VudCcuXG5cbiAgZGVsZXRlZF9wb3NpdGlvbiAoYV9wb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBHaXZlbiB0aGUgcG9zaXRpb24gb2YgYSBkZWxldGVkIGl0ZW0gYXQgYGFfcG9zJyBnaXZlcyB0aGUgYXNzb2NpYXRlZCBwb3NpdGlvblxuICAgICAgLS0gaW4gYGNvbnRlbnQva2V5cycuXG4gICAgcmVxdWlyZVxuICAgICAgZGVsZXRlZDogZGVsZXRlZCAoYV9wb3MpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAtaW5kZXhlc19tYXAuaXRlbSAoYV9wb3MpICsgaHRfZGVsZXRlZF9wb3NpdGlvblxuICAgICAgICAtLSBTb21ldGltZSB3ZSBzaHJpbmsgYGtleXMnIGFuZCBgY29udGVudCcgd2hpbGUgcmVtb3ZpbmcgaXRlbXMsIGFzIGEgcmVzdWx0LCBzb21lXG4gICAgICAgIC0tIHN0b3JlZCBkZWxldGVkIHBvc2l0aW9uIGluIGBpbmRleGVzX21hcCcgYXJlIGJleW9uZCBga2V5cycgYW5kIGBjb250ZW50Jy4gSW4gdGhvc2VcbiAgICAgICAgLS0gY2FzZXMsIHdlIHNpbXBseSByZXR1cm4gdGhlIGxvY2F0aW9uIGZvciB0aGUgbmV4dCBpbnNlcnRpb24gaW5zdGVhZC5cbiAgICAgIFJlc3VsdCA6PSBSZXN1bHQubWluIChrZXlzLmNvdW50KVxuICAgIGVuc3VyZVxuICAgICAgZGVsZXRlZF9wb3NpdGlvbl9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBkZWxldGVkX3Bvc2l0aW9uX3ZhbGlkOiBSZXN1bHQgPD0ga2V5cy5jb3VudCBhbmQgUmVzdWx0IDw9IGNvbnRlbnQuY291bnRcbiAgICBlbmRcblxuICBvY2N1cGllZCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIHBvc2l0aW9uIGBpJyBvY2N1cGllZCBieSBhIG5vbi1kZWZhdWx0IGtleSBhbmQgYSB2YWx1ZT9cbiAgICByZXF1aXJlXG4gICAgICBpbl9ib3VuZHM6IGRlbGV0ZWRfbWFya3MudmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIGlmIGhhc19kZWZhdWx0IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGkgLz0gaW5kZXhlc19tYXAuaXRlbSAoY2FwYWNpdHkpIGFuZCB0aGVuIG5vdCBkZWxldGVkX21hcmtzLml0ZW0gKGkpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBub3QgZGVsZXRlZF9tYXJrcy5pdGVtIChpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHJ1bHlfb2NjdXBpZWQgKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBwb3NpdGlvbiBgaScgb2NjdXBpZWQgYnkgYSBrZXkgYW5kIGEgdmFsdWU/XG4gICAgZG9cbiAgICAgIGlmIGkgPj0gMCBhbmQgaSA8IGtleXMuY291bnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gKGhhc19kZWZhdWx0IGFuZCBpID0gaW5kZXhlc19tYXAuaXRlbSAoY2FwYWNpdHkpKSBvciBlbHNlIG9jY3VwaWVkIChpKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3JtYWxfa2V5OiAoaSA+PSAwIGFuZCBpIDwga2V5cy5jb3VudCBhbmQgaSAvPSBpbmRleGVzX21hcC5pdGVtIChjYXBhY2l0eSkpIGltcGxpZXMgKG9jY3VwaWVkIChpKSBpbXBsaWVzIFJlc3VsdClcbiAgICAgIGRlZmF1bHRfa2V5OiAoaSA9IGluZGV4ZXNfbWFwLml0ZW0gKGNhcGFjaXR5KSkgaW1wbGllcyAoUmVzdWx0ID0gaGFzX2RlZmF1bHQpXG4gICAgZW5kXG5cbiAgaXNfb2ZmX3Bvc2l0aW9uIChwb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgcG9zJyBhIGN1cnNvciBwb3NpdGlvbiBvdXRzaWRlIHRoZSBhdXRob3JpemVkIHJhbmdlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcG9zIDwgMCBvciBwb3MgPj0ga2V5cy5jb3VudFxuICAgIGVuZFxuXG4gIHNldF9jb250ZW50IChjOiBsaWtlIGNvbnRlbnQpXG4gICAgICAtLSBBc3NpZ24gYGMnIHRvIGBjb250ZW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBjX2F0dGFjaGVkOiBjIC89IFZvaWRcbiAgICBkb1xuICAgICAgY29udGVudCA6PSBjXG4gICAgZW5zdXJlXG4gICAgICBjb250ZW50X3NldDogY29udGVudCA9IGNcbiAgICBlbmRcblxuICBkZWxldGVkIChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgcG9zaXRpb24gYGknIHRoYXQgb2YgYSBkZWxldGVkIGl0ZW0/XG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiBpID49IDAgYW5kIGkgPD0gY2FwYWNpdHlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGluZGV4ZXNfbWFwLml0ZW0gKGkpIDw9IGh0X2RlbGV0ZWRfcG9zaXRpb25cbiAgICBlbmRcblxuICBzZXRfa2V5cyAoYzogbGlrZSBrZXlzKVxuICAgICAgLS0gQXNzaWduIGBjJyB0byBga2V5cycuXG4gICAgcmVxdWlyZVxuICAgICAgY19hdHRhY2hlZDogYyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGtleXMgOj0gY1xuICAgIGVuc3VyZVxuICAgICAga2V5c19zZXQ6IGtleXMgPSBjXG4gICAgZW5kXG5cbiAgc2V0X2RlbGV0ZWRfbWFya3MgKGQ6IGxpa2UgZGVsZXRlZF9tYXJrcylcbiAgICAgIC0tIEFzc2lnbiBgYycgdG8gYGNvbnRlbnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGRfYXR0YWNoZWQ6IGQgLz0gVm9pZFxuICAgIGRvXG4gICAgICBkZWxldGVkX21hcmtzIDo9IGRcbiAgICBlbnN1cmVcbiAgICAgIGRlbGV0ZWRfbWFya3Nfc2V0OiBkZWxldGVkX21hcmtzID0gZFxuICAgIGVuZFxuXG4gIHNldF9pbmRleGVzX21hcCAodjogbGlrZSBpbmRleGVzX21hcCApXG4gICAgICAtLSBBc3NpZ24gYHYnIHRvIGBpbmRleGVzX21hcCcuXG4gICAgZG9cbiAgICAgIGluZGV4ZXNfbWFwIDo9IHZcbiAgICBlbnN1cmVcbiAgICAgIGluZGV4ZXNfbWFwX3NldDogaW5kZXhlc19tYXAgPSB2XG4gICAgZW5kXG5cbiAgZGVmYXVsdF9rZXlfdmFsdWU6IEdcbiAgICAgIC0tIFZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmYXVsdCBrZXksIGlmIGFueVxuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0OiBoYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY29udGVudCBbaW5kZXhlc19tYXAgW2NhcGFjaXR5XV1cbiAgICBlbmRcblxuICBjb21wdXRlZF9kZWZhdWx0X2tleTogZGV0YWNoYWJsZSBLXG4gICAgICAtLSBEZWZhdWx0IGtleVxuICAgICAgLS0gKEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB1c2VkIG9ubHkgaW4gYXNzZXJ0aW9ucztcbiAgICAgIC0tIGVsc2V3aGVyZSwgc2VlIHVzZSBvZiBsb2NhbCBlbnRpdHkgYGxfZGVmYXVsdF9rZXknLilcbiAgICBkb1xuICAgICAgLS0gTm8gaW5zdHJ1Y3Rpb25zIG5lY2Vzc2FyeSAocmV0dXJucyBkZWZhdWx0IHZhbHVlIG9mIHR5cGUgSylcbiAgICBlbmRcblxuICBjb21wdXRlZF9kZWZhdWx0X3ZhbHVlOiBkZXRhY2hhYmxlIEdcbiAgICAgIC0tIERlZmF1bHQgdmFsdWUgb2YgdHlwZSBHXG4gICAgICAtLSAoRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHVzZWQgb25seSBpbiBhc3NlcnRpb25zO1xuICAgICAgLS0gZWxzZXdoZXJlLCBzZWUgdXNlIG9mIGxvY2FsIGVudGl0eSBgbF9kZWZhdWx0X3ZhbHVlJy4pXG4gICAgZG9cbiAgICAgIC0tIE5vIGluc3RydWN0aW9ucyBuZWNlc3NhcnkgKHJldHVybnMgZGVmYXVsdCB2YWx1ZSBvZiB0eXBlIEcpXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfc2VhcmNoIChrZXk6IEspXG4gICAgICAtLSBTZWFyY2ggZm9yIGl0ZW0gb2Yga2V5IGBrZXknLlxuICAgICAgLS0gSWYgc3VjY2Vzc2Z1bCwgc2V0IGBwb3NpdGlvbicgdG8gaW5kZXhcbiAgICAgIC0tIG9mIGl0ZW0gd2l0aCB0aGlzIGtleSAodGhlIHNhbWUgaW5kZXggYXMgdGhlIGtleSdzIGluZGV4KS5cbiAgICAgIC0tIElmIG5vdCwgc2V0IGBwb3NpdGlvbicgdG8gcG9zc2libGUgcG9zaXRpb24gZm9yIGluc2VydGlvbixcbiAgICAgIC0tIGFuZCBzZXQgc3RhdHVzIHRvIGBmb3VuZCcgb3IgYG5vdF9mb3VuZCcuXG4gICAgbG9jYWxcbiAgICAgIGxfZGVmYXVsdF9rZXk6IGRldGFjaGFibGUgS1xuICAgICAgaGFzaF92YWx1ZSwgaW5jcmVtZW50LCBsX3BvcywgbF9pdGVtX3BvcywgbF9jYXBhY2l0eTogSU5URUdFUlxuICAgICAgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uOiBJTlRFR0VSXG4gICAgICBzdG9wOiBJTlRFR0VSXG4gICAgICBsX2tleXM6IGxpa2Uga2V5c1xuICAgICAgbF9pbmRleGVzOiBsaWtlIGluZGV4ZXNfbWFwXG4gICAgICBsX2RlbGV0ZWRfbWFya3M6IGxpa2UgZGVsZXRlZF9tYXJrc1xuICAgICAgbF9rZXk6IEtcbiAgICBkb1xuICAgICAgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uIDo9IGh0X2ltcG9zc2libGVfcG9zaXRpb25cbiAgICAgIGlmIGtleSA9IGxfZGVmYXVsdF9rZXkgb3Iga2V5ID0gVm9pZCB0aGVuXG4gICAgICAgIGl0ZW1fcG9zaXRpb24gOj0gY2FwYWNpdHlcbiAgICAgICAgaWYgaGFzX2RlZmF1bHQgdGhlblxuICAgICAgICAgIGNvbnRyb2wgOj0gZm91bmRfY29uc3RhbnRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNvbnRyb2wgOj0gbm90X2ZvdW5kX2NvbnN0YW50XG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9rZXlzIDo9IGtleXNcbiAgICAgICAgICBsX2luZGV4ZXMgOj0gaW5kZXhlc19tYXBcbiAgICAgICAgICBsX2RlbGV0ZWRfbWFya3MgOj0gZGVsZXRlZF9tYXJrc1xuICAgICAgICAgIGxfY2FwYWNpdHkgOj0gY2FwYWNpdHlcbiAgICAgICAgICBzdG9wIDo9IGxfY2FwYWNpdHlcbiAgICAgICAgICBoYXNoX3ZhbHVlIDo9IGhhc2hfY29kZV9vZiAoa2V5KVxuICAgICAgICAgIGluY3JlbWVudCA6PSAxICsgaGFzaF92YWx1ZSBcXFxcIChsX2NhcGFjaXR5IC0gMSlcbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChoYXNoX3ZhbHVlIFxcXFwgbF9jYXBhY2l0eSkgLSBpbmNyZW1lbnRcbiAgICAgICAgICBjb250cm9sIDo9IG5vdF9mb3VuZF9jb25zdGFudFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIHN0b3AgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICAgIC0tIEdvIHRvIG5leHQgaW5jcmVtZW50LlxuICAgICAgICAgIGxfaXRlbV9wb3MgOj0gKGxfaXRlbV9wb3MgKyBpbmNyZW1lbnQpIFxcXFwgbF9jYXBhY2l0eVxuICAgICAgICAgIGxfcG9zIDo9IGxfaW5kZXhlcyBbbF9pdGVtX3Bvc11cbiAgICAgICAgICBpZiBsX3BvcyA+PSAwIHRoZW5cbiAgICAgICAgICAgIGxfa2V5IDo9IGxfa2V5cy5pdGVtIChsX3BvcylcbiAgICAgICAgICAgIGRlYnVnIChcImRldGVjdF9oYXNoX3RhYmxlX2NhdGNhbGxcIilcbiAgICAgICAgICAgICAgY2hlY2tcbiAgICAgICAgICAgICAgICBjYXRjYWxsX2RldGVjdGVkOiBsX2tleSAvPSBWb2lkIGFuZCB0aGVuIGxfa2V5LnNhbWVfdHlwZSAoa2V5KVxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaWYgc2FtZV9rZXlzIChsX2tleSwga2V5KSB0aGVuXG4gICAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgICAgICBjb250cm9sIDo9IGZvdW5kX2NvbnN0YW50XG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlaWYgbF9wb3MgPSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uIHRoZW5cbiAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgIGVsc2VpZiBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb24gPSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uIHRoZW5cbiAgICAgICAgICAgIGxfcG9zIDo9IC1sX3BvcyArIGh0X2RlbGV0ZWRfcG9zaXRpb25cbiAgICAgICAgICAgIGNoZWNrIGxfcG9zX3ZhbGlkOiBsX3BvcyA8IGxfZGVsZXRlZF9tYXJrcy5jb3VudCBlbmRcbiAgICAgICAgICAgIGlmIG5vdCBsX2RlbGV0ZWRfbWFya3MgW2xfcG9zXSB0aGVuXG4gICAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb24gOj0gbF9pdGVtX3Bvc1xuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgc3RvcCA6PSBzdG9wIC0gMVxuICAgICAgICBlbmRcbiAgICAgICAgaXRlbV9wb3NpdGlvbiA6PSBsX2l0ZW1fcG9zXG4gICAgICBlbmRcbiAgICAgIGRlbGV0ZWRfaXRlbV9wb3NpdGlvbiA6PSBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb25cbiAgICBlbnN1cmVcbiAgICAgIGZvdW5kX29yX25vdF9mb3VuZDogZm91bmQgb3Igbm90X2ZvdW5kXG4gICAgICBkZWxldGVkX2l0ZW1fYXRfZGVsZXRlZF9wb3NpdGlvbjpcbiAgICAgICAgKGRlbGV0ZWRfaXRlbV9wb3NpdGlvbiAvPSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uKSBpbXBsaWVzIChkZWxldGVkIChkZWxldGVkX2l0ZW1fcG9zaXRpb24pKVxuICAgICAgZGVmYXVsdF9pZmZfYXRfY2FwYWNpdHk6IChpdGVtX3Bvc2l0aW9uID0gY2FwYWNpdHkpID0gKGtleSA9IGNvbXB1dGVkX2RlZmF1bHRfa2V5KVxuICAgIGVuZFxuXG4gIHNlYXJjaF9mb3JfaW5zZXJ0aW9uIChrZXk6IEspXG4gICAgICAtLSBBc3N1bWluZyB0aGVyZSBpcyBubyBpdGVtIG9mIGtleSBga2V5JywgY29tcHV0ZVxuICAgICAgLS0gYHBvc2l0aW9uJyBhdCB3aGljaCB0byBpbnNlcnQgc3VjaCBhbiBpdGVtLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9wcmVzZW50OiBub3QgaGFzIChrZXkpXG4gICAgbG9jYWxcbiAgICAgIGxfZGVmYXVsdF9rZXk6IGRldGFjaGFibGUgS1xuICAgICAgaGFzaF92YWx1ZSwgaW5jcmVtZW50LCBsX3BvcywgbF9pdGVtX3BvcywgbF9jYXBhY2l0eTogSU5URUdFUlxuICAgICAgbF9maXJzdF9kZWxldGVkX3Bvc2l0aW9uOiBJTlRFR0VSXG4gICAgICBzdG9wOiBJTlRFR0VSXG4gICAgICBsX2luZGV4ZXM6IGxpa2UgaW5kZXhlc19tYXBcbiAgICAgIGxfZGVsZXRlZF9tYXJrczogbGlrZSBkZWxldGVkX21hcmtzXG4gICAgZG9cbiAgICAgIGxfZmlyc3RfZGVsZXRlZF9wb3NpdGlvbiA6PSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uXG4gICAgICBpZiBrZXkgPSBsX2RlZmF1bHRfa2V5IG9yIGtleSA9IFZvaWQgdGhlblxuICAgICAgICBjaGVja1xuICAgICAgICAgICAgLS0gQmVjYXVzZSBvZiB0aGUgcHJlY29uZGl0aW9uXG4gICAgICAgICAgbm90IGhhc19kZWZhdWx0XG4gICAgICAgIGVuZFxuICAgICAgICBpdGVtX3Bvc2l0aW9uIDo9IGNhcGFjaXR5XG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2luZGV4ZXMgOj0gaW5kZXhlc19tYXBcbiAgICAgICAgICBsX2RlbGV0ZWRfbWFya3MgOj0gZGVsZXRlZF9tYXJrc1xuICAgICAgICAgIGxfY2FwYWNpdHkgOj0gY2FwYWNpdHlcbiAgICAgICAgICBzdG9wIDo9IGxfY2FwYWNpdHlcbiAgICAgICAgICBoYXNoX3ZhbHVlIDo9IGhhc2hfY29kZV9vZiAoa2V5KVxuICAgICAgICAgIGluY3JlbWVudCA6PSAxICsgaGFzaF92YWx1ZSBcXFxcIChsX2NhcGFjaXR5IC0gMSlcbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChoYXNoX3ZhbHVlIFxcXFwgbF9jYXBhY2l0eSkgLSBpbmNyZW1lbnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBzdG9wID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgICAtLSBHbyB0byBuZXh0IGluY3JlbWVudC5cbiAgICAgICAgICBsX2l0ZW1fcG9zIDo9IChsX2l0ZW1fcG9zICsgaW5jcmVtZW50KSBcXFxcIGxfY2FwYWNpdHlcbiAgICAgICAgICBsX3BvcyA6PSBsX2luZGV4ZXMgW2xfaXRlbV9wb3NdXG4gICAgICAgICAgaWYgbF9wb3MgPj0gMCB0aGVuXG4gICAgICAgICAgICAgIC0tIEJlY2F1c2Ugb2YgcHJlY29uZGl0aW9uLCB3ZSBhcmUgc3VyZSB0aGVyZSBpcyBubyBrZXkgY29ycmVzcG9uZGluZyB0byBga2V5Jy5cbiAgICAgICAgICBlbHNlaWYgbF9wb3MgPSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uIHRoZW5cbiAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgIGVsc2VpZiBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb24gPSBodF9pbXBvc3NpYmxlX3Bvc2l0aW9uIHRoZW5cbiAgICAgICAgICAgIGxfcG9zIDo9IC1sX3BvcyArIGh0X2RlbGV0ZWRfcG9zaXRpb25cbiAgICAgICAgICAgIGNoZWNrIGxfcG9zX3ZhbGlkOiBsX3BvcyA8IGxfZGVsZXRlZF9tYXJrcy5jb3VudCBlbmRcbiAgICAgICAgICAgIGlmIG5vdCBsX2RlbGV0ZWRfbWFya3MgW2xfcG9zXSB0aGVuXG4gICAgICAgICAgICAgIHN0b3AgOj0gMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb24gOj0gbF9pdGVtX3Bvc1xuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgc3RvcCA6PSBzdG9wIC0gMVxuICAgICAgICBlbmRcbiAgICAgICAgaXRlbV9wb3NpdGlvbiA6PSBsX2l0ZW1fcG9zXG4gICAgICBlbmRcbiAgICAgIGRlbGV0ZWRfaXRlbV9wb3NpdGlvbiA6PSBsX2ZpcnN0X2RlbGV0ZWRfcG9zaXRpb25cbiAgICBlbnN1cmVcbiAgICAgIGRlbGV0ZWRfaXRlbV9hdF9kZWxldGVkX3Bvc2l0aW9uOlxuICAgICAgICAoZGVsZXRlZF9pdGVtX3Bvc2l0aW9uIC89IGh0X2ltcG9zc2libGVfcG9zaXRpb24pIGltcGxpZXMgKGRlbGV0ZWQgKGRlbGV0ZWRfaXRlbV9wb3NpdGlvbikpXG4gICAgICBkZWZhdWx0X2lmZl9hdF9jYXBhY2l0eTogKGl0ZW1fcG9zaXRpb24gPSBjYXBhY2l0eSkgPSAoa2V5ID0gY29tcHV0ZWRfZGVmYXVsdF9rZXkpXG4gICAgZW5kXG5cbiAga2V5X2F0IChuOiBJTlRFR0VSKTogZGV0YWNoYWJsZSBLXG4gICAgICAtLSBLZXkgYXQgcG9zaXRpb24gYG4nXG4gICAgZG9cbiAgICAgIGlmIGtleXMudmFsaWRfaW5kZXggKG4pIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGtleXMuaXRlbSAobilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGluaXRpYWxfcG9zaXRpb24gKGhhc2hfdmFsdWU6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbml0aWFsIHBvc2l0aW9uIGZvciBhbiBpdGVtIG9mIGhhc2ggY29kZSBgaGFzaF92YWx1ZSdcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChoYXNoX3ZhbHVlIFxcXFwgY2FwYWNpdHkpXG4gICAgZW5kXG5cbiAgcG9zaXRpb25faW5jcmVtZW50IChoYXNoX3ZhbHVlOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gRGlzdGFuY2UgYmV0d2VlbiBzdWNjZXNzaXZlIHBvc2l0aW9ucyBmb3IgaGFzaCBjb2RlXG4gICAgICAtLSBgaGFzaF92YWx1ZScgKGNvbXB1dGVkIGZvciBubyBjeWNsZTogYGNhcGFjaXR5JyBpcyBwcmltZSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IDEgKyBoYXNoX3ZhbHVlIFxcXFwgKGNhcGFjaXR5IC0gMSlcbiAgICBlbmRcblxuICBjb25mbGljdF9jb25zdGFudDogSU5URUdFUiA9IDFcbiAgICAgIC0tIENvdWxkIG5vdCBpbnNlcnQgYW4gYWxyZWFkeSBleGlzdGluZyBrZXlcblxuICBzZXRfY29uZmxpY3RcbiAgICAgIC0tIFNldCBzdGF0dXMgdG8gY29uZmxpY3QuXG4gICAgZG9cbiAgICAgIGNvbnRyb2wgOj0gY29uZmxpY3RfY29uc3RhbnRcbiAgICBlbnN1cmVcbiAgICAgIGNvbmZsaWN0OiBjb25mbGljdFxuICAgIGVuZFxuXG4gIGZvdW5kX2NvbnN0YW50OiBJTlRFR0VSID0gMlxuICAgICAgLS0gS2V5IGZvdW5kXG5cbiAgc2V0X2ZvdW5kXG4gICAgICAtLSBTZXQgc3RhdHVzIHRvIGZvdW5kLlxuICAgIGRvXG4gICAgICBjb250cm9sIDo9IGZvdW5kX2NvbnN0YW50XG4gICAgZW5zdXJlXG4gICAgICBmb3VuZDogZm91bmRcbiAgICBlbmRcblxuICBpbnNlcnRlZF9jb25zdGFudDogSU5URUdFUiA9IDRcbiAgICAgIC0tIEluc2VydGlvbiBzdWNjZXNzZnVsXG5cbiAgc2V0X2luc2VydGVkXG4gICAgICAtLSBTZXQgc3RhdHVzIHRvIGluc2VydGVkLlxuICAgIGRvXG4gICAgICBjb250cm9sIDo9IGluc2VydGVkX2NvbnN0YW50XG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaW5zZXJ0ZWRcbiAgICBlbmRcblxuICBub3RfZm91bmRfY29uc3RhbnQ6IElOVEVHRVIgPSA4XG4gICAgICAtLSBLZXkgbm90IGZvdW5kXG5cbiAgc2V0X25vdF9mb3VuZFxuICAgICAgLS0gU2V0IHN0YXR1cyB0byBub3QgZm91bmQuXG4gICAgZG9cbiAgICAgIGNvbnRyb2wgOj0gbm90X2ZvdW5kX2NvbnN0YW50XG4gICAgZW5zdXJlXG4gICAgICBub3RfZm91bmQ6IG5vdF9mb3VuZFxuICAgIGVuZFxuXG4gIHNldF9ub19zdGF0dXNcbiAgICAgIC0tIFNldCBzdGF0dXMgdG8gbm9ybWFsLlxuICAgIGRvXG4gICAgICBjb250cm9sIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGRlZmF1bHRfc3RhdHVzOiBub3Qgc3BlY2lhbF9zdGF0dXNcbiAgICBlbmRcblxuICByZW1vdmVkX2NvbnN0YW50OiBJTlRFR0VSID0gMTZcbiAgICAgIC0tIFJlbW92ZSBzdWNjZXNzZnVsXG5cbiAgc2V0X3JlbW92ZWRcbiAgICAgIC0tIFNldCBzdGF0dXMgdG8gcmVtb3ZlZC5cbiAgICBkb1xuICAgICAgY29udHJvbCA6PSByZW1vdmVkX2NvbnN0YW50XG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgZW5kXG5cbiAgcmVwbGFjZWRfY29uc3RhbnQ6IElOVEVHRVIgPSAzMlxuICAgICAgLS0gUmVwbGFjZWQgdmFsdWVcblxuICBzZXRfcmVwbGFjZWRcbiAgICAgIC0tIFNldCBzdGF0dXMgdG8gcmVwbGFjZWQuXG4gICAgZG9cbiAgICAgIGNvbnRyb2wgOj0gcmVwbGFjZWRfY29uc3RhbnRcbiAgICBlbnN1cmVcbiAgICAgIHJlcGxhY2VkOiByZXBsYWNlZFxuICAgIGVuZFxuXG4gIHNwZWNpYWxfc3RhdHVzOiBCT09MRUFOXG4gICAgICAtLSBIYXMgc3RhdHVzIGJlZW4gc2V0IHRvIHNvbWUgbm9uLWRlZmF1bHQgdmFsdWU/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY29udHJvbCA+IDApXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHQgPSAoY29udHJvbCA+IDApXG4gICAgZW5kXG5cbiAgYWRkX3NwYWNlXG4gICAgICAtLSBJbmNyZWFzZSBjYXBhY2l0eS5cbiAgICBkb1xuICAgICAgICAtLSBCZSBwZXNzaW1pc3RpYzogcGxhbiBmb3IgbW9yZSBncm93dGggYnkgYWxsb2NhdGluZyAxLjUgbW9yZSB0aGFuIGJlZm9yZVxuICAgICAgYWNjb21tb2RhdGUgKGNvdW50ICsgY291bnQgLy8gMilcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X25vdF9jaGFuZ2VkOiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgYnJlYXRoaW5nX3NwYWNlOiBjb3VudCA8IGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgbWluaW11bV9jYXBhY2l0eTogSU5URUdFUiA9IDJcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5hcHBsaWNhYmxlXG5cbiAgY29sbGVjdGlvbl9leHRlbmQgKHY6IGRldGFjaGFibGUgRylcbiAgICAgIC0tIEluc2VydCBhIG5ldyBvY2N1cnJlbmNlIG9mIGB2Jy5cbiAgICBkb1xuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBrZXlzX25vdF92b2lkOiBrZXlzIC89IFZvaWRcbiAgY29udGVudF9ub3Rfdm9pZDogY29udGVudCAvPSBWb2lkXG4gIGtleXNfZW5vdWdoX2NhcGFjaXR5OiBrZXlzLmNvdW50IDw9IGNhcGFjaXR5ICsgMVxuICBjb250ZW50X2Vub3VnaF9jYXBhY2l0eTogY29udGVudC5jb3VudCA8PSBjYXBhY2l0eSArIDFcbiAgdmFsaWRfaXRlcmF0aW9uX3Bvc2l0aW9uOiBvZmYgb3IgdHJ1bHlfb2NjdXBpZWQgKGl0ZXJhdGlvbl9wb3NpdGlvbilcbiAgY29udHJvbF9ub25fbmVnYXRpdmU6IGNvbnRyb2wgPj0gMFxuICBzcGVjaWFsX3N0YXR1czogc3BlY2lhbF9zdGF0dXMgPVxuICAgIChjb25mbGljdCBvciBpbnNlcnRlZCBvciByZXBsYWNlZCBvciByZW1vdmVkIG9yIGZvdW5kIG9yIG5vdF9mb3VuZClcblxuICBjb3VudF9iaWdfZW5vdWdoOiAwIDw9IGNvdW50XG4gIGNvdW50X3NtYWxsX2Vub3VnaDogY291bnQgPD0gY2FwYWNpdHlcbiAgc2xvdF9jb3VudF9iaWdfZW5vdWdoOiAwIDw9IGNvdW50XG5cbm5vdGVcbiAgaW5zdHJ1Y3Rpb246IFwiW1xuICAgIFNldmVyYWwgcHJvY2VkdXJlcyBhcmUgcHJvdmlkZWQgZm9yIGluc2VydGluZyBhbiBpdGVtXG4gICAgd2l0aCBhIGdpdmVuIGtleS5cblxuICAgIEhlcmUgaXMgaG93IHRvIGNob29zZSBiZXR3ZWVuIHRoZW06XG5cbiAgICAgIC0gVXNlIGBwdXQnIGlmIHlvdSB3YW50IHRvIGRvIGFuIGluc2VydGlvbiBvbmx5IGlmXG4gICAgICAgIHRoZXJlIHdhcyBubyBpdGVtIHdpdGggdGhlIGdpdmVuIGtleSwgZG9pbmcgbm90aGluZ1xuICAgICAgICBvdGhlcndpc2UuIChZb3UgY2FuIGZpbmQgb3V0IG9uIHJldHVybiBpZiB0aGVyZSB3YXMgb25lLFxuICAgICAgICBhbmQgd2hhdCBpdCB3YXMuKVxuXG4gICAgICAtIFVzZSBgZm9yY2UnIGlmIHlvdSBhbHdheXMgd2FudCB0byBpbnNlcnQgdGhlIGl0ZW07XG4gICAgICAgIGlmIHRoZXJlIHdhcyBvbmUgZm9yIHRoZSBnaXZlbiBrZXkgaXQgd2lsbCBiZSByZW1vdmVkLFxuICAgICAgICAoYW5kIHlvdSBjYW4gZmluZCBvdXQgb24gcmV0dXJuIHdoYXQgaXQgd2FzKS5cblxuICAgICAgLSBVc2UgYGV4dGVuZCcgaWYgeW91IGFyZSBzdXJlIHRoZXJlIGlzIG5vIGl0ZW0gd2l0aFxuICAgICAgICB0aGUgZ2l2ZW4ga2V5LCBlbmFibGluZyBmYXN0ZXIgaW5zZXJ0aW9uIChidXRcbiAgICAgICAgdW5wcmVkaWN0YWJsZSBiZWhhdmlvciBpZiB0aGlzIGFzc3VtcHRpb24gaXMgbm90IHRydWUpLlxuXG4gICAgICAtIFVzZSBgcmVwbGFjZScgaWYgeW91IHdhbnQgdG8gcmVwbGFjZSBhbiBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgaXRlbSB3aXRoIHRoZSBnaXZlbiBrZXksIGFuZCBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vbmUuXG5cbiAgICBJbiBhZGRpdGlvbiB5b3UgY2FuIHVzZSBgcmVwbGFjZV9rZXknIHRvIGNoYW5nZSB0aGUga2V5IG9mIGFuXG4gICAgYWxyZWFkeSBwcmVzZW50IGl0ZW0sIGlkZW50aWZpZWQgYnkgaXRzIHByZXZpb3VzIGtleSwgb3JcbiAgICBkbyBub3RoaW5nIGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9yIHRoYXQgcHJldmlvdXMga2V5LlxuICAgIFlvdSBjYW4gZmluZCBvdXQgb24gcmV0dXJuLlxuXG4gICAgVG8gZmluZCBvdXQgd2hldGhlciBhIGtleSBhcHBlYXJzIGluIHRoZSB0YWJsZSwgdXNlIGBoYXMnLlxuICAgIFRvIGZpbmQgb3V0IHRoZSBpdGVtLCBpZiBhbnksIGFzc29jaWF0ZWQgd2l0aCBhIGNlcnRhaW4ga2V5LFxuICAgIHVzZSBgaXRlbScuXG5cbiAgICBCb3RoIG9mIHRoZXNlIHJvdXRpbmVzIHBlcmZvcm0gYSBzZWFyY2guIElmIHlvdSBuZWVkXG4gICAgYm90aCBwaWVjZXMgb2YgaW5mb3JtYXRpb24gKGRvZXMgYSBrZXkgYXBwZWFyPyBBbmQsIGlmIHNvLFxuICAgIHdoYXQgaXMgdGhlIGFzc29jaWF0ZWQgaXRlbT8pLCB5b3UgY2FuIGF2b2lkIHBlcmZvcm1pbmdcbiAgICB0d28gcmVkdW5kYW50IHRyYXZlcnNhbHMgYnkgdXNpbmcgaW5zdGVhZCB0aGUgY29tYmluYXRpb25cbiAgICBvZiBgc2VhcmNoJywgYGZvdW5kJyBhbmQgYGZvdW5kX2l0ZW0nIGFzIGZvbGxvd3M6XG5cbiAgICAgIHlvdXJfdGFibGUuc2VhcmNoICh5b3VyX2tleSlcbiAgICAgIGlmIHlvdXJfdGFibGUuZm91bmQgdGhlblxuICAgICAgICB3aGF0X3lvdV93aGVyZV9sb29raW5nX2ZvciA6PSB5b3VyX3RhYmxlLmZvdW5kX2l0ZW1cbiAgICAgICAgLi4uIERvIHdoYXRldmVyIGlzIG5lZWRlZCB0byBgd2hhdF95b3Vfd2VyZV9sb29raW5nX2ZvcicgLi4uXG4gICAgICBlbHNlXG4gICAgICAgIC4uLiBObyBpdGVtIHdhcyBwcmVzZW50IGZvciBgeW91cl9rZXknIC4uLlxuICAgICAgZW5kXG4gICAgXVwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDQtMTAgMDg6Mjg6MzggLTA3MDAgKFRodSwgMTAgQXByIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0ODA5ICRcIlxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIEhBU0hBQkxFXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgZ29vZF9oYXNoX3ZhbHVlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGJ5IGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIFNlcXVlbmNlcyBvZiBpbW11dGFibGUgOC1iaXQgY2hhcmFjdGVycywgYWNjZXNzaWJsZSB0aHJvdWdoIGludGVnZXIgaW5kaWNlc1xuICAgIGluIGEgY29udGlndW91cyByYW5nZS5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTAzIDE0OjI2OjIwIC0wODAwIChGcmksIDAzIEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5Mzg4OCAkXCJcblxuZnJvemVuIGNsYXNzXG4gIElNTVVUQUJMRV9TVFJJTkdfOFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR184XG4gICAgdW5kZWZpbmVcbiAgICAgIGlzX2ltbXV0YWJsZVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBhcmVhX2xvd2VyXG4gICAgZW5kXG5cbiAgSU1NVVRBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVuYW1lXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsLFxuICAgICAgaXRlbSBhcyBjaGFyYWN0ZXJfMzJfaXRlbSxcbiAgICAgIGhhcyBhcyBjaGFyYWN0ZXJfMzJfaGFzLFxuICAgICAgaW5kZXhfb2YgYXMgY2hhcmFjdGVyXzMyX2luZGV4X29mLFxuICAgICAgbGFzdF9pbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfbGFzdF9pbmRleF9vZixcbiAgICAgIG9jY3VycmVuY2VzIGFzIGNoYXJhY3Rlcl8zMl9vY2N1cnJlbmNlc1xuICAgIHVuZGVmaW5lXG4gICAgICBpc19lcXVhbCwgb3V0LCBjb3B5XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBtYWtlLFxuICBtYWtlX2VtcHR5LFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX3N0cmluZyxcbiAgbWFrZV9mcm9tX2MsXG4gIG1ha2VfZnJvbV9jaWxcblxuY3JlYXRlIHtJTU1VVEFCTEVfU1RSSU5HXzh9XG4gIG1ha2VfZnJvbV9hcmVhX2FuZF9ib3VuZHNcblxuY29udmVydFxuICBtYWtlX2Zyb21fc3RyaW5nICh7UkVBREFCTEVfU1RSSU5HXzgsIFNUUklOR184fSksXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9LFxuICBhc19zdHJpbmdfODoge1NUUklOR184fVxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9hcmVhX2FuZF9ib3VuZHMgKGE6IGxpa2UgYXJlYTsgbG93LCBuOiBsaWtlIGNvdW50KVxuICAgICAgLS0gSW5pdGlhbGl6ZSBjdXJyZW50IHdpdGggYXJlYSBgYScgd2l0aCBsb3dlciBib3VuZHMgYGxvdycgYW5kIGNvdW50IGBuJy5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIGFfdmFsaWRfY291bnQ6IChhLmNvdW50IC0gbG93KSA+PSBjb3VudCArIDFcbiAgICAgIGxvd19ub25fbmVnYXRpdmU6IGxvdyA+PSAwXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gYVxuICAgICAgYXJlYV9sb3dlciA6PSBsb3dcbiAgICAgIGNvdW50IDo9IG5cbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfc2V0OiBhcmVhID0gYVxuICAgICAgYXJlYV9sb3dlcl9zZXQ6IGFyZWFfbG93ZXIgPSBsb3dcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gYV9zeXN0ZW1fc3RyaW5nLmxlbmd0aCArIGRvdG5ldF9jb252ZXJ0b3IuZXNjYXBlX2NvdW50IChhX3N5c3RlbV9zdHJpbmcpXG4gICAgICBlbmRcbiAgICAgIG1ha2UgKGxfY291bnQpXG4gICAgICBpZiBsX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGRvdG5ldF9jb252ZXJ0b3IucmVhZF9zeXN0ZW1fc3RyaW5nX2ludG9fYXJlYV84IChhX3N5c3RlbV9zdHJpbmcsIGFyZWEpXG4gICAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtJTU1VVEFCTEVfU1RSSU5HXzh9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICAgIC0tIEJlY2F1c2UgaXQgaXMgaW1tdXRhYmxlIHdlIGNhbiBzaW1wbHkgc2hhcmUgdGhlIGBhcmVhJyBmcm9tIGBvdGhlcicuXG4gICAgICAgIHN0YW5kYXJkX2NvcHkgKG90aGVyKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5ld19yZXN1bHRfY291bnQ6IGNvdW50ID0gb3RoZXIuY291bnRcbiAgICAgIC0tIHNhbWVfY2hhcmFjdGVyczogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgPSBgb3RoZXInLmBpdGVtJyAoYGknKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpICsgYXJlYV9sb3dlciAtIDEpXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzMyX2l0ZW0gKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgKyBhcmVhX2xvd2VyIC0gMSkudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpICsgYXJlYV9sb3dlciAtIDEpLm5hdHVyYWxfMzJfY29kZVxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgICAgLS0gVXNlIGBjb2RlJyBpbnN0ZWFkIGZvciBjb25zaXN0ZW5jeSB3aXRoIFVuaWNvZGUgaGFuZGxpbmcuXG4gICAgICAtLXwgTm90IG9ic29sZXRlIGJlY2F1c2Ugb2xkIGNvZGUgdXNpbmcganVzdCBBU0NJSSBpcyBzYWZlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpICsgYXJlYV9sb3dlciAtIDEpLmNvZGVcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBhLCBhXzg6IGxpa2UgYXJlYVxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfczMyX2FyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICBkb1xuICAgICAgY3JlYXRlIGEubWFrZV9lbXB0eSAoY291bnQgKyBzLmNvdW50ICsgMSlcbiAgICAgIGEuY29weV9kYXRhIChhcmVhLCBhcmVhX2xvd2VyLCAwLCBjb3VudClcbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfOH0gcyBhcyBsX3M4IHRoZW5cbiAgICAgICAgYS5jb3B5X2RhdGEgKGxfczguYXJlYSwgbF9zOC5hcmVhX2xvd2VyLCBjb3VudCwgbF9zOC5jb3VudCArIDEpXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBsX3MzMiB0aGVuXG4gICAgICAgIGNyZWF0ZSBhXzgubWFrZV9lbXB0eSAobF9zMzIuY291bnQgKyAxKVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAwXG4gICAgICAgICAgaiA6PSBsX3MzMi5hcmVhX2xvd2VyXG4gICAgICAgICAgbF9zMzJfYXJlYSA6PSBsX3MzMi5hcmVhXG4gICAgICAgICAgbmIgOj0gbF9zMzIuY291bnQgLSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhXzguZXh0ZW5kIChsX3MzMl9hcmVhIFtqXS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgYV84LmV4dGVuZCAoJyUvMDAwLycpXG4gICAgICAgIGEuY29weV9kYXRhIChhXzgsIDAsIGNvdW50LCBuYiArIDIpXG4gICAgICBlbmRcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX2FyZWFfYW5kX2JvdW5kcyAoYSwgMCwgY291bnQgKyBzLmNvdW50KVxuICAgIGVuZFxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBjcmVhdGUgYS5tYWtlX2VtcHR5IChjb3VudCArIDEpXG4gICAgICBhLmNvcHlfZGF0YSAoYXJlYSwgYXJlYV9sb3dlciwgMCwgY291bnQgKyAxKVxuICAgICAgbWlycm9yX2FyZWEgKGEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX2FyZWFfYW5kX2JvdW5kcyAoYSwgMCwgY291bnQpXG4gICAgZW5kXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhLm1ha2VfZW1wdHkgKGNvdW50ICsgMSlcbiAgICAgIGEuY29weV9kYXRhIChhcmVhLCBhcmVhX2xvd2VyLCAwLCBjb3VudCArIDEpXG4gICAgICB0b19sb3dlcl9hcmVhIChhLCAwLCBjb3VudCAtIDEpXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9hcmVhX2FuZF9ib3VuZHMgKGEsIDAsIGNvdW50KVxuICAgIGVuZFxuXG4gIGFzX3VwcGVyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBjcmVhdGUgYS5tYWtlX2VtcHR5IChjb3VudCArIDEpXG4gICAgICBhLmNvcHlfZGF0YSAoYXJlYSwgYXJlYV9sb3dlciwgMCwgY291bnQgKyAxKVxuICAgICAgdG9fdXBwZXJfYXJlYSAoYSwgMCwgY291bnQgLSAxKVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fYXJlYV9hbmRfYm91bmRzIChhLCAwLCBjb3VudClcbiAgICBlbmRcblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVJfMzIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgKDEgPD0gc3RhcnRfaW5kZXgpIGFuZCAoc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4KSBhbmQgKGVuZF9pbmRleCA8PSBjb3VudCkgdGhlblxuICAgICAgICBuYiA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgICAgY3JlYXRlIGEubWFrZV9lbXB0eSAobmIgKyAxKVxuICAgICAgICBhLmNvcHlfZGF0YSAoYXJlYSwgYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgMCwgbmIpXG4gICAgICAgIGEuZXh0ZW5kICgnJS8wMDAvJylcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fYXJlYV9hbmRfYm91bmRzIChhLCAwLCBuYilcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGVtcHR5X3N0cmluZ1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2hhcmVkX3N1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUl8zMik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgaWYgKDEgPD0gc3RhcnRfaW5kZXgpIGFuZCAoc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4KSBhbmQgKGVuZF9pbmRleCA8PSBjb3VudCkgdGhlblxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9hcmVhX2FuZF9ib3VuZHMgKGFyZWEsIGFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGVtcHR5X3N0cmluZ1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfZW1wdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBlbXB0eT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNvdW50ID0gMFxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0NIQVJBQ1RFUl84XVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgbmV3X3N0cmluZyAobjogSU5URUdFUl8zMik6IElNTVVUQUJMRV9TVFJJTkdfOFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG4gIGVtcHR5X3N0cmluZzogSU1NVVRBQkxFX1NUUklOR184XG4gICAgICAtLSBTaGFyZWQgZW1wdHkgaW1tdXRhYmxlIHN0cmluZ1xuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMClcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5X3N0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGVtcHR5X3N0cmluZ19lbXB0eTogUmVzdWx0LmlzX2VtcHR5XG4gICAgZW5kXG5cbmZlYXR1cmUge1JFQURBQkxFX1NUUklOR184LCBSRUFEQUJMRV9TVFJJTkdfMzJ9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYXJlYV9sb3dlcjogSU5URUdFUjtcbiAgICAgIC0tIEluZGV4IHdoZXJlIGN1cnJlbnQgc3RyaW5nIHN0YXJ0cyBpbiBgYXJlYSdcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkNvbW1vbiBhbmNlc3RvcnMgdG8gYWxsIGltbXV0YWJsZSBTVFJJTkcgY2xhc3Nlcy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBJTU1VVEFCTEVfU1RSSU5HX0dFTkVSQUxcblxuaW5oZXJpdFxuICBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgIHJlZGVmaW5lXG4gICAgICBpc19pbW11dGFibGVcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaW1tdXRhYmxlOiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuaW52YXJpYW50XG4gIGltbXV0YWJsZTogaXNfaW1tdXRhYmxlXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJUYWJsZXMgd2hvc2Uga2V5cyBhcmUgaW50ZWdlcnMgaW4gYSBjb250aWd1b3VzIGludGVydmFsXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogaW5kZXhhYmxlLCBhY2Nlc3M7XG4gIGFjY2VzczogaW5kZXgsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgSU5ERVhBQkxFIFtHLCBIIC0+IElOVEVHRVJdIGluaGVyaXRcblxuICBUQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIHZhbGlkX2tleSBhcyB2YWxpZF9pbmRleCxcbiAgICAgIGZvcmNlIGFzIHB1dFxuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbR11cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuXG5lbmRcblxuXG5cbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiSW50ZWdlciB2YWx1ZXNcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5JbnQzMlwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIElOVEVHRVJfMzIgaW5oZXJpdFxuXG4gIElOVEVHRVJfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsLFxuICAgICAgdG9fZG91YmxlLFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7SU5URUdFUl8zMl9SRUZ9KSxcbiAgdG9fcmVhbDoge1JFQUxfMzJ9LFxuICB0b19kb3VibGU6IHtSRUFMXzY0fSxcbiAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzMyXG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJJbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiAxNiBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uSW50MTZcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBJTlRFR0VSXzE2IGluaGVyaXRcblxuICBJTlRFR0VSXzE2X1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBvcHBvc2l0ZSxcbiAgICAgIGlkZW50aXR5LFxuICAgICAgYXNfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbCxcbiAgICAgIHRvX2RvdWJsZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0lOVEVHRVJfMTZfUkVGfSksXG4gIHRvX3JlYWw6IHtSRUFMXzMyfSxcbiAgdG9fZG91YmxlOiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfMzI6IHtJTlRFR0VSXzMyfSxcbiAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzE2KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfMTYpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzE2KTogSU5URUdFUl8xNlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl8xNik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfMTZcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfMTZcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfMTYpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzE2KTogSU5URUdFUl8xNlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzE2XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDE2IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBJTlRFR0VSXzE2X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IElOVEVHRVJfMTZcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9faW50ZWdlci5oYXNoX2NvZGVcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXzE2XG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgdG9fY2hhcmFjdGVyXzggaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IElOVEVHRVJfMTYgPSAtMzI3NjhcbiAgTWF4X3ZhbHVlOiBJTlRFR0VSXzE2ID0gMzI3NjdcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogSU5URUdFUl8xNilcbiAgICAgIC0tIE1ha2UgYGknIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBkaXZpZGVkIGJ5IGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtIC89IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsdWU6IFJlc3VsdCA9IChvdGhlci5pdGVtIC89IDApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF8zMl9SRUZ9IG90aGVyIGFzIHJlYWxfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhbF92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IG90aGVyIGFzIGRvdWJsZV92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkb3VibGVfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDApIG9yXG4gICAgICAgIChvdGhlci5jb25mb3Jtc190byAoMC4wKSBhbmQgaXRlbSA+IDApKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgaWYgaXQgaXMgbm90IGl0cyB0eXBlJ3MgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtID49IDBcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0gMCBhbmRcbiAgICAgICAgaXRlbS50b19uYXR1cmFsXzMyID49IHtDSEFSQUNURVJfMzJ9Lk1pbl92YWx1ZSBhbmRcbiAgICAgICAgaXRlbS50b19uYXR1cmFsXzMyIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgYWJzOiBJTlRFR0VSXzE2XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0ID0gaXRlbSkgb3IgKFJlc3VsdCA9IC1pdGVtKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKC0gaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBJTlRFR0VSXzE2X1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IElOVEVHRVJfMTZfUkVGXG4gICAgICAtLSBBc3NvY2lhdGVkIHJlZmVyZW5jZSBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gVHJ1ZSBpZiBub3QgYHplcm8nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzhcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfMTZcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfOH0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfOH0uTWluX3ZhbHVlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBSZXR1cm4gYGl0ZW0nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZTogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fZG91YmxlXG4gICAgZW5kXG5cbiAgdG9faGV4X3N0cmluZzogU1RSSU5HXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICBsb2NhbFxuICAgICAgaSwgdmFsOiBJTlRFR0VSXG4gICAgICBhX2RpZ2l0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAoY3JlYXRlIHtQTEFURk9STX0pLkludGVnZXJfMTZfYml0cyAvLyA0XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaSlcbiAgICAgICAgUmVzdWx0LmZpbGxfYmxhbmtcbiAgICAgICAgdmFsIDo9IGl0ZW1cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAwXG4gICAgICBsb29wXG4gICAgICAgIGFfZGlnaXQgOj0gKHZhbCAmIDB4RilcbiAgICAgICAgUmVzdWx0LnB1dCAoYV9kaWdpdC50b19oZXhfY2hhcmFjdGVyLCBpKVxuICAgICAgICB2YWwgOj0gdmFsIHw+PiA0XG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgUmVzdWx0X3ZhbGlkX2NvdW50OiBSZXN1bHQuY291bnQgPSAoY3JlYXRlIHtQTEFURk9STX0pLkludGVnZXJfMTZfYml0cyAvLyA0XG4gICAgZW5kXG5cbiAgdG9faGV4X2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBpbl9ib3VuZHM6IDAgPD0gaXRlbSBhbmQgaXRlbSA8PSAxNVxuICAgIGxvY2FsXG4gICAgICB0bXA6IElOVEVHRVJcbiAgICBkb1xuICAgICAgdG1wIDo9IGl0ZW1cbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQgaWYgYG4nIHBvc2l0aXZlLFxuICAgICAgLS0gdG8gbGVmdCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzE2OiBuIDw9IDE2XG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfMTY6IG4gPj0gLTE2XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzE2OiBuIDw9IDE2XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfbGVmdCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfbGVmdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18xNjogbiA8PSAxNlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMTY6IG4gPCAxNlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9faW50ZWdlcl8xNiB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMTY6IG4gPCAxNlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX2ludGVnZXJfMTYgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19pbnRlZ2VyXzE2IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IElOVEVHRVJfMTYpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBhbGwgMSBiaXRzIG9mIG0gc2V0IHRvIDFcbiAgICAgIC0tIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8IG1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiBtLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgaW50ZWdlciB2YWx1ZVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDYpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXJfMTYgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYWJzX3JlZjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtID49IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIHNpZ25fdGltZXNfYWJzOiBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiAzMiBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgSU5URUdFUl8zMl9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIlxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgICAgLS0gQ2xlYXIgc2lnbiBiaXQuXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmIDB4N0ZGRkZGRkZcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgdG9fY2hhcmFjdGVyXzggaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IElOVEVHRVJfMzIgPSAtMjE0NzQ4MzY0OFxuICBNYXhfdmFsdWU6IElOVEVHRVJfMzIgPSAyMTQ3NDgzNjQ3XG4gICAgICAtLSBNaW5pbXVtIGFuZCBNYXhpbXVtIHZhbHVlIGhvbGQgaW4gYGl0ZW0nLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGk6IElOVEVHRVJfMzIpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSAwXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IDAgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGFiczogSU5URUdFUl8zMlxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFic19yZWYuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCA9IGl0ZW0pIG9yIChSZXN1bHQgPSAtaXRlbSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgtIGl0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSBcXFxcIG90aGVyLml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpbnRlcnZhbCBhbGlhcyBcInwuLnxcIiAob3RoZXI6IElOVEVHRVIpOiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBJbnRlcnZhbCBmcm9tIGN1cnJlbnQgZWxlbWVudCB0byBgb3RoZXInXG4gICAgICAtLSAoZW1wdHkgaWYgYG90aGVyJyBsZXNzIHRoYW4gY3VycmVudCBpbnRlZ2VyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGl0ZW0sIG90aGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IElOVEVHRVJfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogSU5URUdFUl8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19zbWFsbDogaXRlbSA+PSB7SU5URUdFUl84fS5NaW5fdmFsdWVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX3NtYWxsOiBpdGVtID49IHtJTlRFR0VSXzE2fS5NaW5fdmFsdWVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzE2fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlciwgZnJvemVuIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJldHVybiBgaXRlbScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19kb3VibGVcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8zMl9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHhGKVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8zMl9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbVxuICAgICAgaWYgdG1wIDw9IDkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gKHRtcCArICgnMCcpLmNvZGUpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAoKCdBJykuY29kZSArICh0bXAgLSAxMCkpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X2FuZCAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfYW5kX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9vciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2Vfb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfeG9yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV94b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X25vdDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfbm90KVxuICAgIGVuc3VyZVxuICAgICAgYml0X25vdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3NoaWZ0IChuOiBJTlRFR0VSXzMyKTogSU5URUdFUlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodCBpZiBgbicgcG9zaXRpdmUsXG4gICAgICAtLSB0byBsZWZ0IG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICAgIG5fZ3JlYXRlcl9vcl9lcXVhbF90b19taW51c18zMjogbiA+PSAtMzJcbiAgICBkb1xuICAgICAgaWYgbiA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X3JpZ2h0IChuKS5pdGVtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfbGVmdCAoLSBuKS5pdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9sZWZ0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9sZWZ0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzMyOiBuIDw9IDMyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfcmlnaHQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X3JpZ2h0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfdGVzdCAobjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRlc3QgYG4nLXRoIHBvc2l0aW9uIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl8zMjogbiA8IDMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICYgKDEgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKDEgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKDEgfDw8IG4pLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0X3dpdGhfbWFzayAoYjogQk9PTEVBTjsgbTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGFsbCAxIGJpdHMgb2YgbSBzZXQgdG8gMVxuICAgICAgLS0gaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmIG0uYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMTEpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXIgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYWJzX3JlZjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtID49IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIHNpZ25fdGltZXNfYWJzOiBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJJbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiA2NCBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uSW50NjRcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBJTlRFR0VSXzY0XG5cbmluaGVyaXRcbiAgSU5URUdFUl82NF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgb3Bwb3NpdGUsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWwsXG4gICAgICB0b19kb3VibGUsXG4gICAgICB0b19jaGFyYWN0ZXJfOCxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMixcbiAgICAgIGJpdF9hbmQsXG4gICAgICBiaXRfb3IsXG4gICAgICBiaXRfeG9yLFxuICAgICAgYml0X25vdCxcbiAgICAgIGJpdF9zaGlmdF9sZWZ0LFxuICAgICAgYml0X3NoaWZ0X3JpZ2h0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtJTlRFR0VSXzY0X1JFRn0pLFxuICB0b19yZWFsOiB7UkVBTF8zMn0sXG4gIHRvX2RvdWJsZToge1JFQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzY0KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfNjQpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzY0KTogSU5URUdFUl82NFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl82NCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfNjRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfNjRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfNjQpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzY0KTogSU5URUdFUl82NFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzY0XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl82NFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDY0IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBJTlRFR0VSXzY0X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgICAtLSBHZXQgdGhlIHBvc2l0aXZlIHZhbHVlIG9mIGBpdGVtJyBhbmQgdGhlbiBkb1xuICAgICAgICAtLSBhIG1vZHVsbyBvbiB0aGUgbWF4aW11bSBJTlRFR0VSXzMyIHZhbHVlLlxuICAgICAgUmVzdWx0IDo9IChpdGVtICYgMHgwMDAwMDAwMDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBJTlRFR0VSXzY0ID0gLTkyMjMzNzIwMzY4NTQ3NzU4MDhcbiAgTWF4X3ZhbHVlOiBJTlRFR0VSXzY0ID0gOTIyMzM3MjAzNjg1NDc3NTgwN1xuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBJTlRFR0VSXzY0KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0gMCBhbmQgaXRlbS50b19uYXR1cmFsXzY0IDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSAwIGFuZFxuICAgICAgICBpdGVtLnRvX25hdHVyYWxfNjQgPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZFxuICAgICAgICBpdGVtLnRvX25hdHVyYWxfNjQgPD0ge0NIQVJBQ1RFUl8zMn0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBhYnM6IElOVEVHRVJfNjRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhYnNfcmVmLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgPSBpdGVtKSBvciAoUmVzdWx0ID0gLWl0ZW0pXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoLSBpdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLy8gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gXFxcXCBvdGhlci5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBeIG90aGVyXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogSU5URUdFUl82NF9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBJTlRFR0VSXzY0X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtOQVRVUkFMXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF8xNn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF8zMn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX3NtYWxsOiBpdGVtID49IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMzJ9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMzJ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBSZXR1cm4gYGl0ZW0nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIHRvX3JlYWw6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2RvdWJsZVxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIHZhbDogSU5URUdFUl82NFxuICAgICAgYV9kaWdpdDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzY0X2JpdHMgLy8gNFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAweDBGKS50b19pbnRlZ2VyXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzY0X2JpdHMgLy8gNFxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtLnRvX2ludGVnZXJcbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQgaWYgYG4nIHBvc2l0aXZlLFxuICAgICAgLS0gdG8gbGVmdCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzY0OiBuIDw9IDY0XG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfNjQ6IG4gPj0gLTY0XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzY0OiBuIDw9IDY0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfbGVmdCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfbGVmdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b182NDogbiA8PSA2NFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fNjQ6IG4gPCA2NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9faW50ZWdlcl82NCB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl82NFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fNjQ6IG4gPCA2NFxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX2ludGVnZXJfNjQgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19pbnRlZ2VyXzY0IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IElOVEVHRVJfNjQpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBhbGwgMSBiaXRzIG9mIG0gc2V0IHRvIDFcbiAgICAgIC0tIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8IG1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiBtLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgaW50ZWdlciB2YWx1ZVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDIwKVxuICAgICAgUmVzdWx0LmFwcGVuZF9pbnRlZ2VyXzY0IChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFic19yZWY6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+PSAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IC1DdXJyZW50XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0IH4gQ3VycmVudCkgb3IgKFJlc3VsdCB+IC1DdXJyZW50KVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBzaWduX3RpbWVzX2Ficzogc2lnbiAqIGFicyA9IGl0ZW1cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDggYml0c1wiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlNCeXRlXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgSU5URUdFUl84IGluaGVyaXRcblxuICBJTlRFR0VSXzhfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsLFxuICAgICAgdG9fZG91YmxlLFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7SU5URUdFUl84X1JFRn0pLFxuICB0b19yZWFsOiB7UkVBTF8zMn0sXG4gIHRvX2RvdWJsZToge1JFQUxfNjR9LFxuICB0b19pbnRlZ2VyXzE2OiB7SU5URUdFUl8xNn0sXG4gIHRvX2ludGVnZXJfMzI6IHtJTlRFR0VSXzMyfSxcbiAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBJTlRFR0VSXzgpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBJTlRFR0VSXzhcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfOFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogSU5URUdFUl84XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDggYml0c1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xOSAxNDoyNjoxNCAtMDcwMCAoTW9uLCAxOSBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUxMTcgJFwiXG5cbmNsYXNzXG4gIElOVEVHRVJfOF9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIlxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBJTlRFR0VSXzhcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9faW50ZWdlci5oYXNoX2NvZGVcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXzhcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVsc2VpZiBpdGVtIDwgMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDEpXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDApXG4gICAgZW5kXG5cbiAgYXNjaWlfY2hhcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0b19jaGFyYWN0ZXJfOCBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXJfY29kZTogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIE1pbl92YWx1ZTogSU5URUdFUl84ID0gLTEyOFxuICBNYXhfdmFsdWU6IElOVEVHRVJfOCA9IDEyN1xuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSAwXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IDAgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGFiczogSU5URUdFUl84XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0ID0gaXRlbSkgb3IgKFJlc3VsdCA9IC1pdGVtKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKC0gaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBJTlRFR0VSXzhfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiBWIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogSU5URUdFUl84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gUmV0dXJuIGBpdGVtJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZTogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fZG91YmxlXG4gICAgZW5kXG5cbiAgdG9faGV4X3N0cmluZzogU1RSSU5HXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICBsb2NhbFxuICAgICAgaSwgdmFsOiBJTlRFR0VSXG4gICAgICBhX2RpZ2l0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAyXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaSlcbiAgICAgICAgUmVzdWx0LmZpbGxfYmxhbmtcbiAgICAgICAgdmFsIDo9IGl0ZW1cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAwXG4gICAgICBsb29wXG4gICAgICAgIGFfZGlnaXQgOj0gKHZhbCAmIDE1KVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICByZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IDJcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbVxuICAgICAgUmVzdWx0IDo9IHRtcC50b19oZXhfY2hhcmFjdGVyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IElOVEVHRVJfOFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodCBpZiBgbicgcG9zaXRpdmUsXG4gICAgICAtLSB0byBsZWZ0IG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fODogbiA8PSA4XG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfODogbiA+PSAtOFxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b184OiBuIDw9IDhcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9sZWZ0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9sZWZ0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzg6IG4gPD0gOFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fODogbiA8IDhcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX2ludGVnZXJfOCB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBgbictdGggcG9zaXRpb25cbiAgICAgIC0tIHNldCB0byAxIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl84OiBuIDwgOFxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX2ludGVnZXJfOCB8PDwgbilcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX2ludGVnZXJfOCB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGFsbCAxIGJpdHMgb2YgbSBzZXQgdG8gMVxuICAgICAgLS0gaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmIG0uYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoNClcbiAgICAgIFJlc3VsdC5hcHBlbmRfaW50ZWdlcl84IChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFic19yZWY6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+PSAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IC1DdXJyZW50XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0IH4gQ3VycmVudCkgb3IgKFJlc3VsdCB+IC1DdXJyZW50KVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBzaWduX3RpbWVzX2Ficzogc2lnbiAqIGFicyA9IGl0ZW1cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZSB0aGF0IGNhbiBiZSBpdGVyYXRlZCBvdmVyIHVzaW5nIGBhY3Jvc3MuLi5sb29wLi4uZW5kJy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBJVEVSQUJMRSBbR11cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBuZXdfY3Vyc29yOiBJVEVSQVRJT05fQ1VSU09SIFtHXVxuICAgICAgLS0gRnJlc2ggY3Vyc29yIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHN0cnVjdHVyZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfYXR0YWNoZWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVzIHdob3NlIGl0ZW1zIG1heSBiZSBhY2Nlc3NlZCBzZXF1ZW50aWFsbHksIG9uZS13YXlcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBzZXF1ZW50aWFsLCB0cmF2ZXJzaW5nO1xuICBhY2Nlc3M6IG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgTElORUFSIFtHXSBpbmhlcml0XG5cbiAgVFJBVkVSU0FCTEUgW0ddXG4gICAgcmVkZWZpbmVcbiAgICAgIGRvX2FsbCwgZG9faWYsIHRoZXJlX2V4aXN0cywgZm9yX2FsbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGhhcyAodjogbGlrZSBpdGVtKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJ1Y3R1cmUgaW5jbHVkZSBhbiBvY2N1cnJlbmNlIG9mIGB2Jz9cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZG9cbiAgICAgIHN0YXJ0XG4gICAgICBpZiBub3Qgb2ZmIHRoZW5cbiAgICAgICAgc2VhcmNoICh2KVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gbm90IGV4aGF1c3RlZFxuICAgIGVuZFxuXG4gIGluZGV4X29mICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBgaSctdGggb2NjdXJyZW5jZSBvZiBgdicuXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIHJlcXVpcmVcbiAgICAgIHBvc2l0aXZlX29jY3VycmVuY2VzOiBpID4gMFxuICAgIGxvY2FsXG4gICAgICBvY2N1ciwgcG9zOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIGFuZCB2IC89IFZvaWQgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgc3RhcnRcbiAgICAgICAgICBwb3MgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGV4aGF1c3RlZCBvciAob2NjdXIgPSBpKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaWYgaXRlbSB+IHYgdGhlblxuICAgICAgICAgICAgb2NjdXIgOj0gb2NjdXIgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgICBwb3MgOj0gcG9zICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgcG9zIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBleGhhdXN0ZWQgb3IgKG9jY3VyID0gaSlcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gPSB2IHRoZW5cbiAgICAgICAgICAgIG9jY3VyIDo9IG9jY3VyICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGZvcnRoXG4gICAgICAgICAgcG9zIDo9IHBvcyArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIG9jY3VyID0gaSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBwb3MgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9yZXN1bHQ6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgc2VhcmNoICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBNb3ZlIHRvIGZpcnN0IHBvc2l0aW9uIChhdCBvciBhZnRlciBjdXJyZW50XG4gICAgICAtLSBwb3NpdGlvbikgd2hlcmUgYGl0ZW0nIGFuZCBgdicgYXJlIGVxdWFsLlxuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICAgIC0tIElmIG5vIHN1Y2ggcG9zaXRpb24gZW5zdXJlIHRoYXQgYGV4aGF1c3RlZCcgd2lsbCBiZSB0cnVlLlxuICAgIGRvXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBleGhhdXN0ZWQgb3IgZWxzZSB2IH4gaXRlbVxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBleGhhdXN0ZWQgb3IgZWxzZSB2ID0gaXRlbVxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG9iamVjdF9mb3VuZDogKG5vdCBleGhhdXN0ZWQgYW5kIG9iamVjdF9jb21wYXJpc29uKVxuICAgICAgICAgaW1wbGllcyB2IH4gaXRlbVxuICAgICAgaXRlbV9mb3VuZDogKG5vdCBleGhhdXN0ZWQgYW5kIG5vdCBvYmplY3RfY29tcGFyaXNvbilcbiAgICAgICAgIGltcGxpZXMgdiA9IGl0ZW1cbiAgICBlbmRcblxuICBpbmRleDogSU5URUdFUlxuICAgICAgLS0gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvblxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgb2NjdXJyZW5jZXMgKHY6IGxpa2UgaXRlbSk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgICAgc2VhcmNoICh2KVxuICAgICAgdW50aWxcbiAgICAgICAgZXhoYXVzdGVkXG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgIGZvcnRoXG4gICAgICAgIHNlYXJjaCAodilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGl0ZW1fZm9yX2l0ZXJhdGlvbjogR1xuICAgICAgLS0gSXRlbSBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZjogbm90IG9mZlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleGhhdXN0ZWQ6IEJPT0xFQU5cbiAgICAgIC0tIEhhcyBzdHJ1Y3R1cmUgYmVlbiBjb21wbGV0ZWx5IGV4cGxvcmVkP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb2ZmXG4gICAgZW5zdXJlXG4gICAgICBleGhhdXN0ZWRfd2hlbl9vZmY6IG9mZiBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGFmdGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyB2YWxpZCBwb3NpdGlvbiB0byB0aGUgcmlnaHQgb2YgY3VycmVudCBvbmU/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBvZmY6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIGN1cnJlbnQgaXRlbT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX2VtcHR5IG9yIGFmdGVyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgZmluaXNoXG4gICAgICAtLSBNb3ZlIHRvIGxhc3QgcG9zaXRpb24uXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBmb3J0aFxuICAgICAgLS0gTW92ZSB0byBuZXh0IHBvc2l0aW9uOyBpZiBubyBuZXh0IHBvc2l0aW9uLFxuICAgICAgLS0gZW5zdXJlIHRoYXQgYGV4aGF1c3RlZCcgd2lsbCBiZSB0cnVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9hZnRlcjogbm90IGFmdGVyXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIC0tIG1vdmVkX2ZvcnRoX2JlZm9yZV9lbmQ6IChub3QgYWZ0ZXIpIGltcGxpZXMgaW5kZXggPSBvbGQgaW5kZXggKyAxXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbS5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGM6IGRldGFjaGFibGUgQ1VSU09SXG4gICAgICBjczogZGV0YWNoYWJsZSBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7Q1VSU09SX1NUUlVDVFVSRSBbR119IEN1cnJlbnQgYXMgYWNzIHRoZW5cbiAgICAgICAgY3MgOj0gYWNzXG4gICAgICAgIGMgOj0gYWNzLmN1cnNvclxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGFmdGVyXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbV0pXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcblxuICAgICAgaWYgY3MgLz0gVm9pZCBhbmQgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgY3MuZ29fdG8gKGMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZiAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0ddXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGM6IGRldGFjaGFibGUgQ1VSU09SXG4gICAgICBjczogZGV0YWNoYWJsZSBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7Q1VSU09SX1NUUlVDVFVSRSBbR119IEN1cnJlbnQgYXMgYWNzIHRoZW5cbiAgICAgICAgY3MgOj0gYWNzXG4gICAgICAgIGMgOj0gYWNzLmN1cnNvclxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGFmdGVyXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2l0ZW1dKSB0aGVuXG4gICAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcblxuICAgICAgaWYgY3MgLz0gVm9pZCBhbmQgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgY3MuZ29fdG8gKGMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICBsb2NhbFxuICAgICAgYzogZGV0YWNoYWJsZSBDVVJTT1JcbiAgICAgIGNzOiBkZXRhY2hhYmxlICBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7Q1VSU09SX1NUUlVDVFVSRSBbR119IEN1cnJlbnQgYXMgYWNzIHRoZW5cbiAgICAgICAgY3MgOj0gYWNzXG4gICAgICAgIGMgOj0gYWNzLmN1cnNvclxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGFmdGVyIG9yIFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gdGVzdC5pdGVtIChbaXRlbV0pXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcblxuICAgICAgaWYgY3MgLz0gVm9pZCBhbmQgYyAvPVZvaWQgdGhlblxuICAgICAgICBjcy5nb190byAoYylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZvcl9hbGwgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYWxsIGl0ZW1zP1xuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGM6IGRldGFjaGFibGUgQ1VSU09SXG4gICAgICBjczogZGV0YWNoYWJsZSAgQ1VSU09SX1NUUlVDVFVSRSBbR11cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0NVUlNPUl9TVFJVQ1RVUkUgW0ddfSBDdXJyZW50IGFzIGFjcyB0aGVuXG4gICAgICAgIGNzIDo9IGFjc1xuICAgICAgICBjIDo9IGFjcy5jdXJzb3JcbiAgICAgIGVuZFxuXG4gICAgICBmcm9tXG4gICAgICAgIHN0YXJ0XG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICB1bnRpbFxuICAgICAgICBhZnRlciBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSB0ZXN0Lml0ZW0gKFtpdGVtXSlcbiAgICAgICAgZm9ydGhcbiAgICAgIGVuZFxuXG4gICAgICBpZiBjcyAvPSBWb2lkIGFuZCBjIC89IFZvaWQgdGhlblxuICAgICAgICBjcy5nb190byAoYylcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBlbXB0eTogaXNfZW1wdHkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0ddXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgYWZ0ZXJfY29uc3RyYWludDogYWZ0ZXIgaW1wbGllcyBvZmZcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlNlcXVlbnRpYWwgbGlzdHMsIHdpdGhvdXQgY29tbWl0bWVudCB0byBhIHBhcnRpY3VsYXIgcmVwcmVzZW50YXRpb25cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBsaXN0LCBzZXF1ZW5jZTtcbiAgYWNjZXNzOiBpbmRleCwgY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIExJU1QgW0ddIGluaGVyaXRcblxuICBDSEFJTiBbR11cbiAgICBleHBvcnRcbiAgICAgIHtBTll9IHJlbW92ZVxuICAgIHJlZGVmaW5lXG4gICAgICBmb3J0aCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBvdGhlcicgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50cz9cbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA9IG90aGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IChpc19lbXB0eSA9IG90aGVyLmlzX2VtcHR5KSBhbmRcbiAgICAgICAgICAgIChvYmplY3RfY29tcGFyaXNvbiA9IG90aGVyLm9iamVjdF9jb21wYXJpc29uKSBhbmRcbiAgICAgICAgICAgIChjb3VudCA9IG90aGVyLmNvdW50KVxuICAgICAgICBpZiBSZXN1bHQgYW5kIG5vdCBpc19lbXB0eSB0aGVuXG4gICAgICAgICAgaWZcbiAgICAgICAgICAgIGF0dGFjaGVkIHtDVVJTT1J9IGN1cnNvciBhcyBjMSBhbmQgdGhlblxuICAgICAgICAgICAgYXR0YWNoZWQge0NVUlNPUn0gb3RoZXIuY3Vyc29yIGFzIGMyXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgICBvdGhlci5zdGFydFxuICAgICAgICAgICAgdW50aWxcbiAgICAgICAgICAgICAgYWZ0ZXIgb3Igbm90IFJlc3VsdFxuICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfiBvdGhlci5pdGVtXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBSZXN1bHQgOj0gaXRlbSA9IG90aGVyLml0ZW1cbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGZvcnRoXG4gICAgICAgICAgICAgIG90aGVyLmZvcnRoXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGdvX3RvIChjMSlcbiAgICAgICAgICAgIG90aGVyLmdvX3RvIChjMilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgICBjdXJzb3JzX2V4aXN0OiBGYWxzZVxuICAgICAgICAgICAgICAgIC0tIEJlY2F1c2UgZXZlcnkgbGlzdCBjb250YWlucyBhIGN1cnNvciBvYmplY3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgaXNfZW1wdHkgYW5kIG90aGVyLmlzX2VtcHR5IGFuZFxuICAgICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGluZGljZXNfdW5jaGFuZ2VkOlxuICAgICAgICBpbmRleCA9IG9sZCBpbmRleCBhbmQgb3RoZXIuaW5kZXggPSBvbGQgb3RoZXIuaW5kZXhcbiAgICAgIHRydWVfaW1wbGllc19zYW1lX3NpemU6IFJlc3VsdCBpbXBsaWVzIGNvdW50ID0gb3RoZXIuY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgYWZ0ZXI6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIHZhbGlkIGN1cnNvciBwb3NpdGlvbiB0byB0aGUgcmlnaHQgb2YgY3Vyc29yP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGluZGV4ID0gY291bnQgKyAxKVxuICAgIGVuZFxuXG4gIGJlZm9yZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gdmFsaWQgY3Vyc29yIHBvc2l0aW9uIHRvIHRoZSBsZWZ0IG9mIGN1cnNvcj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpbmRleCA9IDApXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgZm9ydGhcbiAgICAgIC0tIE1vdmUgdG8gbmV4dCBwb3NpdGlvbjsgaWYgbm8gbmV4dCBwb3NpdGlvbixcbiAgICAgIC0tIGVuc3VyZSB0aGF0IGBleGhhdXN0ZWQnIHdpbGwgYmUgdHJ1ZS5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBtb3ZlZF9mb3J0aDogaW5kZXggPSBvbGQgaW5kZXggKyAxXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGJlZm9yZV9kZWZpbml0aW9uOiBiZWZvcmUgPSAoaW5kZXggPSAwKVxuICBhZnRlcl9kZWZpbml0aW9uOiBhZnRlciA9IChpbmRleCA9IGNvdW50ICsgMSlcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBUbyBlYXNpbHkgbWFuYWdlIGFsbG9jYXRpb24gYW5kIHJlbGVhc2Ugb2YgYWxsb2NhdGVkIEMgbWVtb3J5LCBhbmRcbiAgICB0byBwZXJmb3JtIGluc2VydGlvbiBvZiBiYXNpYyBlbGVtZW50cy4gQnl0ZSBvcmRlciBpcyBieSBkZWZhdWx0XG4gICAgcGxhdGZvcm0gc3BlY2lmaWMuXG4gICAgQWx0aG91Z2ggbWVtb3J5IGFsbG9jYXRpb24gcm91dGluZXMgZG8gbm90IGFjY2VwdCBhIHplcm8gc2l6ZWQgcG9pbnRlclxuICAgIE1BTkFHRURfUE9JTlRFUiBkb2VzIGJ5IGFsbG9jYXRpbmcgaW4gZmFjdCBhIDEgYnl0ZSBzaXplZCBwb2ludGVyIGZvclxuICAgIHRoaXMgcGFydGljdWxhciBjYXNlLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTAtMjkgMTc6MTI6MDAgLTA3MDAgKE1vbiwgMjkgT2N0IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDE1ICRcIlxuXG5jbGFzc1xuICBNQU5BR0VEX1BPSU5URVJcblxuaW5oZXJpdFxuICBESVNQT1NBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBjb3B5XG4gICAgZW5kXG5cbiAgUExBVEZPUk1cbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIGNvcHlcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsIG1ha2VfZnJvbV9hcnJheSwgbWFrZV9mcm9tX3BvaW50ZXIsIHNoYXJlX2Zyb21fcG9pbnRlciwgb3duX2Zyb21fcG9pbnRlclxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBgaXRlbScgd2l0aCBgbicgYnl0ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpbmNyZW1lbnRfY291bnRlclxuICAgICAgaXRlbSA6PSBpdGVtLm1lbW9yeV9jYWxsb2MgKG4ubWF4ICgxKSwgMSlcbiAgICAgIGlmIGl0ZW0gPSBkZWZhdWx0X3BvaW50ZXIgdGhlblxuICAgICAgICAoY3JlYXRlIHtFWENFUFRJT05TfSkucmFpc2UgKFwiTm8gbW9yZSBtZW1vcnlcIilcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0gblxuICAgICAgaXNfc2hhcmVkIDo9IEZhbHNlXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBpc19zaGFyZWRfc2V0OiBub3QgaXNfc2hhcmVkXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2FycmF5IChkYXRhOiBBUlJBWSBbTkFUVVJBTF84XSlcbiAgICAgIC0tIEFsbG9jYXRlIGBpdGVtJyB3aXRoIGBkYXRhLmNvdW50JyBieXRlcyBhbmQgY29weVxuICAgICAgLS0gY29udGVudCBvZiBgZGF0YScgaW50byBgaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgZGF0YV9ub3Rfdm9pZDogZGF0YSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluY3JlbWVudF9jb3VudGVyXG4gICAgICBjb3VudCA6PSBkYXRhLmNvdW50XG4gICAgICBpdGVtIDo9IGl0ZW0ubWVtb3J5X2FsbG9jIChjb3VudC5tYXggKDEpKVxuICAgICAgaWYgaXRlbSA9IGRlZmF1bHRfcG9pbnRlciB0aGVuXG4gICAgICAgIChjcmVhdGUge0VYQ0VQVElPTlN9KS5yYWlzZSAoXCJObyBtb3JlIG1lbW9yeVwiKVxuICAgICAgZW5kXG4gICAgICBwdXRfYXJyYXkgKGRhdGEsIDApXG4gICAgICBpc19zaGFyZWQgOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IGRhdGEuY291bnRcbiAgICAgIGlzX3NoYXJlZF9zZXQ6IG5vdCBpc19zaGFyZWRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fcG9pbnRlciAoYV9wdHI6IFBPSU5URVI7IG46IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGBhX2NvdW50JyBieXRlcyBmcm9tIGBhX3B0cicgaW50byBjdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIGFfcHRyX25vdF9udWxsOiBhX3B0ciAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaW5jcmVtZW50X2NvdW50ZXJcbiAgICAgIGl0ZW0gOj0gaXRlbS5tZW1vcnlfYWxsb2MgKG4ubWF4ICgxKSlcbiAgICAgIGlmIGl0ZW0gPSBkZWZhdWx0X3BvaW50ZXIgdGhlblxuICAgICAgICAoY3JlYXRlIHtFWENFUFRJT05TfSkucmFpc2UgKFwiTm8gbW9yZSBtZW1vcnlcIilcbiAgICAgIGVuZFxuICAgICAgaXRlbS5tZW1vcnlfY29weSAoYV9wdHIsIG4pXG4gICAgICBjb3VudCA6PSBuXG4gICAgICBpc19zaGFyZWQgOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGlzX3NoYXJlZF9zZXQ6IG5vdCBpc19zaGFyZWRcbiAgICBlbmRcblxuICBzaGFyZV9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSOyBuOiBJTlRFR0VSKVxuICAgICAgLS0gVXNlIGRpcmVjdGx5IGBhX3B0cicgd2l0aCBjb3VudCBgbicgdG8gaG9sZCBjdXJyZW50IGRhdGEuXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfdmFsaWQ6IGFfcHRyID0gZGVmYXVsdF9wb2ludGVyIGltcGxpZXMgbiA9IDBcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaW5jcmVtZW50X2NvdW50ZXJcbiAgICAgIGl0ZW0gOj0gYV9wdHJcbiAgICAgIGNvdW50IDo9IG5cbiAgICAgIGlzX3NoYXJlZCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGFfcHRyXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgaXNfc2hhcmVkX3NldDogaXNfc2hhcmVkXG4gICAgZW5kXG5cbiAgb3duX2Zyb21fcG9pbnRlciAoYV9wdHI6IFBPSU5URVI7IG46IElOVEVHRVIpXG4gICAgICAtLSBVc2UgZGlyZWN0bHkgYGFfcHRyJyB3aXRoIGNvdW50IGBuJyB0byBob2xkIGN1cnJlbnQgZGF0YSBhbmQgZnJlZVxuICAgICAgLS0gaXRzIGFzc29jaWF0ZWQgQyBtZW1vcnkgd2hlbiBDdXJyZW50IGlzIGNvbGxlY3RlZC5cbiAgICAgIC0tIEl0IGFzc3VtZXMgdGhhdCBgYV9wdHInIHdhcyBhbGxvY2F0ZWQgdXNpbmcgdGhlIEMtYG1hbGxvYycgcm91dGluZSBhbmQgdGh1c1xuICAgICAgLS0gd2lsbCBiZSBmcmVlZCBieSBjYWxsaW5nIHRoZSBDLWBmcmVlJyByb3V0aW5lLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfcHRyX3ZhbGlkOiBhX3B0ciAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaW5jcmVtZW50X2NvdW50ZXJcbiAgICAgIGl0ZW0gOj0gYV9wdHJcbiAgICAgIGNvdW50IDo9IG5cbiAgICAgIGlzX3NoYXJlZCA6PSBGYWxzZVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBhX3B0clxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGlzX3NoYXJlZF9zZXQ6IG5vdCBpc19zaGFyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTZXR0aW5nc1xuXG4gIHNldF9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSOyBuOiBJTlRFR0VSKVxuICAgICAgLS0gVXNlIGRpcmVjdGx5IGBhX3B0cicgd2l0aCBjb3VudCBgbicgdG8gaG9sZCBjdXJyZW50IGRhdGEuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfc2hhcmVkOiBpc19zaGFyZWRcbiAgICAgIGFfcHRyX25vdF9udWxsOiBhX3B0ciA9IGRlZmF1bHRfcG9pbnRlciBpbXBsaWVzIG4gPSAwXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGl0ZW0gOj0gYV9wdHJcbiAgICAgIGNvdW50IDo9IG5cbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gYV9wdHJcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBpc19zaGFyZWRfdW5jaGFuZ2VkOiBpc19zaGFyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBQT0lOVEVSIG5vdGUgb3B0aW9uOiB0cmFuc2llbnQgYXR0cmlidXRlIGVuZFxuICAgICAgLS0gQWNjZXNzIHRvIGFsbG9jYXRlZCBtZW1vcnkuXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBlbGVtZW50cyB0aGF0IEN1cnJlbnQgY2FuIGhvbGQuXG5cbiAgaXNfc2hhcmVkOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgc2hhcmVkIHdpdGggYW5vdGhlciBtZW1vcnkgYXJlYT9cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkIGVxdWFsIHRvIGN1cnJlbnQgb2JqZWN0P1xuICAgIGRvXG4gICAgICBpZiBjb3VudCA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtID0gb3RoZXIuaXRlbSkgb3IgZWxzZSBpdGVtLm1lbW9yeV9jb21wYXJlIChvdGhlci5pdGVtLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFVwZGF0ZSBjdXJyZW50IG9iamVjdCB1c2luZyBmaWVsZHMgb2Ygb2JqZWN0IGF0dGFjaGVkXG4gICAgICAtLSB0byBgb3RoZXInLCBzbyBhcyB0byB5aWVsZCBlcXVhbCBvYmplY3RzLiBJZiBgaXNfc2hhcmVkJ1xuICAgICAgLS0gYW5kIGN1cnJlbnQgaXMgbm90IGxhcmdlIGVub3VnaCB0byBob2xkIGBvdGhlcicgY3JlYXRlXG4gICAgICAtLSBhIG5ldyBwb2ludGVyIGFyZWEgYW5kIGBpc19zaGFyZWQnIGlzIHNldCB0byBgRmFsc2UnLlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgaWYgaXRlbSA9IG90aGVyLml0ZW0gb3IgaXNfc2hhcmVkIHRoZW5cbiAgICAgICAgICAgIC0tIENvcHkgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB2aWEgYHR3aW4nIGJ1dCBldmVuXG4gICAgICAgICAgICAtLSBpZiBpdCBpcyBub3QsIGl0IG1ha2VzIHNlbnNlIHRvIGR1cGxpY2F0ZSB0aGUgbWVtb3J5LlxuICAgICAgICAgICAgLS0gT3IgYmVmb3JlIGBpdGVtJyB3YXMgc2hhcmVkLCBzbyB3ZSBzaW1wbHkgYWxsb2NhdGVcbiAgICAgICAgICAgIC0tIGEgbmV3IG1lbW9yeSBhcmVhIGZyb20gYG90aGVyJyBhbmQgcmVzZXRcbiAgICAgICAgICAgIC0tIHRoZSBgaXNfc2hhcmVkJyBmbGFnLlxuICAgICAgICAgIG1ha2VfZnJvbV9wb2ludGVyIChvdGhlci5pdGVtLCBvdGhlci5jb3VudClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHJlc2l6ZSBDdXJyZW50IGFuZCBjb3B5IGRhdGEuXG4gICAgICAgICAgcmVzaXplIChvdGhlci5jb3VudClcbiAgICAgICAgICBpdGVtLm1lbW9yeV9jb3B5IChvdGhlci5pdGVtLCBvdGhlci5jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2hhcmluZ19zdGF0dXNfbm90X3ByZXNlcnZlZDogKG90aGVyIC89IEN1cnJlbnQpIGltcGxpZXMgKG9sZCBpc19zaGFyZWQgaW1wbGllcyBub3QgaXNfc2hhcmVkKVxuICAgICAgY291bnRfcHJlc2VydmVkOiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzOiBQbGF0Zm9ybSBzcGVjaWZpY1xuXG4gIHJlYWRfbmF0dXJhbF84IChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF84IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoJFJlc3VsdCkubWVtb3J5X2NvcHkgKGl0ZW0gKyBwb3MsIG5hdHVyYWxfOF9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfMTYgKHBvczogSU5URUdFUik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF8xNiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF8xNl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfMzIgKHBvczogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF8zMiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfNjQgKHBvczogSU5URUdFUik6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF82NF9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfOCAocG9zOiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBSZWFkIElOVEVHRVJfOCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfOF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF84IChwb3MpLmFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl8xNiAocG9zOiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gUmVhZCBJTlRFR0VSXzE2IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8xNiAocG9zKS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzMyIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBSZWFkIElOVEVHRVIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzMyIChwb3MpLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfNjQgKHBvczogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIFJlYWQgSU5URUdFUl82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfNjQgKHBvcykuYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIHJlYWRfcG9pbnRlciAocG9zOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gUmVhZCBQT0lOVEVSIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgUG9pbnRlcl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBQb2ludGVyX2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfYm9vbGVhbiAocG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gUmVhZCBCT09MRUFOIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgQm9vbGVhbl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBCb29sZWFuX2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfY2hhcmFjdGVyIChwb3M6IElOVEVHRVIpOiBDSEFSQUNURVJcbiAgICAgIC0tIFJlYWQgQ0hBUkFDVEVSIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgQ2hhcmFjdGVyXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgQ2hhcmFjdGVyXzhfYnl0ZXMpXG4gICAgZW5kXG5cbiAgcmVhZF9yZWFsIChwb3M6IElOVEVHRVIpOiBSRUFMXG4gICAgICAtLSBSZWFkIFJFQUxfMzIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgb2Jzb2xldGUgXCJVc2UgcmVhZF9yZWFsXzMyIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgUmVhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX3JlYWxfMzIgKHBvczogSU5URUdFUik6IFJFQUxcbiAgICAgIC0tIFJlYWQgUkVBTF8zMiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgUmVhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX2RvdWJsZSAocG9zOiBJTlRFR0VSKTogRE9VQkxFXG4gICAgICAtLSBSZWFkIFJFQUxfNjQgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgb2Jzb2xldGUgXCJVc2UgcmVhZF9yZWFsXzY0IGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgUmVhbF82NF9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX3JlYWxfNjQgKHBvczogSU5URUdFUik6IERPVUJMRVxuICAgICAgLS0gUmVhZCBSRUFMXzY0IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgUmVhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBSZWFsXzY0X2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfYXJyYXkgKHBvcywgYV9jb3VudDogSU5URUdFUik6IEFSUkFZIFtOQVRVUkFMXzhdXG4gICAgICAtLSBSZWFkIGBjb3VudCcgYnl0ZXMgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgY291bnRfcG9zaXRpdmU6IGFfY291bnQgPiAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGFfY291bnQpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGNyZWF0ZSBsX2FyZWEubWFrZV9lbXB0eSAoYV9jb3VudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gYV9jb3VudFxuICAgICAgbG9vcFxuICAgICAgICBsX2FyZWEuZXh0ZW5kIChyZWFkX25hdHVyYWxfOCAocG9zICsgaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3BlY2lhbCAobF9hcmVhKVxuICAgIGVuc3VyZVxuICAgICAgcmVhZF9hcnJheV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHJlYWRfYXJyYXlfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IGFfY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZTogUGxhdGZvcm0gc3BlY2lmaWNcblxuICBwdXRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzg7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGksIG5hdHVyYWxfOF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzggKHBvcylcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGksIG5hdHVyYWxfMTZfYnl0ZXMpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfbmF0dXJhbF8xNiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzMyIChpOiBOQVRVUkFMXzMyOyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKGl0ZW0gKyBwb3MpLm1lbW9yeV9jb3B5ICgkaSwgbmF0dXJhbF8zMl9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzMyIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X25hdHVyYWxfNjQgKGk6IE5BVFVSQUxfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRpLCBuYXR1cmFsXzY0X2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX25hdHVyYWxfNjQgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzg7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzggKGkuYXNfbmF0dXJhbF84LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl84IChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTY7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzE2X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF8xNiAoaS5hc19uYXR1cmFsXzE2LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl8xNiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzMyIChpOiBJTlRFR0VSOyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8zMl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgcHV0X25hdHVyYWxfMzIgKGkuYXNfbmF0dXJhbF8zMiwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfMzIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NDsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzY0IChpLmFzX25hdHVyYWxfNjQsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9pbnRlZ2VyXzY0IChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X3BvaW50ZXIgKHA6IFBPSU5URVI7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcCcgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBQb2ludGVyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRwLCBQb2ludGVyX2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IHAgPSByZWFkX3BvaW50ZXIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfYm9vbGVhbiAoYjogQk9PTEVBTjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBiJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIEJvb2xlYW5fYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGIsIEJvb2xlYW5fYnl0ZXMpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogYiA9IHJlYWRfYm9vbGVhbiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBjJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIENoYXJhY3Rlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRjLCBDaGFyYWN0ZXJfOF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBjID0gcmVhZF9jaGFyYWN0ZXIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfcmVhbCAocjogUkVBTDsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGByJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICBvYnNvbGV0ZSBcIlVzZSBwdXRfcmVhbF8zMiBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBSZWFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRyLCBSZWFsXzMyX2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IHIgPSByZWFkX3JlYWxfMzIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfcmVhbF8zMiAocjogUkVBTDsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGByJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJHIsIFJlYWxfMzJfYnl0ZXMpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogciA9IHJlYWRfcmVhbF8zMiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9kb3VibGUgKGQ6IERPVUJMRTsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBkJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICBvYnNvbGV0ZSBcIlVzZSBwdXRfcmVhbF82NCBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBSZWFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRkLCBSZWFsXzY0X2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGQgPSByZWFkX3JlYWxfNjQgKHBvcylcbiAgICBlbmRcblxuICBwdXRfcmVhbF82NCAoZDogRE9VQkxFOyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGQnIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgUmVhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKGl0ZW0gKyBwb3MpLm1lbW9yeV9jb3B5ICgkZCwgUmVhbF82NF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBkID0gcmVhZF9yZWFsXzY0IChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2FycmF5IChkYXRhOiBBUlJBWSBbTkFUVVJBTF84XTsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjb250ZW50IG9mIGBkYXRhJyBpbnRvIGBpdGVtJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBkYXRhX25vdF92b2lkOiBkYXRhIC89IFZvaWRcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgZGF0YS5jb3VudCkgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9zcDogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgIGRvXG4gICAgICBsX3NwIDo9IGRhdGEuYXJlYTtcbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGxfc3AsIGRhdGEuY291bnQpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogcmVhZF9hcnJheSAocG9zLCBkYXRhLmNvdW50KSB+IGRhdGFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3M6IExpdHRsZS1lbmRpYW4gZm9ybWF0XG5cbiAgcmVhZF9uYXR1cmFsXzhfbGUgKHBvczogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gUmVhZCBOQVRVUkFMXzggYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF84X2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfbmF0dXJhbF8xNl9sZSAocG9zOiBJTlRFR0VSKTogTkFUVVJBTF8xNlxuICAgICAgLS0gUmVhZCBOQVRVUkFMXzE2IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8xNl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9oaWdoLCBsX2xvdzogTkFUVVJBTF8xNlxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8xNiAocG9zKVxuICAgICAgZWxzZVxuICAgICAgICBsX2xvdyA6PSB7TkFUVVJBTF8xNn0gMHgwMEZGICYgcmVhZF9uYXR1cmFsXzggKHBvcylcbiAgICAgICAgbF9oaWdoIDo9IHJlYWRfbmF0dXJhbF84IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgICAgIFJlc3VsdCA6PSAobF9oaWdoLnRvX25hdHVyYWxfMTYgfDw8IDgpIHwgbF9sb3dcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlYWRfbmF0dXJhbF8zMl9sZSAocG9zOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUmVhZCBOQVRVUkFMXzMyIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9oaWdoLCBsX2xvdzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8zMiAocG9zKVxuICAgICAgZWxzZVxuICAgICAgICBsX2xvdyA6PSB7TkFUVVJBTF8zMn0gMHgwMDAwRkZGRiAmIHJlYWRfbmF0dXJhbF8xNl9sZSAocG9zKVxuICAgICAgICBsX2hpZ2ggOj0gcmVhZF9uYXR1cmFsXzE2X2xlIChwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKVxuICAgICAgICBSZXN1bHQgOj0gKGxfaGlnaC50b19uYXR1cmFsXzMyIHw8PCAxNikgfCBsX2xvd1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVhZF9uYXR1cmFsXzY0X2xlIChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBSZWFkIE5BVFVSQUxfNjQgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2hpZ2gsIGxfbG93OiBOQVRVUkFMXzY0XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzY0IChwb3MpXG4gICAgICBlbHNlXG4gICAgICAgIGxfbG93IDo9IHtOQVRVUkFMXzY0fSAweDAwMDAwMDAwRkZGRkZGRkYgJiByZWFkX25hdHVyYWxfMzJfbGUgKHBvcylcbiAgICAgICAgbF9oaWdoIDo9IHJlYWRfbmF0dXJhbF8zMl9sZSAocG9zICsgbmF0dXJhbF8zMl9ieXRlcylcbiAgICAgICAgUmVzdWx0IDo9IChsX2hpZ2gudG9fbmF0dXJhbF82NCB8PDwgMzIpIHwgbF9sb3dcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl84X2xlIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzhcbiAgICAgIC0tIFJlYWQgSU5URUdFUl84IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzhfbGUgKHBvcykuYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzE2X2xlIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBSZWFkIElOVEVHRVJfMTYgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzE2X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzE2X2xlIChwb3MpLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfMzJfbGUgKHBvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFJlYWQgSU5URUdFUiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfMzJfbGUgKHBvcykuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl82NF9sZSAocG9zOiBJTlRFR0VSKTogSU5URUdFUl82NFxuICAgICAgLS0gUmVhZCBJTlRFR0VSXzY0IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF82NF9sZSAocG9zKS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgcmVhZF9yZWFsXzMyX2xlIChwb3M6IElOVEVHRVIpOiBSRUFMXG4gICAgICAtLSBSZWFkIFJFQUxfMzIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyByZWFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX25hdDMyOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGNoZWNrXG4gICAgICAgIGNvcnJlY3Rfc2l6ZTogcmVhbF8zMl9ieXRlcyA9IG5hdHVyYWxfMzJfYnl0ZXNcbiAgICAgIGVuZFxuICAgICAgbF9uYXQzMiA6PSByZWFkX25hdHVyYWxfMzJfbGUgKHBvcylcbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoJGxfbmF0MzIsIG5hdHVyYWxfMzJfYnl0ZXMpXG4gICAgZW5kXG5cbiAgcmVhZF9yZWFsXzY0X2xlIChwb3M6IElOVEVHRVIpOiBET1VCTEVcbiAgICAgIC0tIFJlYWQgUkVBTF82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0NjQ6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzY0X2J5dGVzID0gbmF0dXJhbF82NF9ieXRlc1xuICAgICAgZW5kXG4gICAgICBsX25hdDY0IDo9IHJlYWRfbmF0dXJhbF82NF9sZSAocG9zKVxuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5ICgkbF9uYXQ2NCwgbmF0dXJhbF82NF9ieXRlcylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZTogTGl0dGxlLWVuZGlhbiBmb3JtYXRcblxuICBwdXRfbmF0dXJhbF84X2xlIChpOiBOQVRVUkFMXzg7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGksIG5hdHVyYWxfOF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzhfbGUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF8xNl9sZSAoaTogTkFUVVJBTF8xNjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBwdXRfbmF0dXJhbF8xNiAoaSwgcG9zKVxuICAgICAgZWxzZVxuICAgICAgICBwdXRfbmF0dXJhbF84ICgoaSAmIDB4MDBGRikudG9fbmF0dXJhbF84LCBwb3MpXG4gICAgICAgIHB1dF9uYXR1cmFsXzggKCgoKGkgJiAweEZGMDApIHw+PiA4KSAmIDB4MDBGRikudG9fbmF0dXJhbF84LCBwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzE2X2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X25hdHVyYWxfMzJfbGUgKGk6IE5BVFVSQUxfMzI7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgcHV0X25hdHVyYWxfMzIgKGksIHBvcylcbiAgICAgIGVsc2VcbiAgICAgICAgcHV0X25hdHVyYWxfMTZfbGUgKChpICYgMHgwMDAwRkZGRikudG9fbmF0dXJhbF8xNiwgcG9zKVxuICAgICAgICBwdXRfbmF0dXJhbF8xNl9sZSAoKCgoaSAmIDB4RkZGRjAwMDApIHw+PiAxNikgJiAweDAwMDBGRkZGKS50b19uYXR1cmFsXzE2LCBwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfbmF0dXJhbF8zMl9sZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzY0X2xlIChpOiBOQVRVUkFMXzY0OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgaWYgaXNfbGl0dGxlX2VuZGlhbiB0aGVuXG4gICAgICAgIHB1dF9uYXR1cmFsXzY0IChpLCBwb3MpXG4gICAgICBlbHNlXG4gICAgICAgIHB1dF9uYXR1cmFsXzMyX2xlICgoaSAmIDB4MDAwMDAwMDBGRkZGRkZGRikudG9fbmF0dXJhbF8zMiwgcG9zKVxuICAgICAgICBwdXRfbmF0dXJhbF8zMl9sZSAoXG4gICAgICAgICAgKCgoaSAmIDB4RkZGRkZGRkYwMDAwMDAwMCkgfD4+IDMyKSAmIDB4MDAwMDAwMDBGRkZGRkZGRikudG9fbmF0dXJhbF8zMixcbiAgICAgICAgICBwb3MrIG5hdHVyYWxfMzJfYnl0ZXMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzY0X2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfOF9sZSAoaTogSU5URUdFUl84OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF84X2xlIChpLmFzX25hdHVyYWxfOCwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfOF9sZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzE2X2xlIChpOiBJTlRFR0VSXzE2OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgcHV0X25hdHVyYWxfMTZfbGUgKGkuYXNfbmF0dXJhbF8xNiwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfMTZfbGUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl8zMl9sZSAoaTogSU5URUdFUjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzMyX2xlIChpLmFzX25hdHVyYWxfMzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9pbnRlZ2VyXzMyX2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfNjRfbGUgKGk6IElOVEVHRVJfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF82NF9sZSAoaS5hc19uYXR1cmFsXzY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl82NF9sZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9yZWFsXzMyX2xlICh2OiBSRUFMOyBwb3M6IElOVEVHRVJfMzIpXG4gICAgICAtLSBJbnNlcnQgYHYnIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgcmVhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9uYXQzMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBjaGVja1xuICAgICAgICBjb3JyZWN0X3NpemU6IHJlYWxfMzJfYnl0ZXMgPSBuYXR1cmFsXzMyX2J5dGVzXG4gICAgICBlbmRcbiAgICAgICgkbF9uYXQzMikubWVtb3J5X2NvcHkgKCR2LCBuYXR1cmFsXzMyX2J5dGVzKVxuICAgICAgcHV0X25hdHVyYWxfMzJfbGUgKGxfbmF0MzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiB2ID0gcmVhZF9yZWFsXzMyX2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X3JlYWxfNjRfbGUgKHY6IERPVUJMRTsgcG9zOiBJTlRFR0VSXzMyKVxuICAgICAgLS0gSW5zZXJ0IGB2JyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0NjQ6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzY0X2J5dGVzID0gbmF0dXJhbF82NF9ieXRlc1xuICAgICAgZW5kXG4gICAgICAoJGxfbmF0NjQpLm1lbW9yeV9jb3B5ICgkdiwgbmF0dXJhbF82NF9ieXRlcylcbiAgICAgIHB1dF9uYXR1cmFsXzY0X2xlIChsX25hdDY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogdiA9IHJlYWRfcmVhbF82NF9sZSAocG9zKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2VzczogQmlnLWVuZGlhbiBmb3JtYXRcblxuICByZWFkX25hdHVyYWxfOF9iZSAocG9zOiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBSZWFkIE5BVFVSQUxfOCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfOF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgZW5kXG5cbiAgcmVhZF9uYXR1cmFsXzE2X2JlIChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBSZWFkIE5BVFVSQUxfMTYgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2hpZ2gsIGxfbG93OiBOQVRVUkFMXzE2XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBsX2hpZ2ggOj0gcmVhZF9uYXR1cmFsXzggKHBvcylcbiAgICAgICAgbF9sb3cgOj0gKDB4MDBGRikudG9fbmF0dXJhbF8xNiAmIHJlYWRfbmF0dXJhbF84IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgICAgIFJlc3VsdCA6PSAobF9oaWdoLnRvX25hdHVyYWxfMTYgfDw8IDgpIHwgbF9sb3dcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8xNiAocG9zKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVhZF9uYXR1cmFsXzMyX2JlIChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBSZWFkIE5BVFVSQUxfMzIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2hpZ2gsIGxfbG93OiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBsX2hpZ2ggOj0gcmVhZF9uYXR1cmFsXzE2X2JlIChwb3MpXG4gICAgICAgIGxfbG93IDo9ICgweDAwMDBGRkZGKS50b19uYXR1cmFsXzMyICYgcmVhZF9uYXR1cmFsXzE2X2JlIChwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKVxuICAgICAgICBSZXN1bHQgOj0gKGxfaGlnaC50b19uYXR1cmFsXzMyIHw8PCAxNikgfCBsX2xvd1xuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzMyIChwb3MpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfNjRfYmUgKHBvczogSU5URUdFUik6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfaGlnaCwgbF9sb3c6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgaWYgaXNfbGl0dGxlX2VuZGlhbiB0aGVuXG4gICAgICAgIGxfaGlnaCA6PSByZWFkX25hdHVyYWxfMzJfYmUgKHBvcylcbiAgICAgICAgbF9sb3cgOj0ge05BVFVSQUxfNjR9IDB4MDAwMDAwMDBGRkZGRkZGRiAmIHJlYWRfbmF0dXJhbF8zMl9iZSAocG9zICsgbmF0dXJhbF8zMl9ieXRlcylcbiAgICAgICAgUmVzdWx0IDo9IChsX2hpZ2gudG9fbmF0dXJhbF82NCB8PDwgMzIpIHwgbF9sb3dcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF82NCAocG9zKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzhfYmUgKHBvczogSU5URUdFUik6IElOVEVHRVJfOFxuICAgICAgLS0gUmVhZCBJTlRFR0VSXzggYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfOF9iZSAocG9zKS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfMTZfYmUgKHBvczogSU5URUdFUik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFJlYWQgSU5URUdFUl8xNiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfMTZfYmUgKHBvcykuYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl8zMl9iZSAocG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUmVhZCBJTlRFR0VSIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8zMl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8zMl9iZSAocG9zKS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzY0X2JlIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBSZWFkIElOVEVHRVJfNjQgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzY0X2JlIChwb3MpLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICByZWFkX3JlYWxfMzJfYmUgKHBvczogSU5URUdFUik6IFJFQUxcbiAgICAgIC0tIFJlYWQgUkVBTF8zMiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0MzI6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzMyX2J5dGVzID0gbmF0dXJhbF8zMl9ieXRlc1xuICAgICAgZW5kXG4gICAgICBsX25hdDMyIDo9IHJlYWRfbmF0dXJhbF8zMl9iZSAocG9zKVxuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5ICgkbF9uYXQzMiwgbmF0dXJhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX3JlYWxfNjRfYmUgKHBvczogSU5URUdFUik6IERPVUJMRVxuICAgICAgLS0gUmVhZCBSRUFMXzY0IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgcmVhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9uYXQ2NDogTkFUVVJBTF82NFxuICAgIGRvXG4gICAgICBjaGVja1xuICAgICAgICBjb3JyZWN0X3NpemU6IHJlYWxfNjRfYnl0ZXMgPSBuYXR1cmFsXzY0X2J5dGVzXG4gICAgICBlbmRcbiAgICAgIGxfbmF0NjQgOj0gcmVhZF9uYXR1cmFsXzY0X2JlIChwb3MpXG4gICAgICAoJFJlc3VsdCkubWVtb3J5X2NvcHkgKCRsX25hdDY0LCBuYXR1cmFsXzY0X2J5dGVzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlOiBCaWctZW5kaWFuIGZvcm1hdFxuXG4gIHB1dF9uYXR1cmFsXzhfYmUgKGk6IE5BVFVSQUxfODsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfOF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKGl0ZW0gKyBwb3MpLm1lbW9yeV9jb3B5ICgkaSwgbmF0dXJhbF84X2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX25hdHVyYWxfOF9iZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzE2X2JlIChpOiBOQVRVUkFMXzE2OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgaWYgaXNfbGl0dGxlX2VuZGlhbiB0aGVuXG4gICAgICAgIHB1dF9uYXR1cmFsXzggKCgoKGkgJiAweEZGMDApIHw+PiA4KSAmIDB4MDBGRikudG9fbmF0dXJhbF84LCBwb3MpXG4gICAgICAgIHB1dF9uYXR1cmFsXzggKChpICYgMHgwMEZGKS50b19uYXR1cmFsXzgsIHBvcyArIG5hdHVyYWxfOF9ieXRlcylcbiAgICAgIGVsc2VcbiAgICAgICAgcHV0X25hdHVyYWxfMTYgKGksIHBvcylcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX25hdHVyYWxfMTZfYmUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF8zMl9iZSAoaTogTkFUVVJBTF8zMjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBwdXRfbmF0dXJhbF8xNl9iZSAoKCgoaSAmIDB4RkZGRjAwMDApIHw+PiAxNikgJiAweDAwMDBGRkZGKS50b19uYXR1cmFsXzE2LCBwb3MpXG4gICAgICAgIHB1dF9uYXR1cmFsXzE2X2JlICgoaSAmIDB4MDAwMEZGRkYpLnRvX25hdHVyYWxfMTYsIHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpXG4gICAgICBlbHNlXG4gICAgICAgIHB1dF9uYXR1cmFsXzMyIChpLCBwb3MpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzMyX2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X25hdHVyYWxfNjRfYmUgKGk6IE5BVFVSQUxfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgcHV0X25hdHVyYWxfMzJfYmUgKFxuICAgICAgICAgICgoKGkgJiAweEZGRkZGRkZGMDAwMDAwMDApIHw+PiAzMikgJiAweDAwMDAwMDAwRkZGRkZGRkYpLnRvX25hdHVyYWxfMzIsIHBvcylcbiAgICAgICAgcHV0X25hdHVyYWxfMzJfYmUgKChpICYgMHgwMDAwMDAwMEZGRkZGRkZGKS50b19uYXR1cmFsXzMyLFxuICAgICAgICAgIHBvcyArIG5hdHVyYWxfMzJfYnl0ZXMpXG4gICAgICBlbHNlXG4gICAgICAgIHB1dF9uYXR1cmFsXzY0IChpLCBwb3MpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzY0X2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfOF9iZSAoaTogSU5URUdFUl84OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF84X2JlIChpLmFzX25hdHVyYWxfOCwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfOF9iZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzE2X2JlIChpOiBJTlRFR0VSXzE2OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgcHV0X25hdHVyYWxfMTZfYmUgKGkuYXNfbmF0dXJhbF8xNiwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfMTZfYmUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl8zMl9iZSAoaTogSU5URUdFUjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzMyX2JlIChpLmFzX25hdHVyYWxfMzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9pbnRlZ2VyXzMyX2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfNjRfYmUgKGk6IElOVEVHRVJfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF82NF9iZSAoaS5hc19uYXR1cmFsXzY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl82NF9iZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9yZWFsXzMyX2JlICh2OiBSRUFMOyBwb3M6IElOVEVHRVJfMzIpXG4gICAgICAtLSBJbnNlcnQgYHYnIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgcmVhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9uYXQzMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBjaGVja1xuICAgICAgICBjb3JyZWN0X3NpemU6IHJlYWxfMzJfYnl0ZXMgPSBuYXR1cmFsXzMyX2J5dGVzXG4gICAgICBlbmRcbiAgICAgICgkbF9uYXQzMikubWVtb3J5X2NvcHkgKCR2LCBuYXR1cmFsXzMyX2J5dGVzKVxuICAgICAgcHV0X25hdHVyYWxfMzJfYmUgKGxfbmF0MzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiB2ID0gcmVhZF9yZWFsXzMyX2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X3JlYWxfNjRfYmUgKHY6IERPVUJMRTsgcG9zOiBJTlRFR0VSXzMyKVxuICAgICAgLS0gSW5zZXJ0IGB2JyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0NjQ6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzY0X2J5dGVzID0gbmF0dXJhbF82NF9ieXRlc1xuICAgICAgZW5kXG4gICAgICAoJGxfbmF0NjQpLm1lbW9yeV9jb3B5ICgkdiwgbmF0dXJhbF82NF9ieXRlcylcbiAgICAgIHB1dF9uYXR1cmFsXzY0X2JlIChsX25hdDY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogdiA9IHJlYWRfcmVhbF82NF9iZSAocG9zKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbmNhdGVuYXRpb25cblxuICBhcHBlbmQgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBBcHBlbmQgYG90aGVyJyBhdCB0aGUgZW5kIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3NoYXJlZDogbm90IGlzX3NoYXJlZFxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmV3X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5ld19jb3VudCA6PSBjb3VudCArIG90aGVyLmNvdW50XG4gICAgICBpdGVtIDo9IGl0ZW0ubWVtb3J5X3JlYWxsb2MgKG5ld19jb3VudC5tYXggKDEpKVxuICAgICAgaWYgaXRlbSA9IGRlZmF1bHRfcG9pbnRlciB0aGVuXG4gICAgICAgIChjcmVhdGUge0VYQ0VQVElPTlN9KS5yYWlzZSAoXCJObyBtb3JlIG1lbW9yeVwiKVxuICAgICAgZW5kXG4gICAgICAoaXRlbSArIGNvdW50KS5tZW1vcnlfY29weSAob3RoZXIuaXRlbSwgb3RoZXIuY291bnQpXG4gICAgICBjb3VudCA6PSBuZXdfY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIHJlc2l6ZSAobjogSU5URUdFUilcbiAgICAgIC0tIFJlYWxsb2NhdGUgYGl0ZW0nIHRvIGhvbGQgYG4nIGJ5dGVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5vdF9zaGFyZWQ6IG5vdCBpc19zaGFyZWRcbiAgICBkb1xuICAgICAgICAtLSBSZWFsbG9jYXRlLlxuICAgICAgaWYgbiAvPSBjb3VudCB0aGVuXG4gICAgICAgIGl0ZW0gOj0gaXRlbS5tZW1vcnlfcmVhbGxvYyAobi5tYXggKDEpKVxuICAgICAgICBpZiBpdGVtID0gZGVmYXVsdF9wb2ludGVyIHRoZW5cbiAgICAgICAgICAoY3JlYXRlIHtFWENFUFRJT05TfSkucmFpc2UgKFwiTm8gbW9yZSBtZW1vcnlcIilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgICAtLSBSZXNldCBuZXdseSBhbGxvY2F0ZWQgbWVtb3J5IHRvIGAwJy5cbiAgICAgICAgKGl0ZW0gKyBjb3VudCkubWVtb3J5X3NldCAoMCwgbiAtIGNvdW50KVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBuXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIERpc3Bvc2FsXG5cbiAgZGlzcG9zZVxuICAgICAgLS0gUmVsZWFzZSBtZW1vcnkgcG9pbnRlZCBieSBgaXRlbScuXG4gICAgbG9jYWxcbiAgICAgIG51bGw6IFBPSU5URVJcbiAgICBkb1xuICAgICAgaWYgbm90IGlzX3NoYXJlZCB0aGVuXG4gICAgICAgIGl0ZW0ubWVtb3J5X2ZyZWVcbiAgICAgIGVuZFxuICAgICAgaXRlbSA6PSBudWxsXG4gICAgICBpc19zaGFyZWQgOj0gRmFsc2VcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2hhcmVkX3Jlc2V0OiBub3QgaXNfc2hhcmVkXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIERlYnVnZ2luZ1xuXG4gIGFsbG9jYXRpb25fY291bnRlcjogQ0VMTCBbTkFUVVJBTF82NF1cbiAgICAgIC0tIFN0b3JlIGN1cnJlbnQgbnVtYmVyIG9mIGFsbG9jYXRpb24gYmVpbmcgbWFkZS5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0LnB1dCAoMClcbiAgICBlbmRcblxuICBjb3VudGVyOiBOQVRVUkFMXzY0IG5vdGUgb3B0aW9uOiB0cmFuc2llbnQgYXR0cmlidXRlIGVuZFxuICAgICAgLS0gQWxsb2NhdGlvbiBudW1iZXIgYXNzb2NpYXRlZCB0byBDdXJyZW50LlxuXG4gIGluY3JlbWVudF9jb3VudGVyXG4gICAgICAtLSBTZXQgYGNvdW50ZXInIHdpdGggYSBuZXcgYWxsb2NhdGlvbiBudW1iZXIuXG4gICAgZG9cbiAgICAgIGRlYnVnIChcIk1BTkFHRURfUE9JTlRFUl9hbGxvY2F0aW9uXCIpXG4gICAgICAgIGNvdW50ZXIgOj0gYWxsb2NhdGlvbl9jb3VudGVyLml0ZW0gKyAxXG4gICAgICAgIGFsbG9jYXRpb25fY291bnRlci5wdXQgKGNvdW50ZXIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuXG5pbnZhcmlhbnRcbiAgaXRlbV9ub3RfbnVsbDogaXRlbSA9IGRlZmF1bHRfcG9pbnRlciBpbXBsaWVzIChjb3VudCA9IDAgYW5kIGlzX3NoYXJlZClcbiAgdmFsaWRfY291bnQ6IGNvdW50ID49IDBcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuXG5mZWF0dXJlIC0tIENvcnJlY3Rpb25cblxuICBjb3JyZWN0X21pc21hdGNoXG4gICAgICAtLSBBdHRlbXB0IHRvIGNvcnJlY3Qgb2JqZWN0IG1pc21hdGNoIHVzaW5nIGBtaXNtYXRjaF9pbmZvcm1hdGlvbicuXG4gICAgbG9jYWxcbiAgICAgIGxfbXNnOiBTVFJJTkdcbiAgICAgIGxfZXhjOiBFWENFUFRJT05TXG4gICAgZG9cbiAgICAgICAgLS0gSWYgaXQgaXMgbm90IHJlZGVmaW5lZCB0aGVuIHdlIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgIGNyZWF0ZSBsX21zZy5tYWtlX2Zyb21fc3RyaW5nIChcIk1pc21hdGNoOiBcIilcbiAgICAgIGNyZWF0ZSBsX2V4Y1xuICAgICAgbF9tc2cuYXBwZW5kIChnZW5lcmF0aW5nX3R5cGUpXG4gICAgICBsX2V4Yy5yYWlzZV9yZXRyaWV2YWxfZXhjZXB0aW9uIChsX21zZylcbiAgICBlbmRcblxuICBtaXNtYXRjaF9pbmZvcm1hdGlvbjogTUlTTUFUQ0hfSU5GT1JNQVRJT05cbiAgICAgIC0tIE9yaWdpbmFsIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgbWlzbWF0Y2hlZCBvYmplY3RcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkZha2UgYWJzdHJhY3Rpb24gb2YgYSAuTkVUIE5BVElWRV9BUlJBWSBpbiBhIG5vbi0uTkVUIHN5c3RlbVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wNC0yMyAxNDo0OTowMiAtMDcwMCAoVHVlLCAyMyBBcHIgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI0NzAgJFwiXG5cbmZyb3plbiBjbGFzc1xuICBOQVRJVkVfQVJSQVkgW0ddXG5cbmludmFyaWFudFxuICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJVbnNpZ25lZCBpbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiAxNiBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uVUludDE2XCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgTkFUVVJBTF8xNlxuXG5pbmhlcml0XG4gIE5BVFVSQUxfMTZfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIGlkZW50aXR5LFxuICAgICAgYXNfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbF8zMixcbiAgICAgIHRvX3JlYWxfNjQsXG4gICAgICB0b19jaGFyYWN0ZXJfOCxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMixcbiAgICAgIGJpdF9hbmQsXG4gICAgICBiaXRfb3IsXG4gICAgICBiaXRfeG9yLFxuICAgICAgYml0X25vdCxcbiAgICAgIGJpdF9zaGlmdF9sZWZ0LFxuICAgICAgYml0X3NoaWZ0X3JpZ2h0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtOQVRVUkFMXzE2X1JFRn0pLFxuICB0b19yZWFsXzMyOiB7UkVBTF8zMn0sXG4gIHRvX3JlYWxfNjQ6IHtSRUFMXzY0fSxcbiAgdG9faW50ZWdlcl8zMjoge0lOVEVHRVJfMzJ9LFxuICB0b19pbnRlZ2VyXzY0OiB7SU5URUdFUl82NH0sXG4gIHRvX25hdHVyYWxfMzI6IHtOQVRVUkFMXzMyfSxcbiAgdG9fbmF0dXJhbF82NDoge05BVFVSQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzE2KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfMTYpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF8xNik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF8xNik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfMTZcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IE5BVFVSQUxfMTYpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogTkFUVVJBTF8xNik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBOQVRVUkFMXzE2XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF8xNlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDE2IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBOQVRVUkFMXzE2X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfMTZcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXJfY29kZTogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIE1pbl92YWx1ZTogTkFUVVJBTF8xNiA9IDBcbiAgTWF4X3ZhbHVlOiBOQVRVUkFMXzE2ID0gNjU1MzVcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIE1ha2UgYGknIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBkaXZpZGVkIGJ5IGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtIC89IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsdWU6IFJlc3VsdCA9IChvdGhlci5pdGVtIC89IDApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF8zMl9SRUZ9IG90aGVyIGFzIHJlYWxfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhbF92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IG90aGVyIGFzIGRvdWJsZV92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkb3VibGVfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDApIG9yXG4gICAgICAgIChvdGhlci5jb25mb3Jtc190byAoMC4wKSBhbmQgaXRlbSA+IDApKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgaWYgaXQgaXMgbm90IGl0cyB0eXBlJ3MgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfMzJ9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICB1bmFwcGxpY2FibGVfb3Bwb3NpdGU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbm90X2FwcGxpY2FibGU6IEZhbHNlXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSBcXFxcIG90aGVyLml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpbnRlcnZhbCBhbGlhcyBcInwuLnxcIiAob3RoZXI6IElOVEVHRVIpOiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBJbnRlcnZhbCBmcm9tIGN1cnJlbnQgZWxlbWVudCB0byBgb3RoZXInXG4gICAgICAtLSAoZW1wdHkgaWYgYG90aGVyJyBsZXNzIHRoYW4gY3VycmVudCBpbnRlZ2VyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGl0ZW0sIG90aGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBDb252ZXJzaW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogTkFUVVJBTF8xNl9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBOQVRVUkFMXzE2X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtOQVRVUkFMXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8xNlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8xNn0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfMTZcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8xNl9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHhGKVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8xNl9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbS50b19pbnRlZ2VyXzMyXG4gICAgICBpZiB0bXAgPD0gOSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodG1wICsgKCcwJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9ICgoJ0EnKS5jb2RlICsgKHRtcCAtIDEwKSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLmhhcyAoUmVzdWx0KVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18xNjogbiA8PSAxNlxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzE2OiBuID49IC0xNlxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18xNjogbiA8PSAxNlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMTY6IG4gPD0gMTZcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzE2OiBuIDwgMTZcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfMTYgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzE2OiBuIDwgMTZcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzE2IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF8xNiB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICg1KVxuICAgICAgUmVzdWx0LmFwcGVuZF9uYXR1cmFsXzE2IChpdGVtKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiVW5zaWduZWQgaW50ZWdlciB2YWx1ZXMgY29kZWQgb24gMzIgYml0cy5cIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5VSW50MzJcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzMyIGluaGVyaXRcblxuICBOQVRVUkFMXzMyX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWxfMzIsXG4gICAgICB0b19yZWFsXzY0LFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7TkFUVVJBTF8zMl9SRUZ9KSxcbiAgdG9fcmVhbF8zMjoge1JFQUxfMzJ9LFxuICB0b19yZWFsXzY0OiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfNjQ6IHtJTlRFR0VSXzY0fSxcbiAgdG9fbmF0dXJhbF82NDoge05BVFVSQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQ0hBUkFDVEVSXzMyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogTkFUVVJBTF8zMlxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiAzMiBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgTkFUVVJBTF8zMl9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIixcbiAgICAgIG9wcG9zaXRlIGFzIHVuYXBwbGljYWJsZV9vcHBvc2l0ZVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBOQVRVUkFMXzMyXG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgICAgLS0gQ2xlYXIgc2lnbiBiaXQuXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0gJiAweDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBOQVRVUkFMXzMyID0gMFxuICBNYXhfdmFsdWU6IE5BVFVSQUxfMzIgPSA0Mjk0OTY3Mjk1XG4gICAgICAtLSBNaW5pbXVtIGFuZCBNYXhpbXVtIHZhbHVlIGhvbGQgaW4gYGl0ZW0nLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoXG4gICAgICAgIGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUudG9fbmF0dXJhbF8zMiBhbmRcbiAgICAgICAgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIHVuYXBwbGljYWJsZV9vcHBvc2l0ZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBub3RfYXBwbGljYWJsZTogRmFsc2VcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IE5BVFVSQUxfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzE2fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMzJ9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXzMyXG4gICAgZW5kXG5cbiAgdG9fcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF82NFxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQsIHZhbDogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAweEYpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtLnRvX2ludGVnZXJfMzJcbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQ0hBUkFDVEVSXzMyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzMyOiBuID49IC0zMlxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfMzIgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzMyIHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF8zMiB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgyMClcbiAgICAgIFJlc3VsdC5hcHBlbmRfbmF0dXJhbF8zMiAoaXRlbSlcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlVuc2lnbmVkIGludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDY0IGJpdHNcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5VSW50NjRcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzY0XG5cbmluaGVyaXRcbiAgTkFUVVJBTF82NF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsXzMyLFxuICAgICAgdG9fcmVhbF82NCxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe05BVFVSQUxfNjRfUkVGfSksXG4gIHRvX3JlYWxfMzI6IHtSRUFMXzMyfSxcbiAgdG9fcmVhbF82NDoge1JFQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzY0KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfNjQpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF82NCk6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IE5BVFVSQUxfNjQpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogTkFUVVJBTF82NCk6IE5BVFVSQUxfNjRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBOQVRVUkFMXzY0XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF82NFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDY0IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBOQVRVUkFMXzY0X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfNjRcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgICAtLSBHZXQgdGhlIHBvc2l0aXZlIHZhbHVlIG9mIGBpdGVtJyBhbmQgdGhlbiBkb1xuICAgICAgICAtLSBhIG1vZHVsbyBvbiB0aGUgbWF4aW11bSBJTlRFR0VSXzMyIHZhbHVlLlxuICAgICAgUmVzdWx0IDo9IChpdGVtICYgMHgwMDAwMDAwMDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBOQVRVUkFMXzY0ID0gMFxuICBNYXhfdmFsdWU6IE5BVFVSQUxfNjQgPSAxODQ0Njc0NDA3MzcwOTU1MTYxNVxuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfNjRcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKFxuICAgICAgICBpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlLnRvX25hdHVyYWxfNjQgYW5kXG4gICAgICAgIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF82NClcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl8zMn0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgdW5hcHBsaWNhYmxlX29wcG9zaXRlOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5vdF9hcHBsaWNhYmxlOiBGYWxzZVxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLy8gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gXFxcXCBvdGhlci5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBeIG90aGVyICsgMFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IE5BVFVSQUxfNjRfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF82NF9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMzJ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8xNn0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzMyfS5NYXhfdmFsdWUudG9fbmF0dXJhbF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfNjR9Lk1heF92YWx1ZS50b19uYXR1cmFsXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICB2YWw6IE5BVFVSQUxfNjRcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl82NF9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHgwRikudG9faW50ZWdlcl8zMlxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl82NF9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbS50b19pbnRlZ2VyXzMyXG4gICAgICBpZiB0bXAgPD0gOSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodG1wICsgKCcwJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9ICgoJ0EnKS5jb2RlICsgKHRtcCAtIDEwKSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLmhhcyAoUmVzdWx0KVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b182NDogbiA8PSA2NFxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzY0OiBuID49IC02NFxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b182NDogbiA8PSA2NFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fNjQ6IG4gPD0gNjRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzY0OiBuIDwgNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfNjQgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzY0OiBuIDwgNjRcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzY0IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF82NCB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgyMClcbiAgICAgIFJlc3VsdC5hcHBlbmRfbmF0dXJhbF82NCAoaXRlbSlcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDggYml0c1wiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLkJ5dGVcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzggaW5oZXJpdFxuXG4gIE5BVFVSQUxfOF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsXzMyLFxuICAgICAgdG9fcmVhbF82NCxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe05BVFVSQUxfOF9SRUZ9KSxcbiAgdG9fcmVhbF8zMjoge1JFQUxfMzJ9LFxuICB0b19yZWFsXzY0OiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfMTY6IHtJTlRFR0VSXzE2fSxcbiAgdG9faW50ZWdlcl8zMjoge0lOVEVHRVJfMzJ9LFxuICB0b19pbnRlZ2VyXzY0OiB7SU5URUdFUl82NH0sXG4gIHRvX25hdHVyYWxfMTY6IHtOQVRVUkFMXzE2fSxcbiAgdG9fbmF0dXJhbF8zMjoge05BVFVSQUxfMzJ9LFxuICB0b19uYXR1cmFsXzY0OiB7TkFUVVJBTF82NH1cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IE5BVFVSQUxfOCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IE5BVFVSQUxfOCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfOFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogTkFUVVJBTF84XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGFuIGludGVnZXIgdmFsdWUgY29kZWQgb24gOCBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgTkFUVVJBTF84X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfOFxuICAgICAgLS0gSW50ZWdlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIHNpZ246IElOVEVHRVJcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVsc2VpZiBpdGVtIDwgMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDEpXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDApXG4gICAgZW5kXG5cbiAgYXNjaWlfY2hhcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0b19jaGFyYWN0ZXJfOCBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IE5BVFVSQUxfOCA9IDBcbiAgTWF4X3ZhbHVlOiBOQVRVUkFMXzggPSAyNTVcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogTkFUVVJBTF84KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIHVuYXBwbGljYWJsZV9vcHBvc2l0ZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBub3RfYXBwbGljYWJsZTogRmFsc2VcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBOQVRVUkFMXzhfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiBWIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDJcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMTUpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gMlxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtXG4gICAgICBSZXN1bHQgOj0gdG1wLnRvX2hleF9jaGFyYWN0ZXJcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X2FuZCAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfYW5kX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9vciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2Vfb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfeG9yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV94b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X25vdDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfbm90KVxuICAgIGVuc3VyZVxuICAgICAgYml0X25vdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3NoaWZ0IChuOiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b184OiBuIDw9IDhcbiAgICAgIG5fZ3JlYXRlcl9vcl9lcXVhbF90b19taW51c184OiBuID49IC04XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzg6IG4gPD0gOFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fODogbiA8PSA4XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfcmlnaHQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X3JpZ2h0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfdGVzdCAobjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRlc3QgYG4nLXRoIHBvc2l0aW9uIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl84OiBuIDwgOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKSAvPSAwXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXQgKGI6IEJPT0xFQU47IG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzg6IG4gPCA4XG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8ICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgzKVxuICAgICAgUmVzdWx0LmFwcGVuZF9uYXR1cmFsXzggKGl0ZW0pXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG5cbiAgTlVNRVJJQ1xuXG5pbmhlcml0XG4gIERFQlVHX09VVFBVVFxuICAgIHJlbmFtZVxuICAgICAgZGVidWdfb3V0cHV0IGFzIG91dFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIG9ic29sZXRlXG4gICAgICBcIlsyMDA4XzA0XzAxXSBXaWxsIGJlIHJlbW92ZWQgc2luY2Ugbm90IHVzZWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInIChjb21tdXRhdGl2ZSkuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBjb21tdXRhdGl2ZTogUmVzdWx0IH4gKG90aGVyICsgQ3VycmVudClcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuLS0gIG5ldXRyYWxfYWRkaXRpb246IGVxdWFsIChDdXJyZW50ICsgemVybywgQ3VycmVudCk7XG4tLSAgc2VsZl9zdWJ0cmFjdGlvbjogZXF1YWwgKEN1cnJlbnQgLSBDdXJyZW50LCB6ZXJvKTtcbi0tICBuZXV0cmFsX211bHRpcGxpY2F0aW9uOiBlcXVhbCAoQ3VycmVudCAqIG9uZSwgQ3VycmVudCk7XG4tLSAgc2VsZl9kaXZpc2lvbjogZGl2aXNpYmxlIChDdXJyZW50KSBpbXBsaWVzIGVxdWFsIChDdXJyZW50IC8gQ3VycmVudCwgb25lKVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiT2JqZWN0cyB0aGF0IG1heSBiZSBjb21wYXJlZCBhY2NvcmRpbmcgdG8gYSBwYXJ0aWFsIG9yZGVyIHJlbGF0aW9uXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgUEFSVF9DT01QQVJBQkxFXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX2xlc3NfZXF1YWwgYWxpYXMgXCI8PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoQ3VycmVudCA8IG90aGVyKSBvciAoQ3VycmVudCB+IG90aGVyKVxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXIgYWxpYXMgXCI+XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyIDwgQ3VycmVudFxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXJfZXF1YWwgYWxpYXMgXCI+PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAob3RoZXIgPCBDdXJyZW50KSBvciAoQ3VycmVudCB+IG90aGVyKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUGxhdGZvcm0tZGVwZW5kZW50IHByb3BlcnRpZXMuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA2LTE1IDEyOjM0OjMyIC0wNzAwIChGcmksIDE1IEp1biAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4NCAkXCJcblxuY2xhc3MgUExBVEZPUk1cblxuZmVhdHVyZSAtLSBQbGF0Zm9ybVxuXG4gIGlzX3RocmVhZF9jYXBhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHBsYXRmb3JtIGNhcGFibGUgb2YgbXVsdGktdGhyZWFkaW5nP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfc2Nvb3BfY2FwYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBwbGF0Zm9ybSBjYXBhYmxlIG9mIFNDT09QP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfZG90bmV0OiBCT09MRUFOXG4gICAgICAtLSBBcmUgd2UgdGFyZ2V0dGluZyAuTkVUP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfd2luZG93czogQk9PTEVBTlxuICAgICAgLS0gQXJlIHdlIHJ1bm5pbmcgb24gV2luZG93cyBwbGF0Zm9ybT9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIGlzX3VuaXg6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBydW5uaW5nIG9uIGEgVW5peCBsaWtlIHBsYXRmb3JtP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfdm1zOiBCT09MRUFOXG4gICAgICAtLSBBcmUgd2UgcnVubmluZyBvbiBWTVM/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBpc19tYWM6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBydW5uaW5nIG9uIE1hYyBPUz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIGlzX3Z4d29ya3M6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBydW5uaW5nIG9uIFZ4V29ya3M/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBpc19saXR0bGVfZW5kaWFuOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHBsYXRmb3JtIGEgbGl0dGxlIGVuZGlhbiBvbmU/XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0MTY6IE5BVFVSQUxfMTZcbiAgICAgIGxfbmF0ODogTkFUVVJBTF84XG4gICAgICBsX2ZpcnN0OiBOQVRVUkFMXzhcbiAgICBvbmNlXG4gICAgICBsX25hdDE2IDo9IDB4NDMyMVxuICAgICAgbF9uYXQ4IDo9IDB4MjFcbiAgICAgICgkbF9maXJzdCkubWVtb3J5X2NvcHkgKCRsX25hdDE2LCAxKVxuICAgICAgUmVzdWx0IDo9IGxfZmlyc3QgPSBsX25hdDhcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3MgYnl0ZXMgc2l6ZVxuXG4gIGJvb2xlYW5fYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYEJPT0xFQU4nXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfOF9ieXRlczogSU5URUdFUiA9IDFcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl84J1xuXG4gIGNoYXJhY3Rlcl8zMl9ieXRlczogSU5URUdFUiA9IDRcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl8zMidcblxuICBuYXR1cmFsXzhfYnl0ZXM6IElOVEVHRVIgPSAxXG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBOQVRVUkFMXzgnXG5cbiAgbmF0dXJhbF8xNl9ieXRlczogSU5URUdFUiA9IDJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfMTYnXG5cbiAgbmF0dXJhbF8zMl9ieXRlczogSU5URUdFUiA9IDRcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfMzInXG5cbiAgbmF0dXJhbF82NF9ieXRlczogSU5URUdFUiA9IDhcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfNjQnXG5cbiAgaW50ZWdlcl84X2J5dGVzOiBJTlRFR0VSID0gMVxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl84J1xuXG4gIGludGVnZXJfMTZfYnl0ZXM6IElOVEVHRVIgPSAyXG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzE2J1xuXG4gIGludGVnZXJfMzJfYnl0ZXM6IElOVEVHRVIgPSA0XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzMyJ1xuXG4gIGludGVnZXJfNjRfYnl0ZXM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzY0J1xuXG4gIHJlYWxfMzJfYnl0ZXM6IElOVEVHRVIgPSA0XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzMyJ1xuXG4gIHJlYWxfNjRfYnl0ZXM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzY0J1xuXG4gIHBvaW50ZXJfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYFBPSU5URVInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3MgYml0cyBzaXplXG5cbiAgYm9vbGVhbl9iaXRzOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYEJPT0xFQU4nXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBib29sZWFuX2J5dGVzICogOFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl84X2JpdHM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl84J1xuXG4gIGNoYXJhY3Rlcl8zMl9iaXRzOiBJTlRFR0VSID0gMzJcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgQ0hBUkFDVEVSXzMyJ1xuXG4gIG5hdHVyYWxfOF9iaXRzOiBJTlRFR0VSID0gOFxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBOQVRVUkFMXzgnXG5cbiAgbmF0dXJhbF8xNl9iaXRzOiBJTlRFR0VSID0gMTZcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgTkFUVVJBTF8xNidcblxuICBuYXR1cmFsXzMyX2JpdHM6IElOVEVHRVIgPSAzMlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBOQVRVUkFMXzMyJ1xuXG4gIG5hdHVyYWxfNjRfYml0czogSU5URUdFUiA9IDY0XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfNjQnXG5cbiAgaW50ZWdlcl84X2JpdHM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYElOVEVHRVJfOCdcblxuICBpbnRlZ2VyXzE2X2JpdHM6IElOVEVHRVIgPSAxNlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzE2J1xuXG4gIGludGVnZXJfMzJfYml0czogSU5URUdFUiA9IDMyXG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYElOVEVHRVJfMzInXG5cbiAgaW50ZWdlcl82NF9iaXRzOiBJTlRFR0VSID0gNjRcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl82NCdcblxuICByZWFsXzMyX2JpdHM6IElOVEVHRVIgPSAzMlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzMyJ1xuXG4gIHJlYWxfNjRfYml0czogSU5URUdFUiA9IDY0XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYFJFQUxfNjQnXG5cbiAgcG9pbnRlcl9iaXRzOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYFBPSU5URVInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwb2ludGVyX2J5dGVzICogOFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE9ic29sZXRlc1xuXG4gIGNoYXJhY3Rlcl9ieXRlczogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIGluIGEgdmFsdWUgb2YgdHlwZSBgQ0hBUkFDVEVSXzgnXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBjaGFyYWN0ZXJfOF9ieXRlcycgaW5zdGVhZC5cIlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgd2lkZV9jaGFyYWN0ZXJfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGNoYXJhY3Rlcl8zMl9ieXRlcycgaW5zdGVhZC5cIlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9ieXRlczogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGludGVnZXJfMzJfYnl0ZXMnIGluc3RlYWQuXCJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIHJlYWxfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYFJFQUxfMzInXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGByZWFsXzMyX2J5dGVzJyBpbnN0ZWFkLlwiXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBkb3VibGVfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYFJFQUxfNjQnXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGByZWFsXzY0X2J5dGVzJyBpbnN0ZWFkLlwiXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfYml0czogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBDSEFSQUNURVJfOCdcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGNoYXJhY3Rlcl84X2JpdHMnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IDhcbiAgICBlbmRcblxuICBpbnRlZ2VyX2JpdHM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGludGVnZXJfMzJfYml0cycgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gMzJcbiAgICBlbmRcblxuICByZWFsX2JpdHM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgUkVBTF8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHJlYWxfMzJfYml0cycgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gMzJcbiAgICBlbmRcblxuICBkb3VibGVfYml0czogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzY0J1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgcmVhbF82NF9iaXRzJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSA2NFxuICAgIGVuZFxuXG4gIG1heGltdW1fY2hhcmFjdGVyX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIExhcmdlc3Qgc3VwcG9ydGVkIGNvZGUgZm9yIENIQVJBQ1RFUl84IHZhbHVlc1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBge0NIQVJBQ1RFUn0ubWF4X3ZhbHVlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB7Q0hBUkFDVEVSfS5tYXhfdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIG1lYW5pbmdmdWw6IFJlc3VsdCA+PSAxMjdcbiAgICBlbmRcblxuICBtYXhpbXVtX2ludGVnZXI6IElOVEVHRVJcbiAgICAgIC0tIExhcmdlc3Qgc3VwcG9ydGVkIHZhbHVlIG9mIHR5cGUgSU5URUdFUl8zMlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBge0lOVEVHRVJ9Lm1heF92YWx1ZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0ge0lOVEVHRVJ9Lm1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgbWVhbmluZ2Z1bDogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBtaW5pbXVtX2NoYXJhY3Rlcl9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBTbWFsbGVzdCBzdXBwb3J0ZWQgY29kZSBmb3IgQ0hBUkFDVEVSXzggdmFsdWVzXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB7Q0hBUkFDVEVSfS5taW5fdmFsdWUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHtDSEFSQUNURVJ9Lm1pbl92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgbWVhbmluZ2Z1bDogUmVzdWx0IDw9IDBcbiAgICBlbmRcblxuICBtaW5pbXVtX2ludGVnZXI6IElOVEVHRVJcbiAgICAgIC0tIFNtYWxsZXN0IHN1cHBvcnRlZCB2YWx1ZSBvZiB0eXBlIElOVEVHRVJfMzJcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHtJTlRFR0VSfS5taW5fdmFsdWUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHtJTlRFR0VSfS5taW5fdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIG1lYW5pbmdmdWw6IFJlc3VsdCA8PSAwXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgbWVhbnQgdG8gYmUgZXhjaGFuZ2VkIHdpdGggbm9uLUVpZmZlbCBzb2Z0d2FyZS5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgUE9JTlRFUiBpbmhlcml0XG5cbiAgUE9JTlRFUl9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaGFzaF9jb2RlLFxuICAgICAgcGx1cyxcbiAgICAgIHRvX2ludGVnZXJfMzIsXG4gICAgICBpc19kZWZhdWx0X3BvaW50ZXIsXG4gICAgICBvdXRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe1BPSU5URVJfUkVGfSlcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfZGVmYXVsdF9wb2ludGVyOiBCT09MRUFOXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob2Zmc2V0OiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gUG9pbnRlciBtb3ZlZCBieSBhbiBvZmZzZXQgb2YgYG9mZnNldCcgYnl0ZXMuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcG9pbnRlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyByZWZlcmVuY2UgdG8gb2JqZWN0XG4gICAgbWVhbnQgdG8gYmUgZXhjaGFuZ2VkIHdpdGggbm9uLUVpZmZlbCBzb2Z0d2FyZS5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3MgUE9JTlRFUl9SRUZcbmluaGVyaXRcbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbCwgaXNfaGFzaGFibGVcbiAgICBlbmRcblxuICBSRUZBQ1RPUklOR19IRUxQRVJcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IFBPSU5URVJcbiAgICAgIC0tIFBvaW50ZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaGFzaF9jb2RlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmcm96ZW4gc2V0X2l0ZW0gKHA6IFBPSU5URVIpXG4gICAgICAtLSBNYWtlIGBwJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZW5kXG5cbiAgaXNfZGVmYXVsdF9wb2ludGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGBkZWZhdWx0X3BvaW50ZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA9IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGl0ZW0gPSBkZWZhdWx0X3BvaW50ZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG9mZnNldDogSU5URUdFUik6IFBPSU5URVJcbiAgICAgIC0tIFBvaW50ZXIgbW92ZWQgYnkgYW4gb2Zmc2V0IG9mIGBvZmZzZXQnIGJ5dGVzLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSArIG9mZnNldFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IFBPSU5URVJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogUE9JTlRFUl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICByZXF1aXJlXG4tLSAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMzJ9Lk1pbl92YWx1ZVxuLS0gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8zMn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIC0tIFRPRE86IEZpeCBPTkNFIGFyZ3VtZW50c1xuICAgICAgLS1maXhtZSAob25jZSBcIkRvIG5vdCBmb3JnZXQgdG8gYWRkIHByb3BlciBwcmVjb25kaXRpb24gdG8gZW5zdXJlIHdlIGNhbiBjb252ZXJ0IHBvaW50ZXIgJVxuICAgICAgLS0gICV2YWx1ZSBpbnRvIGFuIElOVEVHRVJfMzJcIilcbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2ludGVnZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZW1vcnkgY29weVxuXG4gIG1lbW9yeV9jb3B5IChhX3NvdXJjZTogUE9JTlRFUjsgYV9zaXplOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBgYV9zaXplJyBieXRlcyBmcm9tIGBhX3NvdXJjZScgdG8gYEN1cnJlbnQnLlxuICAgICAgLS0gYGFfc291cmNlJyBhbmQgYEN1cnJlbnQnIHNob3VsZCBub3Qgb3ZlcmxhcC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zaXplOiBhX3NpemUgPj0gMFxuICAgICAgdmFsaWRfc291cmNlOiBhX3NvdXJjZSAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBkb1xuICAgICAgY19tZW1jcHkgKGl0ZW0sIGFfc291cmNlLCBhX3NpemUpXG4gICAgZW5kXG5cbiAgbWVtb3J5X21vdmUgKGFfc291cmNlOiBQT0lOVEVSOyBhX3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGBhX3NpemUnIGJ5dGVzIGZyb20gYGFfc291cmNlJyB0byBgQ3VycmVudCcuXG4gICAgICAtLSBgYV9zb3VyY2UnIGFuZCBgQ3VycmVudCcgY2FuIG92ZXJsYXAuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc2l6ZTogYV9zaXplID49IDBcbiAgICAgIHZhbGlkX3NvdXJjZTogYV9zb3VyY2UgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIGNfbWVtbW92ZSAoaXRlbSwgYV9zb3VyY2UsIGFfc2l6ZSlcbiAgICBlbmRcblxuICBtZW1vcnlfc2V0ICh2YWwsIG46IElOVEVHRVIpXG4gICAgICAtLSBGaWxsIGZpcnN0IGBuJyBieXRlcyBvZiB0aGUgbWVtb3J5IHBvaW50ZWQgYnkgYEN1cnJlbnQnXG4gICAgICAtLSB3aXRoIGNvbnN0YW50IGB2YWwnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3ZhbDogdmFsID49IDBcbiAgICAgIHZhbGlkX246IG4gPj0gMFxuICAgIGRvXG4gICAgICBjX21lbXNldCAoaXRlbSwgdmFsLCBuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFsbG9jYXRpb24vZnJlZVxuXG4gIG1lbW9yeV9hbGxvYyAoYV9zaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQWxsb2NhdGVkIGBzaXplJyBieXRlcyB1c2luZyBgbWFsbG9jJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zaXplOiBhX3NpemUgPiAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjX21hbGxvYyAoYV9zaXplKVxuICAgIGVuZFxuXG4gIG1lbW9yeV9jYWxsb2MgKGFfY291bnQsIGFfZWxlbWVudF9zaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQWxsb2NhdGUgYGFfY291bnQnIGVsZW1lbnRzIG9mIHNpemUgYGFfZWxlbWVudF9zaXplJyBieXRlcyB1c2luZyBgY2FsbG9jLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2VsZW1lbnRfY291bnQ6IGFfY291bnQgPiAwXG4gICAgICB2YWxpZF9lbGVtZW50X3NpemU6IGFfZWxlbWVudF9zaXplID4gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19jYWxsb2MgKGFfY291bnQsIGFfZWxlbWVudF9zaXplKVxuICAgIGVuZFxuXG4gIG1lbW9yeV9yZWFsbG9jIChhX3NpemU6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBSZWFsbG9jIGBDdXJyZW50Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zaXplOiBhX3NpemUgPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19yZWFsbG9jIChpdGVtLCBhX3NpemUpXG4gICAgZW5kXG5cbiAgbWVtb3J5X2ZyZWVcbiAgICAgIC0tIEZyZWUgYWxsb2NhdGVkIG1lbW9yeSB3aXRoIGBtYWxsb2MnLlxuICAgIGRvXG4gICAgICBjX2ZyZWUgKGl0ZW0pXG4gICAgICBzZXRfaXRlbSAoZGVmYXVsdF9wb2ludGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBtZW1vcnlfY29tcGFyZSAob3RoZXI6IFBPSU5URVI7IGFfc2l6ZTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgYEN1cnJlbnQnIGFuZCBgb3RoZXInIGFyZSBpZGVudGljYWwgb24gYGFfc2l6ZScgYnl0ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc2l6ZTogYV9zaXplID4gMFxuICAgICAgdmFsaWRfb3RoZXI6IG90aGVyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19tZW1jbXAgKGl0ZW0sIG90aGVyLCBhX3NpemUpID0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcG9pbnRlciB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5vdXRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBjX21lbWNweSAoZGVzdGluYXRpb24sIHNvdXJjZTogUE9JTlRFUjsgY291bnQ6IElOVEVHRVIpXG4gICAgICAtLSBDIG1lbWNweVxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlICh2b2lkICosIGNvbnN0IHZvaWQgKiwgc2l6ZV90KSB1c2UgPHN0cmluZy5oPlwiXG4gICAgYWxpYXNcbiAgICAgIFwibWVtY3B5XCJcbiAgICBlbmRcblxuICBjX21lbW1vdmUgKGRlc3RpbmF0aW9uLCBzb3VyY2U6IFBPSU5URVI7IGNvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gQyBtZW1tb3ZlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBzaWduYXR1cmUgKHZvaWQgKiwgY29uc3Qgdm9pZCAqLCBzaXplX3QpIHVzZSA8c3RyaW5nLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJtZW1tb3ZlXCJcbiAgICBlbmRcblxuICBjX21lbXNldCAoc291cmNlOiBQT0lOVEVSOyB2YWw6IElOVEVHRVI7IGNvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gQyBtZW1zZXRcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAodm9pZCAqLCBpbnQsIHNpemVfdCkgdXNlIDxzdHJpbmcuaD5cIlxuICAgIGFsaWFzXG4gICAgICBcIm1lbXNldFwiXG4gICAgZW5kXG5cbiAgY19tZW1jbXAgKHNvdXJjZSwgb3RoZXI6IFBPSU5URVI7IGNvdW50OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQyBtZW1jbXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAodm9pZCAqLCB2b2lkICosIHNpemVfdCk6IEVJRl9JTlRFR0VSIHVzZSA8c3RyaW5nLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJtZW1jbXBcIlxuICAgIGVuZFxuXG4gIGNfbWFsbG9jIChzaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQyBtYWxsb2NcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAoc2l6ZV90KTogRUlGX1BPSU5URVIgdXNlIDxzdGRsaWIuaD5cIlxuICAgIGFsaWFzXG4gICAgICBcIm1hbGxvY1wiXG4gICAgZW5kXG5cbiAgY19jYWxsb2MgKG5tZW1iLCBzaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQyBjYWxsb2NcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAoc2l6ZV90LCBzaXplX3QpOiBFSUZfUE9JTlRFUiB1c2UgPHN0ZGxpYi5oPlwiXG4gICAgYWxpYXNcbiAgICAgIFwiY2FsbG9jXCJcbiAgICBlbmRcblxuICBjX3JlYWxsb2MgKHNvdXJjZTogUE9JTlRFUjsgc2l6ZTogSU5URUdFUik6IFBPSU5URVJcbiAgICAgIC0tIEMgcmVhbGxvY1xuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlICh2b2lkICosIHNpemVfdCk6IEVJRl9QT0lOVEVSIHVzZSA8c3RkbGliLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJyZWFsbG9jXCJcbiAgICBlbmRcblxuICBjX2ZyZWUgKHA6IFBPSU5URVIpXG4gICAgICAtLSBDIGZyZWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAodm9pZCAqKSB1c2UgPHN0ZGxpYi5oPlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZnJlZVwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgT2JqZWN0cyByZXByZXNlbnRpbmcgZGVsYXllZCBjYWxscyB0byBhIHByb2NlZHVyZS5cbiAgICB3aXRoIHNvbWUgb3BlcmFuZHMgcG9zc2libHkgc3RpbGwgb3Blbi5cblxuICAgIE5vdGU6IEZlYXR1cmVzIGFyZSB0aGUgc2FtZSBhcyB0aG9zZSBvZiBST1VUSU5FLFxuICAgICAgd2l0aCBgYXBwbHknIG1hZGUgZWZmZWN0aXZlLCBhbmQgbm8gZnVydGhlclxuICAgICAgcmVkZWZpbml0aW9uIG9mIGBpc19lcXVhbCcgYW5kIGBjb3B5Jy5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTI4IDE0OjM1OjIzIC0wODAwIChUdWUsIDI4IEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDEwOSAkXCJcblxuY2xhc3NcbiAgUFJPQ0VEVVJFIFtCQVNFX1RZUEUgLT4gZGV0YWNoYWJsZSBBTlksIE9QRU5fQVJHUyAtPiBkZXRhY2hhYmxlIFRVUExFIGNyZWF0ZSBkZWZhdWx0X2NyZWF0ZSBlbmRdXG5cbmluaGVyaXRcbiAgUk9VVElORSBbQkFTRV9UWVBFLCBPUEVOX0FSR1NdXG4gICAgcmVuYW1lXG4gICAgICBjYWxsIGFzIGNhbGwgYWxpYXMgXCIoKVwiXG4gICAgZW5kXG5cbmNyZWF0ZSB7Tk9ORX1cbiAgc2V0X3JvdXRfZGlzcFxuXG5mZWF0dXJlIC0tIENhbGxzXG5cbiAgYXBwbHlcbiAgICAgIC0tIENhbGwgcHJvY2VkdXJlIHdpdGggYGFyZ3MnIGFzIGxhc3Qgc2V0LlxuICAgIGRvXG4gICAgICBjYWxsIChvcGVyYW5kcylcbiAgICBlbmRcblxuICBjYWxsIGFsaWFzIFwiKClcIiAoYXJnczogZGV0YWNoYWJsZSBzZXBhcmF0ZSBPUEVOX0FSR1MpXG4gICAgbG9jYWxcbiAgICAgIGM6IGxpa2UgY2xvc2VkX29wZXJhbmRzXG4gICAgICBsX2Nsb3NlZF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjIDo9IGNsb3NlZF9vcGVyYW5kc1xuICAgICAgaWYgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jbG9zZWRfY291bnQgOj0gIGMuY291bnRcbiAgICAgIGVuZFxuICAgICAgZmFzdF9jYWxsIChlbmNhcHNfcm91dF9kaXNwLCBjYWxjX3JvdXRfYWRkciwgJGNsb3NlZF9vcGVyYW5kcywgJGFyZ3MsIHJvdXRpbmVfaWQsXG4gICAgICAgICAgICAgICBpc19iYXNpYywgd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudCwgbF9jbG9zZWRfY291bnQsIG9wZW5fY291bnQsICRvcGVuX21hcClcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmYXN0X2NhbGwgKGFfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSO1xuICAgICAgICAgICBhX2Nsb3NlZF9vcGVyYW5kczogUE9JTlRFUjsgYV9vcGVyYW5kczogUE9JTlRFUjtcbiAgICAgICAgIGFfcm91dGluZV9pZDogSU5URUdFUjsgYV9pc19iYXNpYzogQk9PTEVBTjsgYV9jbGFzc19pZF9pbmxpbmVfYWdlbnQ6IElOVEVHRVI7XG4gICAgICAgICBhX2Nsb3NlZF9jb3VudCwgYV9vcGVuX2NvdW50OiBJTlRFR0VSOyBhX29wZW5fbWFwOiBQT0lOVEVSKVxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgaW5saW5lIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiW1xuICAgICAgI2lmZGVmIFdPUktCRU5DSFxuICAgICAgICBpZiAoJGFfcm91dF9kaXNwICE9IDApIHtcbiAgICAgICAgICAoRlVOQ1RJT05fQ0FTVCh2b2lkLCAoRUlGX1BPSU5URVIsIEVJRl9SRUZFUkVOQ0UsIEVJRl9SRUZFUkVOQ0UpKSAkYV9yb3V0X2Rpc3ApKFxuICAgICAgICAgICAgJGFfY2FsY19yb3V0X2FkZHIsICRhX2Nsb3NlZF9vcGVyYW5kcywgJGFfb3BlcmFuZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRfb2JqX2NhbGxfcHJvY2VkdXJlX2R5bmFtaWMgKFxuICAgICAgICAgICAgJGFfcm91dGluZV9pZCxcbiAgICAgICAgICAgICRhX2lzX2Jhc2ljLFxuICAgICAgICAgICAgJGFfY2xhc3NfaWRfaW5saW5lX2FnZW50LFxuICAgICAgICAgICAgJGFfY2xvc2VkX29wZXJhbmRzLFxuICAgICAgICAgICAgJGFfY2xvc2VkX2NvdW50LFxuICAgICAgICAgICAgJGFfb3BlcmFuZHMsXG4gICAgICAgICAgICAkYV9vcGVuX2NvdW50LFxuICAgICAgICAgICAgJGFfb3Blbl9tYXApO1xuICAgICAgICB9XG4gICAgICAjZWxzZVxuICAgICAgICAoRlVOQ1RJT05fQ0FTVCh2b2lkLCAoRUlGX1BPSU5URVIsIEVJRl9SRUZFUkVOQ0UsIEVJRl9SRUZFUkVOQ0UpKSAkYV9yb3V0X2Rpc3ApKFxuICAgICAgICAgICRhX2NhbGNfcm91dF9hZGRyLCAkYV9jbG9zZWRfb3BlcmFuZHMsICRhX29wZXJhbmRzKTtcbiAgICAgICNlbmRpZlxuICAgICAgXVwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJUYWJsZXMgd2hvc2Uga2V5cyBhcmUgaW50ZWdlcnMgaW4gYSBjb250aWd1b3VzIGludGVydmFsXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogaW5kZXhhYmxlLCBhY2Nlc3M7XG4gIGFjY2VzczogaW5kZXgsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgUkVBREFCTEVfSU5ERVhBQkxFIFtHXVxuXG5pbmhlcml0XG4gIElURVJBQkxFIFtHXVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiIChpOiBJTlRFR0VSKTogR1xuICAgICAgLS0gRW50cnkgYXQgcG9zaXRpb24gYGknXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgbmV3X2N1cnNvcjogSU5ERVhBQkxFX0lURVJBVElPTl9DVVJTT1IgW0ddXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuc3RhcnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyBhIHZhbGlkIGluZGV4P1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBvbmx5X2lmX2luX2luZGV4X3NldDpcbiAgICAgICAgUmVzdWx0IGltcGxpZXMgKChpID49IGluZGV4X3NldC5sb3dlcikgYW5kIChpIDw9IGluZGV4X3NldC51cHBlcikpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG5cblxuXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xNCAyMjoyMToxOSAtMDcwMCAoV2VkLCAxNCBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUwNjAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR18zMlxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVuYW1lXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGhhcywgaW5kZXhfb2YsIGxhc3RfaW5kZXhfb2YsIG9jY3VycmVuY2VzXG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgYXNfcmVhZGFibGVfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOH0sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbiArIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGM6IENIQVJBQ1RFUl8zMjsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBzdHJpbmcgb2YgbGVuZ3RoIGBuJyBmaWxsZWQgd2l0aCBgYycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgICAgZmlsbF9jaGFyYWN0ZXIgKGMpXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICAgIGZpbGxlZDogb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGlmIEN1cnJlbnQgLz0gcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZW1wdHkgKGNvdW50ICsgMSlcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCAwLCBjb3VudCArIDEpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9zaGFyZWRfaW1wbGVtZW50YXRpb246IEN1cnJlbnQgLz0gcyBpbXBsaWVzIG5vdCBzaGFyZWRfd2l0aCAocylcbiAgICAgIGluaXRpYWxpemVkOiBzYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbm90X3NoYXJlZF9pbXBsZW1lbnRhdGlvbjogQ3VycmVudCAvPSBzXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoJyUvMDAwLycsIGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG9fY2hhcmFjdGVyXzMyX2FyZWEgKGFyZWEsIDEsIGxfY291bnQpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NfcG9pbnRlciAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBDcmVhdGUgbmV3IGluc3RhbmNlIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX2Zyb21fYycuXCJcbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBtYWtlX2Zyb21fYyAoY19zdHJpbmcpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHNoYXJlZF93aXRoIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChvdGhlciAvPSBWb2lkKSBhbmQgdGhlbiAoYXJlYSA9IG90aGVyLmFyZWEpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IENIQVJBQ1RFUl8zMjsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGksIG5iLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfbG93ZXJfYXJlYSA6PSBhcmVhX2xvd2VyXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleCAtIDEgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgICBuYiA6PSBuYiArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIGEuaXRlbSAoaSkgPSBjXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMVxuICAgICAgICAgICAgLS0gYW5kIHN1YnN0cmFjdCBgYXJlYV9sb3dlcidcbiAgICAgICAgICBSZXN1bHQgOj0gaSArIDEgLSBsX2xvd2VyX2FyZWFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsYXN0X2luZGV4X29mIChjOiBDSEFSQUNURVJfMzI7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJyxcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kIC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCBsX2xvd2VyX2FyZWEgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMS5cbiAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleF9pbl9ib3VuZHMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9wb3MsIGVuZF9wb3MpXG4gICAgZW5kXG5cbiAgc3RyaW5nOiBTVFJJTkdfMzJcbiAgICAgIC0tIE5ldyBTVFJJTkdfMzIgaGF2aW5nIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3RyaW5nX3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN0cmluZ19yZXByZXNlbnRhdGlvbjogU1RSSU5HXzMyXG4gICAgICAtLSBTaW1pbGFyIHRvIGBzdHJpbmcnIGJ1dCBvbmx5IGNyZWF0ZSBhIG5ldyBvYmplY3QgaWYgYEN1cnJlbnQnIGlzIG5vdCBvZiBkeW5hbWljIHR5cGUge1NUUklOR18zMn1cbiAgICBkb1xuICAgICAgaWYgc2FtZV90eXBlIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIHRoZW4gYXR0YWNoZWQge1NUUklOR18zMn0gQ3VycmVudCBhcyBsX3MzMiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3MzMlxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGNvcnJlY3RfdHlwZTogUmVzdWx0LnNhbWVfdHlwZSAoY3JlYXRlIHtTVFJJTkdfMzJ9Lm1ha2VfZW1wdHkpXG4gICAgICBmaXJzdF9pdGVtOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKVxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuc3RyaW5nXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9pbmRleCwgY291bnQpXG4gICAgZW5kXG5cbiAgZnV6enlfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnQ6IElOVEVHRVI7IGZ1eno6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLmZ1enp5X2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnQsIGNvdW50LCBmdXp6KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIEFsbG9jYXRlZCBzcGFjZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5jb3VudCAtIDFcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gQWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1ha2luZyB1cCB0aGUgc3RyaW5nXG5cbiAgb2NjdXJyZW5jZXMgKGM6IENIQVJBQ1RFUl8zMik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50ICsgaVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiBhLml0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB6ZXJvX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBSZXN1bHQgPSAwXG4gICAgICByZWN1cnNlX2lmX25vdF9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSAvPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgICByZWN1cnNlX2lmX2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpID0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IDEgKyBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEsIGNvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpbmRleF9zZXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpbmRleF9zZXRfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIGxvY2FsXG4gICAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2hhc2gsIGxfb3RoZXJfaGFzaDogbGlrZSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgIGRvXG4gICAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBMZXQncyBjb21wYXJlIHRoZSBjb250ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBoYXNoX2NvZGUgYXJlIHRoZSBzYW1lIG9yIG5vdCB5ZXQgY29tcHV0ZWQuXG4gICAgICAgICAgbF9oYXNoIDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgICAgIGxfb3RoZXJfaGFzaCA6PSBvdGhlci5pbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBpZiBsX2hhc2ggPSAwIG9yIGVsc2UgbF9vdGhlcl9oYXNoID0gMCBvciBlbHNlIGxfaGFzaCA9IGxfb3RoZXJfaGFzaCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBuYilcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICBlbmRcblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJyByZWdhcmRsZXNzIG9mIGNhc2luZ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBuYiA9IDAgb3IgZWxzZSBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyLCAxLCBuYiwgMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAoQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnQ6IGF0dGFjaGVkIHtsaWtlIEN1cnJlbnR9IG90aGVyIGFzIGxfb3RoZXIgaW1wbGllcyAoc3RhbmRhcmRfaXNfZXF1YWwgKGxfb3RoZXIpIGltcGxpZXMgUmVzdWx0KVxuICAgICAgdmFsaWRfcmVzdWx0OiBhc19sb3dlciB+IG90aGVyLmFzX2xvd2VyIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBjYXNlbGVzcyBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICBsX2FyZWEsIGxfb3RoZXJfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjMSxjMjogQ0hBUkFDVEVSXzMyXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgaW5kZXhfcG9zIC0gMVxuICAgICAgICAgIGogOj0gb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgICBuYiA6PSBuYiArIGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMxIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGMyIDo9IGxfb3RoZXJfYXJlYS5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGxfcHJvcC50b19sb3dlciAoYzEpIC89IGxfcHJvcC50b19sb3dlciAoYzIpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbmIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG8gYEN1cnJlbnQnIGFuZCBgb3RoZXInIGhhdmUgc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2U/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKHN0cmluZyB+IG90aGVyLnN0cmluZylcbiAgICBlbmRcblxuICBzYW1lX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyICsgc3RhcnRfcG9zIC0gMSwgYXJlYV9sb3dlciArIGluZGV4X3BvcyAtIDEsIG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NoYXJhY3RlcnM6IFJlc3VsdCA9IHN1YnN0cmluZyAoaW5kZXhfcG9zLCBpbmRleF9wb3MgKyBlbmRfcG9zIC0gc3RhcnRfcG9zKS5zYW1lX3N0cmluZyAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbGV4aWNvZ3JhcGhpY2FsbHkgbG93ZXIgdGhhbiBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBvdGhlcl9jb3VudDogSU5URUdFUlxuICAgICAgY3VycmVudF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb3RoZXJfY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgICBpZiBvdGhlcl9jb3VudCA9IGN1cnJlbnRfY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgb3RoZXJfY291bnQpID4gMFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgY3VycmVudF9jb3VudCA8IG90aGVyX2NvdW50IHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgY3VycmVudF9jb3VudCkgPj0gMFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgb3RoZXJfY291bnQpID4gMFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19zdHJpbmdfODogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG5cbiAgaXNfdmFsaWRfYXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBuYiA6PSBjb3VudCArIGlcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkuY29kZSA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDFcbiAgICAgICAgbiA6PSBhcmVhX2xvd2VyICsgZW5kX2luZGV4IC0gMVxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuIG9yIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gaSA+IG5cbiAgICBlbmRcblxuICBoYXMgKGM6IENIQVJBQ1RFUl8zMik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIChsX2FyZWEuaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDwgbmIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzdGFydHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICBsX3NfYXJlYSA6PSBzLmFyZWFcbiAgICAgICAgICAgIGogOj0gYXJlYV9sb3dlciArIGlcbiAgICAgICAgICAgIGkgOj0gcy5hcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgbmIgOj0gcy5hcmVhX2xvd2VyXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgICBpZiBsX2FyZWEuaXRlbSAoaikgLz0gbF9zX2FyZWEuaXRlbSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSBuYiAtLSBKdW1wIG91dCBvZiBsb29wXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHMuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoMSwgcy5jb3VudCkpXG4gICAgZW5kXG5cbiAgZW5kc193aXRoIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBmaW5pc2ggd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGogOj0gY291bnRcbiAgICAgICAgaWYgaSA8PSBqIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgICAgbF9zX2FyZWEgOj0gcy5hcmVhXG4gICAgICAgICAgICBqIDo9IGFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBpIDo9IHMuYXJlYV91cHBlciArIDFcbiAgICAgICAgICAgIG5iIDo9IHMuYXJlYV9sb3dlclxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgaSA9IG5iXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgICAgaiA6PSBqIC0gMVxuICAgICAgICAgICAgaWYgbF9hcmVhLml0ZW0gKGopIC89IGxfc19hcmVhLml0ZW0gKGkpIHRoZW5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICAgIGkgOj0gbmIgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKGNvdW50IC0gcy5jb3VudCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICB2YWxpZF9jb2RlICh2OiBOQVRVUkFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHYnIGEgdmFsaWQgY29kZSBmb3IgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID0gNCB0aGVuXG4gICAgICAgICAgLS0gQ2hlY2sgaWYgdGhpcyBpcyBgdHJ1ZV9jb25zdGFudCdcbiAgICAgICAgUmVzdWx0IDo9IGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbCAodHJ1ZV9jb25zdGFudClcbiAgICAgIGVsc2VpZiBuYiA9IDUgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYGZhbHNlX2NvbnN0YW50J1xuICAgICAgICBSZXN1bHQgOj0gaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsIChmYWxzZV9jb25zdGFudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYHR3aW4nLilcbiAgICBsb2NhbFxuICAgICAgb2xkX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb2xkX2FyZWEgOj0gYXJlYVxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgICAtLSBOb3RlOiA8PSBpcyBuZWVkZWQgYXMgYWxsIEVpZmZlbCBzdHJpbmcgc2hvdWxkIGhhdmUgYW5cbiAgICAgICAgICAtLSBleHRyYSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IG51bGwgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmIG9sZF9hcmVhID0gVm9pZCBvciBlbHNlIG9sZF9hcmVhID0gb3RoZXIuYXJlYSBvciBlbHNlIG9sZF9hcmVhLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgICAgIC0tIFByZXZlbnQgY29weWluZyBvZiBsYXJnZSBgYXJlYScgaWYgb25seSBhIGZldyBjaGFyYWN0ZXJzIGFyZSBhY3R1YWxseSB1c2VkLlxuICAgICAgICAgIGFyZWEgOj0gYXJlYS5yZXNpemVkX2FyZWEgKGNvdW50ICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9sZF9hcmVhLmNvcHlfZGF0YSAoYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgICAgYXJlYSA6PSBvbGRfYXJlYVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBuZXdfcmVzdWx0X2NvdW50OiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgICAtLSBzYW1lX2NoYXJhY3RlcnM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYG90aGVyJy5gaXRlbScgKGBpJylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmaWxsX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgY2hhcmFjdGVycyBhbGwgZXF1YWwgdG8gYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NhcDogbGlrZSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBsX2NhcCA6PSBjYXBhY2l0eVxuICAgICAgaWYgbF9jYXAgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NhcCAtIDEpXG4gICAgICAgIGNvdW50IDo9IGxfY2FwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogY291bnQgPSBjYXBhY2l0eVxuICAgICAgc2FtZV9zaXplOiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgLS0gYWxsX2NoYXI6IEZvciBldmVyeSBgaScgaW4gMS4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYGMnXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgUmVzdWx0Jy5gaXRlbScgKGBpJykgPSBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoYXNfc3RyaW5nXzgpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfaXRlbXM6IHNhbWVfdHlwZSAoXCJcIikgaW1wbGllcyBzYW1lX3N0cmluZ19nZW5lcmFsIChSZXN1bHQpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgc3RyaW5nX3NlYXJjaGVyOiBTVFJJTkdfMzJfU0VBUkNIRVJcbiAgICAgIC0tIFN0cmluZyBzZWFyY2hlciBzcGVjaWFsaXplZCBmb3IgUkVBREFCTEVfU1RSSU5HXzMyIGluc3RhbmNlc1xuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cl9zdHJpY3RfY21wICh0aGlzLCBvdGhlcjogbGlrZSBhcmVhOyB0aGlzX2luZGV4LCBvdGhlcl9pbmRleCwgbjogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENvbXBhcmUgYG4nIGNoYXJhY3RlcnMgZnJvbSBgdGhpcycgc3RhcnRpbmcgYXQgYHRoaXNfaW5kZXgnIHdpdGhcbiAgICAgIC0tIGBuJyBjaGFyYWN0ZXJzIGZyb20gYW5kIGBvdGhlcicgc3RhcnRpbmcgYXQgYG90aGVyX2luZGV4Jy5cbiAgICAgIC0tIDAgaWYgZXF1YWwsIDwgMCBpZiBgdGhpcycgPCBgb3RoZXInLFxuICAgICAgLS0gPiAwIGlmIGB0aGlzJyA+IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICB0aGlzX25vdF92b2lkOiB0aGlzIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX3ZhbGlkOiBuIDw9ICh0aGlzLnVwcGVyIC0gdGhpc19pbmRleCArIDEpIGFuZCBuIDw9IChvdGhlci51cHBlciAtIG90aGVyX2luZGV4ICsgMSlcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmIsIGxfY3VycmVudF9jb2RlLCBsX290aGVyX2NvZGU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHRoaXNfaW5kZXhcbiAgICAgICAgbmIgOj0gaSArIG5cbiAgICAgICAgaiA6PSBvdGhlcl9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY3VycmVudF9jb2RlIDo9IHRoaXMuaXRlbSAoaSkuY29kZVxuICAgICAgICBsX290aGVyX2NvZGUgOj0gb3RoZXIuaXRlbSAoaikuY29kZVxuICAgICAgICBpZiBsX2N1cnJlbnRfY29kZSAvPSBsX290aGVyX2NvZGUgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBsX2N1cnJlbnRfY29kZSAtIGxfb3RoZXJfY29kZVxuICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgICAgLS0gd2l0aCB0aGVpciBsb3dlciB2ZXJzaW9uIHdoZW4gYXZhaWxhYmxlLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogQ0hBUkFDVEVSXzMyXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgbG9vcFxuICAgICAgICBjMSA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGMyIDo9IGxfcHJvcC50b19sb3dlciAoYzEpXG4gICAgICAgICAgLS0gTGV0J3MgYXZvaWQgYSB3cml0ZSBhY2Nlc3MgaWYgbm90IG5lZWRlZC5cbiAgICAgICAgaWYgYzEgLz0gYzIgdGhlblxuICAgICAgICAgIGEucHV0IChjMiwgaSlcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX3VwcGVyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgdXBwZXIgdmVyc2lvbiB3aGVuIGF2YWlsYWJsZS5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBjMSwgYzI6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYzEgOj0gYS5pdGVtIChpKVxuICAgICAgICBjMiA6PSBsX3Byb3AudG9fdXBwZXIgKGMxKVxuICAgICAgICAgIC0tIExldCdzIGF2b2lkIGEgd3JpdGUgYWNjZXNzIGlmIG5vdCBuZWVkZWQuXG4gICAgICAgIGlmIGMxIC89IGMyIHRoZW5cbiAgICAgICAgICBhLnB1dCAoYzIsIGkpXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtaXJyb3JfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gTWlycm9yIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpIDw9IGpcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZVxuICB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMixcbiAgU1RSSU5HXzhfU0VBUkNIRVIsIFNUUklOR18zMl9TRUFSQ0hFUixcbiAgSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSLFxuICBTVFJJTkdfVE9fSU5URUdFUl9DT05WRVJUT1IsXG4gIFNUUklOR19UT19SRUFMX0NPTlZFUlRPUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzXG5cbiAgYXJlYV9sb3dlcjogSU5URUdFUlxuICAgICAgLS0gTWluaW11bSBpbmRleFxuICAgIGRvXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX2xvd2VyX25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICAgIGFyZWFfbG93ZXJfdmFsaWQ6IFJlc3VsdCA8PSBhcmVhLnVwcGVyXG4gICAgZW5kXG5cbiAgYXJlYV91cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV9sb3dlciArIGNvdW50IC0gMVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV91cHBlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICAgIGFyZWFfdXBwZXJfaW5fYm91bmQ6IGFyZWFfbG93ZXIgPD0gUmVzdWx0ICsgMVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgYXJlYV9ub3Rfdm9pZDogYXJlYSAvPSBWb2lkXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xNCAyMjoyMjowMiAtMDcwMCAoV2VkLCAxNCBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUwNjEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR184XG5cbmluaGVyaXRcbiAgUkVBREFCTEVfU1RSSU5HX0dFTkVSQUxcbiAgICByZW5hbWVcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwsXG4gICAgICBpdGVtIGFzIGNoYXJhY3Rlcl8zMl9pdGVtLFxuICAgICAgaGFzIGFzIGNoYXJhY3Rlcl8zMl9oYXMsXG4gICAgICBpbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfaW5kZXhfb2YsXG4gICAgICBsYXN0X2luZGV4X29mIGFzIGNoYXJhY3Rlcl8zMl9sYXN0X2luZGV4X29mLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgY2hhcmFjdGVyXzMyX29jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuICBSRUFEQUJMRV9JTkRFWEFCTEUgW0NIQVJBQ1RFUl84XVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9LFxuICBhc19yZWFkYWJsZV9zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzJ9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbiArIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGM6IENIQVJBQ1RFUl84OyBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlIHN0cmluZyBvZiBsZW5ndGggYG4nIGZpbGxlZCB3aXRoIGBjJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb3VudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgICBmaWxsX2NoYXJhY3RlciAoYylcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgICAgZmlsbGVkOiBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBpZiBDdXJyZW50IC89IHMgdGhlblxuICAgICAgICBjcmVhdGUgYXJlYS5tYWtlX2VtcHR5IChjb3VudCArIDEpXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgMCwgY291bnQgKyAxKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3Rfc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBDdXJyZW50IC89IHMgaW1wbGllcyBub3Qgc2hhcmVkX3dpdGggKHMpXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKCclLzAwMC8nLCBsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvX2NoYXJhY3Rlcl84X2FyZWEgKGFyZWEsIDEsIGxfY291bnQpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NfcG9pbnRlciAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBDcmVhdGUgbmV3IGluc3RhbmNlIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX2Zyb21fYycgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG1ha2VfZnJvbV9jIChjX3N0cmluZylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IGRldGFjaGFibGUgU1lTVEVNX1NUUklORylcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCB3aXRoIGBhX3N5c3RlbV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRm9yIGNvbnNpc3RlbmN5IHdpdGggVW5pY29kZSBzdHJpbmcgaGFuZGxpbmcsIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHNoYXJlZF93aXRoIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBzaGFyZSB0aGUgdGV4dCBvZiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKG90aGVyIC89IFZvaWQpIGFuZCB0aGVuIChhcmVhID0gb3RoZXIuYXJlYSlcbiAgICBlbmRcblxuICBpbmRleF9vZiAoYzogQ0hBUkFDVEVSXzg7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycgYXQgb3IgYWZ0ZXIgYHN0YXJ0X2luZGV4JztcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnRfaW5kZXggPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgaSwgbmIsIGxfbG93ZXJfYXJlYTogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgc3RhcnRfaW5kZXggPD0gbmIgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9sb3dlcl9hcmVhIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4IC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgbF9sb3dlcl9hcmVhXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iIG9yIGVsc2UgYS5pdGVtIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBhZGQgKzEgZHVlIHRvIHRoZSBhcmVhIHN0YXJ0aW5nIGF0IDAgYW5kIG5vdCBhdCAxXG4gICAgICAgICAgICAtLSBhbmQgc3Vic3RyYWN0IGBhcmVhX2xvd2VyJ1xuICAgICAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIChzdGFydF9pbmRleCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBjb3VudClcbiAgICAgIHplcm9faWZfYWJzZW50OiAoUmVzdWx0ID0gMCkgPSBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXMgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYmVmb3JlOiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBSZXN1bHQgLSAxKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZiAoYzogQ0hBUkFDVEVSXzg7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJyxcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kIC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCBsX2xvd2VyX2FyZWEgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMS5cbiAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9hZnRlcjogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4X2luX2JvdW5kcyAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICBlbmRcblxuICBzdHJpbmc6IFNUUklOR184XG4gICAgICAtLSBOZXcgU1RSSU5HXzggaGF2aW5nIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3RyaW5nX3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzh9Lm1ha2VfZW1wdHkpXG4gICAgICBmaXJzdF9pdGVtOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKVxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuc3RyaW5nXG4gICAgZW5kXG5cbiAgc3RyaW5nX3JlcHJlc2VudGF0aW9uOiBTVFJJTkdfOFxuICAgICAgLS0gU2ltaWxhciB0byBgc3RyaW5nJyBidXQgb25seSBjcmVhdGUgYSBuZXcgb2JqZWN0IGlmIGBDdXJyZW50JyBpcyBub3Qgb2YgZHluYW1pYyB0eXBlIHtTVFJJTkdfOH1cbiAgICBkb1xuICAgICAgaWYgc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KSBhbmQgdGhlbiBhdHRhY2hlZCB7U1RSSU5HXzh9IEN1cnJlbnQgYXMgbF9zOCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3M4XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdHJpbmdcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgY29ycmVjdF90eXBlOiBSZXN1bHQuc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnRfaW5kZXgsIGNvdW50KVxuICAgIGVuZFxuXG4gIGZ1enp5X2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0OiBJTlRFR0VSOyBmdXp6OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5mdXp6eV9pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0LCBjb3VudCwgZnV6eilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBBbGxvY2F0ZWQgc3BhY2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuY291bnQgLSAxXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIEFjdHVhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBtYWtpbmcgdXAgdGhlIHN0cmluZ1xuXG4gIG9jY3VycmVuY2VzIChjOiBDSEFSQUNURVJfOCk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgKyBpXG4gICAgICAgIGEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIGEuaXRlbSAoaSkgPSBjIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHplcm9faWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIFJlc3VsdCA9IDBcbiAgICAgIHJlY3Vyc2VfaWZfbm90X2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICAgIHJlY3Vyc2VfaWZfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gMSArIHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSwgY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGluZGV4X3NldF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGluZGV4X3NldF9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2hhc2gsIGxfb3RoZXJfaGFzaDogbGlrZSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBMZXQncyBjb21wYXJlIHRoZSBjb250ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBoYXNoX2NvZGUgYXJlIHRoZSBzYW1lIG9yIG5vdCB5ZXQgY29tcHV0ZWQuXG4gICAgICAgICAgbF9oYXNoIDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgICAgIGxfb3RoZXJfaGFzaCA6PSBvdGhlci5pbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBpZiBsX2hhc2ggPSAwIG9yIGVsc2UgbF9vdGhlcl9oYXNoID0gMCBvciBlbHNlIGxfaGFzaCA9IGxfb3RoZXJfaGFzaCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBuYilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInIHJlZ2FyZGxlc3Mgb2YgY2FzaW5nXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChDdXJyZW50KVxuICAgICAgY29uc2lzdGVudDogYXR0YWNoZWQge2xpa2UgQ3VycmVudH0gb3RoZXIgYXMgbF9vdGhlciBpbXBsaWVzIChzdGFuZGFyZF9pc19lcXVhbCAobF9vdGhlcikgaW1wbGllcyBSZXN1bHQpXG4gICAgICB2YWxpZF9yZXN1bHQ6IGFzX2xvd2VyIH4gb3RoZXIuYXNfbG93ZXIgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9vdGhlcl9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGMxLGMyOiBDSEFSQUNURVJcbiAgICBkb1xuICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGlmIG5iIDw9IGNvdW50IC0gaW5kZXhfcG9zICsgMSB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfb3RoZXJfYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxXG4gICAgICAgICAgaiA6PSBvdGhlci5hcmVhX2xvd2VyICsgc3RhcnRfcG9zIC0gMVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgYzEgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgYzIgOj0gbF9vdGhlcl9hcmVhLml0ZW0gKGopXG4gICAgICAgICAgaWYgYzEgLz0gYzIgYW5kIHRoZW4gYzEuYXNfbG93ZXIgLz0gYzIuYXNfbG93ZXIgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBpIDo9IG5iIC0gMSAtLSBKdW1wIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpbmNyZWFzaW5nX2luZGV4OiBsX2FyZWEudXBwZXIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEbyBgQ3VycmVudCcgYW5kIGBvdGhlcicgaGF2ZSBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZT9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoc3RyaW5nIH4gb3RoZXIuc3RyaW5nKVxuICAgIGVuZFxuXG4gIHNhbWVfY2hhcmFjdGVycyAob3RoZXI6IFJFQURBQkxFX1NUUklOR184OyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDEsIGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxLCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3Bvcykuc2FtZV9zdHJpbmcgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIGxleGljb2dyYXBoaWNhbGx5IGxvd2VyIHRoYW4gYG90aGVyJz9cbiAgICBsb2NhbFxuICAgICAgb3RoZXJfY291bnQ6IElOVEVHRVJcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIG90aGVyX2NvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgICAgaWYgb3RoZXJfY291bnQgPSBjdXJyZW50X2NvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGN1cnJlbnRfY291bnQgPCBvdGhlcl9jb3VudCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIGN1cnJlbnRfY291bnQpID49IDBcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3ZhbGlkX2FzX3N0cmluZ184OiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICAgIG4gOj0gYXJlYV9sb3dlciArIGVuZF9pbmRleCAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuIG9yIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gaSA+IG5cbiAgICBlbmRcblxuICBoYXMgKGM6IENIQVJBQ1RFUl84KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgaW5jbHVkZSBgYyc/XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iIG9yIGVsc2UgKGxfYXJlYS5pdGVtIChpKSA9IGMpXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gKGkgPCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmFsc2VfaWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIG5vdCBSZXN1bHRcbiAgICAgIHRydWVfaWZfZmlyc3Q6IGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzIChjKSlcbiAgICBlbmRcblxuICBzdGFydHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBiZWdpbiB3aXRoIGBzJz9cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfc19hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA9IHMgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBpIDo9IHMuY291bnRcbiAgICAgICAgaWYgaSA8PSBjb3VudCB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX2xvd2VyICsgaVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBzLmNvdW50KSlcbiAgICBlbmRcblxuICBlbmRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgZmluaXNoIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9zX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBqIDo9IGNvdW50XG4gICAgICAgIGlmIGkgPD0gaiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChjb3VudCAtIHMuY291bnQgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgdmFsaWRfY29kZSAodjogTkFUVVJBTF8zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB2JyBhIHZhbGlkIGNvZGUgZm9yIGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdiA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA9IDQgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYHRydWVfY29uc3RhbnQnXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpLmxvd2VyID0gJ3QnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAxKS5sb3dlciA9ICdyJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMikubG93ZXIgPSAndScgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDMpLmxvd2VyID0gJ2UnXG4gICAgICBlbHNlaWYgbmIgPSA1IHRoZW5cbiAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIGlzIGBmYWxzZV9jb25zdGFudCdcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkubG93ZXIgPSAnZicgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDEpLmxvd2VyID0gJ2EnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAyKS5sb3dlciA9ICdsJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMykubG93ZXIgPSAncycgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDQpLmxvd2VyID0gJ2UnXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HXzh9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYHR3aW4nLilcbiAgICBsb2NhbFxuICAgICAgb2xkX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb2xkX2FyZWEgOj0gYXJlYVxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgICAtLSBOb3RlOiA8PSBpcyBuZWVkZWQgYXMgYWxsIEVpZmZlbCBzdHJpbmcgc2hvdWxkIGhhdmUgYW5cbiAgICAgICAgICAtLSBleHRyYSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IG51bGwgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmIG9sZF9hcmVhID0gVm9pZCBvciBlbHNlIG9sZF9hcmVhID0gb3RoZXIuYXJlYSBvciBlbHNlIG9sZF9hcmVhLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgICAgIC0tIFByZXZlbnQgY29weWluZyBvZiBsYXJnZSBgYXJlYScgaWYgb25seSBhIGZldyBjaGFyYWN0ZXJzIGFyZSBhY3R1YWxseSB1c2VkLlxuICAgICAgICAgIGFyZWEgOj0gYXJlYS5yZXNpemVkX2FyZWEgKGNvdW50ICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9sZF9hcmVhLmNvcHlfZGF0YSAoYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgICAgYXJlYSA6PSBvbGRfYXJlYVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBuZXdfcmVzdWx0X2NvdW50OiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgICAtLSBzYW1lX2NoYXJhY3RlcnM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYG90aGVyJy5gaXRlbScgKGBpJylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmaWxsX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBGaWxsIHdpdGggYGNhcGFjaXR5JyBjaGFyYWN0ZXJzIGFsbCBlcXVhbCB0byBgYycuXG4gICAgbG9jYWxcbiAgICAgIGxfY2FwOiBsaWtlIGNhcGFjaXR5XG4gICAgZG9cbiAgICAgIGxfY2FwIDo9IGNhcGFjaXR5XG4gICAgICBpZiBsX2NhcCAvPSAwIHRoZW5cbiAgICAgICAgYXJlYS5maWxsX3dpdGggKGMsIDAsIGxfY2FwIC0gMSlcbiAgICAgICAgY291bnQgOj0gbF9jYXBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmlsbGVkOiBjb3VudCA9IGNhcGFjaXR5XG4gICAgICBzYW1lX3NpemU6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICAtLSBhbGxfY2hhcjogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgYydcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBSZXN1bHQnLmBpdGVtJyAoYGknKSA9IGBpdGVtJyAoYGNvdW50JysxLWBpJylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBvdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2l0ZW1zOiBzYW1lX3R5cGUgKFwiXCIpIGltcGxpZXMgUmVzdWx0LnNhbWVfc3RyaW5nIChDdXJyZW50KVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cmluZ19zZWFyY2hlcjogU1RSSU5HXzhfU0VBUkNIRVJcbiAgICAgIC0tIFN0cmluZyBzZWFyY2hlciBzcGVjaWFsaXplZCBmb3IgUkVBREFCTEVfU1RSSU5HXzggaW5zdGFuY2VzXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlXG4gICAgZW5kXG5cbiAgc3RyX3N0cmljdF9jbXAgKHRoaXMsIG90aGVyOiBsaWtlIGFyZWE7IHRoaXNfaW5kZXgsIG90aGVyX2luZGV4LCBuOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQ29tcGFyZSBgbicgY2hhcmFjdGVycyBmcm9tIGB0aGlzJyBzdGFydGluZyBhdCBgdGhpc19pbmRleCcgd2l0aFxuICAgICAgLS0gYG4nIGNoYXJhY3RlcnMgZnJvbSBhbmQgYG90aGVyJyBzdGFydGluZyBhdCBgb3RoZXJfaW5kZXgnLlxuICAgICAgLS0gMCBpZiBlcXVhbCwgPCAwIGlmIGB0aGlzJyA8IGBvdGhlcicsXG4gICAgICAtLSA+IDAgaWYgYHRoaXMnID4gYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIHRoaXNfbm90X3ZvaWQ6IHRoaXMgLz0gVm9pZFxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fdmFsaWQ6IG4gPD0gKHRoaXMudXBwZXIgLSB0aGlzX2luZGV4ICsgMSkgYW5kIG4gPD0gKG90aGVyLnVwcGVyIC0gb3RoZXJfaW5kZXggKyAxKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYiwgbF9jdXJyZW50X2NvZGUsIGxfb3RoZXJfY29kZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gdGhpc19pbmRleFxuICAgICAgICBuYiA6PSBpICsgblxuICAgICAgICBqIDo9IG90aGVyX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgbF9jdXJyZW50X2NvZGUgOj0gdGhpcy5pdGVtIChpKS5jb2RlXG4gICAgICAgIGxfb3RoZXJfY29kZSA6PSBvdGhlci5pdGVtIChqKS5jb2RlXG4gICAgICAgIGlmIGxfY3VycmVudF9jb2RlIC89IGxfb3RoZXJfY29kZSB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IGxfY3VycmVudF9jb2RlIC0gbF9vdGhlcl9jb2RlXG4gICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlcl9hcmVhIChhOiBsaWtlIGFyZWE7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgICAtLSB3aXRoIHRoZWlyIGxvd2VyIHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgYV9ub3Rfdm9pZDogYSAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGEuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYS5wdXQgKGEuaXRlbSAoaSkubG93ZXIsIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX3VwcGVyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgdXBwZXIgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgbG9vcFxuICAgICAgICBhLnB1dCAoYS5pdGVtIChpKS51cHBlciwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIE1pcnJvciBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBjOiBDSEFSQUNURVJfOFxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpIDw9IGpcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZVxuICB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMixcbiAgU1RSSU5HXzhfU0VBUkNIRVIsIFNUUklOR18zMl9TRUFSQ0hFUixcbiAgSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSLFxuICBTVFJJTkdfVE9fSU5URUdFUl9DT05WRVJUT1IsXG4gIFNUUklOR19UT19SRUFMX0NPTlZFUlRPUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnNcblxuICBhcmVhX2xvd2VyOiBJTlRFR0VSXG4gICAgICAtLSBNaW5pbXVtIGluZGV4XG4gICAgZG9cbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfbG93ZXJfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgICAgYXJlYV9sb3dlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICBlbmRcblxuICBhcmVhX3VwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBNYXhpbXVtIGluZGV4XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX2xvd2VyICsgY291bnQgLSAxXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX3VwcGVyX3ZhbGlkOiBSZXN1bHQgPD0gYXJlYS51cHBlclxuICAgICAgYXJlYV91cHBlcl9pbl9ib3VuZDogYXJlYV9sb3dlciA8PSBSZXN1bHQgKyAxXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBhcmVhX25vdF92b2lkOiBhcmVhIC89IFZvaWRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkNvbW1vbiBhbmNlc3RvcnMgdG8gYWxsIFNUUklORyBjbGFzc2VzLiBSZWFkLW9ubHkgaW50ZXJmYWNlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wMy0xOSAwNjoyNzowMSAtMDcwMCAoV2VkLCAxOSBNYXIgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTQ2MzAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG5cbmluaGVyaXRcbiAgQ09NUEFSQUJMRVxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuICBTVFJJTkdfSEFORExFUlxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlIChuOiBJTlRFR0VSKVxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nOiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbiAgbWFrZV9lbXB0eVxuICAgICAgLS0gQ3JlYXRlIGVtcHR5IHN0cmluZy5cbiAgICBkb1xuICAgICAgbWFrZSAoMClcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5OiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvZGUgYXQgcG9zaXRpb24gYGknXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IGxpa2UgaXRlbTsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X2xhcmdlX2Vub3VnaDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgc3RhcnRfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSBpdGVtIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPD0gbmIgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCA9IDAgb3IgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50KVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKVxuICAgICAgZm91bmRfaWZfcHJlc2VudDogc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9iZWZvcmU6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXNcbiAgICAgICAgbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIFJlc3VsdCAtIDEpLmhhcyAoYylcbiAgICBlbmRcblxuICBsYXN0X2luZGV4X29mIChjOiBsaWtlIGl0ZW07IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfaW5kZXhfZnJvbV9lbmRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2UgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9hZnRlcjogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2ZfY29kZSAoYzogbGlrZSBjb2RlOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnIGF0IG9yIGFmdGVyIGBzdGFydF9pbmRleCc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBzdGFydF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4IDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgc3RhcnRfaW5kZXggPD0gbmIgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBlbHNlIGNvZGUgKGkpID0gY1xuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgaSA8PSBuYiB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IGlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0ID0gMCBvciAoc3RhcnRfaW5kZXggPD0gUmVzdWx0IGFuZCBSZXN1bHQgPD0gY291bnQpXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYykgaW1wbGllcyBjb2RlIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9iZWZvcmU6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0IC0gMSkuaGFzX2NvZGUgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZl9jb2RlIChjOiBsaWtlIGNvZGU7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfaW5kZXhfZnJvbV9lbmRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2UgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKVxuICAgICAgZm91bmRfaWZfcHJlc2VudDogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzX2NvZGUgKGMpIGltcGxpZXMgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYWZ0ZXI6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXNfY29kZSAoYylcbiAgICBlbmRcblxuICBmYWxzZV9jb25zdGFudDogU1RSSU5HXzggPSBcImZhbHNlXCJcbiAgICAgIC0tIENvbnN0YW50IHN0cmluZyBcImZhbHNlXCJcblxuICB0cnVlX2NvbnN0YW50OiBTVFJJTkdfOCA9IFwidHJ1ZVwiXG4gICAgICAtLSBDb25zdGFudCBzdHJpbmcgXCJ0cnVlXCJcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgICBpZiBSZXN1bHQgPSAwIHRoZW5cbiAgICAgICAgICAtLSBUaGUgbWFnaWMgbnVtYmVyIGA4Mzg4NTkzJyBiZWxvdyBpcyB0aGUgZ3JlYXRlc3QgcHJpbWUgbG93ZXIgdGhhblxuICAgICAgICAgIC0tIDJeMjMgc28gdGhhdCB0aGlzIG1hZ2ljIG51bWJlciBzaGlmdGVkIHRvIHRoZSBsZWZ0IGRvZXMgbm90IGV4Y2VlZCAyXjMxLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSAoKFJlc3VsdCBcXFxcIDgzODg1OTMpIHw8PCA4KSArIGl0ZW0gKGkpLmNvZGVcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gUmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjYXNlX2luc2Vuc2l0aXZlX2hhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlIG9mIHRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYEN1cnJlbnQnLlxuICAgIGxvY2FsXG4gICAgICBsX3Byb3BzOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGVcbiAgICAgIGlmIFJlc3VsdCA9IDAgdGhlblxuICAgICAgICAgIC0tIFRoZSBtYWdpYyBudW1iZXIgYDgzODg1OTMnIGJlbG93IGlzIHRoZSBncmVhdGVzdCBwcmltZSBsb3dlciB0aGFuXG4gICAgICAgICAgLS0gMl4yMyBzbyB0aGF0IHRoaXMgbWFnaWMgbnVtYmVyIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgZG9lcyBub3QgZXhjZWVkIDJeMzEuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICAgIGxfcHJvcHMgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSAoKFJlc3VsdCBcXFxcIDgzODg1OTMpIHw8PCA4KSArIGxfcHJvcHMudG9fbG93ZXIgKGl0ZW0gKGkpKS5jb2RlXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGUgOj0gUmVzdWx0XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvbnNpc3RlbnQ6IFJlc3VsdCA9IGFzX2xvd2VyLmhhc2hfY29kZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19pbW11dGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIENhbiB0aGUgY2hhcmFjdGVyIHNlcXVlbmNlIG9mIGBDdXJyZW50JyBiZSBub3QgY2hhbmdlZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHN0cmluZz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpID4gMCkgYW5kIChpIDw9IGNvdW50KVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKDEgPD0gaSBhbmQgaSA8PSBjb3VudClcbiAgICBlbmRcblxuICB2YWxpZF9jb2RlICh2OiBsaWtlIGNvZGUpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdicgYSB2YWxpZCBjb2RlIGZvciBDdXJyZW50P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhIHNlcXVlbmNlIG9mIENIQVJBQ1RFUl84P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfc3RyaW5nXzMyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgQ3VycmVudCcgYSBzZXF1ZW5jZSBvZiBDSEFSQUNURVJfMzI/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc192YWxpZF9hc19zdHJpbmdfODogQk9PTEVBTlxuICAgICAgLS0gSXMgYEN1cnJlbnQnIGNvbnZlcnRpYmxlIHRvIGEgc2VxdWVuY2Ugb2YgQ0hBUkFDVEVSXzggd2l0aG91dCBpbmZvcm1hdGlvbiBsb3NzP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfZW1wdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBlbXB0eT9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX3doaXRlc3BhY2U6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIGNvdW50KVxuICAgIGVuZFxuXG4gIGlzX3N1YnN0cmluZ193aGl0ZXNwYWNlIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3Vic3RyaW5nIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycz9cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9iaWdfZW5vdWdoOiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICBlbmRfaW5kZXhfc21hbGxfZW5vdWdoOiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIGNvbnNpc3RlbnRfaW5kZXhlczogc3RhcnRfaW5kZXggLSAxIDw9IGVuZF9pbmRleFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaGFzIChjOiBsaWtlIGl0ZW0pOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBpbmNsdWRlIGBjJz9cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSAoaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDw9IG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGZhbHNlX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2ZpcnN0OiBjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjIGltcGxpZXMgUmVzdWx0XG4gICAgICByZWN1cnNlOiAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgKFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLmhhcyAoYykpXG4gICAgZW5kXG5cbiAgaGFzX2NvZGUgKGM6IGxpa2UgY29kZSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBlbHNlIChjb2RlIChpKSA9IGMpXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gKGkgPD0gbmIpXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZmFsc2VfaWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIG5vdCBSZXN1bHRcbiAgICAgIHRydWVfaWZfZmlyc3Q6IGNvdW50ID4gMCBhbmQgdGhlbiBjb2RlICgxKSA9IGMgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+IDAgYW5kIHRoZW4gY29kZSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzX2NvZGUgKGMpKVxuICAgIGVuZFxuXG4gIGlzX251bWJlcl9zZXF1ZW5jZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgbnVtYmVyIHNlcXVlbmNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgIGVuc3VyZVxuICAgICAgc3ludGF4X2FuZF9yYW5nZTpcbiAgICAgICAgLS0gUmVzdWx0IGlzIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gIEN1cnJlbnQgY2FuIGJlIHByb2R1Y2VkIGJ5IFwiSW50ZWdlcl9saXRlcmFsXCI6XG4gICAgICAgIC0tXG4gICAgICAgIC0tIEludGVnZXJfbGl0ZXJhbCA9IFtTcGFjZV0gW1NpZ25dIEludGVnZXIgW1NwYWNlXVxuICAgICAgICAtLSBTcGFjZSAgPSBcIiBcIiB8IFwiIFwiIFNwYWNlXG4gICAgICAgIC0tIFNpZ24gICA9IFwiK1wiIHwgXCItXCJcbiAgICAgICAgLS0gSW50ZWdlciAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgID0gXCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJcbiAgICBlbmRcblxuICBpc19yZWFsX3NlcXVlbmNlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSByZWFsIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9yX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9yX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9kb3VibGVcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgIGVuZFxuXG4gIGlzX3JlYWwsIGlzX3JlYWxfMzI6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIFJFQUxfMzI/XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b3JfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b3JfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9yZWFsKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLmlzX2ludGVncmFsX3JlYWxcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSAxLiBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgICAgICAtLSAyLiBUaGUgbnVtZXJpY2FsIHZhbHVlIHJlcHJlc2VudGVkIGJ5ICdDdXJyZW50J1xuICAgICAgICAtLSAgaXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZFxuICAgICAgICAtLSAgYnkgYW4gaW5zdGFuY2Ugb2YgdHlwZSBSRUFMLlxuICAgIGVuZFxuXG4gIGlzX2RvdWJsZSwgaXNfcmVhbF82NDogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgUkVBTF82ND9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2RvdWJsZSlcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9kb3VibGVcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSAxLiBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgICAgICAtLSAyLiBUaGUgbnVtZXJpY2FsIHZhbHVlIHJlcHJlc2VudGVkIGJ5ICdDdXJyZW50J1xuICAgICAgICAtLSAgaXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZFxuICAgICAgICAtLSAgYnkgYW4gaW5zdGFuY2Ugb2YgdHlwZSBET1VCTEUuXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaXNfYm9vbGVhbjogUmVzdWx0ID0gKHRydWVfY29uc3RhbnQuc2FtZV9zdHJpbmdfZ2VuZXJhbCAoYXNfbG93ZXIpIG9yXG4gICAgICAgIGZhbHNlX2NvbnN0YW50LnNhbWVfc3RyaW5nX2dlbmVyYWwgKGFzX2xvd2VyKSlcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzg6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhbiBJTlRFR0VSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2ludGVnZXJfOClcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzE2OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl8xNj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl8xNilcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyLCBpc19pbnRlZ2VyXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl8zMilcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzY0OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl82ND9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl82NClcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzg6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF84KVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfMTY6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfMTY/XG5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF8xNilcbiAgICBlbmRcblxuICBpc19uYXR1cmFsLCBpc19uYXR1cmFsXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBOQVRVUkFMXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9uYXR1cmFsXzMyKVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfNjQ6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfNjQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gQ3VycmVudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBjaGFyYWN0ZXJzIGFsbG9jYXRlZCBpbiBDdXJyZW50XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBvY2N1cnJlbmNlcyAoYzogQ0hBUkFDVEVSXzMyKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGBjJyBhcHBlYXJzIGluIHRoZSBzdHJpbmdcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgemVyb19pZl9lbXB0eTogY291bnQgPSAwIGltcGxpZXMgUmVzdWx0ID0gMFxuICAgICAgcmVjdXJzZV9pZl9ub3RfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgICAgcmVjdXJzZV9pZl9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSAxICsgc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cmluZyBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcicgcmVnYXJkbGVzcyBvZiBjYXNpbmdcbiAgICAgIC0tIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChDdXJyZW50KVxuICAgICAgY29uc2lzdGVudDogYXR0YWNoZWQge2xpa2UgQ3VycmVudH0gb3RoZXIgYXMgbF9vdGhlciBpbXBsaWVzIChzdGFuZGFyZF9pc19lcXVhbCAobF9vdGhlcikgaW1wbGllcyBSZXN1bHQpXG4gICAgICB2YWxpZF9yZXN1bHQ6IGFzX2xvd2VyIH4gb3RoZXIuYXNfbG93ZXIgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgYzEsYzI6IGxpa2UgaXRlbVxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBpbmRleF9wb3NcbiAgICAgICAgICBqIDo9IHN0YXJ0X3Bvc1xuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgYzEgOj0gaXRlbSAoaSlcbiAgICAgICAgICBjMiA6PSBvdGhlci5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGxfcHJvcC50b19sb3dlciAoYzEpIC89IGxfcHJvcC50b19sb3dlciAoYzIpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbmIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGhhc19zdWJzdHJpbmcgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIGNvbnRhaW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZWlmIG90aGVyLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHN1YnN0cmluZ19pbmRleCAob3RoZXIsIDEpID4gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBmYWxzZV9pZl90b29fc21hbGw6IGNvdW50IDwgb3RoZXIuY291bnQgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2luaXRpYWw6IChjb3VudCA+PSBvdGhlci5jb3VudCBhbmQgdGhlblxuICAgICAgICBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBvdGhlci5jb3VudCkpKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgcmVjdXJzZTogKGNvdW50ID49IG90aGVyLmNvdW50IGFuZCB0aGVuXG4gICAgICAgIG5vdCBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBvdGhlci5jb3VudCkpKSBpbXBsaWVzXG4gICAgICAgIChSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5oYXNfc3Vic3RyaW5nIChvdGhlcikpXG4gICAgZW5kXG5cbiAgc2FtZV9zdHJpbmcgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYG90aGVyJyByZXByZXNlbnQgdGhlIHNhbWUgc3RyaW5nIGFzIGBDdXJyZW50Jz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2FtZV9jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICBpIDo9IGluZGV4X3Bvc1xuICAgICAgICAgIGogOj0gc3RhcnRfcG9zXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSAvPSBvdGhlci5pdGVtIChqKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGluY3JlYXNpbmdfaW5kZXg6IG5iIC0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLnNhbWVfc3RyaW5nIChvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykpXG4gICAgZW5kXG5cbiAgc3RhcnRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSAwXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaWYgY29kZSAoaSkgLz0gcy5jb2RlIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKDEsIHMuY291bnQpKVxuICAgIGVuZFxuXG4gIGVuZHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBmaW5pc2ggd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGogOj0gY291bnRcbiAgICAgICAgaWYgaSA8PSBqIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGlmIGNvZGUoaikgLz0gcy5jb2RlIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKGNvdW50IC0gcy5jb3VudCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXhfaW5fYm91bmRzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYG90aGVyJyBhdCBvciBhZnRlciBgc3RhcnRfcG9zJ1xuICAgICAgLS0gYW5kIHRvIG9yIGJlZm9yZSBgZW5kX3Bvcyc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm9udm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgb3RoZXJfbm90ZW1wdHk6IG5vdCBvdGhlci5pc19lbXB0eVxuICAgICAgc3RhcnRfcG9zX2xhcmdlX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIHN0YXJ0X3Bvc19zbWFsbF9lbm91Z2g6IHN0YXJ0X3BvcyA8PSBjb3VudFxuICAgICAgZW5kX3Bvc19sYXJnZV9lbm91Z2g6IGVuZF9wb3MgPj0gc3RhcnRfcG9zXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3JyZWN0X3BsYWNlOiBSZXN1bHQgPiAwIGltcGxpZXMgb3RoZXIuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoUmVzdWx0LCBSZXN1bHQgKyBvdGhlci5jb3VudCAtIDEpKVxuICAgICAgLS0gZm9yYWxsIHggOiBzdGFydF9wb3MuLlJlc3VsdFxuICAgICAgLS0gIG5vdCBzdWJzdHJpbmcgKHgsIHgrb3RoZXIuY291bnQgLTEpLmlzX2VxdWFsIChvdGhlcilcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIG90aGVyIGF0IG9yIGFmdGVyIHN0YXJ0X2luZGV4O1xuICAgICAgLS0gMCBpZiBub25lXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiBzdGFydF9pbmRleCA+PSAxIGFuZCBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIGVsc2VcbiAgICAgICAgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50IC0gb3RoZXIuY291bnQgKyAxKVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9XG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzX3N1YnN0cmluZyAob3RoZXIpXG4gICAgICBhdF90aGlzX2luZGV4OiBSZXN1bHQgPj0gc3RhcnRfaW5kZXggaW1wbGllc1xuICAgICAgICBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChSZXN1bHQsIFJlc3VsdCArIG90aGVyLmNvdW50IC0gMSkpXG4gICAgICBub25lX2JlZm9yZTogUmVzdWx0ID4gc3RhcnRfaW5kZXggaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0ICsgb3RoZXIuY291bnQgLSAyKS5oYXNfc3Vic3RyaW5nIChvdGhlcilcbiAgICBlbmRcblxuICBmdXp6eV9pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydDogSU5URUdFUjsgZnV6ejogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYG90aGVyJyBhdCBvciBhZnRlciBgc3RhcnQnXG4gICAgICAtLSB3aXRoIDAuLmBmdXp6JyBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIHN0cmluZyBhbmQgYG90aGVyJy5cbiAgICAgIC0tIDAgaWYgdGhlcmUgYXJlIG5vIGZ1enp5IG1hdGNoZXNcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF9lbXB0eTogbm90IG90aGVyLmlzX2VtcHR5XG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnQgPD0gY291bnRcbiAgICAgIGFjY2VwdGFibGVfZnV6enk6IGZ1enogPD0gb3RoZXIuY291bnRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBmcm96ZW4gdG9fY2lsOiBTWVNURU1fU1RSSU5HXG4gICAgICAtLSBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgU1lTVEVNX1NUUklORyB1c2luZyBjaGFyYWN0ZXJzXG4gICAgICAtLSBvZiBDdXJyZW50IGJldHdlZW4gaW5kaWNlcyBgMScgYW5kIGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZG90bmV0X2NvbnZlcnRvci5mcm9tX3N0cmluZ190b19zeXN0ZW1fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3N0cmluZ184OiBTVFJJTkdfOFxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfOC5cbiAgICByZXF1aXJlXG4gICAgICBpc192YWxpZF9hc19zdHJpbmdfODogaXNfdmFsaWRfYXNfc3RyaW5nXzhcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX3N0cmluZ184XG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfOF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGlkZW50aXR5OiAoY29uZm9ybXNfdG8gKFwiXCIpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzhfY29udmVyc2lvbjogU1RSSU5HXzhcbiAgICAgIC0tIEVxdWl2YWxlbnQgdG8gYGFzX3N0cmluZ184JyB3aXRoIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAtLSBUbyBiZSB1c2VkIGZvciBtaWdyYXRpbmcgZXhpc3RpbmcgY29kZSB0byBVbmljb2RlXG4gICAgICAtLSB3aGVuIHlvdSBnZXQgYSBjb21waWxlciBlcnJvciBidXQgY2Fubm90IG9yIGRvIG5vdCBoYXZlXG4gICAgICAtLSB0aGUgdGltZSB5ZXQgdG8gYWRkcmVzcyB0aGUgdGFyZ2V0IHJlY2lwaWVudCBvZiB0aGUgc3RyaW5nIHRvIGJlXG4gICAgICAtLSBhIFJFQURBQkxFX1NUUklOR18zMiBvciBkZXNjZW5kYW50cy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVcGRhdGUgcmVjaXBpZW50IG9mIGNhbGwgdG8gdXNlIFJFQURBQkxFX1NUUklOR18zMiBhbmQgZGVzY2VuZGFudHMgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfc3RyaW5nXzhcbiAgICBlbmRcblxuICBhc19yZWFkYWJsZV9zdHJpbmdfODogUkVBREFCTEVfU1RSSU5HXzhcbiAgICAgIC0tXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGV4cGxpY2l0IGNvbnZlcnNpb24gYHRvX3N0cmluZ184JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfOFxuICAgIGVuZFxuXG4gIGFzX3N0cmluZ184OiBTVFJJTkdfOFxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfOC4gSWYgYSBjb2RlIG9mIGBDdXJyZW50JyBpc1xuICAgICAgLS0gbm90IGEgdmFsaWQgY29kZSBmb3IgYSBTVFJJTkdfOCBpdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBudWxsXG4gICAgICAtLSBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvZGU6IGxpa2UgY29kZVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7U1RSSU5HXzh9IEN1cnJlbnQgYXMgbF9yZXN1bHQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9yZXN1bHRcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuYilcbiAgICAgICAgUmVzdWx0LnNldF9jb3VudCAobmIpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfY29kZSA6PSBjb2RlIChpKVxuICAgICAgICAgIGlmIFJlc3VsdC52YWxpZF9jb2RlIChsX2NvZGUpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAobF9jb2RlLCBpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAoMCwgaSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfOF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGlkZW50aXR5OiAoY29uZm9ybXNfdG8gKFwiXCIpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzMyX2NvbnZlcnNpb246IFNUUklOR18zMlxuICAgICAgLS0gRXF1aXZhbGVudCB0byBgYXNfc3RyaW5nXzMyJyB3aXRoIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAtLSBUbyBiZSB1c2VkIGZvciBtaWdyYXRpbmcgZXhpc3RpbmcgY29kZSB0byBVbmljb2RlXG4gICAgICAtLSB3aGVuIHlvdSBnZXQgYSBjb21waWxlciBlcnJvciBidXQgY2Fubm90IG9yIGRvIG5vdCBoYXZlXG4gICAgICAtLSB0aGUgdGltZSB5ZXQgdG8gYWRkcmVzcyB0aGUgc291cmNlIG9mIHRoZSBzdHJpbmcgdG8gYmVcbiAgICAgIC0tIGEgUkVBREFCTEVfU1RSSU5HXzMyIG9yIGRlc2NlbmRhbnRzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVwZGF0ZSB0YXJnZXQgb2YgY2FsbCB0byB1c2UgUkVBREFCTEVfU1RSSU5HXzMyIGFuZCBkZXNjZW5kYW50cyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfMzJcbiAgICBlbmRcblxuICBhc19yZWFkYWJsZV9zdHJpbmdfMzI6IFJFQURBQkxFX1NUUklOR18zMlxuICAgICAgLS1cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgZXhwbGljaXQgY29udmVyc2lvbiBgdG9fc3RyaW5nXzMyJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfMzJcbiAgICBlbmRcblxuICBhc19zdHJpbmdfMzIsIHRvX3N0cmluZ18zMjogU1RSSU5HXzMyXG4gICAgICAtLSBDb252ZXJ0IGBDdXJyZW50JyBhcyBhIFNUUklOR18zMi5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1NUUklOR18zMn0gQ3VycmVudCBhcyBsX3Jlc3VsdCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3Jlc3VsdFxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG5iKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChuYilcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgUmVzdWx0LnB1dF9jb2RlIChjb2RlIChpKSwgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfMzJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpZGVudGl0eTogKGNvbmZvcm1zX3RvIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIFJlc3VsdCA9IEN1cnJlbnQpIG9yIChub3QgY29uZm9ybXNfdG8gKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGFzX2xvd2VyX2F0dGFjaGVkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbGVuZ3RoOiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgYW5jaG9yOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKS5hc19sb3dlclxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuYXNfbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBhc191cHBlcl9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGxlbmd0aDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIGFuY2hvcjogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSkuYXNfdXBwZXJcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLmFzX3VwcGVyXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIDgtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzg6IGlzX2ludGVnZXJfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gMTYtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzE2OiBpc19pbnRlZ2VyXzE2XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgdG9faW50ZWdlciwgdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gMzItYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzMyXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gNjQtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzY0OiBpc19pbnRlZ2VyXzY0XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIDgtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzg6IGlzX25hdHVyYWxfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gMTYtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzE2OiBpc19uYXR1cmFsXzE2XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbCwgdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gMzItYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsOiBpc19uYXR1cmFsXzMyXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gNjQtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzY0OiBpc19uYXR1cmFsXzY0XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbCwgdG9fcmVhbF8zMjogUkVBTFxuICAgICAgLS0gUmVhbCB2YWx1ZTtcbiAgICAgIC0tIGZvciBleGFtcGxlLCB3aGVuIGFwcGxpZWQgdG8gXCIxMjMuMFwiLCB3aWxsIHlpZWxkIDEyMy4wXG4gICAgcmVxdWlyZVxuICAgICAgcmVwcmVzZW50c19hX3JlYWw6IGlzX3JlYWxcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRvX2RvdWJsZS50cnVuY2F0ZWRfdG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZSwgdG9fcmVhbF82NDogRE9VQkxFXG4gICAgICAtLSBcIkRvdWJsZVwiIHZhbHVlO1xuICAgICAgLS0gZm9yIGV4YW1wbGUsIHdoZW4gYXBwbGllZCB0byBcIjEyMy4wXCIsIHdpbGwgeWllbGQgMTIzLjAgKGRvdWJsZSlcbiAgICByZXF1aXJlXG4gICAgICByZXByZXNlbnRzX2FfZG91YmxlOiBpc19kb3VibGVcbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX2RvdWJsZVxuICAgIGVuZFxuXG4gIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gdmFsdWU7XG4gICAgICAtLSBcIlRydWVcIiB5aWVsZHMgYFRydWUnLCBcIkZhbHNlXCIgeWllbGRzIGBGYWxzZSdcbiAgICAgIC0tIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2Jvb2xlYW46IGlzX2Jvb2xlYW5cbiAgICBkb1xuICAgICAgY2hlY2sgdHJ1ZV9jb25zdGFudC5jb3VudCA9IDQgZW5kXG4gICAgICBpZiBjb3VudCA9IDQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0b19ib29sZWFuOiAoUmVzdWx0ID0gYXNfbG93ZXIuc2FtZV9zdHJpbmcgKHRydWVfY29uc3RhbnQpKSBvclxuICAgICAgICAobm90IFJlc3VsdCA9IGFzX2xvd2VyLnNhbWVfc3RyaW5nIChmYWxzZV9jb25zdGFudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHNwbGl0IChhX3NlcGFyYXRvcjogQ0hBUkFDVEVSXzMyKTogTElTVCBbbGlrZSBDdXJyZW50XVxuICAgICAgLS0gU3BsaXQgb24gYGFfc2VwYXJhdG9yJy5cbiAgICBsb2NhbFxuICAgICAgbF9saXN0OiBBUlJBWUVEX0xJU1QgW2xpa2UgQ3VycmVudF1cbiAgICAgIHBhcnQ6IGxpa2UgQ3VycmVudFxuICAgICAgaSwgaiwgYzogSU5URUdFUlxuICAgIGRvXG4gICAgICBjIDo9IGNvdW50XG4gICAgICAgIC0tIFdvcnNlIGNhc2UgYWxsb2NhdGlvbjogZXZlcnkgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yXG4gICAgICBjcmVhdGUgbF9saXN0Lm1ha2UgKGMgKyAxKVxuICAgICAgaWYgYyA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGogOj0gaW5kZXhfb2YgKGFfc2VwYXJhdG9yLCBpKVxuICAgICAgICAgIGlmIGogPSAwIHRoZW5cbiAgICAgICAgICAgICAgLS0gTm8gc2VwYXJhdG9yIHdhcyBmb3VuZCwgd2Ugd2lsbFxuICAgICAgICAgICAgICAtLSBzaW1wbHkgY3JlYXRlIGEgbGlzdCB3aXRoIGEgY29weSBvZlxuICAgICAgICAgICAgICAtLSBDdXJyZW50IGluIGl0LlxuICAgICAgICAgICAgaiA6PSBjICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHBhcnQgOj0gc3Vic3RyaW5nIChpLCBqIC0gMSlcbiAgICAgICAgICBsX2xpc3QuZXh0ZW5kIChwYXJ0KVxuICAgICAgICAgIGkgOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGogPSBjIHRoZW5cbiAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgbGFzdF9jaGFyYWN0ZXJfaXNfYV9zZXBhcmF0b3I6IGl0ZW0gKGopID0gYV9zZXBhcmF0b3JcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEEgc2VwYXJhdG9yIHdhcyBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgICBsX2xpc3QuZXh0ZW5kIChuZXdfc3RyaW5nICgwKSlcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0ZW5kIGVtcHR5IHN0cmluZywgc2luY2UgQ3VycmVudCBpcyBlbXB0eS5cbiAgICAgICAgbF9saXN0LmV4dGVuZCAobmV3X3N0cmluZyAoMCkpXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSBsX2xpc3RcbiAgICAgIGNoZWNrXG4gICAgICAgIGxfbGlzdC5jb3VudCA9IG9jY3VycmVuY2VzIChhX3NlcGFyYXRvcikgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHBsdXNfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50ICsgcy5jb3VudFxuICAgICAgaW5pdGlhbDogZWxrc19jaGVja2luZyBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDEsIGNvdW50KSB+IEN1cnJlbnRcbiAgICAgIGZpbmFsOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoY291bnQgKyAxLCBjb3VudCArIHMuY291bnQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc3Vic3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3Vic3RyaW5nX2NvdW50OiBSZXN1bHQuY291bnQgPSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEgb3IgUmVzdWx0LmNvdW50ID0gMFxuICAgICAgZmlyc3RfY29kZTogUmVzdWx0LmNvdW50ID4gMCBpbXBsaWVzIFJlc3VsdC5pdGVtICgxKSA9IGl0ZW0gKHN0YXJ0X2luZGV4KVxuICAgICAgcmVjdXJzZTogUmVzdWx0LmNvdW50ID4gMCBpbXBsaWVzXG4gICAgICAgIFJlc3VsdC5zdWJzdHJpbmcgKDIsIFJlc3VsdC5jb3VudCkgfiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4ICsgMSwgZW5kX2luZGV4KVxuICAgIGVuZFxuXG4gIGhlYWQgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByZWZpeCwgcmV0YWluaW5nIGZpcnN0IGBuJyBjaGFyYWN0ZXJzIChvciBhcyBtYW55IGFzIGF2YWlsYWJsZSkuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHN1YnN0cmluZyAoMSwgbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgKGNvdW50KVxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAoY291bnQpXG4gICAgZW5kXG5cbiAgdGFpbCAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VmZml4LCByZXRhaW5pbmcgbGFzdCBgbicgY2hhcmFjdGVycyAob3IgYXMgbWFueSBhcyBhdmFpbGFibGUpLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdWJzdHJpbmcgKGNvdW50IC0gbiArIDEsIGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQpXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG4ubWluIChjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gQXNzZXJ0aW9uIGhlbHBlclxuXG4gIGVsa3NfY2hlY2tpbmc6IEJPT0xFQU4gPSBGYWxzZVxuICAgICAgLS0gQXJlIEVMS1MgY2hlY2tpbmdzIHZlcmlmaWVkPyBNdXN0IGJlIFRydWUgd2hlbiBjaGFuZ2luZyBpbXBsZW1lbnRhdGlvbiBvZiBTVFJJTkdfR0VORVJBTCBvciBkZXNjZW5kYW50LlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIG5ld19zdHJpbmcgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBjdXJyZW50IHdpdGggc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X3N0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIG5ld19zdHJpbmdfZW1wdHk6IFJlc3VsdC5pc19lbXB0eVxuICAgICAgbmV3X3N0cmluZ19hcmVhX2JpZ19lbm91Z2g6IFJlc3VsdC5jYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh0eXBlOiBJTlRFR0VSKSA6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhIHZhbGlkIG51bWJlciBhY2NvcmRpbmcgdG8gZ2l2ZW4gYHR5cGUnP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucmVzZXQgKHR5cGUpXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB0eXBlKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLmlzX2ludGVncmFsX2ludGVnZXJcbiAgICBlbmRcblxuICBzdHJpbmdfc2VhcmNoZXI6IFNUUklOR19TRUFSQ0hFUlxuICAgICAgLS0gRmFjaWxpdGllcyB0byBzZWFyY2ggc3RyaW5nIGluIGFub3RoZXIgc3RyaW5nLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzdHJpbmdfc2VhcmNoZXJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY19zdHJpbmdfcHJvdmlkZXI6IENfU1RSSU5HXG4gICAgICAtLSBUbyBjcmVhdGUgRWlmZmVsIHN0cmluZ3MgZnJvbSBDIHN0cmluZy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDApXG4gICAgZW5zdXJlXG4gICAgICBjX3N0cmluZ19wcm92aWRlcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBjdG9pX2NvbnZlcnRvcjogU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVE9SXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byBpbnRlZ2VyIG9yIG5hdHVyYWxcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfdHJhaWxpbmdfc2VwYXJhdG9ycyAoXCIgXCIpXG4gICAgICBSZXN1bHQuc2V0X2xlYWRpbmdfc2VwYXJhdG9yc19hY2NlcHRhYmxlIChUcnVlKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgZW5zdXJlXG4gICAgICBjdG9pX2NvbnZlcnRvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBjdG9yX2NvbnZlcnRvcjogU1RSSU5HX1RPX1JFQUxfQ09OVkVSVE9SXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byByZWFsIG9yIGRvdWJsZVxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgICAgUmVzdWx0LnNldF9sZWFkaW5nX3NlcGFyYXRvcnMgKFwiIFwiKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgICBSZXN1bHQuc2V0X3RyYWlsaW5nX3NlcGFyYXRvcnNfYWNjZXB0YWJsZSAoVHJ1ZSlcbiAgICBlbnN1cmVcbiAgICAgIGN0b3JfY29udmVydG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGRvdG5ldF9jb252ZXJ0b3I6IFNZU1RFTV9TVFJJTkdfRkFDVE9SWVxuICAgICAgLS0gQ29udmVydG9yIHVzZWQgdG8gY29udmVydCBmcm9tIGFuZCB0byBTWVNURU1fU1RSSU5HLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgIGRvdG5ldF9jb252ZXJ0b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX3Byb3BlcnRpZXM6IENIQVJBQ1RFUl9QUk9QRVJUWVxuICAgICAgLS0gQWNjZXNzIHRvIFVuaWNvZGUgY2hhcmFjdGVyIHByb3BlcnRpZXNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HX0dFTkVSQUx9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgaW50ZXJuYWxfaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBDYWNoZSBmb3IgYGhhc2hfY29kZScuXG5cbiAgaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGU6IElOVEVHRVI7XG4gICAgICAtLSBDYXNoIGZvciBgY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGUnLlxuXG5cbmZlYXR1cmUgLS0gQWNjZXNzOiBDdXJzb3JcblxuICBuZXdfY2hhcmFjdGVyXzMyX2N1cnNvcjogU1RSSU5HX0lURVJBVElPTl9DVVJTT1JcbiAgICAgIC0tIEZyZXNoIGN1cnNvciBmb3IgdGhpcyBzdHJpbmcgdGhhdCBpdGVyYXRlcyBvdmVyIGNvZGUgcG9pbnRzIChzZWUgYGNvZGUnKVxuICAgICAgLS0gZXhwb3NlZCBhcyB7Q0hBUkFDVEVSXzMyfS5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChDdXJyZW50KVxuICAgICAgUmVzdWx0LnN0YXJ0XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWFsIHZhbHVlcywgc2luZ2xlIHByZWNpc2lvblwiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlNpbmdsZVwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIFJFQUxfMzIgaW5oZXJpdFxuXG4gIFJFQUxfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBpc19uYW4sXG4gICAgICBpc19uZWdhdGl2ZV9pbmZpbml0eSxcbiAgICAgIGlzX3Bvc2l0aXZlX2luZmluaXR5LFxuICAgICAgdHJ1bmNhdGVkX3RvX2ludGVnZXIsXG4gICAgICB0cnVuY2F0ZWRfdG9faW50ZWdlcl82NCxcbiAgICAgIHRvX2RvdWJsZSxcbiAgICAgIGNlaWxpbmdfcmVhbF8zMixcbiAgICAgIGZsb29yX3JlYWxfMzIsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBvdXRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe1JFQUxfMzJfUkVGfSksXG4gIHRvX2RvdWJsZToge1JFQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBSRUFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCByZWFsP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgUmVwb3J0XG5cbiAgaXNfbmFuOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHRoZSByZXByZXNlbnRhdGlvbiBvZiBgbmFuJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaXNfbmVnYXRpdmVfaW5maW5pdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuZWdhdGl2ZV9pbmZpbml0eSc/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlzX3Bvc2l0aXZlX2luZmluaXR5OiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHRoZSByZXByZXNlbnRhdGlvbiBvZiBgcG9zaXRpdmVfaW5maW5pdHknP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdHJ1bmNhdGVkX3RvX2ludGVnZXI6IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgcGFydCAoc2FtZSBzaWduLCBsYXJnZXN0IGFic29sdXRlXG4gICAgICAtLSB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3QncylcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdHJ1bmNhdGVkX3RvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgcGFydCAoc2FtZSBzaWduLCBsYXJnZXN0IGFic29sdXRlXG4gICAgICAtLSB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3QncylcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDdXJyZW50IHNlZW4gYXMgYSBkb3VibGVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgY2VpbGluZ19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBTbWFsbGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBzbWFsbGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgZmxvb3JfcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gR3JlYXRlc3QgaW50ZWdyYWwgdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogUkVBTF8zMik6IFJFQUxfMzJcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBSRUFMXzMyKTogUkVBTF8zMlxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IFJFQUxfMzIpOiBSRUFMXzMyXG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBSRUFMXzMyKTogUkVBTF8zMlxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBDdXJyZW50IHJlYWwgdG8gdGhlIHBvd2VyIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IFJFQUxfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IFJFQUxfMzJcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcmVhbCB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGEgcmVhbCB2YWx1ZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0xMi0zMCAxNjo1NDo0OSAtMDgwMCAoTW9uLCAzMCBEZWMgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTM4NTUgJFwiXG5cbmNsYXNzIFJFQUxfMzJfUkVGIGluaGVyaXRcblxuICBOVU1FUklDXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IFJFQUxfMzJcbiAgICAgIC0tIE51bWVyaWMgcmVhbCB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHJ1bmNhdGVkX3RvX2ludGVnZXIuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAuMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAuMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKHtSRUFMXzMyfSAxLjApXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKHtSRUFMXzMyfSAwLjApXG4gICAgZW5kXG5cbiAgbmFuOiBSRUFMXzMyXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBvZiBub3QgYSBudW1iZXIgKE5hTilcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIG5lZ2F0aXZlX2luZmluaXR5OiBSRUFMXzMyXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBvZiBuZWdhdGl2ZSBpbmZpbml0eVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgcG9zaXRpdmVfaW5maW5pdHk6IFJFQUxfMzJcbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIG9mIHBvc2l0aXZlIGluZmluaXR5XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBtaW5fdmFsdWU6IFJFQUxfMzIgPSAtMy40MDI4MjM0NjYzODUyODg1OTgxMTcwZSswMzhcbiAgbWF4X3ZhbHVlOiBSRUFMXzMyID0gMy40MDI4MjM0NjYzODUyODg1OTgxMTcwZSswMzhcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbiAgbWFjaGluZV9lcHNpbG9uOiBSRUFMXzMyID0gMS4xOTIwOTI4OTU1MDc4MTI1MDAwMDAwZS0wMDdcbiAgICAgIC0tIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMSBhbmQgdGhlIGxlYXN0IHZhbHVlIGdyZWF0ZXIgdGhhblxuICAgICAgLS0gMSB0aGF0IGlzIHJlcHJlc2VudGFibGUgaW4gdGhlIGdpdmVuIGZsb2F0aW5nIHBvaW50IHR5cGUuXG5cbiAgZXBzaWxvbjogUkVBTF8zMiA9IDEuMTc1NDk0MzUwODIyMjg3NTA3OTY4OGUtMDM4XG4gICAgICAtLSBNaW5pbXVtIG5vcm1hbGl6ZWQgcG9zaXRpdmUgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCByZWFsP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKHI6IFJFQUxfMzIpXG4gICAgICAtLSBNYWtlIGByJyB0aGUgdmFsdWUgb2YgYGl0ZW0nLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogUkVBTF8zMl9SRUYpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwLjBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgcmVmX25vdF9leGFjdF96ZXJvOiBSZXN1bHQgaW1wbGllcyAob3RoZXIuaXRlbSAvPSAwLjApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDAuMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDAuMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMC4wKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwLjBcbiAgICBlbmRcblxuICBpc19uYW46IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuYW4nP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5pc19uYW5cbiAgICBlbmRcblxuICBpc19uZWdhdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYG5lZ2F0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfbmVnYXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuICBpc19wb3NpdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYHBvc2l0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfcG9zaXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBSRUFMXzMyX1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IFJFQUxfMzJfUkVGXG4gICAgICAtLSBBc3NvY2lhdGVkIHJlZmVyZW5jZSBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9faW50ZWdlcjogSU5URUdFUl8zMlxuICAgICAgLS0gSW50ZWdlciBwYXJ0IChzYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50cnVuY2F0ZWRfdG9faW50ZWdlclxuICAgIGVuZFxuXG4gIHRydW5jYXRlZF90b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBhcnQgKHNhbWUgc2lnbiwgbGFyZ2VzdCBhYnNvbHV0ZVxuICAgICAgLS0gdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0J3MpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRydW5jYXRlZF90b19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDdXJyZW50IHNlZW4gYXMgYSBkb3VibGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fZG91YmxlXG4gICAgZW5kXG5cbiAgY2VpbGluZzogSU5URUdFUl8zMlxuICAgICAgLS0gU21hbGxlc3QgaW50ZWdyYWwgdmFsdWUgbm8gc21hbGxlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjZWlsaW5nX3JlYWxfMzIudHJ1bmNhdGVkX3RvX2ludGVnZXJcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub19zbWFsbGVyOiBSZXN1bHQgPj0gaXRlbVxuICAgICAgY2xvc2VfZW5vdWdoOiBSZXN1bHQgLSBpdGVtIDwgaXRlbS5vbmVcbiAgICBlbmRcblxuICBmbG9vcjogSU5URUdFUl8zMlxuICAgICAgLS0gR3JlYXRlc3QgaW50ZWdyYWwgdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBmbG9vcl9yZWFsXzMyLnRydW5jYXRlZF90b19pbnRlZ2VyXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm9fZ3JlYXRlcjogUmVzdWx0IDw9IGl0ZW1cbiAgICAgIGNsb3NlX2Vub3VnaDogaXRlbSAtIFJlc3VsdCA8IFJlc3VsdC5vbmVcbiAgICBlbmRcblxuICByb3VuZGVkOiBJTlRFR0VSXzMyXG4gICAgICAtLSBSb3VuZGVkIGludGVncmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzaWduICogKChhYnMgKyAwLjUpLmZsb29yKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcilcbiAgICBlbmRcblxuICBjZWlsaW5nX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIFNtYWxsZXN0IGludGVncmFsIHZhbHVlIG5vIHNtYWxsZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5jZWlsaW5nX3JlYWxfMzJcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub19zbWFsbGVyOiBSZXN1bHQgPj0gaXRlbVxuICAgICAgY2xvc2VfZW5vdWdoOiBSZXN1bHQgLSBpdGVtIDwgaXRlbS5vbmVcbiAgICBlbmRcblxuICBmbG9vcl9yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBHcmVhdGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uZmxvb3JfcmVhbF8zMlxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vX2dyZWF0ZXI6IFJlc3VsdCA8PSBpdGVtXG4gICAgICBjbG9zZV9lbm91Z2g6IGl0ZW0gLSBSZXN1bHQgPCBSZXN1bHQub25lXG4gICAgZW5kXG5cbiAgcm91bmRlZF9yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBSb3VuZGVkIGludGVncmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzaWduICogKChhYnMgKyB7UkVBTF8zMn0gMC41KS5mbG9vcl9yZWFsXzMyKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gc2lnbiAqICgoYWJzICsge1JFQUxfMzJ9IDAuNSkuZmxvb3JfcmVhbF8zMilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgYWJzOiBSRUFMXzMyXG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwLjBcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgPSBpdGVtKSBvciAoUmVzdWx0ID0gLWl0ZW0pXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gQ3VycmVudCByZWFsIHRvIHRoZSBwb3dlciBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoLSBpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcmVhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5vdXRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhYnNfcmVmOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPSAwLjAgdGhlblxuICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSB3aGVuIGBpdGVtJyBpcyBgLTAnLlxuICAgICAgICBSZXN1bHQgOj0gemVyb1xuICAgICAgZWxzZWlmIGl0ZW0gPiAwLjAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBzaWduX3RpbWVzX2Ficzogbm90IGl0ZW0uaXNfbmFuIGltcGxpZXMgc2lnbiAqIGFicyA9IGl0ZW1cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlYWwgdmFsdWVzLCBkb3VibGUgcHJlY2lzaW9uXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uRG91YmxlXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgUkVBTF82NCBpbmhlcml0XG5cbiAgUkVBTF82NF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIGlzX25hbixcbiAgICAgIGlzX25lZ2F0aXZlX2luZmluaXR5LFxuICAgICAgaXNfcG9zaXRpdmVfaW5maW5pdHksXG4gICAgICB0cnVuY2F0ZWRfdG9faW50ZWdlcixcbiAgICAgIHRydW5jYXRlZF90b19pbnRlZ2VyXzY0LFxuICAgICAgdHJ1bmNhdGVkX3RvX3JlYWwsXG4gICAgICBjZWlsaW5nX3JlYWxfNjQsXG4gICAgICBmbG9vcl9yZWFsXzY0LFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBvcHBvc2l0ZSxcbiAgICAgIGlkZW50aXR5LFxuICAgICAgb3V0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtSRUFMXzY0X1JFRn0pXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBSRUFMXzY0KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCBkb3VibGU/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyBSZXBvcnRcblxuICBpc19uYW46IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuYW4nP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpc19uZWdhdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYG5lZ2F0aXZlX2luZmluaXR5Jz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaXNfcG9zaXRpdmVfaW5maW5pdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBwb3NpdGl2ZV9pbmZpbml0eSc/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0cnVuY2F0ZWRfdG9faW50ZWdlcjogSU5URUdFUl8zMlxuICAgICAgLS0gSW50ZWdlciBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gSW50ZWdlciBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gUmVhbCBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjZWlsaW5nX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIFNtYWxsZXN0IGludGVncmFsIHZhbHVlIG5vIHNtYWxsZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBmbG9vcl9yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBHcmVhdGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIFByb2R1Y3Qgd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gQ3VycmVudCBkb3VibGUgdG8gdGhlIHBvd2VyIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IFJFQUxfNjRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IFJFQUxfNjRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgZG91YmxlIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYSBkb3VibGUtcHJlY2lzaW9uIHJlYWwgbnVtYmVyXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTEyLTMwIDE2OjQ5OjM0IC0wODAwIChNb24sIDMwIERlYyAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5Mzg1NCAkXCJcblxuY2xhc3MgUkVBTF82NF9SRUYgaW5oZXJpdFxuXG4gIE5VTUVSSUNcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIENPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2hhc2hhYmxlLCBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogUkVBTF82NFxuICAgICAgLS0gTnVtZXJpYyBkb3VibGUgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRydW5jYXRlZF90b19pbnRlZ2VyLmhhc2hfY29kZVxuICAgIGVuZFxuXG4gIHNpZ246IElOVEVHRVJcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwLjAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwLjAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxLjApXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDAuMClcbiAgICBlbmRcblxuICBuYW46IFJFQUxfNjRcbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIG9mIG5vdCBhIG51bWJlciAoTmFOKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgbmVnYXRpdmVfaW5maW5pdHk6IFJFQUxfNjRcbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIG9mIG5lZ2F0aXZlIGluZmluaXR5XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBwb3NpdGl2ZV9pbmZpbml0eTogUkVBTF82NFxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gb2YgcG9zaXRpdmUgaW5maW5pdHlcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIG1pbl92YWx1ZTogUkVBTF82NCA9IC0xLjc5NzY5MzEzNDg2MjMxNTcwODE0NTJlKzMwOFxuICBtYXhfdmFsdWU6IFJFQUxfNjQgPSAxLjc5NzY5MzEzNDg2MjMxNTcwODE0NTJlKzMwOFxuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuICBtYWNoaW5lX2Vwc2lsb246IFJFQUxfNjQgPSAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzNlLTAxNlxuICAgICAgLS0gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAxIGFuZCB0aGUgbGVhc3QgdmFsdWUgZ3JlYXRlciB0aGFuXG4gICAgICAtLSAxIHRoYXQgaXMgcmVwcmVzZW50YWJsZSBpbiB0aGUgZ2l2ZW4gZmxvYXRpbmcgcG9pbnQgdHlwZS5cblxuICBlcHNpbG9uOiBSRUFMXzY0ID0gMi4yMjUwNzM4NTg1MDcyMDEzODMwOTAzZS0zMDhcbiAgICAgIC0tIE1pbmltdW0gbm9ybWFsaXplZCBwb3NpdGl2ZSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGRvdWJsZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChkOiBSRUFMXzY0KVxuICAgICAgLS0gTWFrZSBgZCcgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IFJFQUxfNjRfUkVGKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMC4wXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5vdF9leGFjdF96ZXJvOiBSZXN1bHQgaW1wbGllcyAob3RoZXIuaXRlbSAvPSAwLjApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDAuMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDAuMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMC4wKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwLjBcbiAgICBlbmRcblxuICBpc19uYW46IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuYW4nP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5pc19uYW5cbiAgICBlbmRcblxuICBpc19uZWdhdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYG5lZ2F0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfbmVnYXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuICBpc19wb3NpdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYHBvc2l0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfcG9zaXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gQ29udmVyc2lvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IFJFQUxfNjRfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogUkVBTF82NF9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRydW5jYXRlZF90b19pbnRlZ2VyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIHBhcnQgKFNhbWUgc2lnbiwgbGFyZ2VzdCBhYnNvbHV0ZVxuICAgICAgLS0gdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0J3MpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRydW5jYXRlZF90b19pbnRlZ2VyXG4gICAgZW5kXG5cbiAgdHJ1bmNhdGVkX3RvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgcGFydCAoU2FtZSBzaWduLCBsYXJnZXN0IGFic29sdXRlXG4gICAgICAtLSB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3QncylcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udHJ1bmNhdGVkX3RvX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gUmVhbCBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50cnVuY2F0ZWRfdG9fcmVhbFxuICAgIGVuZFxuXG4gIGNlaWxpbmc6IElOVEVHRVJfMzJcbiAgICAgIC0tIFNtYWxsZXN0IGludGVncmFsIHZhbHVlIG5vIHNtYWxsZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY2VpbGluZ19yZWFsXzY0LnRydW5jYXRlZF90b19pbnRlZ2VyXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm9fc21hbGxlcjogUmVzdWx0ID49IGl0ZW1cbiAgICAgIGNsb3NlX2Vub3VnaDogUmVzdWx0IC0gaXRlbSA8IGl0ZW0ub25lXG4gICAgZW5kXG5cbiAgZmxvb3I6IElOVEVHRVJfMzJcbiAgICAgIC0tIEdyZWF0ZXN0IGludGVncmFsIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZmxvb3JfcmVhbF82NC50cnVuY2F0ZWRfdG9faW50ZWdlclxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vX2dyZWF0ZXI6IFJlc3VsdCA8PSBpdGVtXG4gICAgICBjbG9zZV9lbm91Z2g6IGl0ZW0gLSBSZXN1bHQgPCBSZXN1bHQub25lXG4gICAgZW5kXG5cbiAgcm91bmRlZDogSU5URUdFUl8zMlxuICAgICAgLS0gUm91bmRlZCBpbnRlZ3JhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHNpZ24gKiAoKGFicyArIDAuNSkuZmxvb3IpXG4gICAgZW5kXG5cbiAgY2VpbGluZ19yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBTbWFsbGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBzbWFsbGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uY2VpbGluZ19yZWFsXzY0XG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm9fc21hbGxlcjogUmVzdWx0ID49IGl0ZW1cbiAgICAgIGNsb3NlX2Vub3VnaDogUmVzdWx0IC0gaXRlbSA8IGl0ZW0ub25lXG4gICAgZW5kXG5cbiAgZmxvb3JfcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gR3JlYXRlc3QgaW50ZWdyYWwgdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmZsb29yX3JlYWxfNjRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub19ncmVhdGVyOiBSZXN1bHQgPD0gaXRlbVxuICAgICAgY2xvc2VfZW5vdWdoOiBpdGVtIC0gUmVzdWx0IDwgUmVzdWx0Lm9uZVxuICAgIGVuZFxuXG4gIHJvdW5kZWRfcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gUm91bmRlZCBpbnRlZ3JhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcl9yZWFsXzY0KVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcl9yZWFsXzY0KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBhYnM6IFJFQUxfNjRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhYnNfcmVmLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDAuMFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCA9IGl0ZW0pIG9yIChSZXN1bHQgPSAtaXRlbSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEN1cnJlbnQgZG91YmxlIHRvIHRoZSBwb3dlciBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoLSBpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgZG91YmxlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLm91dFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFic19yZWY6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSA9IDAuMCB0aGVuXG4gICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIHdoZW4gYGl0ZW0nIGlzIGAtMCcuXG4gICAgICAgIFJlc3VsdCA6PSB6ZXJvXG4gICAgICBlbHNlaWYgaXRlbSA+IDAuMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAtQ3VycmVudFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCB+IEN1cnJlbnQpIG9yIChSZXN1bHQgfiAtQ3VycmVudClcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIHNpZ25fdGltZXNfYWJzOiBub3QgaXRlbS5pc19uYW4gaW1wbGllcyBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIENvbGxlY3Rpb24gb2YgZmVhdHVyZXMgdGhhdCBhcmUgdXNlZCB0byBtYXJrXG4gICAgcGxhY2VzIGluIGNvZGUgdGhhdCBuZWVkcyByZWZhY3RvcmluZy5cbiAgICBdXCJcblxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBSRUZBQ1RPUklOR19IRUxQRVJcblxuZmVhdHVyZSAtLSBNYXJrZXJzXG5cbiAgZml4bWUgKGNvbW1lbnQ6IFNUUklORylcbiAgICAgIC0tIE1hcmsgY29kZSB0aGF0IGhhcyB0byBiZSBcImZpeGVkXCIgd2l0aCBgY29tbWVudCcuXG4gICAgcmVxdWlyZVxuICAgICAgY29tbWVudF9ub3Rfdm9pZDogY29tbWVudCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIC0tIGRlYnVnIChcInJlZmFjdG9yX2ZpeG1lXCIpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9zdHJpbmcgKFwiRklYTUU6IFwiKVxuICAgICAgLS0gICBpby5lcnJvci5wdXRfc3RyaW5nIChjb21tZW50KVxuICAgICAgLS0gICBpby5lcnJvci5wdXRfbmV3X2xpbmVcbiAgICAgIC0tIGVuZFxuICAgIGVuZFxuXG4gIHRvX2ltcGxlbWVudCAoY29tbWVudDogU1RSSU5HKVxuICAgICAgLS0gTWFyayBjb2RlIHRoYXQgaGFzIHRvIGJlIFwiaW1wbGVtZW50ZWRcIiB3aXRoIGBjb21tZW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBjb21tZW50X25vdF92b2lkOiBjb21tZW50IC89IFZvaWRcbiAgICBkb1xuICAgICAgLS0gZGVidWcgKFwicmVmYWN0b3JfZml4bWVcIilcbiAgICAgIC0tICAgaW8uZXJyb3IucHV0X3N0cmluZyAoXCJUT19CRV9JTVBMRU1FTlRFRDogXCIpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9zdHJpbmcgKGNvbW1lbnQpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9uZXdfbGluZVxuICAgICAgLS0gZW5kXG4gICAgZW5kXG5cbiAgdG9faW1wbGVtZW50X2Fzc2VydGlvbiAoY29tbWVudDogU1RSSU5HKTogQk9PTEVBTlxuICAgICAgLS0gTWFyayBhc3NlcnRpb24gdGhhdCBoYXMgdG8gYmUgXCJpbXBsZW1lbnRlZFwiIHdpdGggYGNvbW1lbnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNvbW1lbnRfbm90X3ZvaWQ6IGNvbW1lbnQgLz0gVm9pZFxuICAgIGRvXG4gICAgICAtLSBUT0RPIGltcGxlbWVudCBkZWJ1ZyBzdGF0ZW1lbnRcbiAgICAgIC0tIGRlYnVnIChcInJlZmFjdG9yX2ZpeG1lXCIpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9zdHJpbmcgKFwiQVNTRVJUSU9OX1RPX0JFX0lNUExFTUVOVEVEOiBcIilcbiAgICAgIC0tICAgaW8uZXJyb3IucHV0X3N0cmluZyAoY29tbWVudClcbiAgICAgIC0tICAgaW8uZXJyb3IucHV0X25ld19saW5lXG4gICAgICAtLSBlbmRcbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgICBBY2Nlc3MgdG8gaW50ZXJuYWwgb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICBUaGlzIGNsYXNzIG1heSBiZSB1c2VkIGFzIGFuY2VzdG9yIGJ5IGNsYXNzZXMgbmVlZGluZyBpdHMgZmFjaWxpdGllcy5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA5LTA2IDIxOjQ1OjQ3IC0wNzAwIChGcmksIDA2IFNlcCAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjkxNyAkXCJcblxuY2xhc3NcbiAgUkVGTEVDVE9SXG5cbmluaGVyaXRcbiAgUkVGTEVDVE9SX0hFTFBFUlxuXG4gIFJFRkxFQ1RPUl9DT05TVEFOVFNcblxuZmVhdHVyZSAtLSBDb25mb3JtYW5jZVxuXG4gIHR5cGVfY29uZm9ybXNfdG8gKHR5cGUxLCB0eXBlMjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYHR5cGUxJyBjb25mb3JtIHRvIGB0eXBlMic/XG4gICAgcmVxdWlyZVxuICAgICAgdHlwZTFfbm9ubmVnYXRpdmU6IHR5cGUxID49IDBcbiAgICAgIHR5cGUyX25vbm5lZ2F0aXZlOiB0eXBlMiA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0udHlwZV9jb25mb3Jtc190byAodHlwZTEsIHR5cGUyKVxuICAgIGVuZFxuXG4gIGZpZWxkX2NvbmZvcm1zX3RvIChhX3NvdXJjZV90eXBlLCBhX2ZpZWxkX3R5cGU6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBhX3NvdXJjZV90eXBlJyBjb25mb3JtIHRvIGBhX2ZpZWxkX3R5cGUnP1xuICAgICAgLS18IERpZmZlcmVudCBmcm9tIGB0eXBlX2NvbmZvcm1zX3RvJyBzaW5jZSBwb3NzaWJsZSBhdHRhY2htZW50IG1hcmsgb2YgYGFfZmllbGRfdHlwZSdcbiAgICAgIC0tfCBpcyBkaXNjYXJkZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zb3VyY2VfdHlwZV9ub25fbmVnYXRpdmU6IGFfc291cmNlX3R5cGUgPj0gMFxuICAgICAgYV9maWVsZF90eXBlX25vbl9uZWdhdGl2ZTogYV9maWVsZF90eXBlID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS50eXBlX2NvbmZvcm1zX3RvIChhX3NvdXJjZV90eXBlLCB7SVNFX1JVTlRJTUV9LmRldGFjaGFibGVfdHlwZSAoYV9maWVsZF90eXBlKSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDcmVhdGlvblxuXG4gIGR5bmFtaWNfdHlwZV9mcm9tX3N0cmluZyAoY2xhc3NfdHlwZTogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBJTlRFR0VSXG4gICAgICAtLSBEeW5hbWljIHR5cGUgY29ycmVzcG9uZGluZyB0byBgY2xhc3NfdHlwZScuXG4gICAgICAtLSBJZiBubyBkeW5hbWljIHR5cGUgYXZhaWxhYmxlLCByZXR1cm5zIC0xLlxuICAgIHJlcXVpcmVcbiAgICAgIGNsYXNzX3R5cGVfbm90X3ZvaWQ6IGNsYXNzX3R5cGUgLz0gVm9pZFxuICAgICAgY2xhc3NfdHlwZV9ub3RfZW1wdHk6IG5vdCBjbGFzc190eXBlLmlzX2VtcHR5XG4gICAgICBpc192YWxpZF90eXBlX3N0cmluZzogaXNfdmFsaWRfdHlwZV9zdHJpbmcgKGNsYXNzX3R5cGUpXG4gICAgbG9jYWxcbiAgICAgIGxfY3N0cjogQ19TVFJJTkdcbiAgICAgIGxfdGFibGU6IGxpa2UgaW50ZXJuYWxfZHluYW1pY190eXBlX3N0cmluZ190YWJsZVxuICAgICAgbF9wcmVfZWNtYV9zdGF0dXM6IEJPT0xFQU5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBsX3RhYmxlIDo9IGludGVybmFsX2R5bmFtaWNfdHlwZV9zdHJpbmdfdGFibGVcbiAgICAgIC0tIGxfdGFibGUuc2VhcmNoIChjbGFzc190eXBlKVxuICAgICAgLS0gaWYgbF90YWJsZS5mb3VuZCB0aGVuXG4gICAgICAtLSAgIFJlc3VsdCA6PSBsX3RhYmxlLmZvdW5kX2l0ZW1cbiAgICAgIC0tIGVsc2VcbiAgICAgIC0tICAgY3JlYXRlIGxfY3N0ci5tYWtlIChjbGFzc190eXBlKVxuICAgICAgLS0gICAgIC0tIFRha2UgaW50byBjb25zaWRlcmF0aW9uIHBvc3NpYmxlIHByZS1FQ01BIG1hcHBpbmcuXG4gICAgICAtLSAgIGxfcHJlX2VjbWFfc3RhdHVzIDo9IHtJU0VfUlVOVElNRX0ucHJlX2VjbWFfbWFwcGluZ19zdGF0dXNcbiAgICAgIC0tICAge0lTRV9SVU5USU1FfS5zZXRfcHJlX2VjbWFfbWFwcGluZyAobm90IGlzX3ByZV9lY21hX21hcHBpbmdfZGlzYWJsZWQpXG4gICAgICAtLSAgIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LnR5cGVfaWRfZnJvbV9uYW1lIChsX2NzdHIuaXRlbSlcbiAgICAgIC0tICAge0lTRV9SVU5USU1FfS5zZXRfcHJlX2VjbWFfbWFwcGluZyAobF9wcmVfZWNtYV9zdGF0dXMpXG4gICAgICAtLSAgIGxfdGFibGUucHV0IChSZXN1bHQsIGNsYXNzX3R5cGUpXG4gICAgICAtLSBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9mcm9tX3N0cmluZ192YWxpZDogUmVzdWx0ID0gLTEgb3IgUmVzdWx0ID0gbm9uZV90eXBlIG9yIFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgbmV3X2luc3RhbmNlX29mICh0eXBlX2lkOiBJTlRFR0VSKTogQU5ZXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgZHluYW1pYyBgdHlwZV9pZCcuXG4gICAgICAtLSBOb3RlOiByZXR1cm5lZCBvYmplY3QgaXMgbm90IGluaXRpYWxpemVkIGFuZCBtYXlcbiAgICAgIC0tIGhlbmNlIHZpb2xhdGUgaXRzIGludmFyaWFudC5cbiAgICAgIC0tIGB0eXBlX2lkJyBjYW5ub3QgcmVwcmVzZW50IGEgU1BFQ0lBTCB0eXBlLCB1c2VcbiAgICAgIC0tIGBuZXdfc3BlY2lhbF9hbnlfaW5zdGFuY2UnIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICBub3Rfc3BlY2lhbF90eXBlOiBub3QgaXNfc3BlY2lhbF90eXBlICh0eXBlX2lkKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19uZXdfaW5zdGFuY2Vfb2YgKHR5cGVfaWQpXG4gICAgZW5zdXJlXG4gICAgICBub3Rfc3BlY2lhbF90eXBlOiBub3QgYXR0YWNoZWQge1NQRUNJQUwgW2RldGFjaGFibGUgQU5ZXX0gUmVzdWx0XG4gICAgICBkeW5hbWljX3R5cGVfc2V0OiBSZXN1bHQuZ2VuZXJhdGluZ190eXBlLnR5cGVfaWQgPSB0eXBlX2lkXG4gICAgZW5kXG5cbiAgbmV3X3NwZWNpYWxfYW55X2luc3RhbmNlICh0eXBlX2lkLCBjb3VudDogSU5URUdFUik6IFNQRUNJQUwgW2RldGFjaGFibGUgQU5ZXVxuICAgICAgLS0gTmV3IGluc3RhbmNlIG9mIGR5bmFtaWMgYHR5cGVfaWQnIHRoYXQgcmVwcmVzZW50c1xuICAgICAgLS0gYSBTUEVDSUFMIHdpdGggYGNvdW50JyBlbGVtZW50LiBUbyBjcmVhdGUgYSBTUEVDSUFMIG9mXG4gICAgICAtLSBiYXNpYyB0eXBlLCB1c2UgYFNQRUNJQUwnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNvdW50X3ZhbGlkOiBjb3VudCA+PSAwXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICAgIHNwZWNpYWxfdHlwZTogaXNfc3BlY2lhbF9hbnlfdHlwZSAodHlwZV9pZClcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5IChjb3VudClcbiAgICAgIGNfc2V0X2R5bmFtaWNfdHlwZSAoUmVzdWx0LCB0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgZHluYW1pY190eXBlX3NldDogUmVzdWx0LmdlbmVyYXRpbmdfdHlwZS50eXBlX2lkID0gdHlwZV9pZFxuICAgICAgY291bnRfc2V0OiBSZXN1bHQuY291bnQgPSAwXG4gICAgICBjYXBhY2l0eV9zZXQ6IFJlc3VsdC5jYXBhY2l0eSA9IGNvdW50XG4gICAgZW5kXG5cbiAgbmV3X3R1cGxlX2Zyb21fc3BlY2lhbCAodHlwZV9pZDogSU5URUdFUjsgdmFsdWVzOiBTUEVDSUFMIFtkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWV0pOiBkZXRhY2hhYmxlIFRVUExFXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgYSB0dXBsZSBvZiB0eXBlIGB0eXBlX2lkJyBmaWxsZWQgd2l0aCBgdmFsdWVzJyBpZiBhbGwgdHlwZXMgb2YgaXRlbXMgYXJlIHN1aXRhYmxlLlxuICAgICAgLS0gYFZvaWQnIGlmIHNvbWUgaXRlbXMgZnJvbSBgdmFsdWVzJyBhcmUgaW5hcHByb3ByaWF0ZSBmb3IgYSB0dXBsZSBvZiB0eXBlIGB0eXBlX2lkJy5cbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICAgIGlzX3R1cGxlX3R5cGU6IGlzX3R1cGxlX3R5cGUgKHR5cGVfaWQpXG4gICAgICAtLSBzdWZmaWNpZW50X3ZhbHVlc19jb3VudDogdmFsdWVzLmNvdW50ID49IHR1cGxlX3R5cGVfY291bnQgKHR5cGVfaWQpXG4gICAgICAtLSB2YWxpZF92YWx1ZV90eXBlczogYWNyb3NzIDEgfC4ufCB0dXBsZV90eXBlX2NvdW50ICh0eXBlX2lkKSBhcyBpIGFsbCB2YWxpZF9vYmplY3RfZm9yX3R1cGxlX2luZGV4ICh2YWx1ZXMgW2kgLSAxXSwgaSlcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgdjogZGV0YWNoYWJsZSBzZXBhcmF0ZSBBTllcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNfbmV3X3R1cGxlX2luc3RhbmNlX29mICh0eXBlX2lkKVxuICAgICAgaSA6PSBSZXN1bHQuY291bnRcbiAgICAgIGlmIGkgPD0gdmFsdWVzLmNvdW50IHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPD0gMCBvciBlbHNlIG5vdCBhdHRhY2hlZCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIHYgOj0gdmFsdWVzIFtpIC0gMV1cbiAgICAgICAgICBpZiBSZXN1bHQudmFsaWRfdHlwZV9mb3JfaW5kZXggKHYsIGkpIHRoZW5cbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIGNvbXBhdGlibGUgd2l0aCB0dXBsZSBpdGVtIGF0IGluZGV4IGBpJy5cbiAgICAgICAgICAgIFJlc3VsdCBbaV0gOj0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdHVwbGUgaXRlbSBhdCBpbmRleCBgaScuXG4gICAgICAgICAgICBSZXN1bHQgOj0gVm9pZFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gSW5zdWZmaWNpZW50IG51bWJlciBvZiB2YWx1ZXMuXG4gICAgICAgIFJlc3VsdCA6PSBWb2lkXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9zZXQ6IGF0dGFjaGVkIFJlc3VsdCBpbXBsaWVzIFJlc3VsdC5nZW5lcmF0aW5nX3R5cGUudHlwZV9pZCA9IHR5cGVfaWRcbiAgICAgIHZhbHVlc19zZXQ6IGF0dGFjaGVkIFJlc3VsdCBpbXBsaWVzIGFjcm9zcyAxIHwuLnwgUmVzdWx0LmNvdW50IGFzIGsgYWxsIFJlc3VsdC5pdGVtIChrLml0ZW0pID0gdmFsdWVzIFtrLml0ZW0gLSAxXSBlbmRcbiAgICBlbmRcblxuICBuZXdfdHVwbGVfZnJvbV90dXBsZSAodHlwZV9pZDogSU5URUdFUjsgc291cmNlOiBzZXBhcmF0ZSBUVVBMRSk6IGRldGFjaGFibGUgVFVQTEVcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBhIHR1cGxlIG9mIHR5cGUgYHR5cGVfaWQnIGZpbGxlZCB3aXRoIHZhbHVlcyBmb20gYHNvdXJjZScgaWYgYWxsIHZhbHVlIHR5cGVzIGFyZSBzdWl0YWJsZS5cbiAgICAgIC0tIGBWb2lkJyBpZiBzb21lIHZhbHVlcyBmcm9tIGBzb3VyY2UnIGFyZSBpbmFwcHJvcHJpYXRlIGZvciBhIHR1cGxlIG9mIHR5cGUgYHR5cGVfaWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgICAgaXNfdHVwbGVfdHlwZTogaXNfdHVwbGVfdHlwZSAodHlwZV9pZClcbiAgICAgIC0tIHN1ZmZpY2llbnRfdmFsdWVzX2NvdW50OiBzb3VyY2UuY291bnQgPj0gdHVwbGVfdHlwZV9jb3VudCAodHlwZV9pZClcbiAgICAgIC0tIHZhbGlkX3ZhbHVlX3R5cGVzOiBhY3Jvc3MgMSB8Li58IHR1cGxlX3R5cGVfY291bnQgKHR5cGVfaWQpIGFzIGkgYWxsIHZhbGlkX29iamVjdF9mb3JfdHVwbGVfaW5kZXggKHZhbHVlcyBbaSAtIDFdLCBpKVxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICB2OiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19uZXdfdHVwbGVfaW5zdGFuY2Vfb2YgKHR5cGVfaWQpXG4gICAgICBpIDo9IFJlc3VsdC5jb3VudFxuICAgICAgaWYgaSA8PSBzb3VyY2UuY291bnQgdGhlblxuICAgICAgICBpZiBzb3VyY2Uub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIFJlc3VsdC5jb21wYXJlX29iamVjdHNcbiAgICAgICAgZW5kXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpIDw9IDAgb3IgZWxzZSBub3QgYXR0YWNoZWQgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICB2IDo9IHNvdXJjZSBbaV1cbiAgICAgICAgICBpZiBSZXN1bHQudmFsaWRfdHlwZV9mb3JfaW5kZXggKHYsIGkpIHRoZW5cbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIGNvbXBhdGlibGUgd2l0aCB0dXBsZSBpdGVtIGF0IGluZGV4IGBpJy5cbiAgICAgICAgICAgIFJlc3VsdCBbaV0gOj0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdHVwbGUgaXRlbSBhdCBpbmRleCBgaScuXG4gICAgICAgICAgICBSZXN1bHQgOj0gVm9pZFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gSW5zdWZmaWNpZW50IG51bWJlciBvZiB2YWx1ZXMuXG4gICAgICAgIFJlc3VsdCA6PSBWb2lkXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9zZXQ6IGF0dGFjaGVkIFJlc3VsdCBpbXBsaWVzIFJlc3VsdC5nZW5lcmF0aW5nX3R5cGUudHlwZV9pZCA9IHR5cGVfaWRcbiAgICAgIG9iamVjdF9jb21wYXJpc29uX3NldDogYXR0YWNoZWQgUmVzdWx0IGltcGxpZXMgUmVzdWx0Lm9iamVjdF9jb21wYXJpc29uID0gc291cmNlLm9iamVjdF9jb21wYXJpc29uXG4gICAgICB2YWx1ZXNfc2V0OiBhdHRhY2hlZCBSZXN1bHQgaW1wbGllcyBhY3Jvc3MgMSB8Li58IFJlc3VsdC5jb3VudCBhcyBrIGFsbCBSZXN1bHQuaXRlbSAoay5pdGVtKSA9IHNvdXJjZSBbay5pdGVtXSBlbmRcbiAgICBlbmRcblxuICB0eXBlX29mX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBUWVBFIFtkZXRhY2hhYmxlIEFOWV1cbiAgICAgIC0tIEFzc29jaWF0ZWQgVFlQRSBpbnN0YW5jZSBmb3IgYW4gb2JqZWN0IG9mIHR5cGUgaWQgYHR5cGVfaWQnXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjX25ld190eXBlX2luc3RhbmNlX29mICh0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19zcGVjaWFsX2FueV90eXBlICh0eXBlX2lkOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSByZXByZXNlbnRlZCBieSBgdHlwZV9pZCcgcmVwcmVzZW50XG4gICAgICAtLSBhIFNQRUNJQUwgW1hYXSB3aGVyZSBYWCBpcyBhIHJlZmVyZW5jZSB0eXBlLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlIChFSUZfSU5URUdFUik6IEVJRl9CT09MRUFOIHVzZSAlXCJlaWZfaW50ZXJuYWwuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZWlmX3NwZWNpYWxfYW55X3R5cGVcIlxuICAgIGVuZFxuXG4gIGlzX3NwZWNpYWxfdHlwZSAodHlwZV9pZDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIHR5cGUgcmVwcmVzZW50ZWQgYnkgYHR5cGVfaWQnIHJlcHJlc2VudFxuICAgICAgLS0gYSBTUEVDSUFMIFtYWF0gd2hlcmUgWFggaXMgYSByZWZlcmVuY2UgdHlwZVxuICAgICAgLS0gb3IgYSBiYXNpYyB0eXBlLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlIChFSUZfSU5URUdFUik6IEJPT0xFQU4gdXNlICVcImVpZl9pbnRlcm5hbC5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJlaWZfaXNfc3BlY2lhbF90eXBlXCJcbiAgICBlbmRcblxuICBpc190dXBsZV90eXBlICh0eXBlX2lkOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSByZXByZXNlbnRlZCBieSBgdHlwZV9pZCcgcmVwcmVzZW50IGEgVFVQTEU/XG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBzaWduYXR1cmUgKEVJRl9JTlRFR0VSKTogQk9PTEVBTiB1c2UgJVwiZWlmX2ludGVybmFsLmglXCJcIlxuICAgIGFsaWFzXG4gICAgICBcImVpZl9pc190dXBsZV90eXBlXCJcbiAgICBlbmRcblxuICBpc19hdHRhY2hlZF90eXBlIChhX3R5cGVfaWQ6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYV90eXBlX2lkJyBhbiBhdHRhY2hlZCB0eXBlP1xuICAgIHJlcXVpcmVcbiAgICAgIGFfdHlwZV9ub25fbmVnYXRpdmU6IGFfdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uaXNfYXR0YWNoZWRfdHlwZSAoYV90eXBlX2lkKVxuICAgIGVuZFxuXG4gIGlzX2ZpZWxkX3RyYW5zaWVudF9vZl90eXBlIChpOiBJTlRFR0VSOyBhX3R5cGVfaWQ6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaSctdGggZmllbGQgb2YgYG9iamVjdCcgYSB0cmFuc2llbnQgYXR0cmlidXRlP1xuICAgICAgLS0gSS5lLiBhbiBhdHRyaWJ1dGUgdGhhdCBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0b3JlZD9cbiAgICByZXF1aXJlXG4gICAgICBhX3R5cGVfbm9uX25lZ2F0aXZlOiBhX3R5cGVfaWQgPj0gMFxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDFcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBmaWVsZF9jb3VudF9vZl90eXBlIChhX3R5cGVfaWQpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uaXNfZmllbGRfdHJhbnNpZW50X29mX3R5cGUgKGksIGFfdHlwZV9pZClcbiAgICBlbmRcblxuICBpc19maWVsZF9leHBhbmRlZF9vZl90eXBlIChpOiBJTlRFR0VSOyBhX3R5cGVfaWQ6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaSctdGggZmllbGQgb2YgdHlwZSBgYV90eXBlX2lkJyBhIHVzZXItZGVmaW5lZCBleHBhbmRlZCBhdHRyaWJ1dGU/XG4gICAgcmVxdWlyZVxuICAgICAgYV90eXBlX25vbl9uZWdhdGl2ZTogYV90eXBlX2lkID49IDBcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAxXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gZmllbGRfY291bnRfb2ZfdHlwZSAoYV90eXBlX2lkKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LmlzX2ZpZWxkX2V4cGFuZGVkX29mX3R5cGUgKGksIGFfdHlwZV9pZClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBjbGFzc19uYW1lX29mX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIGR5bmFtaWMgdHlwZSBgdHlwZV9pZCcuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uZ2VuZXJhdG9yX29mX3R5cGUgKHR5cGVfaWQpXG4gICAgZW5kXG5cbiAgdHlwZV9uYW1lX29mX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgYHR5cGVfaWQnJ3MgZ2VuZXJhdGluZyB0eXBlICh0eXBlIG9mIHdoaWNoIGB0eXBlX2lkJ1xuICAgICAgLS0gaXMgYSBkaXJlY3QgaW5zdGFuY2UpLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LmdlbmVyYXRpbmdfdHlwZV9vZl90eXBlICh0eXBlX2lkKVxuICAgIGVuZFxuXG4gIGF0dGFjaGVkX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBBdHRhY2hlZCB2ZXJzaW9uIG9mIGB0eXBlX2lkJy5cbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS5hdHRhY2hlZF90eXBlICh0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgdW5jaGFuZ2VkX2lmX2F0dGFjaGVkOiBpc19hdHRhY2hlZF90eXBlICh0eXBlX2lkKSBpbXBsaWVzIHR5cGVfaWQgPSBSZXN1bHRcbiAgICBlbmRcblxuICBkZXRhY2hhYmxlX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBEZXRhY2hhYmxlIHZlcnNpb24gb2YgYHR5cGVfaWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LmRldGFjaGFibGVfdHlwZSAodHlwZV9pZClcbiAgICBlbnN1cmVcbiAgICAgIHVuY2hhbmdlZF9pZl9kZXRhY2hhYmxlOiBub3QgaXNfYXR0YWNoZWRfdHlwZSAodHlwZV9pZCkgaW1wbGllcyB0eXBlX2lkID0gUmVzdWx0XG4gICAgZW5kXG5cbiAgZ2VuZXJpY19jb3VudF9vZl90eXBlICh0eXBlX2lkOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGdlbmVyaWMgcGFyYW1ldGVyIGluIGB0eXBlX2lkJy5cbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS5nZW5lcmljX3BhcmFtZXRlcl9jb3VudCAodHlwZV9pZClcbiAgICBlbmRcblxuICBnZW5lcmljX2R5bmFtaWNfdHlwZV9vZl90eXBlICh0eXBlX2lkOiBJTlRFR0VSOyBpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gRHluYW1pYyB0eXBlIG9mIGdlbmVyaWMgcGFyYW1ldGVyIG9mIGB0eXBlX2lkJyBhdCBwb3NpdGlvbiBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICB0eXBlX2lkX2dlbmVyaWM6IGdlbmVyaWNfY291bnRfb2ZfdHlwZSAodHlwZV9pZCkgPiAwXG4gICAgICBpX3ZhbGlkOiBpID4gMCBhbmQgaSA8PSBnZW5lcmljX2NvdW50X29mX3R5cGUgKHR5cGVfaWQpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uZWlmX2dlbl9wYXJhbV9pZCAodHlwZV9pZCwgaSlcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9ub25uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBzdG9yYWJsZV92ZXJzaW9uX29mX3R5cGUgKGFfdHlwZV9pZDogSU5URUdFUik6IGRldGFjaGFibGUgSU1NVVRBQkxFX1NUUklOR184XG4gICAgICAtLSBTdG9yYWJsZSB2ZXJzaW9uIGlmIGFueSBzcGVjaWZpZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV90eXBlX2lkX25vbm5lZ2F0aXZlOiBhX3R5cGVfaWQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX3Jlc3VsdCwgbF9udWxsOiBQT0lOVEVSXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gaWRfdG9fc3RvcmFibGVfdmVyc2lvbi5zZWFyY2ggKGFfdHlwZV9pZClcbiAgICAgIC0tIGlmIGlkX3RvX3N0b3JhYmxlX3ZlcnNpb24uZm91bmQgdGhlblxuICAgICAgLS0gICBSZXN1bHQgOj0gaWRfdG9fc3RvcmFibGVfdmVyc2lvbi5mb3VuZF9pdGVtXG4gICAgICAtLSBlbHNlXG4gICAgICAtLSAgIGxfcmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uc3RvcmFibGVfdmVyc2lvbl9vZl90eXBlIChhX3R5cGVfaWQpXG4gICAgICAtLSAgIGlmIGxfcmVzdWx0IC89IGxfbnVsbCB0aGVuXG4gICAgICAtLSAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fYyAobF9yZXN1bHQpXG4gICAgICAtLSAgICAgaWYgUmVzdWx0LmlzX2VtcHR5IHRoZW5cbiAgICAgIC0tICAgICAgIFJlc3VsdCA6PSBWb2lkXG4gICAgICAtLSAgICAgZW5kXG4gICAgICAtLSAgIGVuZFxuICAgICAgLS0gICBpZF90b19zdG9yYWJsZV92ZXJzaW9uLnB1dCAoUmVzdWx0LCBhX3R5cGVfaWQpXG4gICAgICAtLSBlbmRcbiAgICBlbmRcblxuICBmaWVsZF9uYW1lX29mX3R5cGUgKGk6IElOVEVHRVI7IHR5cGVfaWQ6IElOVEVHRVIpOiBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgYGknLXRoIGZpZWxkIG9mIGR5bmFtaWMgdHlwZSBgdHlwZV9pZCcuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdodDogaSA8PSBmaWVsZF9jb3VudF9vZl90eXBlICh0eXBlX2lkKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX2MgKHtJU0VfUlVOVElNRX0uZmllbGRfbmFtZV9vZl90eXBlIChpLCB0eXBlX2lkKSlcbiAgICBlbmRcblxuICBmaWVsZF90eXBlX29mX3R5cGUgKGk6IElOVEVHRVI7IHR5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIG9mIGBpJy10aCBmaWVsZCBvZiBkeW5hbWljIHR5cGUgYHR5cGVfaWQnXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGZpZWxkX2NvdW50X29mX3R5cGUgKHR5cGVfaWQpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uZmllbGRfdHlwZV9vZl90eXBlIChpLCB0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgZmllbGRfdHlwZV9ub25uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBmaWVsZF9zdGF0aWNfdHlwZV9vZl90eXBlIChpOiBJTlRFR0VSOyB0eXBlX2lkOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gU3RhdGljIHR5cGUgb2YgZGVjbGFyZWQgYGknLXRoIGZpZWxkIG9mIGR5bmFtaWMgdHlwZSBgdHlwZV9pZCdcbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAxXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gZmllbGRfY291bnRfb2ZfdHlwZSAodHlwZV9pZClcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS5maWVsZF9zdGF0aWNfdHlwZV9vZl90eXBlIChpLCB0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgZmllbGRfdHlwZV9ub25uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBWZXJzaW9uXG5cbiAgY29tcGlsZXJfdmVyc2lvbjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgZmllbGRfY291bnRfb2ZfdHlwZSAodHlwZV9pZDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBsb2dpY2FsIGZpZWxkcyBpbiBkeW5hbWljIHR5cGUgYHR5cGVfaWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gc2lnbmF0dXJlIChFSUZfSU5URUdFUik6IEVJRl9JTlRFR0VSIHVzZSAlXCJlaWZfaW50ZXJuYWwuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZWlfY291bnRfZmllbGRfb2ZfdHlwZVwiXG4gICAgZW5kXG5cbiAgcGVyc2lzdGVudF9maWVsZF9jb3VudF9vZl90eXBlIChhX3R5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgbG9naWNhbCBmaWVsZHMgaW4gZHluYW1pYyB0eXBlIGB0eXBlX2lkJyB0aGF0IGFyZSBub3QgdHJhbnNpZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIGFfdHlwZV9ub25fbmVnYXRpdmU6IGFfdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0ucGVyc2lzdGVudF9maWVsZF9jb3VudF9vZl90eXBlIChhX3R5cGVfaWQpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgaW50ZXJuYWxfZHluYW1pY190eXBlX3N0cmluZ190YWJsZTogU1RSSU5HX1RBQkxFIFtJTlRFR0VSXVxuICAgICAgLS0gVGFibGUgb2YgZHluYW1pYyB0eXBlIGluZGV4ZWQgYnkgdHlwZSBuYW1lXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMDApXG4gICAgZW5zdXJlXG4gICAgICBpbnRlcm5hbF9keW5hbWljX3R5cGVfc3RyaW5nX3RhYmxlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGlkX3RvX3N0b3JhYmxlX3ZlcnNpb246IEhBU0hfVEFCTEUgW2RldGFjaGFibGUgSU1NVVRBQkxFX1NUUklOR184LCBJTlRFR0VSXVxuICAgICAgLS0gQnVmZmVyIGZvciBgc3RvcmFibGVfdmVyc2lvbl9vZl90eXBlJyBsb29rdXBzIGluZGV4IGJ5IHR5cGVfaWQuXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMDApXG4gICAgZW5zdXJlXG4gICAgICBpZF90b19zdG9yYWJsZV92ZXJzaW9uX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGNfbmV3X2luc3RhbmNlX29mICh0eXBlX2lkOiBJTlRFR0VSKTogQU5ZXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgZHluYW1pYyBgdHlwZV9pZCcuXG4gICAgICAtLSBOb3RlOiByZXR1cm5lZCBvYmplY3QgaXMgbm90IGluaXRpYWxpemVkIGFuZCBtYXlcbiAgICAgIC0tIGhlbmNlIHZpb2xhdGUgaXRzIGludmFyaWFudC5cbiAgICAgIC0tIGB0eXBlX2lkJyBjYW5ub3QgcmVwcmVzZW50IGEgU1BFQ0lBTCB0eXBlLCB1c2VcbiAgICAgIC0tIGBuZXdfc3BlY2lhbF9hbnlfaW5zdGFuY2UnIGluc3RlYWQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX21hY3Jvcy5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJSVExOU01BUlRcIlxuICAgIGVuZFxuXG4gIGNfbmV3X3R1cGxlX2luc3RhbmNlX29mICh0eXBlX2lkOiBJTlRFR0VSKTogVFVQTEVcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiB0dXBsZSBvZiB0eXBlIGB0eXBlX2lkJy5cbiAgICAgIC0tIE5vdGU6IHJldHVybmVkIG9iamVjdCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIG1heVxuICAgICAgLS0gaGVuY2UgdmlvbGF0ZSBpdHMgaW52YXJpYW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9tYWNyb3MuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiUlRMTlRcIlxuICAgIGVuZFxuXG4gIGNfbmV3X3R5cGVfaW5zdGFuY2Vfb2YgKHR5cGVfaWQ6IElOVEVHRVIpOiBUWVBFIFtkZXRhY2hhYmxlIEFOWV1cbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBUWVBFIGZvciBvYmplY3Qgb2YgdHlwZSBgdHlwZV9pZCcuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX21hY3Jvcy5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJSVExOVFlcIlxuICAgIGVuZFxuXG4gIGNfc2V0X2R5bmFtaWNfdHlwZSAob2JqOiBTUEVDSUFMIFtkZXRhY2hhYmxlIEFOWV07IGR0eXBlOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBvYmonIGR5bmFtaWMgdHlwZSB0byBgZHR5cGUnLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEzLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb25zdGFudHMgdG8gcmVwcmVzZW50IGFic3RyYWN0IHR5cGVzIGluIHtSRUZGTEVDVE9SfSBhbmQge09CSkVDVF9QUk9YWX0uXCJcbiAgY2VjaWw6IFwiVGhlIHZhbHVlcyBhcmUgaW4gc3luYyB3aXRoIENFQ0lMIGNvbnN0YW50cyBFSUZfKl9UWVBFLlwiXG4gIHJ1bnRpbWU6IFwiVGhlIHZhbHVlcyByZXByZXNlbnQgYWJzdHJhY3QgdHlwZXMgdXNlZCBieSBydW4tdGltZSwgZS5nLiB7SVNFX1JVTlRJTUV9LmZpZWxkX3R5cGVfb2ZfdHlwZS5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA1LTIwIDE2OjE1OjE3IC0wNzAwIChNb24sIDIwIE1heSAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjU1NyAkXCJcblxuY2xhc3NcbiAgUkVGTEVDVE9SX0NPTlNUQU5UU1xuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIG5vbmVfdHlwZTogSU5URUdFUiA9IC0yXG4gICAgICAtLSBUeXBlIElEIHJlcHJlc2VudGF0aW9uIGZvciBOT05FLlxuXG4gIHBvaW50ZXJfdHlwZTogSU5URUdFUiA9IDBcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7UE9JTlRFUn0uXG5cbiAgcmVmZXJlbmNlX3R5cGU6IElOVEVHRVIgPSAxXG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBhIHJlZmVyZW5jZSB0eXBlLlxuXG4gIGNoYXJhY3Rlcl84X3R5cGUsIGNoYXJhY3Rlcl90eXBlOiBJTlRFR0VSID0gMlxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtDSEFSQUNURVJfOH0uXG5cbiAgYm9vbGVhbl90eXBlOiBJTlRFR0VSID0gM1xuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtCT09MRUFOfS5cblxuICBpbnRlZ2VyXzMyX3R5cGUsIGludGVnZXJfdHlwZTogSU5URUdFUiA9IDRcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7SU5URUdFUl8zMn0uXG5cbiAgcmVhbF8zMl90eXBlLCByZWFsX3R5cGU6IElOVEVHRVIgPSA1XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBwcmVkZWZpbmVkIHR5cGUge1JFQUxfMzJ9LlxuXG4gIHJlYWxfNjRfdHlwZSwgZG91YmxlX3R5cGU6IElOVEVHRVIgPSA2XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBwcmVkZWZpbmVkIHR5cGUge1JFQUxfNjR9LlxuXG4gIGV4cGFuZGVkX3R5cGU6IElOVEVHRVIgPSA3XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBhIG5vbi1wcmVkZWZpbmVkIGV4cGFuZGVkIHR5cGUuXG5cbiAgYml0X3R5cGU6IElOVEVHRVIgPSA4XG4gICAgICAtLSBUaGlzIHR5cGUgaXMgb2Jzb2xldGUgYW5kIGlzIG5vdCB1c2VkIGFueW1vcmUuXG5cbiAgaW50ZWdlcl84X3R5cGU6IElOVEVHRVIgPSA5XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBwcmVkZWZpbmVkIHR5cGUge0lOVEVHRVJfOH0uXG5cbiAgaW50ZWdlcl8xNl90eXBlOiBJTlRFR0VSID0gMTBcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7SU5URUdFUl8xNn0uXG5cbiAgaW50ZWdlcl82NF90eXBlOiBJTlRFR0VSID0gMTFcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7SU5URUdFUl82NH0uXG5cbiAgY2hhcmFjdGVyXzMyX3R5cGUsIHdpZGVfY2hhcmFjdGVyX3R5cGU6IElOVEVHRVIgPSAxMlxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtDSEFSQUNURVJfMzJ9LlxuXG4gIG5hdHVyYWxfOF90eXBlOiBJTlRFR0VSID0gMTNcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7TkFUVVJBTF84fS5cblxuICBuYXR1cmFsXzE2X3R5cGU6IElOVEVHRVIgPSAxNFxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtOQVRVUkFMXzE2fS5cblxuICBuYXR1cmFsXzMyX3R5cGU6IElOVEVHRVIgPSAxNVxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtOQVRVUkFMXzMyfS5cblxuICBuYXR1cmFsXzY0X3R5cGU6IElOVEVHRVIgPSAxNlxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtOQVRVUkFMXzY0fS5cblxuICBtaW5fcHJlZGVmaW5lZF90eXBlOiBJTlRFR0VSID0gLTJcbiAgbWF4X3ByZWRlZmluZWRfdHlwZTogSU5URUdFUiA9IDE2XG5cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiSGVscGVyIGZvciByb3V0aW5lcyBpbiBJTlRFUk5BTCBjbGFzcy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDMtMDQgMTU6MDE6MjUgLTA4MDAgKE1vbiwgMDQgTWFyIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTc4ICRcIlxuXG5jbGFzc1xuICBSRUZMRUNUT1JfSEVMUEVSXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX3ByZV9lY21hX21hcHBpbmdfZGlzYWJsZWQ6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBtYXBwaW5nIG9sZCBuYW1lcyB0byBuZXcgRUNNQSBuYW1lcz9cbiAgICAgIC0tIEZhbHNlIG1lYW5zIG1hcHBpbmcgU1RSSU5HIHRvIFNUUklOR184LCBJTlRFR0VSIHRvIElOVEVHRVJfMzIsLi4uXG4gICAgICAtLSBSZWRlZmluZSBpbiBkZXNjZW5kYW50cyBvZiBSRUZMRUNUT1IgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZiBpbnNwZWN0aW9uIHF1ZXJpZXMgb2YgUkVGTEVDVE9SLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICBlbmRcblxuICBpc192YWxpZF90eXBlX3N0cmluZyAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgcycgYSB2YWxpZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGEgVFlQRS5cbiAgICBsb2NhbFxuICAgICAgbF90eXBlX25hbWU6IFNUUklOR18zMlxuICAgICAgbF9zdGFydF9wb3MsIGxfZW5kX3BvczogSU5URUdFUlxuICAgICAgbF9jbGFzc190eXBlX25hbWU6IFNUUklOR18zMlxuICAgICAgbF9wYXJhbWV0ZXJzOiBsaWtlIHBhcmFtZXRlcnNfZGVjb21wb3NpdGlvblxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgYW5kIHRoZW4gbm90IHMuaXNfZW1wdHkgdGhlblxuICAgICAgICBjcmVhdGUgbF9jbGFzc190eXBlX25hbWUubWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChzKVxuICAgICAgICBsX2NsYXNzX3R5cGVfbmFtZS5sZWZ0X2FkanVzdFxuICAgICAgICBsX2NsYXNzX3R5cGVfbmFtZS5yaWdodF9hZGp1c3RcblxuICAgICAgICAgIC0tIExldCdzIHNlZSBpZiBpdCBpcyBhIGdlbmVyaWMgdHlwZS5cbiAgICAgICAgbF9zdGFydF9wb3MgOj0gbF9jbGFzc190eXBlX25hbWUuaW5kZXhfb2YgKCdbJywgMSlcblxuICAgICAgICBpZiBsX3N0YXJ0X3BvcyA+IDEgdGhlblxuICAgICAgICAgICAgLS0gTG9va3MgbGlrZSBpdCBpcyBhIGdlbmVyaWMgY2xhc3MuXG4gICAgICAgICAgbF9lbmRfcG9zIDo9IGxfY2xhc3NfdHlwZV9uYW1lLmNvdW50XG4gICAgICAgICAgaWYgbF9jbGFzc190eXBlX25hbWUuaXRlbSAobF9lbmRfcG9zKSAvPSAnXScgdGhlblxuICAgICAgICAgICAgbF9lbmRfcG9zIDo9IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpZlxuICAgICAgICAgICAgbF9lbmRfcG9zID0gbF9jbGFzc190eXBlX25hbWUuY291bnQgYW5kIGxfc3RhcnRfcG9zIDwgbF9lbmRfcG9zIGFuZFxuICAgICAgICAgICAgbF9jbGFzc190eXBlX25hbWUub2NjdXJyZW5jZXMgKCdbJykgPSBsX2NsYXNzX3R5cGVfbmFtZS5vY2N1cnJlbmNlcyAoJ10nKVxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgLS0gQSB3ZWxsIGZvcm1lZCBnZW5lcmljIGNsYXNzLlxuICAgICAgICAgICAgbF90eXBlX25hbWUgOj0gbF9jbGFzc190eXBlX25hbWUuc3Vic3RyaW5nICgxLCBsX3N0YXJ0X3BvcyAtIDEpXG4gICAgICAgICAgICBsX3R5cGVfbmFtZS5sZWZ0X2FkanVzdFxuICAgICAgICAgICAgbF90eXBlX25hbWUucmlnaHRfYWRqdXN0XG5cbiAgICAgICAgICAgIGlmIGlzX3ZhbGlkX2lkZW50aWZpZXIgKGxfdHlwZV9uYW1lKSB0aGVuXG4gICAgICAgICAgICAgIGxfcGFyYW1ldGVycyA6PSBwYXJhbWV0ZXJzX2RlY29tcG9zaXRpb24gKFxuICAgICAgICAgICAgICAgIGxfY2xhc3NfdHlwZV9uYW1lLnN1YnN0cmluZyAobF9zdGFydF9wb3MgKyAxLCBsX2VuZF9wb3MgLSAxKSlcbiAgICAgICAgICAgICAgaWYgbF9wYXJhbWV0ZXJzIC89IFZvaWQgdGhlblxuICAgICAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICAgICAgICBsX3BhcmFtZXRlcnMuc3RhcnRcbiAgICAgICAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgICAgICAgbF9wYXJhbWV0ZXJzLmFmdGVyIG9yIG5vdCBSZXN1bHRcbiAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfdHlwZV9zdHJpbmcgKGxfcGFyYW1ldGVycy5pdGVtKVxuICAgICAgICAgICAgICAgICAgbF9wYXJhbWV0ZXJzLmZvcnRoXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEVuc3VyZXMgdGhhdCBpdCBpcyBhIHZhbGlkIHR5cGUgbmFtZS5cbiAgICAgICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaWRlbnRpZmllciAobF9jbGFzc190eXBlX25hbWUpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWFwcGVkX3R5cGUgKGFfdHlwZTogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgICAgLS0gSWYgYGlzX3ByZV9lY21hX21hcHBpbmdfZGlzYWJsZWQnIGBhX3R5cGUnLCBvdGhlcndpc2VcbiAgICAgIC0tIHRoZSBtYXBwZWQgdHlwZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV90eXBlX25vdF92b2lkOiBhX3R5cGUgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBsX3RhYmxlOiBsaWtlIHByZV9lY21hX3R5cGVfbWFwcGluZ1xuICAgICAgcjogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfcHJlX2VjbWFfbWFwcGluZ19kaXNhYmxlZCB0aGVuXG4gICAgICAgIGxfdGFibGUgOj0gcHJlX2VjbWFfdHlwZV9tYXBwaW5nXG4gICAgICAgIGxfdGFibGUuc2VhcmNoIChhX3R5cGUpXG4gICAgICAgIGlmIGxfdGFibGUuZm91bmQgdGhlblxuICAgICAgICAgIHIgOj0gbF90YWJsZS5mb3VuZF9pdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiByID0gVm9pZCB0aGVuXG4gICAgICAgIHIgOj0gYV90eXBlXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSByXG4gICAgZW5zdXJlXG4gICAgICBtYXBwZWRfdHlwZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb246IHN0YXR1cyByZXBvcnRcblxuICBpc192YWxpZF9pZGVudGlmaWVyIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBzJyBhIHZhbGlkIEVpZmZlbCBpZGVudGlmaWVyP1xuICAgIHJlcXVpcmVcbiAgICAgIG5hbWVfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgY2M6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICBpZiBub3Qgcy5pc19lbXB0eSB0aGVuXG4gICAgICAgIGNjIDo9IHMuaXRlbSAoMSlcbiAgICAgICAgbmIgOj0gcy5jb3VudCArIDFcbiAgICAgICAgaWYgY2MgPSBhdHRhY2hlZF9tYXJrIG9yIGNjID0gZGV0YWNoYWJsZV9tYXJrIHRoZW5cbiAgICAgICAgICBpIDo9IDJcbiAgICAgICAgZWxzZWlmIHMuc3Vic3RyaW5nX2luZGV4IChhdHRhY2hlZF9rZXl3b3JkLCAxKSA9IDEgdGhlblxuICAgICAgICAgIGkgOj0gYXR0YWNoZWRfa2V5d29yZC5jb3VudCArIDFcbiAgICAgICAgZWxzZWlmIHMuc3Vic3RyaW5nX2luZGV4IChkZXRhY2hhYmxlX2tleXdvcmQsIDEpID0gMSB0aGVuXG4gICAgICAgICAgaSA6PSBkZXRhY2hhYmxlX2tleXdvcmQuY291bnQgKyAxXG4gICAgICAgIGVsc2VpZiBzLnN1YnN0cmluZ19pbmRleCAoZXhwYW5kZWRfa2V5d29yZCwgMSkgPSAxIHRoZW5cbiAgICAgICAgICBpIDo9IGV4cGFuZGVkX2tleXdvcmQuY291bnQgKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPiAxIHRoZW5cbiAgICAgICAgICAgIC0tIFJlbW92ZSBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBhdHRhY2htZW50IG1hcmsgYW5kIHRoZSB0eXBlIG5hbWUuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmIgb3Igbm90IHMuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBzLml0ZW0gKGkpLmlzX2FscGhhIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBjYyA6PSBzLml0ZW0gKGkpXG4gICAgICAgICAgICBpZiBub3QgKGNjLmlzX2FscGhhIG9yIGNjLmlzX2RpZ2l0IG9yIGNjID0gJ18nKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIERlY29tcG9zZSBzdHJpbmcgdHlwZVxuXG4gIHBhcmFtZXRlcnNfZGVjb21wb3NpdGlvbiAoYV9zdHI6IFJFQURBQkxFX1NUUklOR18zMik6IGRldGFjaGFibGUgQVJSQVlFRF9MSVNUIFtSRUFEQUJMRV9TVFJJTkdfMzJdXG4gICAgICAtLSBEZWNvbXBvc2UgYGFfc3RyJyB3aGljaCBzaG91bGQgYmUgb2YgdGhlIGZvcm0gXCJBLCBCLCBEIFtHXSwgSCBbRSAsRl1cIlxuICAgICAgLS0gaW50byBhIGxpc3Qgb2Ygc3RyaW5ncyBcIkFcIiwgXCJCXCIsIFwiRCBbR11cIiwgXCJIIFtFLCBGXVwiXG4gICAgICAtLSBJZiBkZWNvbXBvc2l0aW9uIGlzIG5vdCBwb3NzaWJsZSwgVm9pZC5cbiAgICByZXF1aXJlXG4gICAgICBhX3N0cl9ub3Rfdm9pZDogYV9zdHIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9pbnZhbGlkOiBCT09MRUFOXG4gICAgICBsX2ZpcnN0X3BvczogSU5URUdFUlxuICAgICAgbF9uZXN0aW5nOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICg1KVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgbF9maXJzdF9wb3MgOj0gMVxuICAgICAgICBuYiA6PSBhX3N0ci5jb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iIG9yIGxfaW52YWxpZFxuICAgICAgbG9vcFxuICAgICAgICBpbnNwZWN0XG4gICAgICAgICAgYV9zdHIuaXRlbSAoaSlcbiAgICAgICAgd2hlbiAnLCcgdGhlblxuICAgICAgICAgIGlmIGxfbmVzdGluZyA9IDAgdGhlblxuICAgICAgICAgICAgUmVzdWx0LmV4dGVuZCAoYV9zdHIuc3Vic3RyaW5nIChsX2ZpcnN0X3BvcywgaSAtIDEpKVxuICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgd2hlbiAnWycgdGhlblxuICAgICAgICAgIGxfbmVzdGluZyA6PSBsX25lc3RpbmcgKyAxXG4gICAgICAgIHdoZW4gJ10nIHRoZW5cbiAgICAgICAgICBsX25lc3RpbmcgOj0gbF9uZXN0aW5nIC0gMVxuICAgICAgICAgIGxfaW52YWxpZCA6PSBsX25lc3RpbmcgPCAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAtLSBEbyBub3RoaW5nXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIG5vdCBsX2ludmFsaWQgYW5kIHRoZW4gbF9uZXN0aW5nID0gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5leHRlbmQgKGFfc3RyLnN1YnN0cmluZyAobF9maXJzdF9wb3MsIGkgLSAxKSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IFZvaWRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBFQ01BIG1hcHBpbmcgaGVscGVyXG5cbiAgcHJlX2VjbWFfdHlwZV9tYXBwaW5nOiBTVFJJTkdfVEFCTEUgW1NUUklOR11cbiAgICAgIC0tIE1hcHBpbmcgYmV0d2VlbiBwcmUtRUNNQSB0eXBlIG5hbWluZyBhbmQgbmV3IG5hbWVzLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMTIpXG4gICAgICBSZXN1bHQucHV0IChcIlNUUklOR184XCIsIFwiU1RSSU5HXCIpXG4gICAgICBSZXN1bHQucHV0IChcIklOVEVHRVJfMzJcIiwgXCJJTlRFR0VSXCIpXG4gICAgICBSZXN1bHQucHV0IChcIklOVEVHRVJfMzJfUkVGXCIsIFwiSU5URUdFUl9SRUZcIilcbiAgICAgIFJlc3VsdC5wdXQgKFwiQ0hBUkFDVEVSXzhcIiwgXCJDSEFSQUNURVJcIilcbiAgICAgIFJlc3VsdC5wdXQgKFwiQ0hBUkFDVEVSXzhfUkVGXCIsIFwiQ0hBUkFDVEVSX1JFRlwiKVxuICAgICAgUmVzdWx0LnB1dCAoXCJDSEFSQUNURVJfMzJcIiwgXCJXSURFX0NIQVJBQ1RFUlwiKVxuICAgICAgUmVzdWx0LnB1dCAoXCJDSEFSQUNURVJfMzJfUkVGXCIsIFwiV0lERV9DSEFSQUNURVJfUkVGXCIpXG4gICAgICBSZXN1bHQucHV0IChcIlJFQUxfMzJcIiwgXCJSRUFMXCIpXG4gICAgICBSZXN1bHQucHV0IChcIlJFQUxfMzJfUkVGXCIsIFwiUkVBTF9SRUZcIilcbiAgICAgIFJlc3VsdC5wdXQgKFwiUkVBTF82NFwiLCBcIkRPVUJMRVwiKVxuICAgICAgUmVzdWx0LnB1dCAoXCJSRUFMXzY0X1JFRlwiLCBcIkRPVUJMRV9SRUZcIilcbiAgICBlbnN1cmVcbiAgICAgIHByZV9lY21hX3R5cGVfbWFwcGluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBhdHRhY2hlZF9tYXJrOiBDSEFSQUNURVJfMzIgPSAnISdcbiAgZGV0YWNoYWJsZV9tYXJrOiBDSEFSQUNURVJfMzIgPSAnPydcbiAgYXR0YWNoZWRfa2V5d29yZDogU1RSSU5HID0gXCJhdHRhY2hlZFwiXG4gIGRldGFjaGFibGVfa2V5d29yZDogU1RSSU5HID0gXCJkZXRhY2hhYmxlXCJcbiAgZXhwYW5kZWRfa2V5d29yZDogU1RSSU5HID0gXCJleHBhbmRlZFwiXG4gICAgICAtLSBTeW1ib2xzIHVzZSBmb3IgYXR0YWNobWVudCBtYXJrcy5cblxuZmVhdHVyZSB7Tk9ORX0gLS0gVHlwZSBjcmVhdGlvblxuXG4gIHR5cGVfa2V5d29yZDogU1RSSU5HID0gXCJUWVBFXCI7XG4gICAgICAtLSBVc2VkIGZvciBjcmVhdGluZyB0eXBlIG9iamVjdHMuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiRmluaXRlIHN0cnVjdHVyZXMgd2hvc2UgaXRlbSBjb3VudCBpcyBzdWJqZWN0IHRvIGNoYW5nZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHN0b3JhZ2U7XG4gIHNpemU6IHJlc2l6YWJsZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIFJFU0laQUJMRSBbR10gaW5oZXJpdFxuXG4gIEJPVU5ERUQgW0ddXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBHcm93dGhfcGVyY2VudGFnZTogSU5URUdFUiA9IDUwXG4gICAgICAtLSBQZXJjZW50YWdlIGJ5IHdoaWNoIHN0cnVjdHVyZSB3aWxsIGdyb3cgYXV0b21hdGljYWxseVxuXG4gIE1pbmltYWxfaW5jcmVhc2U6IElOVEVHRVIgPSA1XG4gICAgICAtLSBNaW5pbWFsIG51bWJlciBvZiBhZGRpdGlvbmFsIGl0ZW1zXG5cbiAgYWRkaXRpb25hbF9zcGFjZTogSU5URUdFUlxuICAgICAgLS0gUHJvcG9zZWQgbnVtYmVyIG9mIGFkZGl0aW9uYWwgaXRlbXNcbiAgICAgIC0tfCBSZXN1bHQgaXMgYSByZWFzb25hYmxlIHZhbHVlLCByZXN1bHRpbmcgZnJvbSBhIHNwYWNlLXRpbWUgdHJhZGVvZmYuXG4gICAgZG9cbiAgICAgICAgLS0gVG8gcHJldmVudCBvdmVyZmxvdyB3ZSBkbyBub3QgdXNlIGBncm93dGhfcGVyY2VudGFnZScgYnV0IGl0cyBrbm93biB2YWx1ZS5cbiAgICAgIFJlc3VsdCA6PSAoY2FwYWNpdHkgLy8gMikubWF4IChNaW5pbWFsX2luY3JlYXNlKVxuICAgIGVuc3VyZVxuICAgICAgQXRfbGVhc3Rfb25lOiBSZXN1bHQgPj0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZXNpemFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgY2FwYWNpdHknIGJlIGNoYW5nZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBhdXRvbWF0aWNfZ3Jvd1xuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhY2NvbW1vZGF0ZSBhdCBsZWFzdFxuICAgICAgLS0gYEdyb3d0aF9wZXJjZW50YWdlJyBtb3JlIGl0ZW1zLlxuICAgICAgLS18IFRyYWRlcyBzcGFjZSBmb3IgdGltZTpcbiAgICAgIC0tfCBhbGxvY2F0ZXMgZmFpcmx5IGxhcmdlIGNodW5rcyBvZiBtZW1vcnkgYnV0IG5vdCB2ZXJ5IG9mdGVuLlxuICAgIHJlcXVpcmVcbiAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlXG4gICAgZG9cbiAgICAgIGdyb3cgKGNhcGFjaXR5ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICBlbnN1cmVcbiAgICAgIGluY3JlYXNlZF9jYXBhY2l0eTogY2FwYWNpdHkgPj0gb2xkIGNhcGFjaXR5ICsgb2xkIGFkZGl0aW9uYWxfc3BhY2VcbiAgICBlbmRcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgY2FwYWNpdHkgaXMgYXQgbGVhc3QgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jYXBhY2l0eTogY2FwYWNpdHkgPj0gaVxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIERlY3JlYXNlIGBjYXBhY2l0eScgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICAtLSBBcHBseSB0byByZWR1Y2UgYWxsb2NhdGVkIHN0b3JhZ2UuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBtaW5pbWFsX2NhcGFjaXR5OiBjYXBhY2l0eSA9IGNvdW50XG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGluY3JlYXNlX2J5X2F0X2xlYXN0X29uZTogTWluaW1hbF9pbmNyZWFzZSA+PSAxXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgT2JqZWN0cyByZXByZXNlbnRpbmcgZGVsYXllZCBjYWxscyB0byBhIHJvdXRpbmUsXG4gICAgd2l0aCBzb21lIG9wZXJhbmRzIHBvc3NpYmx5IHN0aWxsIG9wZW5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTI4IDE0OjM1OjIzIC0wODAwIChUdWUsIDI4IEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDEwOSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgUk9VVElORSBbQkFTRV9UWVBFIC0+IGRldGFjaGFibGUgQU5ZLCBPUEVOX0FSR1MgLT4gZGV0YWNoYWJsZSBUVVBMRSBjcmVhdGUgZGVmYXVsdF9jcmVhdGUgZW5kXVxuXG5pbmhlcml0XG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFJFRkxFQ1RPUlxuICAgIGV4cG9ydFxuICAgICAge05PTkV9IGFsbFxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LFxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIGFkYXB0IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIGBvdGhlcicuXG4gICAgICAtLSBVc2VmdWwgaW4gZGVzY2VuZGFudHMuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBjb25mb3JtaW5nOiBjb25mb3Jtc190byAob3RoZXIpXG4gICAgZG9cbiAgICAgIHJvdXRfZGlzcCA6PSBvdGhlci5yb3V0X2Rpc3BcbiAgICAgIGVuY2Fwc19yb3V0X2Rpc3AgOj0gb3RoZXIuZW5jYXBzX3JvdXRfZGlzcFxuICAgICAgY2FsY19yb3V0X2FkZHIgOj0gb3RoZXIuY2FsY19yb3V0X2FkZHJcbiAgICAgIGNsb3NlZF9vcGVyYW5kcyA6PSBvdGhlci5jbG9zZWRfb3BlcmFuZHNcbiAgICAgIG9wZXJhbmRzIDo9IG90aGVyLm9wZXJhbmRzXG4gICAgICByb3V0aW5lX2lkIDo9IG90aGVyLnJvdXRpbmVfaWRcbiAgICAgIGlzX2Jhc2ljIDo9IG90aGVyLmlzX2Jhc2ljXG4gICAgICBpc190YXJnZXRfY2xvc2VkIDo9IG90aGVyLmlzX3RhcmdldF9jbG9zZWRcbiAgICAgIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQgOj0gb3RoZXIud3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudFxuICAgICAgb3Blbl9jb3VudCA6PSBvdGhlci5vcGVuX2NvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgZnJvemVuIG9wZXJhbmRzOiBkZXRhY2hhYmxlIE9QRU5fQVJHU1xuXG4gIHRhcmdldDogZGV0YWNoYWJsZSBBTllcbiAgICAgIC0tIFRhcmdldCBvZiBjYWxsXG4gICAgbG9jYWxcbiAgICAgIGM6IGxpa2UgY2xvc2VkX29wZXJhbmRzXG4gICAgZG9cbiAgICAgICAgLS0gQmVjYXVzZSBhIHRhcmdldCBvYmplY3QgaXMgbmV2ZXIgc2VwYXJhdGUgcmVsYXRpdmUgdG8gdGhlIHJvdXRpbmUgb2JqZWN0LFxuICAgICAgICAtLSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgY2hlY2tlZCBhZ2FpbnN0IHtBTll9IHJhdGhlciB0aGFuIHtzZXBhcmF0ZSBBTll9LlxuICAgICAgaWYgaXNfdGFyZ2V0X2Nsb3NlZCB0aGVuXG4gICAgICAgIGMgOj0gY2xvc2VkX29wZXJhbmRzXG4gICAgICAgIGlmIGMgLz0gVm9pZCBhbmQgdGhlbiBjLmNvdW50ID4gMCBhbmQgdGhlbiBhdHRhY2hlZCB7QU5ZfSBjLml0ZW0gKDEpIGFzIHIgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSByXG4gICAgICAgIGVuZFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtUVVBMRX0gb3BlcmFuZHMgYXMgbyBhbmQgdGhlbiBvLmNvdW50ID4gMCBhbmQgdGhlbiBhdHRhY2hlZCB7QU5ZfSBvLml0ZW0gKDEpIGFzIHIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByb3V0X2Rpc3AuaGFzaF9jb2RlLmJpdF94b3IgKHJvdXRpbmVfaWQuaGFzaF9jb2RlKVxuICAgIGVuZFxuXG4gIHByZWNvbmRpdGlvbiAoYXJnczogbGlrZSBvcGVyYW5kcyk6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBhcmdzJyBzYXRpc2Z5IHJvdXRpbmUncyBwcmVjb25kaXRpb25cbiAgICAgIC0tIGluIGN1cnJlbnQgc3RhdGU/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAtLXwgRklYTUUgY29tcGlsZXIgc3VwcG9ydCBuZWVkZWQhXG4gICAgZW5kXG5cbiAgcG9zdGNvbmRpdGlvbiAoYXJnczogbGlrZSBvcGVyYW5kcyk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBzdGF0ZSBzYXRpc2Z5IHJvdXRpbmUnc1xuICAgICAgLS0gcG9zdGNvbmRpdGlvbiBmb3IgYGFyZ3MnP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgLS18IEZJWE1FIGNvbXBpbGVyIHN1cHBvcnQgbmVlZGVkIVxuICAgIGVuZFxuXG4gIGVtcHR5X29wZXJhbmRzOiBhdHRhY2hlZCBPUEVOX0FSR1NcbiAgICAgIC0tIEVtcHR5IHR1cGxlIG1hdGNoaW5nIG9wZW4gb3BlcmFuZHMuXG4gICAgb2Jzb2xldGUgXCJUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBhcyBub24tdm9pZC1zYWZlLiBbMjIuMDcuMjAxM11cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9vcGVyYW5kc19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgY2FsbGFibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBDYW4gcm91dGluZSBiZSBjYWxsZWQgb24gY3VycmVudCBvYmplY3Q/XG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBhc3NvY2lhdGVkIHJvdXRpbmUgdGhlIHNhbWUgYXMgdGhlIG9uZVxuICAgICAgLS0gYXNzb2NpYXRlZCB3aXRoIGBvdGhlcicuXG4gICAgZG9cbiAgICAgIC0tfCBEbyBub3QgY29tcGFyZSBpbXBsZW1lbnRhdGlvbiBkYXRhXG4gICAgICBSZXN1bHQgOj0gY2xvc2VkX29wZXJhbmRzIH4gb3RoZXIuY2xvc2VkX29wZXJhbmRzXG4gICAgICAgIGFuZCB0aGVuIG9wZXJhbmRzIH4gb3RoZXIub3BlcmFuZHNcbiAgICAgICAgYW5kIHRoZW4gb3Blbl9tYXAgfiBvdGhlci5vcGVuX21hcFxuICAgICAgICBhbmQgdGhlbiAocm91dF9kaXNwID0gb3RoZXIucm91dF9kaXNwKVxuICAgICAgICBhbmQgdGhlbiAocm91dGluZV9pZCA9IG90aGVyLnJvdXRpbmVfaWQpXG4gICAgICAgIGFuZCB0aGVuICh3cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50ID0gb3RoZXIud3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudClcbiAgICAgICAgYW5kIHRoZW4gKGVuY2Fwc19yb3V0X2Rpc3AgPSBvdGhlci5lbmNhcHNfcm91dF9kaXNwKVxuICAgICAgICBhbmQgdGhlbiAoY2FsY19yb3V0X2FkZHIgPSBvdGhlci5jYWxjX3JvdXRfYWRkcilcbiAgICBlbmRcblxuICB2YWxpZF9vcGVyYW5kcyAoYXJnczogZGV0YWNoYWJsZSBzZXBhcmF0ZSBUVVBMRSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYXJncycgdmFsaWQgb3BlcmFuZHMgZm9yIHRoaXMgcm91dGluZT9cbiAgICBsb2NhbFxuICAgICAgaSwgYXJnX3R5cGVfY29kZTogSU5URUdFUlxuICAgICAgYXJnOiBsaWtlIHtUVVBMRX0uaXRlbVxuICAgICAgb3Blbl90eXBlX2NvZGVzOiBTVFJJTkdcbiAgICAgIGxfdHlwZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhcmdzID0gVm9pZCB0aGVuXG4gICAgICAgICAgLS0gVm9pZCBvcGVyYW5kcyBhcmUgb25seSBhbGxvd2VkXG4gICAgICAgICAgLS0gaWYgb2JqZWN0IGhhcyBubyBvcGVuIG9wZXJhbmRzLlxuICAgICAgICBSZXN1bHQgOj0gKG9wZW5fY291bnQgPSAwKVxuICAgICAgZWxzZWlmIGFyZ3MuY291bnQgPj0gb3Blbl9jb3VudCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIG9wZW5fdHlwZV9jb2RlcyA6PSBlaWZfZ2VuX3R5cGVjb2RlX3N0ciAoJEN1cnJlbnQpXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG9wZW5fY291bnQgb3Igbm90IFJlc3VsdFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXJnX3R5cGVfY29kZSA6PSBhcmdzLml0ZW1fY29kZSAoaSlcbiAgICAgICAgICBSZXN1bHQgOj0gYXJnX3R5cGVfY29kZSA9IG9wZW5fdHlwZV9jb2Rlcy5pdGVtIChpICsgMSkuY29kZVxuICAgICAgICAgIGlmIFJlc3VsdCBhbmQgdGhlbiBhcmdfdHlwZV9jb2RlID0ge1RVUExFfS5yZWZlcmVuY2VfY29kZSB0aGVuXG4gICAgICAgICAgICBhcmcgOj0gYXJncy5pdGVtIChpKVxuICAgICAgICAgICAgbF90eXBlIDo9IG9wZW5fb3BlcmFuZF90eXBlIChpKVxuICAgICAgICAgICAgICAtLSBJZiBleHBlY3RlZCB0eXBlIGlzIGF0dGFjaGVkLCB0aGVuIHdlIG5lZWQgdG8gdmVyaWZ5IHRoYXQgdGhlIGFjdHVhbFxuICAgICAgICAgICAgICAtLSBpcyBpbmRlZWQgYXR0YWNoZWQuXG4gICAgICAgICAgICBpZiBpc19hdHRhY2hlZF90eXBlIChsX3R5cGUpIHRoZW5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IGFyZyAvPSBWb2lkIGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgZmllbGRfY29uZm9ybXNfdG8gKHR5cGVfaWRfb2YgKGFyZyksIGxfdHlwZSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IGFyZyA9IFZvaWQgb3IgZWxzZVxuICAgICAgICAgICAgICAgIGZpZWxkX2NvbmZvcm1zX3RvICh0eXBlX2lkX29mIChhcmcpLCBsX3R5cGUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiBSZXN1bHQgYW5kIHRoZW4gbm90IGlzX3RhcmdldF9jbG9zZWQgYW5kIHRoZW4gYXJncyAvPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZ3MuaXRlbSAoMSkgLz0gVm9pZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdmFsaWRfdGFyZ2V0IChhcmdzOiBkZXRhY2hhYmxlIFRVUExFKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdHVwbGUgYGFyZ3MnIGEgdmFsaWQgdGFyZ2V0XG4gICAgZG9cbiAgICAgIGlmIGFyZ3MgLz0gVm9pZCBhbmQgdGhlbiBhcmdzLmNvdW50ID4gMCB0aGVuXG4gICAgICAgIGlmIGFyZ3MuaXNfcmVmZXJlbmNlX2l0ZW0gKDEpIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gYXJncy5yZWZlcmVuY2VfaXRlbSAoMSkgLz0gVm9pZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc190YXJnZXRfY2xvc2VkOiBCT09MRUFOXG4gICAgICAtLSBJcyB0YXJnZXQgZm9yIGN1cnJlbnQgYWdlbnQgY2xvc2VkLCBpLmUuIHNwZWNpZmllZCBhdCBjcmVhdGlvbiB0aW1lP1xuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgb3Blbl9jb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIG9wZW4gb3BlcmFuZHMuXG5cbmZlYXR1cmUgLS0gU2V0dGluZ3NcblxuICBmcm96ZW4gc2V0X29wZXJhbmRzIChhcmdzOiBkZXRhY2hhYmxlIE9QRU5fQVJHUylcbiAgICAgIC0tIFVzZSBgYXJncycgYXMgb3BlcmFuZHMgZm9yIG5leHQgY2FsbC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZG9cbiAgICAgIG9wZXJhbmRzIDo9IGFyZ3NcbiAgICBlbnN1cmVcbiAgICAgIG9wZXJhbmRzX3NldDogKG9wZXJhbmRzIC89IFZvaWQgaW1wbGllcyAob3BlcmFuZHMgfiBhcmdzKSkgb3JcbiAgICAgICAgKG9wZXJhbmRzID0gVm9pZCBpbXBsaWVzIChhcmdzID0gVm9pZCBvciBlbHNlIGFyZ3MuaXNfZW1wdHkpKVxuICAgIGVuZFxuXG4gIHNldF90YXJnZXQgKGFfdGFyZ2V0OiBsaWtlIHRhcmdldClcbiAgICAgIC0tIFNldCBgYV90YXJnZXQnIGFzIHRoZSBuZXh0IGB0YXJnZXQnIGZvciByZW1haW5pbmcgY2FsbHMgdG8gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBhX3RhcmdldF9ub3Rfdm9pZDogYV90YXJnZXQgLz0gVm9pZFxuICAgICAgaXNfdGFyZ2V0X2Nsb3NlZDogaXNfdGFyZ2V0X2Nsb3NlZFxuICAgICAgdGFyZ2V0X25vdF92b2lkOiB0YXJnZXQgLz0gVm9pZFxuICAgICAgc2FtZV90YXJnZXRfdHlwZTogYXR0YWNoZWQgdGFyZ2V0IGFzIHQgYW5kIHRoZW4gdC5zYW1lX3R5cGUgKGFfdGFyZ2V0KVxuICAgIGxvY2FsXG4gICAgICBjOiBsaWtlIGNsb3NlZF9vcGVyYW5kc1xuICAgIGRvXG4gICAgICBjIDo9IGNsb3NlZF9vcGVyYW5kc1xuICAgICAgaWYgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYy5wdXQgKGFfdGFyZ2V0LCAxKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0YXJnZXRfc2V0OiB0YXJnZXQgPSBhX3RhcmdldFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFVzZSBzYW1lIHJvdXRpbmUgYXMgYG90aGVyJy5cbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIHN0YW5kYXJkX2NvcHkgKG90aGVyKVxuICAgICAgICBpZiBhdHRhY2hlZCBvcGVyYW5kcyBhcyBsX29wZXJhbmRzIHRoZW5cbiAgICAgICAgICBvcGVyYW5kcyA6PSBsX29wZXJhbmRzLnR3aW5cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9jYWxsX3N0YXR1czogb3RoZXIuY2FsbGFibGUgaW1wbGllcyBjYWxsYWJsZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBjYWxsIChhcmdzOiBkZXRhY2hhYmxlIHNlcGFyYXRlIE9QRU5fQVJHUylcbiAgICAgIC0tIENhbGwgcm91dGluZSB3aXRoIGBhcmdzJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBhcHBseVxuICAgICAgLS0gQ2FsbCByb3V0aW5lIHdpdGggYG9wZXJhbmRzJyBhcyBsYXN0IHNldC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKG9wZXJhbmRzKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRXh0ZW5kZWQgb3BlcmF0aW9uc1xuXG4gIGZsZXhpYmxlX2NhbGwgKGE6IGRldGFjaGFibGUgc2VwYXJhdGUgVFVQTEUpXG4gICAgICAtLSBDYWxsIHJvdXRpbmUgd2l0aCBhcmd1bWVudHMgYGEnLlxuICAgICAgLS0gQ29tcGFyZWQgdG8gYGNhbGwnIHRoZSB0eXBlIG9mIGBhJyBtYXkgYmUgZGlmZmVyZW50IGZyb20gYHtPUEVOX0FSR1N9Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGEpXG4gICAgbG9jYWxcbiAgICAgIGRlZmF1bHRfYXJndW1lbnRzOiBkZXRhY2hhYmxlIE9QRU5fQVJHU1xuICAgIGRvXG4gICAgICBpZiBub3QgYXR0YWNoZWQgYSB0aGVuXG4gICAgICAgIGNhbGwgKGRlZmF1bHRfYXJndW1lbnRzKVxuICAgICAgZWxzZVxuICAgICAgICAtLSBUT0RPIGltcGxlbWVudCBpbiBqYXZhc2NyaXB0XG4gICAgICAgIC0tIGNoZWNrXG4gICAgICAgIC0tICAgZnJvbV9wcmVjb25kaXRpb246IGF0dGFjaGVkIHtPUEVOX0FSR1N9IG5ld190dXBsZV9mcm9tX3R1cGxlICgoe09QRU5fQVJHU30pLnR5cGVfaWQsIGEpIGFzIHhcbiAgICAgICAgLS0gdGhlblxuICAgICAgICAtLSAgIGNhbGwgKHgpXG4gICAgICAgIC0tIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT2Jzb2xldGVcblxuICBhZGFwdF9mcm9tIChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gQWRhcHQgZnJvbSBgb3RoZXInLiBVc2VmdWwgaW4gZGVzY2VuZGFudHMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiUGxlYXNlIHVzZSBgYWRhcHQnIGluc3RlYWQgKGl0J3MgYWxzbyBhIGNyZWF0aW9uIHByb2NlZHVyZSlcIlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgY29uZm9ybWluZzogY29uZm9ybXNfdG8gKG90aGVyKVxuICAgIGRvXG4gICAgICBhZGFwdCAob3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge1JPVVRJTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZnJvemVuIGNsb3NlZF9vcGVyYW5kczogZGV0YWNoYWJsZSBUVVBMRVxuICAgICAgLS0gQWxsIGNsb3NlZCBhcmd1bWVudHMgcHJvdmlkZWQgYXQgY3JlYXRpb24gdGltZVxuXG4gIGNsb3NlZF9jb3VudDogSU5URUdFUlxuICAgICAgLS0gVGhlIG51bWJlciBvZiBjbG9zZWQgb3BlcmFuZHMgKGluY2x1ZGluZyB0aGUgdGFyZ2V0IGlmIGl0IGlzIGNsb3NlZClcbiAgICBsb2NhbFxuICAgICAgYzogZGV0YWNoYWJsZSBUVVBMRVxuICAgIGRvXG4gICAgICBjIDo9IGNsb3NlZF9vcGVyYW5kc1xuICAgICAgaWYgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGMuY291bnRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb3plbiByb3V0X2Rpc3A6IFBPSU5URVJcbiAgICAgIC0tIFJvdXRpbmUgZGlzcGF0Y2hlclxuXG4gIGZyb3plbiBjYWxjX3JvdXRfYWRkcjogUE9JTlRFUlxuICAgICAgLS0gQWRkcmVzcyBvZiB0aGUgZmluYWwgcm91dGluZVxuXG4gIGZyb3plbiBvcGVuX21hcDogZGV0YWNoYWJsZSBBUlJBWSBbSU5URUdFUl1cbiAgICAgIC0tIEluZGV4IG1hcCBmb3Igb3BlbiBhcmd1bWVudHNcblxuICBmcm96ZW4gZW5jYXBzX3JvdXRfZGlzcDogUE9JTlRFUlxuICAgICAgLS0gRWlmZmVsIHJvdXRpbmUgZGlzcGF0Y2hlclxuXG4gIGZyb3plbiByb3V0aW5lX2lkOiBJTlRFR0VSXG5cbiAgZnJvemVuIGlzX2Jhc2ljOiBCT09MRUFOXG5cbiAgZnJvemVuIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQ6IElOVEVHRVJcblxuICBmcm96ZW4gc2V0X3JvdXRfZGlzcCAoYV9yb3V0X2Rpc3AsIGFfZW5jYXBzX3JvdXRfZGlzcCwgYV9jYWxjX3JvdXRfYWRkcjogUE9JTlRFUjtcbiAgICAgICAgICAgICAgYV9yb3V0aW5lX2lkOiBJTlRFR0VSOyBhX29wZW5fbWFwOiBsaWtlIG9wZW5fbWFwO1xuICAgICAgICAgICAgICBhX2lzX2Jhc2ljLCBhX2lzX3RhcmdldF9jbG9zZWQ6IEJPT0xFQU47IGFfd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudDogSU5URUdFUjtcbiAgICAgICAgICAgICAgYV9jbG9zZWRfb3BlcmFuZHM6IFRVUExFOyBhX29wZW5fY291bnQ6IElOVEVHRVIpXG4gICAgICAtLSBJbml0aWFsaXplIG9iamVjdC5cbiAgICByZXF1aXJlXG4gICAgICB0YXJnZXRfdmFsaWQ6IGFfaXNfdGFyZ2V0X2Nsb3NlZCBpbXBsaWVzIHZhbGlkX3RhcmdldCAoYV9jbG9zZWRfb3BlcmFuZHMpXG4gICAgZG9cbiAgICAgIHNldF9yb3V0X2Rpc3BfaW50IChhX3JvdXRfZGlzcCwgYV9lbmNhcHNfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyLCBhX3JvdXRpbmVfaWQsXG4gICAgICAgICAgICAgICAgIGFfb3Blbl9tYXAsIGFfaXNfYmFzaWMsIGFfaXNfdGFyZ2V0X2Nsb3NlZCxcbiAgICAgICAgICAgICAgICAgYV93cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50LCBhX2Nsb3NlZF9vcGVyYW5kcywgYV9vcGVuX2NvdW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfcm91dF9kaXNwX2ZpbmFsIChhX3JvdXRfZGlzcCwgYV9lbmNhcHNfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSXG4gICAgICAgICAgICAgICAgICBhX2Nsb3NlZF9vcGVyYW5kczogVFVQTEU7IGFfaXNfdGFyZ2V0X2Nsb3NlZDogQk9PTEVBTjsgYV9vcGVuX2NvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBvYmplY3QuXG4gICAgZG9cbiAgICAgIHJvdXRfZGlzcCA6PSBhX3JvdXRfZGlzcFxuICAgICAgZW5jYXBzX3JvdXRfZGlzcCA6PSBhX2VuY2Fwc19yb3V0X2Rpc3BcbiAgICAgIGNhbGNfcm91dF9hZGRyIDo9IGFfY2FsY19yb3V0X2FkZHJcbiAgICAgIGNsb3NlZF9vcGVyYW5kcyA6PSBhX2Nsb3NlZF9vcGVyYW5kc1xuICAgICAgaXNfdGFyZ2V0X2Nsb3NlZCA6PSBhX2lzX3RhcmdldF9jbG9zZWRcbiAgICAgIG9wZW5fY291bnQgOj0gYV9vcGVuX2NvdW50XG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9yb3V0X2Rpc3BfaW50IChhX3JvdXRfZGlzcCwgYV9lbmNhcHNfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSO1xuICAgICAgICAgICAgICAgICAgYV9yb3V0aW5lX2lkOiBJTlRFR0VSOyBhX29wZW5fbWFwOiBsaWtlIG9wZW5fbWFwO1xuICAgICAgICAgICAgICAgIGFfaXNfYmFzaWMsIGFfaXNfdGFyZ2V0X2Nsb3NlZDogQk9PTEVBTjsgYV93cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50OiBJTlRFR0VSO1xuICAgICAgICAgICAgICAgIGFfY2xvc2VkX29wZXJhbmRzOiBUVVBMRTsgYV9vcGVuX2NvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBvYmplY3QuXG4gICAgcmVxdWlyZVxuICAgICAgYV9yb3V0aW5lX2lkX3ZhbGlkOiBhX3JvdXRpbmVfaWQgPiAtMVxuICAgIGRvXG4gICAgICByb3V0X2Rpc3AgOj0gYV9yb3V0X2Rpc3BcbiAgICAgIGVuY2Fwc19yb3V0X2Rpc3AgOj0gYV9lbmNhcHNfcm91dF9kaXNwXG4gICAgICBjYWxjX3JvdXRfYWRkciA6PSBhX2NhbGNfcm91dF9hZGRyXG4gICAgICByb3V0aW5lX2lkIDo9IGFfcm91dGluZV9pZFxuICAgICAgb3Blbl9tYXAgOj0gYV9vcGVuX21hcFxuICAgICAgaXNfYmFzaWMgOj0gYV9pc19iYXNpY1xuICAgICAgaXNfdGFyZ2V0X2Nsb3NlZCA6PSBhX2lzX3RhcmdldF9jbG9zZWRcbiAgICAgIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQgOj0gYV93cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50XG4gICAgICBjbG9zZWRfb3BlcmFuZHMgOj0gYV9jbG9zZWRfb3BlcmFuZHNcbiAgICAgIG9wZW5fY291bnQgOj0gYV9vcGVuX2NvdW50XG4gICAgZW5zdXJlXG4gICAgICByb3V0X2Rpc3Bfc2V0OiByb3V0X2Rpc3AgPSBhX3JvdXRfZGlzcFxuICAgICAgZW5jYXBzX3JvdXRfZGlzcF9zZXQ6IGVuY2Fwc19yb3V0X2Rpc3AgPSBhX2VuY2Fwc19yb3V0X2Rpc3BcbiAgICAgIGNhbGNfcm91dF9hZGRyX3NldDogY2FsY19yb3V0X2FkZHIgPSBhX2NhbGNfcm91dF9hZGRyXG4gICAgICByb3V0aW5lX2lkX3NldDogcm91dGluZV9pZCA9IGFfcm91dGluZV9pZFxuICAgICAgb3Blbl9tYXBfc2V0OiBvcGVuX21hcCA9IGFfb3Blbl9tYXBcbiAgICAgIGlzX3RhcmdldF9jbG9zZWRfc2V0OiBpc190YXJnZXRfY2xvc2VkID0gYV9pc190YXJnZXRfY2xvc2VkXG4gICAgICBpc19iYXNpY19zZXQ6IGlzX2Jhc2ljID0gYV9pc19iYXNpY1xuICAgICAgd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudF9zZXQ6IHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQgPSBhX3dyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnRcbiAgICAgIGNsb3NlZF9vcGVyYW5kc19zZXQ6IGNsb3NlZF9vcGVyYW5kcyA9IGFfY2xvc2VkX29wZXJhbmRzXG4gICAgICBvcGVuX2NvdW50X3NldDogb3Blbl9jb3VudCA9IGFfb3Blbl9jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBvcGVuX3R5cGVzOiBkZXRhY2hhYmxlIEFSUkFZIFtJTlRFR0VSXVxuICAgICAgLS0gVHlwZXMgb2Ygb3BlbiBvcGVyYW5kc1xuXG4gIG9wZW5fb3BlcmFuZF90eXBlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gVHlwZSBvZiBgaSd0aCBvcGVuIG9wZXJhbmQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zaXRpdmU6IGkgPj0gMVxuICAgICAgd2l0aGluX2JvdW5kczogaSA8PSBvcGVuX2NvdW50XG4gICAgbG9jYWxcbiAgICAgIG86IGxpa2Ugb3Blbl90eXBlc1xuICAgIGRvXG4gICAgICBvIDo9IG9wZW5fdHlwZXNcbiAgICAgIGlmIG8gPSBWb2lkIHRoZW5cbiAgICAgICAgY3JlYXRlIG8ubWFrZV9maWxsZWQgKC0xLCAxLCBvcGVuX2NvdW50KVxuICAgICAgICBvcGVuX3R5cGVzIDo9IG9cbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IG8uaXRlbSAoaSlcbiAgICAgIGlmIFJlc3VsdCA9IC0xIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh7T1BFTl9BUkdTfSkuZ2VuZXJpY19wYXJhbWV0ZXJfdHlwZSAoaSkudHlwZV9pZFxuICAgICAgICBvLnB1dCAoUmVzdWx0LCBpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHlwZV9pZF9vZiAoYTogc2VwYXJhdGUgQU5ZKTogSU5URUdFUlxuICAgICAgLS0gVHlwZSBJRCBvZiBhbiBvYmplY3QgYGEnLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYS5nZW5lcmF0aW5nX3R5cGUudHlwZV9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBFeHRlcm5hbHNcblxuICBlaWZfZ2VuX3R5cGVjb2RlX3N0ciAob2JqOiBQT0lOVEVSKTogU1RSSU5HXG4gICAgICAtLSBDb2RlIG5hbWUgZm9yIGdlbmVyaWMgcGFyYW1ldGVyIGBwb3MnIGluIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlIChFSUZfUkVGRVJFTkNFKTogRUlGX1JFRkVSRU5DRSB1c2UgJVwiZWlmX2dlbl9jb25mLmglXCJcIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE9ic29sZXRlXG5cbiAgYXJndW1lbnRzOiBkZXRhY2hhYmxlIE9QRU5fQVJHU1xuICAgIG9ic29sZXRlXG4gICAgICBcInVzZSBvcGVyYW5kc1wiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvcGVyYW5kc1xuICAgIGVuZFxuXG4gIHNldF9hcmd1bWVudHMgKGFyZ3M6IGRldGFjaGFibGUgT1BFTl9BUkdTKVxuICAgIG9ic29sZXRlXG4gICAgICBcInVzZSBzZXRfb3BlcmFuZHNcIlxuICAgIGRvXG4gICAgICBzZXRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZW5kXG5cbiAgdmFsaWRfYXJndW1lbnRzIChhcmdzOiBkZXRhY2hhYmxlIE9QRU5fQVJHUyk6IEJPT0xFQU5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJ1c2UgdmFsaWRfb3BlcmFuZHNcIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgRmluaXRlIHNlcXVlbmNlczogc3RydWN0dXJlcyB3aGVyZSBleGlzdGluZyBpdGVtcyBhcmUgYXJyYW5nZWRcbiAgICBhbmQgYWNjZXNzZWQgc2VxdWVudGlhbGx5LCBhbmQgbmV3IG9uZXMgY2FuIGJlIGFkZGVkIGF0IHRoZSBlbmQuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHNlcXVlbmNlO1xuICBhY2Nlc3M6IGN1cnNvciwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBTRVFVRU5DRSBbR10gaW5oZXJpdFxuXG4gIEFDVElWRSBbR11cbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsXG4gICAgZW5kXG5cbiAgQklMSU5FQVIgW0ddXG5cbiAgRklOSVRFIFtHXVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZWFkYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgYSBjdXJyZW50IGl0ZW0gdGhhdCBtYXkgYmUgcmVhZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBvZmZcbiAgICBlbmRcblxuXG4gIHdyaXRhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBhIGN1cnJlbnQgaXRlbSB0aGF0IG1heSBiZSBtb2RpZmllZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBvZmZcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIGZvcmNlICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gICAgZG9cbiAgICAgIGV4dGVuZCAodilcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGhhcyAodilcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFNFUVVFTkNFIFtHXSlcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbDogbGlrZSBzXG4gICAgZG9cbiAgICAgIGwgOj0gc1xuICAgICAgaWYgcyA9IEN1cnJlbnQgdGhlblxuICAgICAgICBsIDo9IHR3aW5cbiAgICAgIGVuZFxuICAgICAgZnJvbVxuICAgICAgICBsLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBsLmV4aGF1c3RlZFxuICAgICAgbG9vcFxuICAgICAgICBleHRlbmQgKGwuaXRlbSlcbiAgICAgICAgbC5mb3J0aFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID49IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIHB1dCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byBlbmQuXG4gICAgZG9cbiAgICAgIGV4dGVuZCAodilcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcHJ1bmUgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIFJlbW92ZSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdicgaWYgYW55LlxuICAgICAgLS0gSWYgbm8gc3VjaCBvY2N1cnJlbmNlIGdvIGBvZmYnLlxuICAgIGRvXG4gICAgICBzdGFydFxuICAgICAgc2VhcmNoICh2KVxuICAgICAgaWYgbm90IGV4aGF1c3RlZCB0aGVuXG4gICAgICAgIHJlbW92ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGB2JzsgZ28gYG9mZicuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGV4aGF1c3RlZFxuICAgICAgbG9vcFxuICAgICAgICBzZWFyY2ggKHYpXG4gICAgICAgIGlmIG5vdCBleGhhdXN0ZWQgdGhlblxuICAgICAgICAgIHJlbW92ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTAzLTA0IDE1OjAxOjI1IC0wODAwIChNb24sIDA0IE1hciAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjE3OCAkXCJcblxuZnJvemVuIGNsYXNzXG4gIFNQRUNJQUwgW1RdXG5cbmluaGVyaXRcbiAgQUJTVFJBQ1RfU1BFQ0lBTFxuICAgIHJlZGVmaW5lXG4gICAgICBkZWJ1Z19vdXRwdXRcbiAgICBlbmRcblxuICBSRUFEQUJMRV9JTkRFWEFCTEUgW1RdXG5cbmNyZWF0ZVxuICBtYWtlX2VtcHR5LFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX25hdGl2ZV9hcnJheVxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHkgKG46IElOVEVHRVIpXG4gICAgICAtLSBDcmVhdGUgYSBzcGVjaWFsIG9iamVjdCBmb3IgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBjYXBhY2l0eV9zZXQ6IGNhcGFjaXR5ID0gblxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IDBcbiAgICBlbmRcblxuICBtYWtlX2ZpbGxlZCAodjogVDsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBhIHNwZWNpYWwgb2JqZWN0IGZvciBgbicgZW50cmllcyBpbml0aWFsaXplZCB3aXRoIGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlX2VtcHR5IChuKVxuICAgICAgZmlsbF93aXRoICh2LCAwLCBuIC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X3NldDogY2FwYWNpdHkgPSBuXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAodiwgMCwgbiAtIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX25hdGl2ZV9hcnJheSAoYW5fYXJyYXk6IGxpa2UgbmF0aXZlX2FycmF5KVxuICAgICAgLS0gQ3JlYXRlIGEgc3BlY2lhbCBvYmplY3QgZnJvbSBgYW5fYXJyYXknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIGFuX2FycmF5X25vdF92b2lkOiBhbl9hcnJheSAvPSBWb2lkXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiAoaTogSU5URUdFUik6IFQgYXNzaWduIHB1dFxuICAgICAgLS0gSXRlbSBhdCBgaSctdGggcG9zaXRpb25cbiAgICAgIC0tIChpbmRpY2VzIGJlZ2luIGF0IDApXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogVFxuICAgICAgLS0gSXRlbSBhdCBgaSctdGggcG9zaXRpb25cbiAgICAgIC0tIChpbmRpY2VzIGJlZ2luIGF0IDApXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAoaSlcbiAgICBlbmRcblxuICBpbmRleF9vZiAodjogVDsgc3RhcnRfcG9zaXRpb246IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGl0ZW0gaWRlbnRpY2FsIHRvIGB2Jy5cbiAgICAgIC0tIC0xIGlmIG5vbmUuXG4gICAgICAtLSAoVXNlIG9iamVjdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbi4pXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfcG9zaXRpb246IHN0YXJ0X3Bvc2l0aW9uID49IDBcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfcG9zaXRpb25cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA+PSBuYiBvciBlbHNlIGl0ZW0gKFJlc3VsdCkgfiB2XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIFJlc3VsdCA+PSBuYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBmb3VuZF9vcl9ub3RfZm91bmQ6IFJlc3VsdCA9IC0xIG9yIGVsc2UgKFJlc3VsdCA+PSAwIGFuZCB0aGVuIFJlc3VsdCA8IGNvdW50KVxuICAgIGVuZFxuXG4gIGl0ZW1fYWRkcmVzcyAoaTogSU5URUdFUik6IFBPSU5URVJcbiAgICAgIC0tIEFkZHJlc3Mgb2YgZWxlbWVudCBhdCBwb3NpdGlvbiBgaScuXG4gICAgICAtLSBVc2Ugb25seSB3aGVuIGludGVyZmFjaW5nIHdpdGggQyBleHRlcm5hbHMgd2hlbiBDdXJyZW50IGlzIGd1YXJhbnRlZWQgdG8gbm90IG1vdmUgaW4gbWVtb3J5LlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDBcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBiYXNlX2FkZHJlc3MgKyBpICogZWxlbWVudF9zaXplXG4gICAgZW5zdXJlXG4gICAgICBlbGVtZW50X2FkZHJlc3Nfbm90X251bGw6IFJlc3VsdCAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBlbmRcblxuICBiYXNlX2FkZHJlc3M6IFBPSU5URVJcbiAgICAgIC0tIEFkZHJlc3Mgb2YgZWxlbWVudCBhdCBwb3NpdGlvbiBgMCcuXG4gICAgICAtLSBVc2Ugb25seSB3aGVuIGludGVyZmFjaW5nIHdpdGggQyBleHRlcm5hbHMgd2hlbiBDdXJyZW50IGlzIGd1YXJhbnRlZWQgdG8gbm90IG1vdmUgaW4gbWVtb3J5LlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGJhc2VfYWRkcmVzc19ub3RfbnVsbDogUmVzdWx0IC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuZFxuXG4gIG5hdGl2ZV9hcnJheTogTkFUSVZFX0FSUkFZIFtUXVxuICAgICAgLS0gT25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIC5ORVRcbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICBlbmRcblxuICB0b19hcnJheTogQVJSQVkgW1RdXG4gICAgICAtLSBCdWlsZCBhbiBhcnJheSByZXByZXNlbnRhdGlvbiBvZiBDdXJyZW50IGZyb20gYDEnIHRvIGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3NwZWNpYWwgKEN1cnJlbnQpXG4gICAgZW5zdXJlXG4gICAgICB0b19hcnJheV9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHRvX2FycmF5X2xvd2VyX3NldDogUmVzdWx0Lmxvd2VyID0gMVxuICAgICAgdG9fYXJyYXlfdXBwZXJfc2V0OiBSZXN1bHQudXBwZXIgPSBjb3VudFxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsb3dlciwgdXBwZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBsb3dlcjogSU5URUdFUiA9IDBcbiAgICAgIC0tIE1pbmltdW0gaW5kZXggb2YgQ3VycmVudFxuXG4gIHVwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBNYXhpbXVtIGluZGV4IG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNvdW50IC0gMVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogbG93ZXIgPD0gUmVzdWx0ICsgMVxuICAgIGVuZFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBDb3VudCBvZiBzcGVjaWFsIGFyZWFcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIENhcGFjaXR5IG9mIHNwZWNpYWwgYXJlYVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZmlsbGVkX3dpdGggKHY6IFQ7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIGJldHdlZW4gaW5kZXggYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHNldCB0byBgdic/XG4gICAgICAtLSAoVXNlIHJlZmVyZW5jZSBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbi4pXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBjb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleCBvciBlbHNlIG5vdCBSZXN1bHRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpID0gdlxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzYW1lX2l0ZW1zIChvdGhlcjogbGlrZSBDdXJyZW50OyBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIHRoZSBgbicgZWxlbWVudHMgb2YgYG90aGVyJyBmcm9tIGBzb3VyY2VfaW5kZXgnIHBvc2l0aW9uIHRoZSBzYW1lIGFzXG4gICAgICAtLSB0aGUgYG4nIGVsZW1lbnRzIG9mIGBDdXJyZW50JyBmcm9tIGBkZXN0aW5hdGlvbl9pbmRleCc/XG4gICAgICAtLSAoVXNlIHJlZmVyZW5jZSBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbi4pXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gb3RoZXIuY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc291cmNlX2luZGV4XG4gICAgICAgICAgaiA6PSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIG90aGVyLml0ZW0gKGkpIC89IGl0ZW0gKGopIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfb25fZW1wdHlfYXJlYTogKG4gPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIEN1cnJlbnQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoMCA8PSBpKSBhbmQgKGkgPCBjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAodjogVDsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYGknLXRoIGl0ZW0gYnkgYHYnLlxuICAgICAgLS0gKEluZGljZXMgYmVnaW4gYXQgMC4pXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDBcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8IGNvdW50XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gdlxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgZm9yY2UgKHY6IFQ7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJZiBgaScgaXMgZXF1YWwgdG8gYGNvdW50JyBpbmNyZWFzZSBgY291bnQnIGJ5IG9uZSBhbmQgaW5zZXJ0IGB2JyBhdCBpbmRleCBgY291bnQnLFxuICAgICAgLS0gb3RoZXJ3aXNlIHJlcGxhY2UgYGknLXRoIGl0ZW0gYnkgYHYnLlxuICAgICAgLS0gKEluZGljZXMgYmVnaW4gYXQgMC4pXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDBcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudFxuICAgICAgbm90X2Z1bGw6IGkgPSBjb3VudCBpbXBsaWVzIGNvdW50IDwgY2FwYWNpdHlcbiAgICBkb1xuICAgICAgaWYgaSA8IGNvdW50IHRoZW5cbiAgICAgICAgcHV0ICh2LCBpKVxuICAgICAgZWxzZVxuICAgICAgICBleHRlbmQgKHYpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gKGkgKyAxKS5tYXggKG9sZCBjb3VudClcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgZW5kXG5cbiAgZXh0ZW5kICh2OiBUKVxuICAgICAgLS0gQWRkIGB2JyBhdCBpbmRleCBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNvdW50X3NtYWxsX2Vub3VnaDogY291bnQgPCBjYXBhY2l0eVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X2luY3JlYXNlZDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50IC0gMSkgPSB2XG4gICAgZW5kXG5cbiAgZXh0ZW5kX2ZpbGxlZCAodjogVClcbiAgICAgIC0tIFNldCBpdGVtcyBiZXR3ZWVuIGBjb3VudCcgYW5kIGBjYXBhY2l0eSAtIDEnIHdpdGggYHYnLlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKHYsIGNvdW50LCBjYXBhY2l0eSAtIDEpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfaW5jcmVhc2VkOiBjb3VudCA9IGNhcGFjaXR5XG4gICAgICBmaWxsZWQ6IGZpbGxlZF93aXRoICh2LCBvbGQgY291bnQsIGNhcGFjaXR5IC0gMSlcbiAgICBlbmRcblxuICBmaWxsX3dpdGggKHY6IFQ7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgaXRlbXMgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4JyB3aXRoIGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X2luX2JvdW5kOiBzdGFydF9pbmRleCA8PSBjb3VudFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgY2FwYWNpdHlcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfY291bnQ6IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGxfY291bnQgOj0gY291bnQubWluIChlbmRfaW5kZXggKyAxKVxuICAgICAgICBuYiA6PSBsX2NvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgcHV0ICh2LCBpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBsX2NvdW50XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleCArIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBleHRlbmQgKHYpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X2RlZmluaXRpb246IGNvdW50ID0gKG9sZCBjb3VudCkubWF4IChlbmRfaW5kZXggKyAxKVxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAodiwgc3RhcnRfaW5kZXgsIGVuZF9pbmRleClcbiAgICBlbmRcblxuICBmaWxsX3dpdGhfZGVmYXVsdCAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIENsZWFyIGl0ZW1zIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfc2VsZl9pbml0aWFsaXppbmc6ICh7VH0pLmhhc19kZWZhdWx0XG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGNvdW50XG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoKHtUfSkuZGVmYXVsdCwgc3RhcnRfaW5kZXgsIGVuZF9pbmRleClcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKCh7VH0pLmRlZmF1bHQsIHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X2RhdGEgKG90aGVyOiBTUEVDSUFMIFtUXTsgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgbicgZWxlbWVudHMgb2YgYG90aGVyJyBmcm9tIGBzb3VyY2VfaW5kZXgnIHBvc2l0aW9uIHRvIEN1cnJlbnQgYXRcbiAgICAgIC0tIGBkZXN0aW5hdGlvbl9pbmRleCcgYW5kIHNoaWZ0IGVsZW1lbnRzIGJldHdlZW4gYGRlc3RpbmF0aW9uX2luZGV4JyBhbmQgYGNvdW50J1xuICAgICAgLS0gdG8gdGhlIHJpZ2h0LiBPdGhlciBlbGVtZW50cyBvZiBDdXJyZW50IHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBvdGhlci5jb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBjb3VudCArIG4gPD0gY2FwYWNpdHlcbiAgICAgIHNhbWVfdHlwZTogb3RoZXIuY29uZm9ybXNfdG8gKEN1cnJlbnQpXG4gICAgbG9jYWxcbiAgICAgIGxfcmVtYWluaW5nX2l0ZW1zLCBsX29mZnNldCwgbF9uYl9pdGVtc19sZWZ0OiBJTlRFR0VSXG4gICAgICBsX3NvdXJjZV9pbmRleCwgbF9lbmRfaW5kZXgsIGxfZGVzdGluYXRpb25faW5kZXg6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9yZW1haW5pbmdfaXRlbXMgOj0gY291bnQgLSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgaWYgbF9yZW1haW5pbmdfaXRlbXMgPSAwIHRoZW5cbiAgICAgICAgICAtLSBJdCBpcyBiZWluZyBhZGRlZCBhdCB0aGUgZW5kIG9mIEN1cnJlbnQsIHRoZXJlZm9yZSB3ZSBjYW4gc2ltcGx5IGV4dGVuZC5cbiAgICAgICAgY29weV9kYXRhIChvdGhlciwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGVsc2VpZiBuIDw9IGxfcmVtYWluaW5nX2l0ZW1zIHRoZW5cbiAgICAgICAgICAtLSBTaW1wbGUgY2FzZSB3aGVyZSB3ZSBjYW4gcGVyZm9ybSBhIG1vdmUgb2YgdGhlIGV4aXN0aW5nIGl0ZW1zIHRvIHRoZSBlbmRcbiAgICAgICAgICAtLSBhbmQgdGhlbiBjb3B5IHRoZSBlbGVtZW50cyBvZiBgb3RoZXInLlxuICAgICAgICBtb3ZlX2RhdGEgKGRlc3RpbmF0aW9uX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCArIG4sIGxfcmVtYWluaW5nX2l0ZW1zKVxuICAgICAgICBjb3B5X2RhdGEgKG90aGVyLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEJlY2F1c2Ugd2UgY2Fubm90IGhhdmUgdW5pbml0aWFsaXplZCBpdGVtcywgd2UgY2Fubm90IG1vdmUgYWxsIHRoZSByZW1haW5pbmcgaXRlbXMgYmV5b25kIGNvdW50XG4gICAgICAgICAgLS0gaW5zdGVhZCB3ZSBjb3B5IGJ5IGNodW5rcyBvZiBgbF9yZW1haW5pbmdfaXRlbXMnLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zb3VyY2VfaW5kZXggOj0gc291cmNlX2luZGV4XG4gICAgICAgICAgbF9kZXN0aW5hdGlvbl9pbmRleCA6PSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIGxfZW5kX2luZGV4IDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgICBsX25iX2l0ZW1zX2xlZnQgOj0gblxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfcmVtYWluaW5nX2l0ZW1zXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zb3VyY2VfaW5kZXggPj0gbF9lbmRfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG1vdmVfZGF0YSAobF9kZXN0aW5hdGlvbl9pbmRleCwgbF9kZXN0aW5hdGlvbl9pbmRleCArIGxfb2Zmc2V0LCBsX3JlbWFpbmluZ19pdGVtcylcbiAgICAgICAgICBjb3B5X2RhdGEgKG90aGVyLCBsX3NvdXJjZV9pbmRleCwgbF9kZXN0aW5hdGlvbl9pbmRleCwgbF9vZmZzZXQpXG4gICAgICAgICAgbF9kZXN0aW5hdGlvbl9pbmRleCA6PSBsX2Rlc3RpbmF0aW9uX2luZGV4ICsgbF9vZmZzZXRcbiAgICAgICAgICBsX3NvdXJjZV9pbmRleCA6PSBsX3NvdXJjZV9pbmRleCArIGxfb2Zmc2V0XG4gICAgICAgICAgICAtLSBDb21wdXRlIGhvdyBtYW55IG1vcmUgaXRlbXMgd2UgaGF2ZSB0byBjb3B5LlxuICAgICAgICAgIGxfbmJfaXRlbXNfbGVmdCA6PSBsX25iX2l0ZW1zX2xlZnQgLSBsX3JlbWFpbmluZ19pdGVtc1xuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfb2Zmc2V0Lm1pbiAobF9uYl9pdGVtc19sZWZ0KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY29waWVkOiBzYW1lX2l0ZW1zIChvdGhlciwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gb2xkIGNvdW50ICsgblxuICAgIGVuZFxuXG4gIGNvcHlfZGF0YSAob3RoZXI6IFNQRUNJQUwgW1RdOyBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBgbicgZWxlbWVudHMgb2YgYG90aGVyJyBmcm9tIGBzb3VyY2VfaW5kZXgnIHBvc2l0aW9uIHRvIEN1cnJlbnQgYXRcbiAgICAgIC0tIGBkZXN0aW5hdGlvbl9pbmRleCcuIE90aGVyIGVsZW1lbnRzIG9mIEN1cnJlbnQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IG90aGVyLmNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgICAgc2FtZV90eXBlOiBvdGhlci5jb25mb3Jtc190byAoQ3VycmVudClcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgbW92ZV9kYXRhIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBqIDo9IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgICAgbmIgOj0gc291cmNlX2luZGV4ICsgblxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9yY2UgKG90aGVyLml0ZW0gKGkpLCBqKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjb3BpZWQ6IHNhbWVfaXRlbXMgKG90aGVyLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGRlc3RpbmF0aW9uX2luZGV4ICsgbilcbiAgICBlbmRcblxuICBtb3ZlX2RhdGEgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGBuJyBlbGVtZW50cyBvZiBDdXJyZW50IGZyb20gYHNvdXJjZV9zdGFydCcgcG9zaXRpb24gdG8gYGRlc3RpbmF0aW9uX2luZGV4Jy5cbiAgICAgIC0tIE90aGVyIGVsZW1lbnRzIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IGNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBpZiBzb3VyY2VfaW5kZXggPSBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICBlbHNlaWYgc291cmNlX2luZGV4ID4gZGVzdGluYXRpb25faW5kZXggdGhlblxuICAgICAgICBpZiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPCBzb3VyY2VfaW5kZXggdGhlblxuICAgICAgICAgIG5vbl9vdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGlmIHNvdXJjZV9pbmRleCArIG4gPCBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICAgICAgbm9uX292ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbW92ZWQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGRlc3RpbmF0aW9uX2luZGV4ICsgbilcbiAgICBlbmRcblxuICBvdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBgbicgZWxlbWVudHMgb2YgQ3VycmVudCBmcm9tIGBzb3VyY2Vfc3RhcnQnIHBvc2l0aW9uIHRvIGBkZXN0aW5hdGlvbl9pbmRleCcuXG4gICAgICAtLSBPdGhlciBlbGVtZW50cyByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgZGlmZmVyZW50X3NvdXJjZV9hbmRfdGFyZ2V0OiBzb3VyY2VfaW5kZXggLz0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNhcGFjaXR5XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX29mZnNldDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBzb3VyY2VfaW5kZXggPCBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICAgICAgLS0gV2Ugc2hpZnQgZnJvbSBsZWZ0IHRvIHJpZ2h0IHN0YXJ0aW5nIGZyb20gdGhlIGVuZFxuICAgICAgICAgIC0tIGR1ZSB0byBwb3NzaWJsZSBvdmVybGFwcGluZy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc291cmNlX2luZGV4ICsgbiAtIDFcbiAgICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggLSAxXG4gICAgICAgICAgbF9vZmZzZXQgOj0gZGVzdGluYXRpb25faW5kZXggLSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25faW5kZXggKyBuID49IGNvdW50KSB0aGVuXG4gICAgICAgICAgICAgIC0tIEluaXRpYWxpemUgZWxlbWVudHMgYWJvdmUgYGNvdW50JyB0byBhIGR1bW15IGl0ZW0uXG4gICAgICAgICAgICBmaWxsX3dpdGggKGl0ZW0gKHNvdXJjZV9pbmRleCksIGNvdW50LCBkZXN0aW5hdGlvbl9pbmRleCArIG4gLSAxKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGNoZWNrXG4gICAgICAgICAgICBsX29mZnNldF9wb3NpdGl2ZTogbF9vZmZzZXQgPiAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBwdXQgKGl0ZW0gKGkpLCBpICsgbF9vZmZzZXQpXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBXZSBzaGlmdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHNvdXJjZV9pbmRleFxuICAgICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgICBsX29mZnNldCA6PSBzb3VyY2VfaW5kZXggLSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIGNoZWNrXG4gICAgICAgICAgICBsX29mZnNldF9wb3NpdGl2ZTogbF9vZmZzZXQgPiAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBmb3JjZSAoaXRlbSAoaSksIGkgLSBsX29mZnNldClcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBtb3ZlZDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZGVzdGluYXRpb25faW5kZXggKyBuKVxuICAgIGVuZFxuXG4gIG5vbl9vdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBgbicgZWxlbWVudHMgb2YgQ3VycmVudCBmcm9tIGBzb3VyY2Vfc3RhcnQnIHBvc2l0aW9uIHRvIGBkZXN0aW5hdGlvbl9pbmRleCcuXG4gICAgICAtLSBPdGhlciBlbGVtZW50cyByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgZGlmZmVyZW50X3NvdXJjZV9hbmRfdGFyZ2V0OiBzb3VyY2VfaW5kZXggLz0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgIG5vbl9vdmVybGFwcGluZzpcbiAgICAgICAgKHNvdXJjZV9pbmRleCA8IGRlc3RpbmF0aW9uX2luZGV4IGltcGxpZXMgc291cmNlX2luZGV4ICsgbiA8IGRlc3RpbmF0aW9uX2luZGV4KSBvclxuICAgICAgICAoc291cmNlX2luZGV4ID4gZGVzdGluYXRpb25faW5kZXggaW1wbGllcyBkZXN0aW5hdGlvbl9pbmRleCArIG4gPCBzb3VyY2VfaW5kZXgpXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IGNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHNvdXJjZV9pbmRleFxuICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggKyBuXG4gICAgICAgIGxfb2Zmc2V0IDo9IGRlc3RpbmF0aW9uX2luZGV4IC0gc291cmNlX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgZm9yY2UgKGl0ZW0gKGkpLCBpICsgbF9vZmZzZXQpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbW92ZWQ6IHNhbWVfaXRlbXMgKEN1cnJlbnQsIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZGVzdGluYXRpb25faW5kZXggKyBuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gS2VlcCB0aGUgZmlyc3QgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICAgIGxlc3NfdGhhbl9jb3VudDogbiA8PSBjb3VudFxuICAgIGRvXG4gICAgICBzZXRfY291bnQgKG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG5cbiAgICAgIGtlcHQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCAwLCAwLCBuKVxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIEtlZXAgdGhlIGxhc3QgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICAgIGxlc3NfdGhhbl9jb3VudDogbiA8PSBjb3VudFxuICAgIGRvXG4gICAgICBvdmVybGFwcGluZ19tb3ZlIChjb3VudCAtIG4sIDAsIG4pXG4gICAgICBzZXRfY291bnQgKG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG5cbiAgICAgIGtlcHQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCBuLCAwLCBuKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIHRoZSBmaXJzdCBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgICAgbGVzc190aGFuX2NvdW50OiBuIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBvbGQgY291bnQgLSBuXG4gICAgICBrZXB0OiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgbiwgMCwgY291bnQpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBLZWVwIHRoZSBmaXJzdCAgYGNvdW50IC0gbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgICAgbGVzc190aGFuX2NvdW50OiBuIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGtlZXBfaGVhZCAoY291bnQgLSBuKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBvbGQgY291bnQgLSBuXG4gICAgICBrZXB0OiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgMCwgMCwgY291bnQpXG4gICAgZW5kXG5cbiAgcmVzaXplZF9hcmVhIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDcmVhdGUgYSBjb3B5IG9mIEN1cnJlbnQgd2l0aCBhIGNvdW50IG9mIGBuJ1xuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5IChuKVxuICAgICAgUmVzdWx0LmNvcHlfZGF0YSAoQ3VycmVudCwgMCwgMCwgbi5taW4gKGNvdW50KSlcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF9kaWZmZXJlbnRfZnJvbV9jdXJyZW50OiBSZXN1bHQgLz0gQ3VycmVudFxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAgbmV3X2NhcGFjaXR5OiBSZXN1bHQuY2FwYWNpdHkgPSBuXG4gICAgICBwcmVzZXJ2ZWQ6IFJlc3VsdC5zYW1lX2l0ZW1zIChDdXJyZW50LCAwLCAwLCBuLm1pbiAob2xkIGNvdW50KSlcbiAgICBlbmRcblxuICByZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0IChhX2RlZmF1bHRfdmFsdWU6IFQ7IG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENyZWF0ZSBhIGNvcHkgb2YgQ3VycmVudCB3aXRoIGEgY291bnQgb2YgYG4nIHdoZXJlIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbiAgICAgIC0tIGVudHJpZXMgYXJlIHNldCB0byBgYV9kZWZhdWx0X3ZhbHVlJy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAobilcbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdC5jb3B5X2RhdGEgKEN1cnJlbnQsIDAsIDAsIGNvdW50KVxuICAgICAgICBSZXN1bHQuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIGNvdW50LCBuIC0gMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0LmNvcHlfZGF0YSAoQ3VycmVudCwgMCwgMCwgbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgUmVzdWx0X2RpZmZlcmVudF9mcm9tX2N1cnJlbnQ6IFJlc3VsdCAvPSBDdXJyZW50XG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG5cbiAgICAgIG5ld19jYXBhY2l0eTogUmVzdWx0LmNhcGFjaXR5ID0gblxuICAgICAgcHJlc2VydmVkOiBSZXN1bHQuc2FtZV9pdGVtcyAoQ3VycmVudCwgMCwgMCwgbi5taW4gKG9sZCBjb3VudCkpXG4gICAgZW5kXG5cbiAgYWxpYXNlZF9yZXNpemVkX2FyZWEgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRyeSB0byByZXNpemUgYEN1cnJlbnQnIHdpdGggYSBjb3VudCBvZiBgbicsIGlmIG5vdFxuICAgICAgLS0gcG9zc2libGUgYSBuZXcgY29weVxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBuZXdfY2FwYWNpdHk6IFJlc3VsdC5jYXBhY2l0eSA9IG5cbiAgICAgIHByZXNlcnZlZDogUmVzdWx0LnNhbWVfaXRlbXMgKG9sZCB0d2luLCAwLCAwLCBuLm1pbiAob2xkIGNvdW50KSlcbiAgICBlbmRcblxuICBhbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogVDsgbjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVHJ5IHRvIHJlc2l6ZSBgQ3VycmVudCcgd2l0aCBhIGNvdW50IG9mIGBuJywgaWYgbm90XG4gICAgICAtLSBwb3NzaWJsZSBhIG5ldyBjb3B5LiBOb24geWV0IGluaXRpYWxpemVkIGVudHJpZXMgYXJlIHNldCB0byBgYV9kZWZhdWx0X3ZhbHVlJy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIFJlc3VsdC5maWxsX3dpdGggKGFfZGVmYXVsdF92YWx1ZSwgUmVzdWx0LmNvdW50LCBuIC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIG5ld19jb3VudDogUmVzdWx0LmNvdW50ID0gblxuICAgICAgbmV3X2NhcGFjaXR5OiBSZXN1bHQuY2FwYWNpdHkgPSBuXG4gICAgICBwcmVzZXJ2ZWQ6IFJlc3VsdC5zYW1lX2l0ZW1zIChvbGQgdHdpbiwgMCwgMCwgbi5taW4gKG9sZCBjb3VudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlcGxhY2VfYWxsICh2OiBUKVxuICAgICAgLS0gUmVwbGFjZSBhbGwgaXRlbXMgd2l0aCBgdicuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGNvdW50IC0gMVxuICAgICAgdW50aWxcbiAgICAgICAgaSA8IDBcbiAgICAgIGxvb3BcbiAgICAgICAgcHV0ICh2LCBpKVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNsZWFyZWQ6IGZpbGxlZF93aXRoICh2LCAwLCB1cHBlcilcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVzZXQgY291bnQgdG8gemVyby5cbiAgICBkb1xuICAgICAgc2V0X2NvdW50ICgwKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X3Jlc2V0OiBjb3VudCA9IDBcbiAgICBlbmRcblxuICBjbGVhcl9hbGxcbiAgICAgIC0tIFJlc2V0IGFsbCBpdGVtcyB0byBkZWZhdWx0IHZhbHVlcy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJCZWNhdXNlIG9mIHRoZSBuZXcgcHJlY29uZGl0aW9uLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYGZpbGxfd2l0aCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0OiAoe1R9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBmaWxsX3dpdGhfZGVmYXVsdCAoMCwgdXBwZXIpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfcmVzZXQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1RdXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtIChpKV0pXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2lmX2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1RdXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1RdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2l0ZW0gKGkpXSkgdGhlblxuICAgICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbSAoaSldKVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdGhlcmVfZXhpc3RzX2luX2JvdW5kcyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1RdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhdCBsZWFzdCBvbmUgaXRlbT9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iIG9yIFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gdGVzdC5pdGVtIChbaXRlbSAoaSldKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmb3JfYWxsX2luX2JvdW5kcyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1RdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhbGwgaXRlbXM/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSB0ZXN0Lml0ZW0gKFtpdGVtIChpKV0pXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2FsbF93aXRoX2luZGV4X2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1QsIElOVEVHRVJdXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIHJlY2VpdmVzIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgaiA6PSBsb3dlclxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhY3Rpb24uY2FsbCAoW2l0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4X2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1QsIElOVEVHRVJdXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1QsIElOVEVHRVJdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBgYWN0aW9uJyBhbmQgYHRlc3QnIHJlY2VpdmUgdGhlIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBvciBgdGVzdCcgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgaiA6PSBsb3dlclxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiB0ZXN0Lml0ZW0gKFtpdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2l0ZW0gKGkpLCBqXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgZGVidWdfb3V0cHV0OiBTVFJJTkdcbiAgICAgIC0tIFN0cmluZyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGVidWdnZXIgdG8gcmVwcmVzZW50IGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFByZWN1cnNvclxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmcgKFwiLCBjYXBhY2l0eT1cIilcbiAgICAgIFJlc3VsdC5hcHBlbmRfaW50ZWdlciAoY2FwYWNpdHkpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZWxlbWVudF9zaXplOiBJTlRFR0VSXG4gICAgICAtLSBTaXplIG9mIGVsZW1lbnRzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZWxlbWVudF9zaXplX25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBzZXRfY291bnQgKG46IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB3aXRoIGBuJy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICB2YWxpZF9uZXdfY291bnQ6IG4gPD0gY291bnRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgY2FwYWNpdHlfcHJlc2VydmVkOiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgY291bnRfbGVzc190aGFuX2NhcGFjaXR5OiBjb3VudCA8PSBjYXBhY2l0eVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsImNsYXNzXG4gIFNUUklOR1xuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR18zMlxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgZW5kXG5cbiAgU1RSSU5HX0dFTkVSQUxcbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaGFzLCBpbmRleF9vZiwgbGFzdF9pbmRleF9vZiwgb2NjdXJyZW5jZXNcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWxcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0NIQVJBQ1RFUl8zMiwgSU5URUdFUl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBwcnVuZV9hbGwsXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgUkVTSVpBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaXRlbSwgYXQsIHB1dCwgdmFsaWRfaW5kZXhcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fc3RyaW5nLFxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIGFzX3N0cmluZ184OiB7UkVBREFCTEVfU1RSSU5HXzgsIFNUUklOR184fVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgczMyIHRoZW5cbiAgICAgICAgbWFrZV9mcm9tX3N0cmluZyAoczMyKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlIChzLmNvdW50KVxuICAgICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IGRldGFjaGFibGUgU1lTVEVNX1NUUklORylcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCB3aXRoIGBhX3N5c3RlbV9zdHJpbmcnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBhX3N5c3RlbV9zdHJpbmcubGVuZ3RoICsgZG90bmV0X2NvbnZlcnRvci5lc2NhcGVfY291bnQgKGFfc3lzdGVtX3N0cmluZylcbiAgICAgIGVuZFxuICAgICAgbWFrZSAobF9jb3VudClcbiAgICAgIGlmIGxfY291bnQgPiAwIGFuZCB0aGVuIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgc2V0X2NvdW50IChsX2NvdW50KVxuICAgICAgICBkb3RuZXRfY29udmVydG9yLnJlYWRfc3lzdGVtX3N0cmluZ19pbnRvIChhX3N5c3RlbV9zdHJpbmcsIEN1cnJlbnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGxfY291bnQgOj0gY19zdHJpbmdfcHJvdmlkZXIuY291bnRcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3RyaW5nX2ludG8gKEN1cnJlbnQpXG4gICAgZW5zdXJlXG4gICAgICBub196ZXJvX2J5dGU6IG5vdCBoYXMgKCclLzAvJylcbiAgICAgIC0tIGNoYXJhY3RlcnM6IGZvciBhbGwgaSBpbiAxLi5jb3VudCwgaXRlbSAoaSkgZXF1YWxzXG4gICAgICAtLSAgICAgICBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIChpIC0gMSlcbiAgICAgIC0tIGNvcnJlY3RfY291bnQ6IHRoZSBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIGNvdW50XG4gICAgICAtLSAgICAgICBpcyBOVUxMXG4gICAgZW5kXG5cbiAgZnJvbV9jX3N1YnN0cmluZyAoY19zdHJpbmc6IFBPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIHN1YnN0cmluZyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChjX3N0cmluZyArIChzdGFydF9wb3MgLSAxKSwgbF9jb3VudClcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvIChDdXJyZW50LCAxLCBsX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY291bnQ6IGNvdW50ID0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIC0tIGNoYXJhY3RlcnM6IGZvciBhbGwgaSBpbiAxLi5jb3VudCwgaXRlbSAoaSkgZXF1YWxzXG4gICAgICAtLSAgICAgICBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIChpIC0gMSlcbiAgICBlbmRcblxuICBhZGFwdCAoczogU1RSSU5HXzMyKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPYmplY3Qgb2YgYSB0eXBlIGNvbmZvcm1pbmcgdG8gdGhlIHR5cGUgb2YgYHMnLFxuICAgICAgLS0gaW5pdGlhbGl6ZWQgd2l0aCBhdHRyaWJ1dGVzIGZyb20gYHMnXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgUmVzdWx0LnNoYXJlIChzKVxuICAgIGVuc3VyZVxuICAgICAgYWRhcHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzaGFyZWRfaW1wbGVtZW50YXRpb246IFJlc3VsdC5zaGFyZWRfd2l0aCAocylcbiAgICBlbmRcblxuICByZW1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9zdHJpbmc6IGNvdW50ID0gMFxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzIgYXNzaWduIHB1dFxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSkuY29kZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIG9ic29sZXRlXG4gICAgICBcIkR1ZSB0byBwb3RlbnRpYWwgdHJ1bmNhdGlvbiBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYGNvZGUgKGkpJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5uYXR1cmFsXzMyX2NvZGUuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGFyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnNcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/IChBbnN3ZXI6IHllcy4pXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiB5ZXMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG4gIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IEJPT0xFQU4gPSBGYWxzZVxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0ICh0OiBSRUFEQUJMRV9TVFJJTkdfMzI7IG4xLCBuMjogSU5URUdFUilcbiAgICAgIC0tIFNldCBjdXJyZW50IHN0cmluZyB0byBzdWJzdHJpbmcgb2YgYHQnIGZyb20gaW5kaWNlcyBgbjEnXG4gICAgICAtLSB0byBgbjInLCBvciB0byBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBzdWJzdHJpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHQgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfMzJcbiAgICBkb1xuICAgICAgcyA6PSB0LnN1YnN0cmluZyAobjEsIG4yKVxuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19zdWJzdHJpbmc6IHNhbWVfc3RyaW5nICh0LnN1YnN0cmluZyAobjEsIG4yKSlcbiAgICBlbmRcblxuICBzdWJjb3B5IChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kXG4gICAgICAtLSBgZW5kX3BvcycgdG8gY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICAgIGVub3VnaF9zcGFjZTogKGNvdW50IC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBsb2NhbFxuICAgICAgbF9vdGhlcl9hcmVhLCBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBlbmRfcG9zID49IHN0YXJ0X3BvcyB0aGVuXG4gICAgICAgIGxfb3RoZXJfYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGlmIGxfYXJlYSAvPSBsX290aGVyX2FyZWEgdGhlblxuICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfb3RoZXJfYXJlYSwgc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBjb3BpZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpbmRleF9wb3MgLSAxKSArXG4gICAgICAgIG9sZCBvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykgK1xuICAgICAgICBvbGQgc3Vic3RyaW5nIChpbmRleF9wb3MgKyAoZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnIHRvIGBlbmRfaW5kZXgnIHdpdGggYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBkaWZmOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgc19jb3VudDogSU5URUdFUlxuICAgICAgb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHNfY291bnQgOj0gcy5jb3VudFxuICAgICAgb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICBkaWZmIDo9IHNfY291bnQgLSAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgbmV3X3NpemUgOj0gZGlmZiArIG9sZF9jb3VudFxuICAgICAgaWYgZGlmZiA+IDAgdGhlblxuICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIHRoZSBzdHJpbmcuXG4gICAgICAgIGdyb3cgKG5ld19zaXplKVxuICAgICAgZW5kXG5cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIC0tfCBXZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBmb3J3YXJkIChpZiBkaWZmIGlzID4gMCksIGJhY2t3YXJkIChpZiBkaWZmIDwgMCksXG4gICAgICAgIC0tfCBhbmQgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICBpZiBkaWZmIC89IDAgdGhlblxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoZW5kX2luZGV4LCBlbmRfaW5kZXggKyBkaWZmLCBvbGRfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICBlbmRcbiAgICAgICAgLS18IFNldCBuZXcgY291bnRcbiAgICAgIHNldF9jb3VudCAobmV3X3NpemUpXG4gICAgICAgIC0tfCBXZSBjb3B5IHRoZSBzdWJzdHJpbmcuXG4gICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgc3RhcnRfaW5kZXggLSAxLCBzX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50IC0gZW5kX2luZGV4ICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICByZXBsYWNlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCAoc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICtcbiAgICAgICAgICBzICsgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZ19hbGwgKG9yaWdpbmFsLCBuZXc6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgb2NjdXJyZW5jZSBvZiBgb3JpZ2luYWwnIHdpdGggYG5ldycuXG4gICAgcmVxdWlyZVxuICAgICAgb3JpZ2luYWxfZXhpc3RzOiBvcmlnaW5hbCAvPSBWb2lkXG4gICAgICBuZXdfZXhpc3RzOiBuZXcgLz0gVm9pZFxuICAgICAgb3JpZ2luYWxfbm90X2VtcHR5OiBub3Qgb3JpZ2luYWwuaXNfZW1wdHlcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9ibGFua1xuICAgICAgLS0gUmVwbGFjZSBhbGwgY3VycmVudCBjaGFyYWN0ZXJzIHdpdGggYmxhbmtzLlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgYWxsX2JsYW5rOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKCcgJykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGZpbGxfYmxhbmtcbiAgICAgIC0tIEZpbGwgd2l0aCBgY2FwYWNpdHknIGJsYW5rIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGZpbGxfY2hhcmFjdGVyICgnICcpXG4gICAgZW5zdXJlXG4gICAgICBmaWxsZWQ6IGZ1bGxcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gY2FwYWNpdHkpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICAtLSBhbGxfYmxhbms6IEZvciBldmVyeSBgaScgaW4gYGNvdW50Jy4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYEJsYW5rJ1xuICAgIGVuZFxuXG4gIGZpbGxfd2l0aCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBjaGFyYWN0ZXIgd2l0aCBgYycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbF9jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgYXJlYS5maWxsX3dpdGggKGMsIDAsIGxfY291bnQgLSAxKVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBmaWxsZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIHJlcGxhY2VfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkJ1wiXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoYylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgbG9jYWxcbiAgICAgIG5iOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGVmdF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIG5iLCBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbmJfc3BhY2UgPiBuYiBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChuYl9zcGFjZSkpXG4gICAgICBsb29wXG4gICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudCB2YWx1ZS5cbiAgICAgICAgbmIgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmJfc3BhY2UsIDAsIG5iKVxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGkgOj0gbmJcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwXG4gICAgICBsb29wXG4gICAgICAgIGMgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGMpIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGFyZSBkb25lLlxuICAgICAgICAgIGkgOj0gLTFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50LlxuICAgICAgICBjb3VudCA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2hhcmUgKG90aGVyOiBTVFJJTkdfMzIpXG4gICAgICAtLSBNYWtlIGN1cnJlbnQgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcicuXG4gICAgICAtLSBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmdcbiAgICAgIC0tIHdpbGwgYWxzbyBhZmZlY3QgYG90aGVyJywgYW5kIGNvbnZlcnNlbHkuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICBjb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZF9jb3VudDogb3RoZXIuY291bnQgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IG90aGVyLmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbiAgcHV0IChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgYGMnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAoYywgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHB1dF9jb2RlICh2OiBOQVRVUkFMXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknIGJ5IGNoYXJhY3RlciBvZiBjb2RlIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYudG9fY2hhcmFjdGVyXzMyLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgcHJlcGVuZCAobF9zMzIpXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7U1RSSU5HX0dFTkVSQUx9IChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJlY2VkZSwgcHJlcGVuZF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFkZCBgYycgYXQgZnJvbnQuXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCAxLCBjb3VudClcbiAgICAgIGxfYXJlYS5wdXQgKGMsIDApXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCAxKVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgY291bnRcbiAgICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgb2YgY3VycmVudC5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIGxfc19jb3VudCwgY291bnQpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgYmVnaW5uaW5nLlxuICAgICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgMCwgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBiJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYi5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgZCcgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGQub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGkub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgcHJlcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgYXBwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnRcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCBsX2NvdW50LCBsX3NfY291bnQpXG4gICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKEN1cnJlbnQgKyBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkpKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoY291bnQgKyBzLmNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoQ3VycmVudClcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhcHBlbmRlZDogcyAvPSBWb2lkIGltcGxpZXNcbiAgICAgICAgKGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCB0d2luICsgb2xkIHMudHdpbikpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzggKGk6IElOVEVHRVJfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzE2IChpOiBJTlRFR0VSXzE2KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl8xNlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzE2fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl82NH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfOCAoaTogTkFUVVJBTF84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMTYgKGk6IE5BVFVSQUxfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMzIgKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzMyXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfNjQgKGk6IE5BVFVSQUxfNjQpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzY0XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHIub3V0KVxuICAgIGVuZFxuXG4gIGFwcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2NoYXJhY3RlciwgZXh0ZW5kIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBBcHBlbmQgYGMnIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgY3VycmVudF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjdXJyZW50X2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBjdXJyZW50X2NvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGN1cnJlbnRfY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBhcmVhLnB1dCAoYywgY3VycmVudF9jb3VudClcbiAgICAgIGNvdW50IDo9IGN1cnJlbnRfY291bnQgKyAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpdGVtX2luc2VydGVkOiBpdGVtIChjb3VudCkgPSBjXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgc3RhYmxlX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgY291bnQgLSAxKSB+IChvbGQgdHdpbilcbiAgICBlbmRcblxuICBhcHBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBiJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYi5vdXQpXG4gICAgZW5kXG5cbiAgaW5zZXJ0IChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBBZGQgYHMnIHRvIGxlZnQgb2YgcG9zaXRpb24gYGknIGluIGN1cnJlbnQgc3RyaW5nLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBpbnNlcnRfc3RyaW5nJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudCArIDFcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYHMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHBvcyA6PSBpIC0gMVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIGxfc19jb3VudCwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBwb3MsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBjJyBhdCBpbmRleCBgaScsIHNoaWZ0aW5nIGNoYXJhY3RlcnMgYmV0d2VlbiByYW5rc1xuICAgICAgLS0gYGknIGFuZCBgY291bnQnIHJpZ2h0d2FyZHMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgbmV3X3NpemUgOj0gMSArIGNvdW50XG4gICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcblxuICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICBwb3MgOj0gaSAtIDFcbiAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAocG9zLCBwb3MgKyAxLCBjb3VudCAtIHBvcylcblxuICAgICAgICAtLSBJbnNlcnQgbmV3IGNoYXJhY3RlclxuICAgICAgbF9hcmVhLnB1dCAoYywgcG9zKVxuXG4gICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG9uZV9tb3JlX2NoYXJhY3RlcjogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSBjXG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlbW92ZSAoaTogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBgaSctdGggY2hhcmFjdGVyLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdC5cbiAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAoaSwgaSAtIDEsIGxfY291bnQgLSBpKVxuICAgICAgICAtLSBVcGRhdGUgY29udGVudC5cbiAgICAgIGNvdW50IDo9IGxfY291bnQgLSAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IDBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF90YWlsIChjb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKG4ubWluIChjb3VudCkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3N1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCdcbiAgICAgIC0tIHRvIGBlbmRfaW5kZXgnIGluY2x1c2l2ZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbmJfcmVtb3ZlZDogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYl9yZW1vdmVkIDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbmJfcmVtb3ZlZCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfaW5kZXggKyBuYl9yZW1vdmVkIC0gMSwgc3RhcnRfaW5kZXggLSAxLCBsX2NvdW50IC0gZW5kX2luZGV4KVxuICAgICAgICBjb3VudCA6PSBsX2NvdW50IC0gbmJfcmVtb3ZlZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICsgb2xkIHN1YnN0cmluZyAoZW5kX2luZGV4ICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBuID4gbF9jb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IDBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF9oZWFkIChsX2NvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgY291bnQgLSBuLm1pbiAoY291bnQpKSlcbiAgICBlbmRcblxuICBwcnVuZSAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnLCBpZiBhbnkuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBjb3VudGVyIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGNvdW50ZXIgPiBjb3VudCBvciBlbHNlIChpdGVtIChjb3VudGVyKSA9IGMpXG4gICAgICBsb29wXG4gICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgY291bnRlciA8PSBjb3VudCB0aGVuXG4gICAgICAgIHJlbW92ZSAoY291bnRlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9jaGFyOiBDSEFSQUNURVJfMzJcbiAgICBkb1xuICAgICAgICAtLSBUcmF2ZXJzZSBzdHJpbmcgYW5kIHNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnRcbiAgICAgICAgLS0gZWFjaCB0aW1lIHdlIGZpbmQgYW4gb2NjdXJyZW5jZSBvZiBgYycuXG4gICAgICBmcm9tXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgbF9jaGFyIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICBpZiBsX2NoYXIgLz0gYyB0aGVuXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9jaGFyLCBqKVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0galxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgY2hhbmdlZF9jb3VudDogY291bnQgPSAob2xkIGNvdW50KSAtIChvbGQgb2NjdXJyZW5jZXMgKGMpKVxuICAgICAgLS0gcmVtb3ZlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgLz0gYGMnXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsX2xlYWRpbmcgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgbGVhZGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoMSkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfdHJhaWxpbmcgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgdHJhaWxpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKGNvdW50KSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoY291bnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG4gIGNsZWFyX2FsbFxuICAgICAgLS0gUmVzZXQgYWxsIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB3aXBlX291dCcgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgaXNfZW1wdHk6IGNvdW50ID0gMFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGFkYXB0X3NpemVcbiAgICAgIC0tIEFkYXB0IHRoZSBzaXplIHRvIGFjY29tbW9kYXRlIGBjb3VudCcgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgcmVzaXplIChjb3VudClcbiAgICBlbmRcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgY2hhcmFjdGVyLlxuICAgIGRvXG4gICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgnJS8wMDAvJywgbmV3c2l6ZSArIDEpXG4gICAgZW5kXG5cbiAgZ3JvdyAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIEVuc3VyZSB0aGF0IHRoZSBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgbmV3c2l6ZScuXG4gICAgZG9cbiAgICAgIGlmIG5ld3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3c2l6ZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfc3RyaW5nOiBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b191cHBlclxuICAgIGVuZFxuXG4gIGxlZnRfanVzdGlmeVxuICAgICAgLS0gTGVmdCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aXRkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlIHNwYWNlcy5cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBsZWZ0X2FkanVzdFxuXG4gICAgICAgIC0tIEdldCBuZXcgY291bnRcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgLS0gYGxlZnRfYWRqdXN0JyBkaWQgcmVtb3ZlIHNvbWUgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAtLSBzb21lIHdoaXRlIHNwYWNlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjZW50ZXJfanVzdGlmeVxuICAgICAgLS0gQ2VudGVyIGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYiwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxlZnRfbmJfc3BhY2UsIHJpZ2h0X25iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgPSBuYiBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChsZWZ0X25iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA6PSBsZWZ0X25iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAtMSBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgIGxvb3BcbiAgICAgICAgcmlnaHRfbmJfc3BhY2UgOj0gcmlnaHRfbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFdlIGVuY291cmFnZSB0aGF0IG1vcmUgc3BhY2VzIHdpbGwgYmUgcHV0IHRvIHRoZSBsZWZ0LCB3aGVuXG4gICAgICAgIC0tIG51bWJlciBvZiBzcGFjZXMgaXMgbm90IGV2ZW4uXG4gICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlICsgcmlnaHRfbmJfc3BhY2VcbiAgICAgIGlmIGxfb2Zmc2V0IFxcXFwgMiA9IDAgdGhlblxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMlxuICAgICAgZWxzZVxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMiAtIDFcbiAgICAgIGVuZFxuICAgICAgaWYgbF9vZmZzZXQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgbGVmdCAoZGVwZW5kaW5nIG9uIHNpZ24gb2ZcbiAgICAgICAgICAtLSBgbF9vZmZzZXQnIGJ5IGBsX29mZnNldCcgcG9zaXRpb24uXG4gICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCxcbiAgICAgICAgICBuYiAtIGxlZnRfbmJfc3BhY2UgLSByaWdodF9uYl9zcGFjZSlcblxuICAgICAgICBpZiBsX29mZnNldCA8IDAgdGhlblxuICAgICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaWxsIHJpZ2h0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBuYiAtIHJpZ2h0X25iX3NwYWNlIC0gbF9vZmZzZXQsIG5iIC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9qdXN0aWZ5XG4gICAgICAtLSBSaWdodCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBuYl9zcGFjZSA6PSBuYiAtIGlcbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGkpLCBpICsgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpICsgMVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbmJfc3BhY2UgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgbmJfc3BhY2UgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9qdXN0aWZ5IChwaXZvdDogQ0hBUkFDVEVSXzMyOyBwb3NpdGlvbjogSU5URUdFUilcbiAgICAgIC0tIEp1c3RpZnkgYSBzdHJpbmcgYmFzZWQgb24gYSBgcGl2b3QnXG4gICAgICAtLSBhbmQgdGhlIGBwb3NpdGlvbicgaXQgbmVlZHMgdG8gYmUgaW5cbiAgICAgIC0tIHRoZSBmaW5hbCBzdHJpbmcuXG4gICAgICAtLSBUaGlzIHdpbGwgZ3JvdyB0aGUgc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgLS0gdG8gZ2V0IHRoZSBwaXZvdCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9wb3NpdGlvbjogcG9zaXRpb24gPD0gY2FwYWNpdHlcbiAgICAgIHBvc2l0aXZlX3Bvc2l0aW9uOiBwb3NpdGlvbiA+PSAxXG4gICAgICBwaXZvdF9ub3Rfc3BhY2U6IHBpdm90IC89ICcgJ1xuICAgICAgbm90X2VtcHR5OiBub3QgaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgbF9pbmRleF9vZl9waXZvdCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9pbmRleF9vZl9waXZvdCA6PSBpbmRleF9vZiAocGl2b3QsIDEpXG4gICAgICBpZiBsX2luZGV4X29mX3Bpdm90IC89IDAgdGhlblxuICAgICAgICBpZiBsX2luZGV4X29mX3Bpdm90IDwgcG9zaXRpb24gdGhlblxuICAgICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgQ3VycmVudCBzbyB0aGF0IHdlIGNhbiBzaGlmdCBDdXJyZW50IGJ5XG4gICAgICAgICAgICAtLSBgbF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uJy5cbiAgICAgICAgICBsX25ld19zaXplIDo9IGNvdW50ICsgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90XG4gICAgICAgICAgZ3JvdyAobF9uZXdfc2l6ZSlcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCwgY291bnQpXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCAwLCBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3QgLSAxKVxuICAgICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHNoaWZ0IGNvbnRlbnQgdG8gdGhlIGxlZnQgYW5kIHJlc2V0IHRyYWlsaW5nIHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uLCAwLCBjb3VudCAtIGxfaW5kZXhfb2ZfcGl2b3QgKyBwb3NpdGlvbilcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uLCBjb3VudCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fbG93ZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX2xvd2VyKVxuICAgIGVuZFxuXG4gIHRvX3VwcGVyXG4gICAgICAtLSBDb252ZXJ0IHRvIHVwcGVyIGNhc2UuXG4gICAgZG9cbiAgICAgIHRvX3VwcGVyX2FyZWEgKGFyZWEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBsZW5ndGhfYW5kX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBhc191cHBlcilcbiAgICBlbmRcblxuICBsaW5lYXJfcmVwcmVzZW50YXRpb246IExJTkVBUiBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2M6IEFOWVxuICAgICAgLS0gQSByZWZlcmVuY2UgdG8gYSBDIGZvcm0gb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICAtLSBVc2VmdWwgb25seSBmb3IgaW50ZXJmYWNpbmcgd2l0aCBDIHNvZnR3YXJlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLnB1dCAoJyVVJywgY291bnQpXG4gICAgICBSZXN1bHQgOj0gbF9hcmVhXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5taXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvclxuICAgICAgLS0gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgIC0tIFwiSGVsbG8gd29ybGRcIiAtPiBcImRscm93IG9sbGVIXCIuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzMyXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGNvdW50IC0gMVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPD0galxuICAgICAgICBsb29wXG4gICAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgICAgYS5wdXQgKGEuaXRlbSAoaiksIGkpXG4gICAgICAgICAgYS5wdXQgKGMsIGopXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgPSBvbGQgYGl0ZW0nIChgY291bnQnKzEtYGknKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkb1xuICAgICAgaWYgKDEgPD0gc3RhcnRfaW5kZXgpIGFuZCAoc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4KSBhbmQgKGVuZF9pbmRleCA8PSBjb3VudCkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuYXJlYS5jb3B5X2RhdGEgKGFyZWEsIHN0YXJ0X2luZGV4IC0gMSwgMCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbXVsdGlwbHkgKG46IElOVEVHRVIpXG4gICAgICAtLSBEdXBsaWNhdGUgYSBzdHJpbmcgd2l0aGluIGl0c2VsZlxuICAgICAgLS0gKFwiaGVsbG9cIikubXVsdGlwbHkoMykgPT4gXCJoZWxsb2hlbGxvaGVsbG9cIlxuICAgIHJlcXVpcmVcbiAgICAgIG1lYW5pbmdmdWxfbXVsdGlwbGllcjogbiA+PSAxXG4gICAgbG9jYWxcbiAgICAgIHM6IGxpa2UgQ3VycmVudFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBzIDo9IHR3aW5cbiAgICAgIGdyb3cgKG4gKiBjb3VudClcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMVxuICAgICAgbG9vcFxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmcm96ZW4gc2V0X2NvdW50IChudW1iZXI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB0byBgbnVtYmVyJyBvZiBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSBudW1iZXJcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgbmV3X3N0cmluZyAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IGluc3RhbmNlIG9mIGN1cnJlbnQgd2l0aCBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBUcmFuc2Zvcm1hdGlvblxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggZHVyaW5nIHJldHJpZXZlIHVzaW5nIGBtaXNtYXRjaF9pbmZvcm1hdGlvbicuXG4gICAgZG9cbiAgICAgICAgLS0gTm90aGluZyB0byBiZSBkb25lIGJlY2F1c2Ugd2Ugb25seSBhZGRlZCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB0aGF0IHdpbGxcbiAgICAgICAgLS0gYmUgcmVjb21wdXRlZCBuZXh0IHRpbWUgd2UgcXVlcnkgYGhhc2hfY29kZScuXG5cbiAgICAgICAgLS0gSW4gLk5FVCwgd2UgaGF2ZSBhIG1pc21hdGNoIHRoYXQgaXMgdHJpZ2dlcmVkIGR1ZSB0byB0aGUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgICAgLS0gU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXSBhcyBhIC5ORVQgYXJyYXkgb2YgVUludDE2LlxuICAgICAgaWYgYXJlYSA9IFZvaWQgYW5kIHRoZW4gYXR0YWNoZWQge2xpa2UgYXJlYX0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJhcmVhXCIpIGFzIGxfYXJlYSB0aGVuXG4gICAgICAgIGFyZWEgOj0gbF9hcmVhXG4gICAgICBlbmRcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgY29tcGFyZV9jaGFyYWN0ZXI6IG5vdCBvYmplY3RfY29tcGFyaXNvblxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIFNlcXVlbmNlcyBvZiAzMi1iaXQgY2hhcmFjdGVycywgYWNjZXNzaWJsZSB0aHJvdWdoIGludGVnZXIgaW5kaWNlc1xuICAgIGluIGEgY29udGlndW91cyByYW5nZS5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAzLTI1IDIwOjQ2OjU0IC0wNzAwIChUdWUsIDI1IE1hciAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDcxNyAkXCJcblxuY2xhc3NcbiAgU1RSSU5HXzMyXG5cbmluaGVyaXRcbiAgUkVBREFCTEVfU1RSSU5HXzMyXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBlbmRcblxuICBTVFJJTkdfR0VORVJBTFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWxcbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaGFzLCBpbmRleF9vZiwgbGFzdF9pbmRleF9vZiwgb2NjdXJyZW5jZXNcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbQ0hBUkFDVEVSXzMyLCBJTlRFR0VSXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIHBydW5lX2FsbCxcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBSRVNJWkFCTEUgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgVE9fU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBpdGVtLCBhdCwgcHV0LCB2YWxpZF9pbmRleFxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9zdHJpbmcsXG4gIG1ha2VfZnJvbV9zdHJpbmdfZ2VuZXJhbCxcbiAgbWFrZV9mcm9tX2MsXG4gIG1ha2VfZnJvbV9jX3BvaW50ZXIsXG4gIG1ha2VfZnJvbV9jaWxcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgbWFrZV9mcm9tX2NpbCAoe1NZU1RFTV9TVFJJTkd9KSxcbiAgYXNfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOCwgU1RSSU5HXzh9XG5cbmZlYXR1cmUgLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBzMzIgdGhlblxuICAgICAgICBtYWtlX2Zyb21fc3RyaW5nIChzMzIpXG4gICAgICBlbHNlXG4gICAgICAgIG1ha2UgKHMuY291bnQpXG4gICAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jaWwgKGFfc3lzdGVtX3N0cmluZzogZGV0YWNoYWJsZSBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IHdpdGggYGFfc3lzdGVtX3N0cmluZycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGFfc3lzdGVtX3N0cmluZy5sZW5ndGggKyBkb3RuZXRfY29udmVydG9yLmVzY2FwZV9jb3VudCAoYV9zeXN0ZW1fc3RyaW5nKVxuICAgICAgZW5kXG4gICAgICBtYWtlIChsX2NvdW50KVxuICAgICAgaWYgbF9jb3VudCA+IDAgYW5kIHRoZW4gYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBzZXRfY291bnQgKGxfY291bnQpXG4gICAgICAgIGRvdG5ldF9jb252ZXJ0b3IucmVhZF9zeXN0ZW1fc3RyaW5nX2ludG8gKGFfc3lzdGVtX3N0cmluZywgQ3VycmVudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBjb250ZW50cyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdHJpbmdfaW50byAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIG5vX3plcm9fYnl0ZTogbm90IGhhcyAoJyUvMC8nKVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgICAgLS0gY29ycmVjdF9jb3VudDogdGhlIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgY291bnRcbiAgICAgIC0tICAgICAgIGlzIE5VTExcbiAgICBlbmRcblxuICBmcm9tX2Nfc3Vic3RyaW5nIChjX3N0cmluZzogUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gc3Vic3RyaW5nIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGNfc3RyaW5nICsgKHN0YXJ0X3BvcyAtIDEpLCBsX2NvdW50KVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG8gKEN1cnJlbnQsIDEsIGxfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgIGVuZFxuXG4gIGFkYXB0IChzOiBTVFJJTkdfMzIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9iamVjdCBvZiBhIHR5cGUgY29uZm9ybWluZyB0byB0aGUgdHlwZSBvZiBgcycsXG4gICAgICAtLSBpbml0aWFsaXplZCB3aXRoIGF0dHJpYnV0ZXMgZnJvbSBgcydcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBSZXN1bHQuc2hhcmUgKHMpXG4gICAgZW5zdXJlXG4gICAgICBhZGFwdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNoYXJlZF9pbXBsZW1lbnRhdGlvbjogUmVzdWx0LnNoYXJlZF93aXRoIChzKVxuICAgIGVuZFxuXG4gIHJlbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG1ha2UnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkb1xuICAgICAgbWFrZSAobilcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5X3N0cmluZzogY291bnQgPSAwXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMiBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKVxuICAgIGVuZFxuXG4gIGNvZGUgKGk6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLm5hdHVyYWxfMzJfY29kZS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gU3RvcmFnZSBmb3IgY2hhcmFjdGVyc1xuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gTWF5IG5ldyBpdGVtcyBiZSBhZGRlZD8gKEFuc3dlcjogeWVzLilcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvbjogQk9PTEVBTiA9IEZhbHNlXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXQgKHQ6IFJFQURBQkxFX1NUUklOR18zMjsgbjEsIG4yOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGN1cnJlbnQgc3RyaW5nIHRvIHN1YnN0cmluZyBvZiBgdCcgZnJvbSBpbmRpY2VzIGBuMSdcbiAgICAgIC0tIHRvIGBuMicsIG9yIHRvIGVtcHR5IHN0cmluZyBpZiBubyBzdWNoIHN1YnN0cmluZy5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIHM6IFJFQURBQkxFX1NUUklOR18zMlxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyB0byBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgICAgZW5vdWdoX3NwYWNlOiAoY291bnQgLSBpbmRleF9wb3MpID49IChlbmRfcG9zIC0gc3RhcnRfcG9zKVxuICAgIGxvY2FsXG4gICAgICBsX290aGVyX2FyZWEsIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGVuZF9wb3MgPj0gc3RhcnRfcG9zIHRoZW5cbiAgICAgICAgbF9vdGhlcl9hcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaWYgbF9hcmVhIC89IGxfb3RoZXJfYXJlYSB0aGVuXG4gICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9vdGhlcl9hcmVhLCBzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGNvcGllZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGluZGV4X3BvcyAtIDEpICtcbiAgICAgICAgb2xkIG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSArXG4gICAgICAgIG9sZCBzdWJzdHJpbmcgKGluZGV4X3BvcyArIChlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCcgdG8gYGVuZF9pbmRleCcgd2l0aCBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bGxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGRpZmY6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBzX2NvdW50OiBJTlRFR0VSXG4gICAgICBvbGRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBvbGRfY291bnQgOj0gY291bnRcbiAgICAgIGRpZmYgOj0gc19jb3VudCAtIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBuZXdfc2l6ZSA6PSBkaWZmICsgb2xkX2NvdW50XG4gICAgICBpZiBkaWZmID4gMCB0aGVuXG4gICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgdGhlIHN0cmluZy5cbiAgICAgICAgZ3JvdyAobmV3X3NpemUpXG4gICAgICBlbmRcblxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgLS18IFdlIG1vdmUgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGZvcndhcmQgKGlmIGRpZmYgaXMgPiAwKSwgYmFja3dhcmQgKGlmIGRpZmYgPCAwKSxcbiAgICAgICAgLS18IGFuZCBub3RoaW5nIG90aGVyd2lzZS5cbiAgICAgIGlmIGRpZmYgLz0gMCB0aGVuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChlbmRfaW5kZXgsIGVuZF9pbmRleCArIGRpZmYsIG9sZF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgIGVuZFxuICAgICAgICAtLXwgU2V0IG5ldyBjb3VudFxuICAgICAgc2V0X2NvdW50IChuZXdfc2l6ZSlcbiAgICAgICAgLS18IFdlIGNvcHkgdGhlIHN1YnN0cmluZy5cbiAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBzdGFydF9pbmRleCAtIDEsIHNfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnQgLSBlbmRfaW5kZXggKyBzdGFydF9pbmRleCAtIDFcbiAgICAgIHJlcGxhY2VkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIChzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgK1xuICAgICAgICAgIHMgKyBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nX2FsbCAob3JpZ2luYWwsIG5ldzogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2ZpcnN0X3BvcywgbF9uZXh0X3BvczogSU5URUdFUlxuICAgICAgbF9vcmlnX2NvdW50LCBsX25ld19jb3VudCwgbF9uZXdfbG93ZXIsIGxfY291bnQsIGksIGxfaW5kZXhfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfc3JjX2luZGV4LCBsX2Rlc3RfaW5kZXgsIGxfcHJldl9pbmRleCwgbF9jb3B5X2RlbHRhOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfbmV3X2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxfc3RyaW5nX3NlYXJjaGVyOiBsaWtlIHN0cmluZ19zZWFyY2hlclxuICAgICAgbF9pbmRleF9saXN0OiBTUEVDSUFMIFtJTlRFR0VSXVxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfc3RyaW5nX3NlYXJjaGVyIDo9IHN0cmluZ19zZWFyY2hlclxuICAgICAgICBsX3N0cmluZ19zZWFyY2hlci5pbml0aWFsaXplX2RlbHRhcyAob3JpZ2luYWwpXG4gICAgICAgIGxfb3JpZ19jb3VudCA6PSBvcmlnaW5hbC5jb3VudFxuICAgICAgICBsX25ld19jb3VudCA6PSBuZXcuY291bnRcbiAgICAgICAgaWYgbF9vcmlnX2NvdW50ID49IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCAxLCBsX2NvdW50KVxuICAgICAgICAgIGlmIGxfZmlyc3RfcG9zID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBsX29yaWdfY291bnQgPSBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3RyaW5nIHdpbGwgbm90IGJlIHJlc2l6ZWQsIHNpbXBseSBwZXJmb3JtIGNoYXJhY3RlciBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgPSAwXG4gICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICBpZiBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IDw9IGxfY291bnQgdGhlblxuICAgICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSAwXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZWlmIGxfb3JpZ19jb3VudCA+IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgLS0gTmV3IHN0cmluZyBpcyBzbWFsbGVyIHRoYW4gcHJldmlvdXMgc3RyaW5nLCB3ZSBjYW4gb3B0aW1pemVcbiAgICAgICAgICAgICAgLS0gc3Vic3RpdHV0aW9uIGJ5IG9ubHkgbW92aW5nIGJsb2NrIGJldHdlZW4gdHdvIG9jY3VycmVuY2VzIG9mIGBvcmdpbmFsJy5cbiAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCBsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgdW50aWxcbiAgICAgICAgICAgICAgbF9uZXh0X3BvcyA9IDBcbiAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICAtLSBDb3B5IG5ldyBzdHJpbmcgaW50byBDdXJyZW50XG4gICAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2ZpcnN0X3BvcyAtIDEgLSBsX29mZnNldCwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyBiZXR3ZWVuIGBsX2ZpcnN0X3BvcycgYW5kIGBsX25leHRfcG9zJ1xuICAgICAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQgLSAxLFxuICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgLSAxIC0gbF9vZmZzZXQsIGxfbmV4dF9wb3MgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9uZXh0X3Bvc1xuICAgICAgICAgICAgICBsX29mZnNldCA6PSBsX29mZnNldCArIChsX29yaWdfY291bnQgLSBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgaWYgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCA8PSBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICBsX25leHRfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50LCBsX2NvdW50KVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSAwXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIC0tIFBlcmZvcm0gZmluYWwgc3Vic3RpdHV0aW9uOlxuICAgICAgICAgICAgICAtLSBDb3B5IG5ldyBzdHJpbmcgaW50byBDdXJyZW50XG4gICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxIC0gbF9vZmZzZXQsIGxfbmV3X2NvdW50KVxuICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQgLSAxLFxuICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IC0gMSAtIGxfb2Zmc2V0LCBsX2NvdW50ICsgMSAtIGxfZmlyc3RfcG9zIC0gbF9vcmlnX2NvdW50KVxuICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gbGFzdCBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfb2Zmc2V0ICsgKGxfb3JpZ19jb3VudCAtIGxfbmV3X2NvdW50KVxuXG4gICAgICAgICAgICAgIC0tIFVwZGF0ZSBgY291bnQnXG4gICAgICAgICAgICBzZXRfY291bnQgKGxfY291bnQgLSBsX29mZnNldClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAtLSBTdHJpbmcgd2FzIG1vZGlmaWVkIHdlIG5lZWQgdG8gcmVjb21wdXRlIHRoZSBgaGFzaF9jb2RlJy5cbiAgICAgICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBhdHRhY2hlZCBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfbGlzdF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIDEsIGxfY291bnQpIGFzIGxfbGlzdCB0aGVuXG4gICAgICAgICAgICAtLSBHZXQgdGhlIG51bWJlciBvZiBzdWJzdGl0dXRpb24gdG8gYmUgcGVyZm9ybWVkIGJ5IGdldHRpbmcgYSBsaXN0XG4gICAgICAgICAgICAtLSBvZiBsb2NhdGlvbiB3aGVyZSBgb3JpZ2luYWwnIGFwcGVhcnMuXG4gICAgICAgICAgbF9pbmRleF9saXN0IDo9IGxfbGlzdC5hcmVhXG4gICAgICAgICAgbF9pbmRleF9jb3VudCA6PSBsX2luZGV4X2xpc3QuY291bnRcbiAgICAgICAgICAgIC0tIFN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgdXAgdG8gd2hpY2ggd2UgbmVlZCB0byBtb3ZlXG4gICAgICAgICAgICAtLSBjaGFyYWN0ZXJzIGluIHRoZSByZWFsbG9jYXRlZCBzdHJpbmcuXG4gICAgICAgICAgbF9wcmV2X2luZGV4IDo9IGxfY291bnRcbiAgICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAgbF9jb3B5X2RlbHRhIDo9IGxfbmV3X2NvdW50IC0gbF9vcmlnX2NvdW50XG4gICAgICAgICAgbF9jb3VudCA6PSBsX2NvdW50ICsgKGxfaW5kZXhfY291bnQgKiBsX2NvcHlfZGVsdGEpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyVVJywgbF9jb3VudCArIDEpXG4gICAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgICAgICAgIC0tIFBlcmZvcm0gdGhlIHN1YnN0aXR1dGlvbiBzdGFydGluZyBmcm9tIHRoZSBlbmQuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgaSA6PSBsX2luZGV4X2NvdW50XG4gICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGxfc3JjX2luZGV4IDo9IGxfaW5kZXhfbGlzdC5pdGVtIChpKVxuICAgICAgICAgICAgbF9kZXN0X2luZGV4IDo9IGxfc3JjX2luZGV4ICsgaSAqIGxfY29weV9kZWx0YVxuICAgICAgICAgICAgICAtLSBTaGlmdCBub24tbWF0Y2hpbmcgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb2YgdGhlIG5ld2x5IHJlcGxhY2VkIHN0cmluZy5cbiAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX3NyY19pbmRleCArIGxfb3JpZ19jb3VudCAtIDEsIGxfZGVzdF9pbmRleCArIGxfbmV3X2NvdW50IC0gMSwgbF9wcmV2X2luZGV4IC0gbF9zcmNfaW5kZXggLSBsX29yaWdfY291bnQgKyAxKVxuICAgICAgICAgICAgICAtLSBTdG9yZSBuZXcgZW5kIG9mIHN0cmluZyB3aGVyZSBjaGFyYWN0ZXJzIHdpbGwgYmUgbW92ZWQuXG4gICAgICAgICAgICBsX3ByZXZfaW5kZXggOj0gbF9zcmNfaW5kZXggLSAxXG5cbiAgICAgICAgICAgICAgLS0gQ29weSBgbmV3JyB0byBpdHMgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2Rlc3RfaW5kZXggLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIFVwZGF0ZSB0aGUgbmV3IGBjb3VudCcgd2hpY2ggYWxzbyByZXNldHMgdGhlIGBoYXNoX2NvZGUnLlxuICAgICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBsX2NvdW50IC89IDAgdGhlblxuICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYywgMCwgbF9jb3VudCAtIDEpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgcmVwbGFjZV9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBmaWxsX3dpdGgnIGluc3RlYWQnXCJcbiAgICBkb1xuICAgICAgZmlsbF93aXRoIChjKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgZmlyc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBkb1xuICAgICAgaWYgbiA8IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBsb2NhbFxuICAgICAgbmI6IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsZWZ0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgbmIsIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBuYl9zcGFjZSA+IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKG5iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50IHZhbHVlLlxuICAgICAgICBuYiA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYl9zcGFjZSwgMCwgbmIpXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgaSA6PSBuYlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA8IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbm90IGxfcHJvcC5pc19zcGFjZSAoYykgdGhlblxuICAgICAgICAgICAgLS0gV2UgYXJlIGRvbmUuXG4gICAgICAgICAgaSA6PSAtMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzaGFyZSAob3RoZXI6IFNUUklOR18zMilcbiAgICAgIC0tIE1ha2UgY3VycmVudCBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJy5cbiAgICAgIC0tIFN1YnNlcXVlbnQgY2hhbmdlcyB0byB0aGUgY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZ1xuICAgICAgLS0gd2lsbCBhbHNvIGFmZmVjdCBgb3RoZXInLCBhbmQgY29udmVyc2VseS5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgIGNvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkX2NvdW50OiBvdGhlci5jb3VudCA9IGNvdW50XG4gICAgICBzaGFyZWRfYXJlYTogb3RoZXIuYXJlYSA9IGFyZWFcbiAgICBlbmRcblxuICBwdXQgKGM6IENIQVJBQ1RFUl8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfMzIsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBwcmVwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcmVjZWRlLCBwcmVwZW5kX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gQWRkIGBjJyBhdCBmcm9udC5cbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIDEsIGNvdW50KVxuICAgICAgbF9hcmVhLnB1dCAoYywgMClcbiAgICAgIGNvdW50IDo9IGNvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgZW5kXG5cbiAgcHJlcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBvZiBjdXJyZW50LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgbF9zX2NvdW50LCBjb3VudClcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBiZWdpbm5pbmcuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCAwLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoaS5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBwcmVwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBhcHBlbmQgKGxfczMyKVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSkpXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChjb3VudCArIHMuY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGFwcGVuZGVkOiBzIC89IFZvaWQgaW1wbGllc1xuICAgICAgICAoZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHR3aW4gKyBvbGQgcy50d2luKSlcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfOCAoaTogSU5URUdFUl84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfOH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzY0IChpOiBJTlRFR0VSXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8zMiAoaTogTkFUVVJBTF8zMilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMzJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF82NCAoaTogTkFUVVJBTF82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWEucHV0IChjLCBjdXJyZW50X2NvdW50KVxuICAgICAgY291bnQgOj0gY3VycmVudF9jb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBpbnNlcnQgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEFkZCBgcycgdG8gbGVmdCBvZiBwb3NpdGlvbiBgaScgaW4gY3VycmVudCBzdHJpbmcuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGluc2VydF9zdHJpbmcnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50ICsgMVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID4gMFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCBpKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkgKyBvbGQgKHMudHdpbikgKyBvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIGluc2VydF9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICBuZXdfc2l6ZSA6PSAxICsgY291bnRcbiAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgIHBvcyA6PSBpIC0gMVxuICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIDEsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgIC0tIEluc2VydCBuZXcgY2hhcmFjdGVyXG4gICAgICBsX2FyZWEucHV0IChjLCBwb3MpXG5cbiAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgb25lX21vcmVfY2hhcmFjdGVyOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IGNcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChpLCBpIC0gMSwgbF9jb3VudCAtIGkpXG4gICAgICAgIC0tIFVwZGF0ZSBjb250ZW50LlxuICAgICAgY291bnQgOj0gbF9jb3VudCAtIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAobi5taW4gKGNvdW50KSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4J1xuICAgICAgLS0gdG8gYGVuZF9pbmRleCcgaW5jbHVzaXZlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBuYl9yZW1vdmVkOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iX3JlbW92ZWQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBuYl9yZW1vdmVkID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9pbmRleCArIG5iX3JlbW92ZWQgLSAxLCBzdGFydF9pbmRleCAtIDEsIGxfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICAgIGNvdW50IDo9IGxfY291bnQgLSBuYl9yZW1vdmVkXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgKyBvbGQgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgbGFzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIG4gPiBsX2NvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX2hlYWQgKGxfY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBjb3VudCAtIG4ubWluIChjb3VudCkpKVxuICAgIGVuZFxuXG4gIHBydW5lIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycsIGlmIGFueS5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgY291bnRlcjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGNvdW50ZXIgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgY291bnRlciA+IGNvdW50IG9yIGVsc2UgKGl0ZW0gKGNvdW50ZXIpID0gYylcbiAgICAgIGxvb3BcbiAgICAgICAgY291bnRlciA6PSBjb3VudGVyICsgMVxuICAgICAgZW5kXG4gICAgICBpZiBjb3VudGVyIDw9IGNvdW50IHRoZW5cbiAgICAgICAgcmVtb3ZlIChjb3VudGVyKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICAgIC0tIFRyYXZlcnNlIHN0cmluZyBhbmQgc2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdFxuICAgICAgICAtLSBlYWNoIHRpbWUgd2UgZmluZCBhbiBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBsX2NoYXIgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIGxfY2hhciAvPSBjIHRoZW5cbiAgICAgICAgICBsX2FyZWEucHV0IChsX2NoYXIsIGopXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBqXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjaGFuZ2VkX2NvdW50OiBjb3VudCA9IChvbGQgY291bnQpIC0gKG9sZCBvY2N1cnJlbmNlcyAoYykpXG4gICAgICAtLSByZW1vdmVkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSAvPSBgYydcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfbGVhZGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBsZWFkaW5nIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHkgb3IgZWxzZSBpdGVtICgxKSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbF90cmFpbGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBjaGFyYWN0ZXIuXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKCclLzAwMC8nLCBuZXdzaXplICsgMSlcbiAgICBlbmRcblxuICBncm93IChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgdGhlIGNhcGFjaXR5IGlzIGF0IGxlYXN0IGBuZXdzaXplJy5cbiAgICBkb1xuICAgICAgaWYgbmV3c2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdzaXplKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuIDo9IGNvdW50XG4gICAgICBpZiBuIDwgY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9zdHJpbmc6IHNhbWVfc3RyaW5nIChvbGQgdHdpbilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX3VwcGVyXG4gICAgZW5kXG5cbiAgbGVmdF9qdXN0aWZ5XG4gICAgICAtLSBMZWZ0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpdGR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGUgc3BhY2VzLlxuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGxlZnRfYWRqdXN0XG5cbiAgICAgICAgLS0gR2V0IG5ldyBjb3VudFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgaWYgaSA8IG5iIHRoZW5cbiAgICAgICAgICAtLSBgbGVmdF9hZGp1c3QnIGRpZCByZW1vdmUgc29tZSBjaGFyYWN0ZXJzLCBzbyB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAgIC0tIHNvbWUgd2hpdGUgc3BhY2VzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNlbnRlcl9qdXN0aWZ5XG4gICAgICAtLSBDZW50ZXIganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iLCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbGVmdF9uYl9zcGFjZSwgcmlnaHRfbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA9IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGxlZnRfbmJfc3BhY2UpKVxuICAgICAgbG9vcFxuICAgICAgICBsZWZ0X25iX3NwYWNlIDo9IGxlZnRfbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IC0xIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGkpKVxuICAgICAgbG9vcFxuICAgICAgICByaWdodF9uYl9zcGFjZSA6PSByaWdodF9uYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gV2UgZW5jb3VyYWdlIHRoYXQgbW9yZSBzcGFjZXMgd2lsbCBiZSBwdXQgdG8gdGhlIGxlZnQsIHdoZW5cbiAgICAgICAgLS0gbnVtYmVyIG9mIHNwYWNlcyBpcyBub3QgZXZlbi5cbiAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgKyByaWdodF9uYl9zcGFjZVxuICAgICAgaWYgbF9vZmZzZXQgXFxcXCAyID0gMCB0aGVuXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyXG4gICAgICBlbHNlXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyIC0gMVxuICAgICAgZW5kXG4gICAgICBpZiBsX29mZnNldCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodCBvciBsZWZ0IChkZXBlbmRpbmcgb24gc2lnbiBvZlxuICAgICAgICAgIC0tIGBsX29mZnNldCcgYnkgYGxfb2Zmc2V0JyBwb3NpdGlvbi5cbiAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0LFxuICAgICAgICAgIG5iIC0gbGVmdF9uYl9zcGFjZSAtIHJpZ2h0X25iX3NwYWNlKVxuXG4gICAgICAgIGlmIGxfb2Zmc2V0IDwgMCB0aGVuXG4gICAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEZpbGwgcmlnaHQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIG5iIC0gcmlnaHRfbmJfc3BhY2UgLSBsX29mZnNldCwgbmIgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2p1c3RpZnlcbiAgICAgIC0tIFJpZ2h0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICByaWdodF9hZGp1c3RcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIG5iX3NwYWNlIDo9IG5iIC0gaVxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAoaSksIGkgKyBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGkgKyAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBuYl9zcGFjZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBuYl9zcGFjZSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX2p1c3RpZnkgKHBpdm90OiBDSEFSQUNURVJfMzI7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgdGVtcDogQVJSQVlFRF9MSVNUIFtDSEFSQUNURVJfMzJdXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSB0ZW1wLm1ha2UgKGNhcGFjaXR5KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjb3VudFxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYzogQU5ZXG4gICAgICAtLSBBIHJlZmVyZW5jZSB0byBhIEMgZm9ybSBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIC0tIFVzZWZ1bCBvbmx5IGZvciBpbnRlcmZhY2luZyB3aXRoIEMgc29mdHdhcmUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2lzX2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEucHV0ICgnJVUnLCBjb3VudClcbiAgICAgIFJlc3VsdCA6PSBsX2FyZWFcbiAgICBlbmRcblxuICBtaXJyb3JlZDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBNaXJyb3IgaW1hZ2Ugb2Ygc3RyaW5nO1xuICAgICAgLS0gUmVzdWx0IGZvciBcIkhlbGxvIHdvcmxkXCIgaXMgXCJkbHJvdyBvbGxlSFwiLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0Lm1pcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yXG4gICAgICAtLSBSZXZlcnNlIHRoZSBvcmRlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgLS0gXCJIZWxsbyB3b3JsZFwiIC0+IFwiZGxyb3cgb2xsZUhcIi5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgICAtLSBOb3RoaW5nIHRvIGJlIGRvbmUgYmVjYXVzZSB3ZSBvbmx5IGFkZGVkIGBpbnRlcm5hbF9oYXNoX2NvZGUnIHRoYXQgd2lsbFxuICAgICAgICAtLSBiZSByZWNvbXB1dGVkIG5leHQgdGltZSB3ZSBxdWVyeSBgaGFzaF9jb2RlJy5cblxuICAgICAgICAtLSBJbiAuTkVULCB3ZSBoYXZlIGEgbWlzbWF0Y2ggdGhhdCBpcyB0cmlnZ2VyZWQgZHVlIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAgICAtLSBTUEVDSUFMIFtDSEFSQUNURVJfMzJdIGFzIGEgLk5FVCBhcnJheSBvZiBVSW50MTYuXG4gICAgICBpZiBhcmVhID0gVm9pZCBhbmQgdGhlbiBhdHRhY2hlZCB7bGlrZSBhcmVhfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcImFyZWFcIikgYXMgbF9hcmVhIHRoZW5cbiAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMjYgMTQ6NDk6NDAgLTA3MDAgKFdlZCwgMjYgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NzIxICRcIlxuXG5jbGFzc1xuICBTVFJJTkdfOFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR184XG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBlbmRcblxuICBTVFJJTkdfR0VORVJBTFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwsXG4gICAgICBpdGVtIGFzIGNoYXJhY3Rlcl8zMl9pdGVtLFxuICAgICAgaGFzIGFzIGNoYXJhY3Rlcl8zMl9oYXMsXG4gICAgICBpbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfaW5kZXhfb2YsXG4gICAgICBsYXN0X2luZGV4X29mIGFzIGNoYXJhY3Rlcl8zMl9sYXN0X2luZGV4X29mLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgY2hhcmFjdGVyXzMyX29jY3VycmVuY2VzXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbQ0hBUkFDVEVSXzgsIElOVEVHRVJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsLFxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFJFU0laQUJMRSBbQ0hBUkFDVEVSXzhdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl84XVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBpdGVtLCBhdCwgcHV0LCB2YWxpZF9pbmRleFxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9zdHJpbmcsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIGFzX3N0cmluZ18zMjoge1JFQURBQkxFX1NUUklOR18zMiwgU1RSSU5HXzMyfVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gYV9zeXN0ZW1fc3RyaW5nLmxlbmd0aCArIGRvdG5ldF9jb252ZXJ0b3IuZXNjYXBlX2NvdW50IChhX3N5c3RlbV9zdHJpbmcpXG4gICAgICBlbmRcbiAgICAgIG1ha2UgKGxfY291bnQpXG4gICAgICBpZiBsX2NvdW50ID4gMCBhbmQgdGhlbiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZG90bmV0X2NvbnZlcnRvci5yZWFkX3N5c3RlbV9zdHJpbmdfaW50byAoYV9zeXN0ZW1fc3RyaW5nLCBDdXJyZW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvbV9jIChjX3N0cmluZzogUE9JTlRFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyIChjX3N0cmluZylcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N0cmluZ19pbnRvIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgbm9femVyb19ieXRlOiBub3QgaGFzICgnJS8wLycpXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgICAtLSBjb3JyZWN0X2NvdW50OiB0aGUgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyBjb3VudFxuICAgICAgLS0gICAgICAgaXMgTlVMTFxuICAgIGVuZFxuXG4gIGZyb21fY19zdWJzdHJpbmcgKGNfc3RyaW5nOiBQT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBzdWJzdHJpbmcgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoY19zdHJpbmcgKyAoc3RhcnRfcG9zIC0gMSksIGxfY291bnQpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdWJzdHJpbmdfaW50byAoQ3VycmVudCwgMSwgbF9jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NvdW50OiBjb3VudCA9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgZW5kXG5cbiAgYWRhcHQgKHM6IFNUUklOR184KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPYmplY3Qgb2YgYSB0eXBlIGNvbmZvcm1pbmcgdG8gdGhlIHR5cGUgb2YgYHMnLFxuICAgICAgLS0gaW5pdGlhbGl6ZWQgd2l0aCBhdHRyaWJ1dGVzIGZyb20gYHMnXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgUmVzdWx0LnNoYXJlIChzKVxuICAgIGVuc3VyZVxuICAgICAgYWRhcHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzaGFyZWRfaW1wbGVtZW50YXRpb246IFJlc3VsdC5zaGFyZWRfd2l0aCAocylcbiAgICBlbmRcblxuICByZW1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9zdHJpbmc6IGNvdW50ID0gMFxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfOCBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfMzJfaXRlbSAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICBkb1xuICAgICAgICAtLSBXZSBzaG91bGQgYmUgdXNpbmcgYGFyZWEuaXRlbSAoaSAtIDEpLnRvX2NoYXJhY3Rlcl8zMidcbiAgICAgICAgLS0gYnV0IHNvbWUgZGVzY2VuZGFudHMgb2YgU1RSSU5HIHRoYXQgaGF2ZSB0aGVpciBjb250ZW50IGVuY29kZWRcbiAgICAgICAgLS0gaW4gVVRGLTggZm9yIGV4YW1wbGUgcmVsaWVzIG9uIGBjb2RlJyB0byBnZXQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLS0gQ0hBUkFDVEVSXzMyIGJ5IHJlYWRpbmcgbW9yZSB0aGFuIG9uZSBieXRlLiBPbmNlIHRoZXkgaGF2ZVxuICAgICAgICAtLSBiZWVuIHVwZGF0ZWQgdG8gdXNlIGBjaGFyYWN0ZXJfMzJfaXRlbScgd2UgY2FuIHJldmVydCB0aGUgY29kZVxuICAgICAgICAtLSBiYWNrIHRvIHVzaW5nIGBhcmVhJyBkaXJlY3RseS5cbiAgICAgIFJlc3VsdCA6PSBjb2RlIChpKS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1lcmljIGNvZGUgb2YgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICAgIC0tIFVzZSBgY29kZScgaW5zdGVhZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBVbmljb2RlIGhhbmRsaW5nLlxuICAgICAgLS18IE5vdCBvYnNvbGV0ZSBiZWNhdXNlIG9sZCBjb2RlIHVzaW5nIGp1c3QgQVNDSUkgaXMgc2FmZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLmNvZGVcbiAgICBlbmRcblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnMuXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkPyAoQW5zd2VyOiB5ZXMuKVxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBCT09MRUFOID0gRmFsc2VcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldCAodDogUkVBREFCTEVfU1RSSU5HXzg7IG4xLCBuMjogSU5URUdFUilcbiAgICAgIC0tIFNldCBjdXJyZW50IHN0cmluZyB0byBzdWJzdHJpbmcgb2YgYHQnIGZyb20gaW5kaWNlcyBgbjEnXG4gICAgICAtLSB0byBgbjInLCBvciB0byBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBzdWJzdHJpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHQgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfOFxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIHRvIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgICBlbm91Z2hfc3BhY2U6IChjb3VudCAtIGluZGV4X3BvcykgPj0gKGVuZF9wb3MgLSBzdGFydF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGxfb3RoZXJfYXJlYSwgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgZW5kX3BvcyA+PSBzdGFydF9wb3MgdGhlblxuICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpZiBsX2FyZWEgLz0gbF9vdGhlcl9hcmVhIHRoZW5cbiAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX290aGVyX2FyZWEsIHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY29waWVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaW5kZXhfcG9zIC0gMSkgK1xuICAgICAgICBvbGQgb3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpICtcbiAgICAgICAgb2xkIHN1YnN0cmluZyAoaW5kZXhfcG9zICsgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKSwgY291bnQpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnIHRvIGBlbmRfaW5kZXgnIHdpdGggYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBkaWZmOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgc19jb3VudDogSU5URUdFUlxuICAgICAgb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHNfY291bnQgOj0gcy5jb3VudFxuICAgICAgb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICBkaWZmIDo9IHNfY291bnQgLSAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgbmV3X3NpemUgOj0gZGlmZiArIG9sZF9jb3VudFxuICAgICAgaWYgZGlmZiA+IDAgdGhlblxuICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIHRoZSBzdHJpbmcuXG4gICAgICAgIGdyb3cgKG5ld19zaXplKVxuICAgICAgZW5kXG5cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIC0tfCBXZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBmb3J3YXJkIChpZiBkaWZmIGlzID4gMCksIGJhY2t3YXJkIChpZiBkaWZmIDwgMCksXG4gICAgICAgIC0tfCBhbmQgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICBpZiBkaWZmIC89IDAgdGhlblxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoZW5kX2luZGV4LCBlbmRfaW5kZXggKyBkaWZmLCBvbGRfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICBlbmRcbiAgICAgICAgLS18IFNldCBuZXcgY291bnRcbiAgICAgIHNldF9jb3VudCAobmV3X3NpemUpXG4gICAgICAgIC0tfCBXZSBjb3B5IHRoZSBzdWJzdHJpbmcuXG4gICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgc3RhcnRfaW5kZXggLSAxLCBzX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50IC0gZW5kX2luZGV4ICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICByZXBsYWNlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCAoc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICtcbiAgICAgICAgICBzICsgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZ19hbGwgKG9yaWdpbmFsLCBuZXc6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2ZpcnN0X3BvcywgbF9uZXh0X3BvczogSU5URUdFUlxuICAgICAgbF9vcmlnX2NvdW50LCBsX25ld19jb3VudCwgbF9uZXdfbG93ZXIsIGxfY291bnQsIGksIGxfaW5kZXhfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfc3JjX2luZGV4LCBsX2Rlc3RfaW5kZXgsIGxfcHJldl9pbmRleCwgbF9jb3B5X2RlbHRhOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfbmV3X2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxfc3RyaW5nX3NlYXJjaGVyOiBsaWtlIHN0cmluZ19zZWFyY2hlclxuICAgICAgbF9pbmRleF9saXN0OiBTUEVDSUFMIFtJTlRFR0VSXVxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfc3RyaW5nX3NlYXJjaGVyIDo9IHN0cmluZ19zZWFyY2hlclxuICAgICAgICBsX3N0cmluZ19zZWFyY2hlci5pbml0aWFsaXplX2RlbHRhcyAob3JpZ2luYWwpXG4gICAgICAgIGxfb3JpZ19jb3VudCA6PSBvcmlnaW5hbC5jb3VudFxuICAgICAgICBsX25ld19jb3VudCA6PSBuZXcuY291bnRcbiAgICAgICAgaWYgbF9vcmlnX2NvdW50ID49IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCAxLCBsX2NvdW50KVxuICAgICAgICAgIGlmIGxfZmlyc3RfcG9zID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBsX29yaWdfY291bnQgPSBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3RyaW5nIHdpbGwgbm90IGJlIHJlc2l6ZWQsIHNpbXBseSBwZXJmb3JtIGNoYXJhY3RlciBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgPSAwXG4gICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICBpZiBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IDw9IGxfY291bnQgdGhlblxuICAgICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSAwXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZWlmIGxfb3JpZ19jb3VudCA+IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAtLSBOZXcgc3RyaW5nIGlzIHNtYWxsZXIgdGhhbiBwcmV2aW91cyBzdHJpbmcsIHdlIGNhbiBvcHRpbWl6ZVxuICAgICAgICAgICAgICAgIC0tIHN1YnN0aXR1dGlvbiBieSBvbmx5IG1vdmluZyBibG9jayBiZXR3ZWVuIHR3byBvY2N1cnJlbmNlcyBvZiBgb3JnaW5hbCcuXG4gICAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgICBsX25leHRfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50LCBsX2NvdW50KVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA9IDBcbiAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgLS0gQ29weSBuZXcgc3RyaW5nIGludG8gQ3VycmVudFxuICAgICAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2ZpcnN0X3BvcyAtIDEgLSBsX29mZnNldCwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgYGxfbmV4dF9wb3MnXG4gICAgICAgICAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50IC0gMSxcbiAgICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgLSAxIC0gbF9vZmZzZXQsIGxfbmV4dF9wb3MgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX25leHRfcG9zXG4gICAgICAgICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQgKyAobF9vcmlnX2NvdW50IC0gbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgaWYgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCA8PSBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAgIGxfbmV4dF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQsIGxfY291bnQpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSAwXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gZmluYWwgc3Vic3RpdHV0aW9uOlxuICAgICAgICAgICAgICAgIC0tIENvcHkgbmV3IHN0cmluZyBpbnRvIEN1cnJlbnRcbiAgICAgICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9uZXdfYXJlYSwgbF9uZXdfbG93ZXIsIGxfZmlyc3RfcG9zIC0gMSAtIGxfb2Zmc2V0LCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCAtIDEgLSBsX29mZnNldCwgbF9jb3VudCArIDEgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gbGFzdCBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQgKyAobF9vcmlnX2NvdW50IC0gbF9uZXdfY291bnQpXG5cbiAgICAgICAgICAgICAgICAtLSBVcGRhdGUgYGNvdW50J1xuICAgICAgICAgICAgICBzZXRfY291bnQgKGxfY291bnQgLSBsX29mZnNldClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAtLSBTdHJpbmcgd2FzIG1vZGlmaWVkIHdlIG5lZWQgdG8gcmVjb21wdXRlIHRoZSBgaGFzaF9jb2RlJy5cbiAgICAgICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBhdHRhY2hlZCBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfbGlzdF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIDEsIGxfY291bnQpIGFzIGxfbGlzdCB0aGVuXG4gICAgICAgICAgICAtLSBHZXQgdGhlIG51bWJlciBvZiBzdWJzdGl0dXRpb24gdG8gYmUgcGVyZm9ybWVkIGJ5IGdldHRpbmcgYSBsaXN0XG4gICAgICAgICAgICAtLSBvZiBsb2NhdGlvbiB3aGVyZSBgb3JpZ2luYWwnIGFwcGVhcnMuXG4gICAgICAgICAgbF9pbmRleF9saXN0IDo9IGxfbGlzdC5hcmVhXG4gICAgICAgICAgbF9pbmRleF9jb3VudCA6PSBsX2luZGV4X2xpc3QuY291bnRcbiAgICAgICAgICAgIC0tIFN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgdXAgdG8gd2hpY2ggd2UgbmVlZCB0byBtb3ZlXG4gICAgICAgICAgICAtLSBjaGFyYWN0ZXJzIGluIHRoZSByZWFsbG9jYXRlZCBzdHJpbmcuXG4gICAgICAgICAgbF9wcmV2X2luZGV4IDo9IGxfY291bnRcbiAgICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAgbF9jb3B5X2RlbHRhIDo9IGxfbmV3X2NvdW50IC0gbF9vcmlnX2NvdW50XG4gICAgICAgICAgbF9jb3VudCA6PSBsX2NvdW50ICsgKGxfaW5kZXhfY291bnQgKiBsX2NvcHlfZGVsdGEpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyVVJywgbF9jb3VudCArIDEpXG4gICAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgICAgICAgIC0tIFBlcmZvcm0gdGhlIHN1YnN0aXR1dGlvbiBzdGFydGluZyBmcm9tIHRoZSBlbmQuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgaSA6PSBsX2luZGV4X2NvdW50XG4gICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGxfc3JjX2luZGV4IDo9IGxfaW5kZXhfbGlzdC5pdGVtIChpKVxuICAgICAgICAgICAgbF9kZXN0X2luZGV4IDo9IGxfc3JjX2luZGV4ICsgaSAqIGxfY29weV9kZWx0YVxuICAgICAgICAgICAgICAtLSBTaGlmdCBub24tbWF0Y2hpbmcgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb2YgdGhlIG5ld2x5IHJlcGxhY2VkIHN0cmluZy5cbiAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX3NyY19pbmRleCArIGxfb3JpZ19jb3VudCAtIDEsIGxfZGVzdF9pbmRleCArIGxfbmV3X2NvdW50IC0gMSwgbF9wcmV2X2luZGV4IC0gbF9zcmNfaW5kZXggLSBsX29yaWdfY291bnQgKyAxKVxuICAgICAgICAgICAgICAtLSBTdG9yZSBuZXcgZW5kIG9mIHN0cmluZyB3aGVyZSBjaGFyYWN0ZXJzIHdpbGwgYmUgbW92ZWQuXG4gICAgICAgICAgICBsX3ByZXZfaW5kZXggOj0gbF9zcmNfaW5kZXggLSAxXG5cbiAgICAgICAgICAgICAgLS0gQ29weSBgbmV3JyB0byBpdHMgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2Rlc3RfaW5kZXggLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIFVwZGF0ZSB0aGUgbmV3IGBjb3VudCcgd2hpY2ggYWxzbyByZXNldHMgdGhlIGBoYXNoX2NvZGUnLlxuICAgICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGxfY291bnQgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NvdW50IC0gMSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICByZXBsYWNlX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkJ1wiXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoYylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgbG9jYWxcbiAgICAgIG5iOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGVmdF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIG5iLCBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbmJfc3BhY2UgPiBuYiBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAobmJfc3BhY2UpLmlzX3NwYWNlXG4gICAgICBsb29wXG4gICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudCB2YWx1ZS5cbiAgICAgICAgbmIgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmJfc3BhY2UsIDAsIG5iKVxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGkgOj0gbmJcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwIG9yIGVsc2Ugbm90IGxfYXJlYS5pdGVtIChpKS5pc19zcGFjZVxuICAgICAgbG9vcFxuICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNoYXJlIChvdGhlcjogU1RSSU5HXzgpXG4gICAgICAtLSBNYWtlIGN1cnJlbnQgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcicuXG4gICAgICAtLSBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmdcbiAgICAgIC0tIHdpbGwgYWxzbyBhZmZlY3QgYG90aGVyJywgYW5kIGNvbnZlcnNlbHkuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICBjb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZF9jb3VudDogb3RoZXIuY291bnQgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IG90aGVyLmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbiAgcHV0IChjOiBDSEFSQUNURVJfODsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfOCwgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHByZWNlZGUsIHByZXBlbmRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIEFkZCBgYycgYXQgZnJvbnQuXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCAxLCBjb3VudClcbiAgICAgIGxfYXJlYS5wdXQgKGMsIDApXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR184fSBzIGFzIGxfczggdGhlblxuICAgICAgICBwcmVwZW5kIChsX3M4KVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCBsX3NfY291bnQsIGNvdW50KVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGJlZ2lubmluZy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIDAsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmQgKGIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChkLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChpLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChyLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgcHJlcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzh9IHMgYXMgbF9zOCB0aGVuXG4gICAgICAgIGFwcGVuZCAobF9zOClcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpKSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIFJlc3VsdC5hcHBlbmQgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzgpXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhcHBlbmRlZDogcyAvPSBWb2lkIGltcGxpZXNcbiAgICAgICAgKGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCB0d2luICsgb2xkIHMudHdpbikpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl8xNn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzggKGk6IE5BVFVSQUxfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMzIgKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzMyXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzY0IChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gQXBwZW5kIGBjJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgY3VycmVudF9jb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjdXJyZW50X2NvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgYXJlYS5wdXQgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgICBjb3VudCA6PSBjdXJyZW50X2NvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXRlbV9pbnNlcnRlZDogaXRlbSAoY291bnQpID0gY1xuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHN0YWJsZV9iZWZvcmU6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGNvdW50IC0gMSkgfiAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgYXBwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmQgKGIub3V0KVxuICAgIGVuZFxuXG4gIGluc2VydCAoczogUkVBREFCTEVfU1RSSU5HXzg7IGk6IElOVEVHRVIpXG4gICAgICAtLSBBZGQgYHMnIHRvIGxlZnQgb2YgcG9zaXRpb24gYGknIGluIGN1cnJlbnQgc3RyaW5nLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBpbnNlcnRfc3RyaW5nJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudCArIDFcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfODsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgYycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgIG5ld19zaXplIDo9IDEgKyBjb3VudFxuICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgcG9zIDo9IGkgLSAxXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgMSwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgLS0gSW5zZXJ0IG5ldyBjaGFyYWN0ZXJcbiAgICAgIGxfYXJlYS5wdXQgKGMsIHBvcylcblxuICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBvbmVfbW9yZV9jaGFyYWN0ZXI6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gY1xuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmUgKGk6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYGknLXRoIGNoYXJhY3Rlci5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKGksIGkgLSAxLCBsX2NvdW50IC0gaSlcbiAgICAgICAgLS0gVXBkYXRlIGNvbnRlbnQuXG4gICAgICBjb3VudCA6PSBsX2NvdW50IC0gMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nIChuLm1pbiAoY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnXG4gICAgICAtLSB0byBgZW5kX2luZGV4JyBpbmNsdXNpdmUuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIG5iX3JlbW92ZWQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmJfcmVtb3ZlZCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIG5iX3JlbW92ZWQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X2luZGV4ICsgbmJfcmVtb3ZlZCAtIDEsIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgICAgY291bnQgOj0gbF9jb3VudCAtIG5iX3JlbW92ZWRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArIG9sZCBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBsYXN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbiA+IGxfY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAobF9jb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGNvdW50IC0gbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcHJ1bmUgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnLCBpZiBhbnkuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBjb3VudGVyIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGNvdW50ZXIgPiBjb3VudCBvciBlbHNlIChpdGVtIChjb3VudGVyKSA9IGMpXG4gICAgICBsb29wXG4gICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgY291bnRlciA8PSBjb3VudCB0aGVuXG4gICAgICAgIHJlbW92ZSAoY291bnRlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgZG9cbiAgICAgICAgLS0gVHJhdmVyc2Ugc3RyaW5nIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0XG4gICAgICAgIC0tIGVhY2ggdGltZSB3ZSBmaW5kIGFuIG9jY3VycmVuY2Ugb2YgYGMnLlxuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY2hhciA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbF9jaGFyIC89IGMgdGhlblxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfY2hhciwgailcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGNvdW50IDo9IGpcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNoYW5nZWRfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCkgLSAob2xkIG9jY3VycmVuY2VzIChjKSlcbiAgICAgIC0tIHJlbW92ZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpIC89IGBjJ1xuICAgIGVuZFxuXG4gIHBydW5lX2FsbF9sZWFkaW5nIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlbW92ZSBhbGwgbGVhZGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoMSkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfdHJhaWxpbmcgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgnJS8wMDAvJywgbmV3c2l6ZSArIDEpXG4gICAgZW5kXG5cbiAgZ3JvdyAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIEVuc3VyZSB0aGF0IHRoZSBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgbmV3c2l6ZScuXG4gICAgZG9cbiAgICAgIGlmIG5ld3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3c2l6ZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfc3RyaW5nOiBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b191cHBlclxuICAgIGVuZFxuXG4gIGxlZnRfanVzdGlmeVxuICAgICAgLS0gTGVmdCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aXRkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlIHNwYWNlcy5cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBsZWZ0X2FkanVzdFxuXG4gICAgICAgIC0tIEdldCBuZXcgY291bnRcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgLS0gYGxlZnRfYWRqdXN0JyBkaWQgcmVtb3ZlIHNvbWUgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAtLSBzb21lIHdoaXRlIHNwYWNlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjZW50ZXJfanVzdGlmeVxuICAgICAgLS0gQ2VudGVyIGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYiwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxlZnRfbmJfc3BhY2UsIHJpZ2h0X25iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgPSBuYiBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAobGVmdF9uYl9zcGFjZSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA6PSBsZWZ0X25iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAtMSBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgcmlnaHRfbmJfc3BhY2UgOj0gcmlnaHRfbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFdlIGVuY291cmFnZSB0aGF0IG1vcmUgc3BhY2VzIHdpbGwgYmUgcHV0IHRvIHRoZSBsZWZ0LCB3aGVuXG4gICAgICAgIC0tIG51bWJlciBvZiBzcGFjZXMgaXMgbm90IGV2ZW4uXG4gICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlICsgcmlnaHRfbmJfc3BhY2VcbiAgICAgIGlmIGxfb2Zmc2V0IFxcXFwgMiA9IDAgdGhlblxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMlxuICAgICAgZWxzZVxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMiAtIDFcbiAgICAgIGVuZFxuICAgICAgaWYgbF9vZmZzZXQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgbGVmdCAoZGVwZW5kaW5nIG9uIHNpZ24gb2ZcbiAgICAgICAgICAtLSBgbF9vZmZzZXQnIGJ5IGBsX29mZnNldCcgcG9zaXRpb24uXG4gICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCxcbiAgICAgICAgICBuYiAtIGxlZnRfbmJfc3BhY2UgLSByaWdodF9uYl9zcGFjZSlcblxuICAgICAgICBpZiBsX29mZnNldCA8IDAgdGhlblxuICAgICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaWxsIHJpZ2h0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBuYiAtIHJpZ2h0X25iX3NwYWNlIC0gbF9vZmZzZXQsIG5iIC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9qdXN0aWZ5XG4gICAgICAtLSBSaWdodCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBuYl9zcGFjZSA6PSBuYiAtIGlcbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGkpLCBpICsgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpICsgMVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbmJfc3BhY2UgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgbmJfc3BhY2UgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9qdXN0aWZ5IChwaXZvdDogQ0hBUkFDVEVSXzg7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0NIQVJBQ1RFUl84XVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2M6IEFOWVxuICAgICAgLS0gQSByZWZlcmVuY2UgdG8gYSBDIGZvcm0gb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICAtLSBVc2VmdWwgb25seSBmb3IgaW50ZXJmYWNpbmcgd2l0aCBDIHNvZnR3YXJlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLnB1dCAoJyVVJywgY291bnQpXG4gICAgICBSZXN1bHQgOj0gbF9hcmVhXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5taXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvclxuICAgICAgLS0gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgIC0tIFwiSGVsbG8gd29ybGRcIiAtPiBcImRscm93IG9sbGVIXCIuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzhcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgLS0gTm90aGluZyB0byBiZSBkb25lIGJlY2F1c2Ugd2Ugb25seSBhZGRlZCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB0aGF0IHdpbGxcbiAgICAgIC0tIGJlIHJlY29tcHV0ZWQgbmV4dCB0aW1lIHdlIHF1ZXJ5IGBoYXNoX2NvZGUnLlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVtcHR5X2FyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl84XVxuICAgICAgLS0gRW1wdHkgYGFyZWEnIHRvIGF2b2lkIHVzZWxlc3MgY3JlYXRpb24gb2YgZW1wdHkgYXJlYXMgd2hlbiB3aXBpbmcgb3V0IGEgU1RSSU5HLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlNpbXBseSBjcmVhdGUgYGFyZWEnIGRpcmVjdGx5LlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAoMSlcbiAgICAgIFJlc3VsdC5leHRlbmQgKCclVScpXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9hcmVhX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb21tb24gYW5jZXN0b3JzIHRvIGFsbCBTVFJJTkcgY2xhc3Nlcy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMTkgMDc6MzY6MTAgLTA3MDAgKFdlZCwgMTkgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NjMzICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBTVFJJTkdfR0VORVJBTFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICBlbmRcblxuY29udmVydFxuICBhc19zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzIsIFNUUklOR18zMn0sXG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9XG5cbmZlYXR1cmUgLS0gU2V0dGluZ3NcblxuICBwdXRfY29kZSAodjogbGlrZSBjb2RlOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGNvZGUgYHYnIGF0IHBvc2l0aW9uIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb2RlOiB2YWxpZF9jb2RlICh2KVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogY29kZSAoaSkgPSB2XG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gU2V0dGluZ3NcblxuICBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IDAgPD0gbnVtYmVyIGFuZCBudW1iZXIgPD0gY2FwYWNpdHlcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG51bWJlclxuICAgIGVuZFxuXG4gIHNldF9pbnRlcm5hbF9oYXNoX2NvZGUgKHY6IGxpa2UgaW50ZXJuYWxfaGFzaF9jb2RlKVxuICAgICAgLS0gU2V0IGBpbnRlcm5hbF9oYXNoX2NvZGUnIHdpdGggYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm9ubmVnYXRpdmU6IHYgPj0gMFxuICAgIGRvXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gdlxuICAgIGVuc3VyZVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlX3NldDogaW50ZXJuYWxfaGFzaF9jb2RlID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgYXBwZW5kX2NvZGUgKGM6IGxpa2UgY29kZSlcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NvZGU6IHZhbGlkX2NvZGUgKGMpXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudClcbiAgICAgIGVuZFxuICAgICAgc2V0X2NvdW50IChjdXJyZW50X2NvdW50KVxuICAgICAgcHV0X2NvZGUgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGNvZGUgKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBsX3NfY291bnRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jb2RlIChzLmNvZGUgKGkpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50XG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHRvX3N0cmluZ18zMiArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUpXG4gICAgICAgIGVuZFxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jb2RlIChzLmNvZGUgKGkpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkICh0b19zdHJpbmdfMzIgKyBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkpKVxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSlcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgQ3VycmVudCcgYXQgdGhlIGVuZCBzdGFydGluZyBmcm9tIHRoZSBlbmQgc2luY2UgaXQgd2lsbCBwcm9iYWJseSBvdmVybGFwLlxuICAgICAgICBzZXRfY291bnQgKGxfbmV3X3NpemUpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxfY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKGNvZGUgKGkpLCBpICsgbF9zX2NvdW50KVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgcycgYXQgdGhlIGJlZ2lubmluZyBvZiBDdXJyZW50LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGxfc19jb3VudFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKHMuY29kZSAoaSksIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnRvX3N0cmluZ18zMiArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBDb3B5IGBDdXJyZW50JyBhdCB0aGUgZW5kIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBzaW5jZSBpdCB3aWxsIHByb2JhYmx5IG92ZXJsYXAuXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbF9jb3VudFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBwdXRfY29kZSAoY29kZSAoaSksIGkgKyBsX3NfY291bnQpXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBDb3B5IGBzJyBhdCB0aGUgYmVnaW5uaW5nIG9mIEN1cnJlbnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgICAgaiA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKHMuY29kZSAoaSksIGopXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpLnRvX3N0cmluZ18zMiArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAga2VwdDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKGNvdW50IC0gbi5taW4oY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIGxlZnRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtICgxKS5pc19zcGFjZVxuICAgICAga2VwdDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAoKG9sZCB0d2luKS5zdWJzdHJpbmcgKG9sZCBjb3VudCAtIGNvdW50ICsgMSwgb2xkIGNvdW50KSlcbiAgICAgIG9ubHlfc3BhY2VzX3JlbW92ZWRfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoMSwgKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpIC0gMSlcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtIChjb3VudCkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKChvbGQgdHdpbikuc3Vic3RyaW5nICgxLCBjb3VudCkpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2FmdGVyOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpICsgY291bnQsIG9sZCBjb3VudClcbiAgICBlbmRcblxuICBhZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGRvXG4gICAgICBsZWZ0X2FkanVzdFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnRfbGVmdDogbm90IGlzX2VtcHR5IGltcGxpZXMgbm90IGl0ZW0gKDEpLmlzX3NwYWNlXG4gICAgICBuZXdfY291bnRfcmlnaHQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtIChjb3VudCkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyAob2xkIHR3aW4pLmhhc19zdWJzdHJpbmcgKEN1cnJlbnQpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIChvbGQgdHdpbikuaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIChvbGQgdHdpbikuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCAxKSAtIDEpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2FmdGVyOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpICsgY291bnQsIG9sZCBjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50IC0gMVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIHRvX3N0cmluZ18zMiB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkudG9fc3RyaW5nXzMyICsgb2xkIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KS50b19zdHJpbmdfMzIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIG5ld19zaXplX2xhcmdlX2Vub3VnaDogbmV3c2l6ZSA+PSBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY2FwYWNpdHlfbGFyZ2VfZW5vdWdoOiBjYXBhY2l0eSA+PSBuZXdzaXplXG4gICAgICBzYW1lX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBtdXRhYmxlOiBub3QgaXNfaW1tdXRhYmxlXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJPYmplY3RzIHRoYXQgY2FuIGFjY2VzcyBgc2V0X2NvdW50JyBmcm9tIFNUUklOR1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIFNUUklOR19IQU5ETEVSXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgSGFzaCB0YWJsZXMsIHVzZWQgdG8gc3RvcmUgaXRlbXMgaWRlbnRpZmllZCBieSBzdHJpbmcga2V5cyB0aGF0IGFyZSBjb21wYXJlZCB3aXRoIG9yIHdpdGhvdXQgY2FzZSBzZW5zaXRpdml0eS5cbiAgICBdXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHdhcm5pbmc6IFwiW1xuICAgIE1vZGlmeWluZyBhbiBvYmplY3QgdXNlZCBhcyBhIGtleSBieSBhbiBpdGVtIHByZXNlbnQgaW4gYSB0YWJsZSB3aWxsXG4gICAgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiBJZiB5b3Ugd2lsbCBiZSBtb2RpZnlpbmcga2V5IG9iamVjdHMsXG4gICAgcGFzcyBhIGNsb25lLCBub3QgdGhlIG9iamVjdCBpdHNlbGYsIG9yIGFuIGltbXV0YWJsZSBvYmplY3QsIGFzIGtleSBhcmd1bWVudCB0b1xuICAgIGBwdXQnIGFuZCBgcmVwbGFjZV9rZXknLlxuICAgIF1cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA1LTIwIDE2OjE1OjE3IC0wNzAwIChNb24sIDIwIE1heSAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjU1NyAkXCJcblxuY2xhc3NcbiAgU1RSSU5HX1RBQkxFIFtHXVxuXG5pbmhlcml0XG4gIEhBU0hfVEFCTEUgW0csIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXVxuICAgIHJlZGVmaW5lXG4gICAgICBzYW1lX2tleXMsIGhhc2hfY29kZV9vZiwgZW1wdHlfZHVwbGljYXRlLCBpc19lcXVhbFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSwgbWFrZV9lcXVhbCwgbWFrZV9jYXNlbGVzcywgbWFrZV9lcXVhbF9jYXNlbGVzc1xuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfY2FzZWxlc3MgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBoYXNoIHRhYmxlIGZvciBhdCBsZWFzdCBgbicgaXRlbXMuXG4gICAgICAtLSBUaGUgdGFibGUgd2lsbCBiZSByZXNpemVkIGF1dG9tYXRpY2FsbHlcbiAgICAgIC0tIGlmIG1vcmUgdGhhbiBgbicgaXRlbXMgYXJlIGluc2VydGVkLlxuICAgICAgLS0gS2V5cyB3aWxsIGJlIGNvbXBhcmVkIGNhc2VsZXNzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZSA6PSBUcnVlXG4gICAgICBtYWtlIChuKVxuICAgIGVuc3VyZVxuICAgICAgYnJlYXRoaW5nX3NwYWNlOiBuIDwgY2FwYWNpdHlcbiAgICAgIG1vcmVfdGhhbl9taW5pbXVtOiBjYXBhY2l0eSA+IE1pbmltdW1fY2FwYWNpdHlcbiAgICAgIG5vX3N0YXR1czogbm90IHNwZWNpYWxfc3RhdHVzXG4gICAgICBpc19jYXNlX2luc2Vuc2l0aXZlOiBpc19jYXNlX2luc2Vuc2l0aXZlXG4gICAgZW5kXG5cbiAgbWFrZV9lcXVhbF9jYXNlbGVzcyAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGhhc2ggdGFibGUgZm9yIGF0IGxlYXN0IGBuJyBpdGVtcy5cbiAgICAgIC0tIFRoZSB0YWJsZSB3aWxsIGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseVxuICAgICAgLS0gaWYgbW9yZSB0aGFuIGBuJyBpdGVtcyBhcmUgaW5zZXJ0ZWQuXG4gICAgICAtLSBLZXlzIHdpbGwgYmUgY29tcGFyZWQgY2FzZWxlc3MuXG4gICAgICAtLSBJdGVtcyB3aWxsIGJlIGNvbXBhcmVkIHVzaW5nIGB+Jy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmUgOj0gVHJ1ZVxuICAgICAgbWFrZV9lcXVhbCAobilcbiAgICBlbnN1cmVcbiAgICAgIGJyZWF0aGluZ19zcGFjZTogbiA8IGNhcGFjaXR5XG4gICAgICBtb3JlX3RoYW5fbWluaW11bTogY2FwYWNpdHkgPiBNaW5pbXVtX2NhcGFjaXR5XG4gICAgICBub19zdGF0dXM6IG5vdCBzcGVjaWFsX3N0YXR1c1xuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZTogaXNfY2FzZV9pbnNlbnNpdGl2ZVxuICAgICAgY29tcGFyZV9vYmplY3RzOiBvYmplY3RfY29tcGFyaXNvblxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEhhc2ggY29kZVxuXG4gIGhhc2hfY29kZV9vZiAoYV9rZXk6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIGlmIGlzX2Nhc2VfaW5zZW5zaXRpdmUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYV9rZXkuY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGVcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGFfa2V5Lmhhc2hfY29kZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2Nhc2VfaW5zZW5zaXRpdmU6IEJPT0xFQU5cbiAgICAgIC0tIElnbm9yaW5nIGNhc2Ugd2hlbiBjb21wYXJpbmcga2V5cz9cbiAgICAgIC0tIChEZWZhdWx0OiBGYWxzZSlcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgc2FtZV9rZXlzIChhX3NlYXJjaF9rZXksIGFfa2V5OiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBhX3NlYXJjaF9rZXknIHRoZSBzYW1lIGtleSBhcyBgYV9rZXknID9cbiAgICBkb1xuICAgICAgaWYgaXNfY2FzZV9pbnNlbnNpdGl2ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBhX3NlYXJjaF9rZXkuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAoYV9rZXkpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBhX3NlYXJjaF9rZXkuc2FtZV9zdHJpbmcgKGFfa2V5KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHRhYmxlIGNvbnRhaW4gdGhlIHNhbWUgaW5mb3JtYXRpb24gYXMgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgaXNfY2FzZV9pbnNlbnNpdGl2ZSA9IG90aGVyLmlzX2Nhc2VfaW5zZW5zaXRpdmUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gUHJlY3Vyc29yIChvdGhlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBEdXBsaWNhdGlvblxuXG4gIGVtcHR5X2R1cGxpY2F0ZSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ3JlYXRlIGFuIGVtcHR5IGNvcHkgb2YgQ3VycmVudCB0aGF0IGNhbiBhY2NvbW1vZGF0ZSBgbicgaXRlbXNcbiAgICBkb1xuICAgICAgaWYgaXNfY2FzZV9pbnNlbnNpdGl2ZSB0aGVuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9jYXNlbGVzcyAobilcbiAgICAgIGVsc2VcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgICAgZW5kXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgIFJlc3VsdC5jb21wYXJlX29iamVjdHNcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBIZWxwZXJcblxuICBjaGFyYWN0ZXJfcHJvcGVydGllczogQ0hBUkFDVEVSX1BST1BFUlRZXG4gICAgICAtLSBIZWxwZXIgZm9yIGVmZmljaWVudCBjYXNlIGNvbnZlcnNpb25zLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogIFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiRmFrZSBhYnN0cmFjdGlvbiBvZiBhIC5ORVQgU1lTVEVNX1NUUklORyBpbiBhIG5vbi0uTkVUIHN5c3RlbVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIFNZU1RFTV9TVFJJTkdcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBsZW5ndGg6IElOVEVHRVIgZG8gZW5kXG5cbmludmFyaWFudFxuICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb250YWluZXJzIHdob3NlIGl0ZW1zIGFyZSBhY2Nlc3NpYmxlIHRocm91Z2gga2V5c1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHRhYmxlLCBhY2Nlc3M7XG4gIGFjY2Vzczoga2V5LCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzIFRBQkxFIFtHLCBIXSBpbmhlcml0XG5cbiAgQkFHIFtHXVxuICAgIHJlbmFtZVxuICAgICAgcHV0IGFzIGJhZ19wdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGs6IEgpOiBHIGFzc2lnbiBmb3JjZVxuICAgICAgLS0gRW50cnkgb2Yga2V5IGBrJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2tleSAoaylcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9rZXkgKGs6IEgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaycgYSB2YWxpZCBrZXk/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAodjogRzsgazogSClcbiAgICAgIC0tIEFzc29jaWF0ZSB2YWx1ZSBgdicgd2l0aCBrZXkgYGsnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfa2V5IChrKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgZm9yY2UgKHY6IEc7IGs6IEgpXG4gICAgICAtLSBBc3NvY2lhdGUgdmFsdWUgYHYnIHdpdGgga2V5IGBrJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2tleSAoaylcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGspID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBiYWdfcHV0ICh2OiBHKVxuICAgIGRvXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgU3RydWN0dXJlIHRoYXQgY2FuIGJlIGl0ZXJhdGVkIG92ZXIgdXNpbmcgYGFjcm9zcy4uLmxvb3AuLi5lbmQnLlxuICAgIHVzaW5nIGBrZXknIGFuZCBgaXRlbScuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wNS0yMCAxNjoxNToxNyAtMDcwMCAoTW9uLCAyMCBNYXkgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI1NTcgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFRBQkxFX0lURVJBQkxFIFtHLEtdXG5cbmluaGVyaXRcbiAgSVRFUkFCTEUgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbmV3X2N1cnNvcjogVEFCTEVfSVRFUkFUSU9OX0NVUlNPUiBbRyxLXVxuICAgICAgLS0gRnJlc2ggY3Vyc29yIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHN0cnVjdHVyZVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gc3BlY2lhbCBvYmplY3RzLCBmb3IgZGlyZWN0IGFjY2VzcyB0byBhcnJheXMgYW5kIHN0cmluZ3NcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBUT19TUEVDSUFMIFtUXVxuXG5jcmVhdGVcbiAgbWFrZV9lbXB0eV9hcmVhLFxuICBtYWtlX2ZpbGxlZF9hcmVhXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgYXJlYTogU1BFQ0lBTCBbVF1cbiAgICAgIC0tIFNwZWNpYWwgZGF0YSB6b25lXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9lbXB0eV9hcmVhIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlcyBhIHNwZWNpYWwgb2JqZWN0IGZvciBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2VtcHR5IChuKVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGFyZWEgLz0gVm9pZFxuICAgICAgY2FwYWNpdHlfc2V0OiBhcmVhLmNhcGFjaXR5ID0gblxuICAgICAgY291bnRfc2V0OiBhcmVhLmNvdW50ID0gMFxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkX2FyZWEgKGFfZGVmYXVsdF92YWx1ZTogVDsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZXMgYSBzcGVjaWFsIG9iamVjdCBmb3IgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKGFfZGVmYXVsdF92YWx1ZSwgbilcbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBhcmVhIC89IFZvaWRcbiAgICAgIGNhcGFjaXR5X3NldDogYXJlYS5jYXBhY2l0eSA9IG5cbiAgICAgIGNvdW50X3NldDogYXJlYS5jb3VudCA9IG5cbiAgICAgIGFyZWFfZmlsbGVkOiBhcmVhLmZpbGxlZF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIDAsIG4gLSAxKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IFQgYXNzaWduIHB1dFxuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgQ3VycmVudD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEudmFsaWRfaW5kZXggKGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQgKHY6IFQ7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIGFyZWEucHV0ICh2LCBpKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9hcmVhIChvdGhlcjogbGlrZSBhcmVhKVxuICAgICAgLS0gTWFrZSBgb3RoZXInIHRoZSBuZXcgYGFyZWEnXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gb3RoZXJcbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfc2V0OiBhcmVhID0gb3RoZXJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBTdHJ1Y3R1cmVzIGZvciB3aGljaCB0aGVyZSBleGlzdHMgYSB0cmF2ZXJzYWwgcG9saWN5XG4gICAgdGhhdCB3aWxsIHZpc2l0IGV2ZXJ5IGVsZW1lbnQgZXhhY3RseSBvbmNlLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiB0cmF2ZXJzYWJsZSwgdHJhdmVyc2luZztcbiAgYWNjZXNzOiBjdXJzb3I7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgVFJBVkVSU0FCTEUgW0ddXG5cbmluaGVyaXRcblxuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogR1xuICAgICAgLS0gSXRlbSBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZjogbm90IG9mZlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIG9mZjogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gY3VycmVudCBpdGVtP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgc3RhcnRcbiAgICAgIC0tIE1vdmUgdG8gZmlyc3QgcG9zaXRpb24gaWYgYW55LlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cblxuICBkb19hbGwgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fZXhpc3RzOiBhY3Rpb24gLz0gVm9pZFxuICAgIGRvXG4gICAgICBsaW5lYXJfcmVwcmVzZW50YXRpb24uZG9fYWxsIChhY3Rpb24pXG4gICAgZW5kXG5cbiAgZG9faWYgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV07XG4gICB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fZXhpc3RzOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9leGlzdHM6IHRlc3QgLz0gVm9pZFxuICAgICAgLS0gdGVzdC5pc19wdXJlXG4gICAgZG9cbiAgICAgIGxpbmVhcl9yZXByZXNlbnRhdGlvbi5kb19pZiAoYWN0aW9uLCB0ZXN0KVxuICAgIGVuZFxuXG4gIHRoZXJlX2V4aXN0cyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhdCBsZWFzdCBvbmUgaXRlbT9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X2V4aXN0czogdGVzdCAvPSBWb2lkXG4gICAgICAtLSB0ZXN0LmlzX3B1cmVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGxpbmVhcl9yZXByZXNlbnRhdGlvbi50aGVyZV9leGlzdHMgKHRlc3QpXG4gICAgZW5kXG5cbiAgZm9yX2FsbCAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhbGwgaXRlbXM/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9leGlzdHM6IHRlc3QgLz0gVm9pZFxuICAgICAgLS0gdGVzdC5pc19wdXJlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBsaW5lYXJfcmVwcmVzZW50YXRpb24uZm9yX2FsbCAodGVzdClcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgZW1wdHlfY29uc3RyYWludDogaXNfZW1wdHkgaW1wbGllcyBvZmZcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkltcGxlbWVudGF0aW9uIG9mIFRVUExFXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTAxIDA0OjMzOjQ3IC0wODAwIChXZWQsIDAxIEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5Mzg2NSAkXCJcblxuY2xhc3NcbiAgVFVQTEVcblxuaW5oZXJpdFxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHJlZGVmaW5lXG4gICAgICBjb3JyZWN0X21pc21hdGNoLCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbZGV0YWNoYWJsZSBzZXBhcmF0ZSBBTlldXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaW5kZXg6IElOVEVHRVIpOiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWSBhc3NpZ24gcHV0XG4gICAgICAtLSBFbnRyeSBvZiBrZXkgYGluZGV4Jy5cbiAgICBkb1xuICAgICAgaW5zcGVjdCBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIGJvb2xlYW5fY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIGNoYXJhY3Rlcl84X2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX2NoYXJhY3Rlcl84X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX2NoYXJhY3Rlcl8zMl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIHJlYWxfNjRfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfcmVhbF82NF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIHJlYWxfMzJfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfcmVhbF8zMl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIHBvaW50ZXJfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfcG9pbnRlcl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIG5hdHVyYWxfOF9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9uYXR1cmFsXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBuYXR1cmFsXzE2X2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX25hdHVyYWxfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX25hdHVyYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBuYXR1cmFsXzY0X2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX25hdHVyYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBpbnRlZ2VyXzhfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl84X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gaW50ZWdlcl8xNl9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9pbnRlZ2VyXzE2X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gaW50ZWdlcl8zMl9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9pbnRlZ2VyXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gaW50ZWdlcl82NF9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9pbnRlZ2VyXzY0X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gUmVmZXJlbmNlX2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX3JlZmVyZW5jZV9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWZlcmVuY2VfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWVxuICAgICAgLS0gUmVmZXJlbmNlIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfcmVmZXJlbmNlOiBpc19yZWZlcmVuY2VfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfcmVmZXJlbmNlX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICBib29sZWFuX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2Jvb2xlYW46IGlzX2Jvb2xlYW5faXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzhfaXRlbSwgY2hhcmFjdGVyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2NoYXJhY3Rlcl84OiBpc19jaGFyYWN0ZXJfOF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9jaGFyYWN0ZXJfOF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzMyX2l0ZW0sIHdpZGVfY2hhcmFjdGVyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19jaGFyYWN0ZXJfMzI6IGlzX2NoYXJhY3Rlcl8zMl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9jaGFyYWN0ZXJfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIHJlYWxfNjRfaXRlbSwgZG91YmxlX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogUkVBTF82NFxuICAgICAgLS0gRG91YmxlIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfbnVtZXJpYzogaXNfZG91YmxlX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX3JlYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfOF9pdGVtIChpbmRleDogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gTkFUVVJBTF84IGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfaW50ZWdlcjogaXNfbmF0dXJhbF84X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX25hdHVyYWxfOF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgbmF0dXJhbF8xNl9pdGVtIChpbmRleDogSU5URUdFUik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIE5BVFVSQUxfMTYgaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19pbnRlZ2VyOiBpc19uYXR1cmFsXzE2X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX25hdHVyYWxfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBOQVRVUkFMXzMyIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfaW50ZWdlcjogaXNfbmF0dXJhbF8zMl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9uYXR1cmFsXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICBuYXR1cmFsXzY0X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogTkFUVVJBTF82NFxuICAgICAgLS0gTkFUVVJBTF82NCBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2ludGVnZXI6IGlzX25hdHVyYWxfNjRfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfbmF0dXJhbF82NF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgaW50ZWdlcl84X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBJTlRFR0VSXzggaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzhfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl84X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICBpbnRlZ2VyXzE2X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gSU5URUdFUl8xNiBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2ludGVnZXI6IGlzX2ludGVnZXJfMTZfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl8xNl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9pdGVtLCBpbnRlZ2VyXzMyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gSU5URUdFUl8zMiBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2ludGVnZXI6IGlzX2ludGVnZXJfMzJfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl8zMl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgaW50ZWdlcl82NF9pdGVtIChpbmRleDogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIElOVEVHRVJfNjQgaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzY0X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX2ludGVnZXJfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIHBvaW50ZXJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBQb2ludGVyIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfcG9pbnRlcjogaXNfcG9pbnRlcl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9wb2ludGVyX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICByZWFsXzMyX2l0ZW0sIHJlYWxfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBSRUFMXzMyXG4gICAgICAtLSByZWFsIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfcmVhbF9vcl9pbnRlZ2VyOiBpc19yZWFsX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX3JlYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgb2JqZWN0X2NvbXBhcmlzb246IEJPT0xFQU5cbiAgICAgIC0tIE11c3Qgc2VhcmNoIG9wZXJhdGlvbnMgdXNlIGBlcXVhbCcgcmF0aGVyIHRoYW4gYD0nXG4gICAgICAtLSBmb3IgY29tcGFyaW5nIHJlZmVyZW5jZXM/IChEZWZhdWx0OiBubywgdXNlIGA9Jy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgMClcbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IGNvbnNpZGVyZWRcbiAgICAgIC0tIGVxdWFsIHRvIGN1cnJlbnQgb2JqZWN0P1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9vYmplY3RfY29tcGFyZTogQk9PTEVBTlxuICAgIGRvXG4gICAgICBsX29iamVjdF9jb21wYXJlIDo9IG9iamVjdF9jb21wYXJpc29uXG4gICAgICBpZiBsX29iamVjdF9jb21wYXJlID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICBpZiBsX29iamVjdF9jb21wYXJlIHRoZW5cbiAgICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgIGkgPiBuYiBvciBub3QgUmVzdWx0XG4gICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBpdGVtIChpKSB+IG90aGVyLml0ZW0gKGkpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IFByZWN1cnNvciB7SEFTSEFCTEV9IChvdGhlcilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgc2V0dGluZ1xuXG4gIGNvbXBhcmVfb2JqZWN0c1xuICAgICAgLS0gRW5zdXJlIHRoYXQgZnV0dXJlIHNlYXJjaCBvcGVyYXRpb25zIHdpbGwgdXNlIGBlcXVhbCdcbiAgICAgIC0tIHJhdGhlciB0aGFuIGA9JyBmb3IgY29tcGFyaW5nIHJlZmVyZW5jZXMuXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgMCwgVHJ1ZSlcbiAgICBlbnN1cmVcbiAgICAgIG9iamVjdF9jb21wYXJpc29uOiBvYmplY3RfY29tcGFyaXNvblxuICAgIGVuZFxuXG4gIGNvbXBhcmVfcmVmZXJlbmNlc1xuICAgICAgLS0gRW5zdXJlIHRoYXQgZnV0dXJlIHNlYXJjaCBvcGVyYXRpb25zIHdpbGwgdXNlIGA9J1xuICAgICAgLS0gcmF0aGVyIHRoYW4gYGVxdWFsJyBmb3IgY29tcGFyaW5nIHJlZmVyZW5jZXMuXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgMCwgRmFsc2UpXG4gICAgZW5zdXJlXG4gICAgICByZWZlcmVuY2VfY29tcGFyaXNvbjogbm90IG9iamVjdF9jb21wYXJpc29uXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgbG9jYWxcbiAgICAgIGksIG5iLCBsX2hhc2g6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBpbnNwZWN0IGVpZl9pdGVtX3R5cGUoJEN1cnJlbnQsIGkpXG4gICAgICAgIHdoZW4gYm9vbGVhbl9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9ib29sZWFuX2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiBjaGFyYWN0ZXJfOF9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9jaGFyYWN0ZXJfOF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX2NoYXJhY3Rlcl8zMl9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gcmVhbF82NF9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9yZWFsXzY0X2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiByZWFsXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX3JlYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGkpLmhhc2hfY29kZVxuICAgICAgICB3aGVuIHBvaW50ZXJfY29kZSB0aGVuIGxfaGFzaCA6PSBlaWZfcG9pbnRlcl9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gbmF0dXJhbF84X2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX25hdHVyYWxfOF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gbmF0dXJhbF8xNl9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9uYXR1cmFsXzE2X2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX25hdHVyYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGkpLmhhc2hfY29kZVxuICAgICAgICB3aGVuIG5hdHVyYWxfNjRfY29kZSB0aGVuIGxfaGFzaCA6PSBlaWZfbmF0dXJhbF82NF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gaW50ZWdlcl84X2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX2ludGVnZXJfOF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gaW50ZWdlcl8xNl9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9pbnRlZ2VyXzE2X2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiBpbnRlZ2VyXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX2ludGVnZXJfMzJfaXRlbSAoJEN1cnJlbnQsIGkpLmhhc2hfY29kZVxuICAgICAgICB3aGVuIGludGVnZXJfNjRfY29kZSB0aGVuIGxfaGFzaCA6PSBlaWZfaW50ZWdlcl82NF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gcmVmZXJlbmNlX2NvZGUgdGhlblxuICAgICAgICAgIGlmIGF0dGFjaGVkIHtIQVNIQUJMRX0gZWlmX3JlZmVyZW5jZV9pdGVtICgkQ3VycmVudCwgaSkgYXMgbF9rZXkgdGhlblxuICAgICAgICAgICAgbF9oYXNoIDo9IGxfa2V5Lmhhc2hfY29kZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfaGFzaCA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgbF9oYXNoICogaW50ZXJuYWxfcHJpbWVzLmlfdGggKGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgICAtLSBFbnN1cmUgaXQgaXMgYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICAgIFJlc3VsdCA6PSBSZXN1bHQuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGs6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaycgYSB2YWxpZCBrZXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBrID49IDEgYW5kIHRoZW4gayA8PSBjb3VudFxuICAgIGVuZFxuXG4gIHZhbGlkX3R5cGVfZm9yX2luZGV4ICh2OiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWTsgaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBvYmplY3QgYHYnIGEgdmFsaWQgdGFyZ2V0IGZvciBlbGVtZW50IGF0IHBvc2l0aW9uIGBpbmRleCc/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBsb2NhbFxuICAgICAgbF9yZWZsZWN0b3I6IFJFRkxFQ1RPUlxuICAgIGRvXG4gICAgICBpZiB2ID0gVm9pZCB0aGVuXG4gICAgICAgICAgLS0gQSBWb2lkIGVudHJ5IGlzIHZhbGlkIG9ubHkgZm9yIHJlZmVyZW5jZXMgYW5kIGFzIGxvbmcgYXMgdGhlIGV4cGVjdGVkIHR5cGVcbiAgICAgICAgICAtLSBpcyBkZXRhY2hhYmxlLlxuICAgICAgICBpZiBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gcmVmZXJlbmNlX2NvZGUgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBub3QgZ2VuZXJhdGluZ190eXBlLmdlbmVyaWNfcGFyYW1ldGVyX3R5cGUgKGluZGV4KS5pc19hdHRhY2hlZFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgaW5zcGVjdCBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICAgIHdoZW4gYm9vbGVhbl9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtCT09MRUFOX1JFRn0gdiBhcyBsX2JcbiAgICAgICAgd2hlbiBjaGFyYWN0ZXJfOF9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtDSEFSQUNURVJfOF9SRUZ9IHYgYXMgbF9jXG4gICAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge0NIQVJBQ1RFUl8zMl9SRUZ9IHYgYXMgbF93Y1xuICAgICAgICB3aGVuIHJlYWxfNjRfY29kZSB0aGVuIFJlc3VsdCA6PSBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IHYgYXMgbF9kXG4gICAgICAgIHdoZW4gcmVhbF8zMl9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gdiBhcyBsX3JcbiAgICAgICAgd2hlbiBwb2ludGVyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge1BPSU5URVJfUkVGfSB2IGFzIGxfcFxuICAgICAgICB3aGVuIG5hdHVyYWxfOF9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtOQVRVUkFMXzhfUkVGfSB2IGFzIGxfdWk4XG4gICAgICAgIHdoZW4gbmF0dXJhbF8xNl9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtOQVRVUkFMXzE2X1JFRn0gdiBhcyBsX3VpMTZcbiAgICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge05BVFVSQUxfMzJfUkVGfSB2IGFzIGxfdWkzMlxuICAgICAgICB3aGVuIG5hdHVyYWxfNjRfY29kZSB0aGVuIFJlc3VsdCA6PSBhdHRhY2hlZCB7TkFUVVJBTF82NF9SRUZ9IHYgYXMgbF91aTY0XG4gICAgICAgIHdoZW4gaW50ZWdlcl84X2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge0lOVEVHRVJfOF9SRUZ9IHYgYXMgbF9pOFxuICAgICAgICB3aGVuIGludGVnZXJfMTZfY29kZSB0aGVuIFJlc3VsdCA6PSBhdHRhY2hlZCB7SU5URUdFUl8xNl9SRUZ9IHYgYXMgbF9pMTZcbiAgICAgICAgd2hlbiBpbnRlZ2VyXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSB2IGFzIGxfaTMyXG4gICAgICAgIHdoZW4gaW50ZWdlcl82NF9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtJTlRFR0VSXzY0X1JFRn0gdiBhcyBsX2k2NFxuICAgICAgICB3aGVuIFJlZmVyZW5jZV9jb2RlIHRoZW5cbiAgICAgICAgICAgIC0tIExldCdzIGNoZWNrIHRoYXQgdHlwZSBvZiBgdicgY29uZm9ybXMgdG8gc3BlY2lmaWVkIHR5cGUgb2YgYGluZGV4Jy10aFxuICAgICAgICAgICAgLS0gYXJndW1lbnRzIG9mIGN1cnJlbnQgVFVQTEUuXG4gICAgICAgICAgY3JlYXRlIGxfcmVmbGVjdG9yXG4gICAgICAgICAgUmVzdWx0IDo9IGxfcmVmbGVjdG9yLmZpZWxkX2NvbmZvcm1zX3RvICh2LmdlbmVyYXRpbmdfdHlwZS50eXBlX2lkLCBnZW5lcmF0aW5nX3R5cGUuZ2VuZXJpY19wYXJhbWV0ZXJfdHlwZSAoaW5kZXgpLnR5cGVfaWQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBlbGVtZW50IGluIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGxvd2VyOiBJTlRFR0VSID0gMVxuICAgICAgLS0gTG93ZXIgYm91bmQgb2YgVFVQTEUuXG5cbiAgdXBwZXI6IElOVEVHRVJcbiAgICAgIC0tIFVwcGVyIGJvdW5kIG9mIFRVUExFLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY291bnRcbiAgICBlbmRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgQ3VycmVudCBlbXB0eT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNvdW50ID0gMFxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobG93ZXIsIHVwcGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWTsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGVfZm9yX2luZGV4OiB2YWxpZF90eXBlX2Zvcl9pbmRleCAodiwgaW5kZXgpXG4gICAgZG9cbiAgICAgIGluc3BlY3QgZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBib29sZWFuX2NvZGUgdGhlbiBlaWZfcHV0X2Jvb2xlYW5faXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gY2hhcmFjdGVyXzhfY29kZSB0aGVuIGVpZl9wdXRfY2hhcmFjdGVyXzhfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBlaWZfcHV0X2NoYXJhY3Rlcl8zMl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiByZWFsXzY0X2NvZGUgdGhlbiBlaWZfcHV0X3JlYWxfNjRfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gcmVhbF8zMl9jb2RlIHRoZW4gZWlmX3B1dF9yZWFsXzMyX2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIHBvaW50ZXJfY29kZSB0aGVuIGVpZl9wdXRfcG9pbnRlcl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiBuYXR1cmFsXzhfY29kZSB0aGVuIGVpZl9wdXRfbmF0dXJhbF84X2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIG5hdHVyYWxfMTZfY29kZSB0aGVuIGVpZl9wdXRfbmF0dXJhbF8xNl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBlaWZfcHV0X25hdHVyYWxfMzJfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gbmF0dXJhbF82NF9jb2RlIHRoZW4gZWlmX3B1dF9uYXR1cmFsXzY0X2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIGludGVnZXJfOF9jb2RlIHRoZW4gZWlmX3B1dF9pbnRlZ2VyXzhfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gaW50ZWdlcl8xNl9jb2RlIHRoZW4gZWlmX3B1dF9pbnRlZ2VyXzE2X2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIGludGVnZXJfMzJfY29kZSB0aGVuIGVpZl9wdXRfaW50ZWdlcl8zMl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiBpbnRlZ2VyXzY0X2NvZGUgdGhlbiBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gUmVmZXJlbmNlX2NvZGUgdGhlbiBlaWZfcHV0X3JlZmVyZW5jZV9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHV0X3JlZmVyZW5jZSAodjogZGV0YWNoYWJsZSBzZXBhcmF0ZSBBTlk7IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGVfZm9yX2luZGV4OiB2YWxpZF90eXBlX2Zvcl9pbmRleCAodiwgaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19yZWZlcmVuY2VfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfcmVmZXJlbmNlX2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgZW5kXG5cbiAgcHV0X2Jvb2xlYW4gKHY6IEJPT0xFQU47IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGU6IGlzX2Jvb2xlYW5faXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgaW5kZXgsIHYpXG4gICAgZW5kXG5cbiAgcHV0X2NoYXJhY3Rlcl84LCBwdXRfY2hhcmFjdGVyICh2OiBDSEFSQUNURVJfODsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfY2hhcmFjdGVyXzhfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfY2hhcmFjdGVyXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9jaGFyYWN0ZXJfMzIsIHB1dF93aWRlX2NoYXJhY3RlciAodjogQ0hBUkFDVEVSXzMyOyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19jaGFyYWN0ZXJfMzJfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfY2hhcmFjdGVyXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfcmVhbF82NCwgcHV0X2RvdWJsZSAodjogUkVBTF82NDsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfZG91YmxlX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X3JlYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9yZWFsXzMyLCBwdXRfcmVhbCAodjogUkVBTF8zMjsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfcmVhbF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9yZWFsXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfcG9pbnRlciAodjogUE9JTlRFUjsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfcG9pbnRlcl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9wb2ludGVyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF84ICh2OiBOQVRVUkFMXzg7IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGU6IGlzX25hdHVyYWxfOF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9uYXR1cmFsXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzE2ICh2OiBOQVRVUkFMXzE2OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19uYXR1cmFsXzE2X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X25hdHVyYWxfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzMyICh2OiBOQVRVUkFMXzMyOyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19uYXR1cmFsXzMyX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X25hdHVyYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzY0ICh2OiBOQVRVUkFMXzY0OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19uYXR1cmFsXzY0X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X25hdHVyYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyLCBwdXRfaW50ZWdlcl8zMiAodjogSU5URUdFUl8zMjsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfaW50ZWdlcl8zMl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9pbnRlZ2VyXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl84ICh2OiBJTlRFR0VSXzg7IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGU6IGlzX2ludGVnZXJfOF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9pbnRlZ2VyXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzE2ICh2OiBJTlRFR0VSXzE2OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19pbnRlZ2VyXzE2X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X2ludGVnZXJfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzY0ICh2OiBJTlRFR0VSXzY0OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19pbnRlZ2VyXzY0X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFR5cGUgcXVlcmllc1xuXG4gIGlzX2Jvb2xlYW5faXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYSBCT09MRUFOP1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IGJvb2xlYW5fY29kZSlcbiAgICBlbmRcblxuICBpc19jaGFyYWN0ZXJfOF9pdGVtLCBpc19jaGFyYWN0ZXJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYSBDSEFSQUNURVJfOD9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBjaGFyYWN0ZXJfOF9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2NoYXJhY3Rlcl8zMl9pdGVtLCBpc193aWRlX2NoYXJhY3Rlcl9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhIENIQVJBQ1RFUl8zMj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBjaGFyYWN0ZXJfMzJfY29kZSlcbiAgICBlbmRcblxuICBpc19kb3VibGVfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYSBSRUFMXzY0P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IHJlYWxfNjRfY29kZSlcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzhfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYW4gTkFUVVJBTF84P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IG5hdHVyYWxfOF9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfMTZfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYW4gTkFUVVJBTF8xNj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBuYXR1cmFsXzE2X2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfbmF0dXJhbF8zMl9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBOQVRVUkFMXzMyP1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IG5hdHVyYWxfMzJfY29kZSlcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzY0X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgaXRlbSBhdCBgaW5kZXgnIGFuIE5BVFVSQUxfNjQ/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gbmF0dXJhbF82NF9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2ludGVnZXJfOF9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBJTlRFR0VSXzg/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gaW50ZWdlcl84X2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl8xNl9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBJTlRFR0VSXzE2P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IGludGVnZXJfMTZfY29kZSlcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyX2l0ZW0sIGlzX2ludGVnZXJfMzJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYW4gSU5URUdFUl8zMj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBpbnRlZ2VyXzMyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl82NF9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBJTlRFR0VSXzY0P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IGludGVnZXJfNjRfY29kZSlcbiAgICBlbmRcblxuICBpc19wb2ludGVyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgaXRlbSBhdCBgaW5kZXgnIGEgUE9JTlRFUj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBwb2ludGVyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfcmVhbF9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhIFJFQUxfMzI/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gcmVhbF8zMl9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX3JlZmVyZW5jZV9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhIFJFRkVSRU5DRT9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSByZWZlcmVuY2VfY29kZSlcbiAgICBlbmRcblxuICBpc19udW1lcmljX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgaXRlbSBhdCBgaW5kZXgnIGEgbnVtYmVyP1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0aGUgcHJlY2lzZSB0eXBlIHF1ZXJ5IGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGxvY2FsXG4gICAgICB0Y29kZTogbGlrZSBpdGVtX2NvZGVcbiAgICBkb1xuICAgICAgdGNvZGUgOj0gZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgaW5zcGVjdCB0Y29kZVxuICAgICAgd2hlblxuICAgICAgICBpbnRlZ2VyXzhfY29kZSwgaW50ZWdlcl8xNl9jb2RlLCBpbnRlZ2VyXzMyX2NvZGUsXG4gICAgICAgIGludGVnZXJfNjRfY29kZSwgcmVhbF8zMl9jb2RlLCByZWFsXzY0X2NvZGVcbiAgICAgIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgLS0gTm90aGluZyB0byBkbyBoZXJlIHNpbmNlIFJlc3VsdCBhbHJlYWR5IGluaXRpYWxpemVkIHRvIEZhbHNlLlxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0aGUgc2FtZSBiYXNpYyB0eXBlIG9yIGFsbCBvZiByZWZlcmVuY2UgdHlwZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKGFueV9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1fYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIEJPT0xFQU4/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChib29sZWFuX2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9jaGFyYWN0ZXJfOCwgaXNfdW5pZm9ybV9jaGFyYWN0ZXI6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKGNoYXJhY3Rlcl84X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9jaGFyYWN0ZXJfMzIsIGlzX3VuaWZvcm1fd2lkZV9jaGFyYWN0ZXI6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChjaGFyYWN0ZXJfMzJfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX2RvdWJsZTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIFJFQUxfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChyZWFsXzY0X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9uYXR1cmFsXzg6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBOQVRVUkFMXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChuYXR1cmFsXzhfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX25hdHVyYWxfMTY6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBOQVRVUkFMXzE2P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAobmF0dXJhbF8xNl9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1fbmF0dXJhbF8zMjogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIE5BVFVSQUxfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChuYXR1cmFsXzMyX2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9uYXR1cmFsXzY0OiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIG9mIHR5cGUgTkFUVVJBTF82ND9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKG5hdHVyYWxfNjRfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX2ludGVnZXJfODogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIElOVEVHRVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKGludGVnZXJfOF9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1faW50ZWdlcl8xNjogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIElOVEVHRVJfMTY/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChpbnRlZ2VyXzE2X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9pbnRlZ2VyLCBpc191bmlmb3JtX2ludGVnZXJfMzI6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBJTlRFR0VSP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAoaW50ZWdlcl8zMl9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1faW50ZWdlcl82NDogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIElOVEVHRVJfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChpbnRlZ2VyXzY0X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9wb2ludGVyOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIG9mIHR5cGUgUE9JTlRFUj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKHBvaW50ZXJfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX3JlYWw6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBSRUFMXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAocmVhbF8zMl9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1fcmVmZXJlbmNlOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIG9mIHJlZmVyZW5jZSB0eXBlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAocmVmZXJlbmNlX2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoYV9vdGhlcjogVFVQTEUpOiBkZXRhY2hhYmxlIGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29uY2F0ZW5hdGlvbiBvZiBgQ3VycmVudCcgd2l0aCBgYV9vdGhlcidcbiAgICAgIC0tfCBub3RlOiBpdCBtYXkgYmUgVm9pZCBpZiB0aGUgcmVzdWx0IGV4Y2VlZHMgdGhlIGFsbG93ZWQgY2FwYWNpdHkgZm9yIGEgdHVwbGUuXG4gICAgICAtLXwgd2FybmluZzogdGhpcyBmdW5jdGlvbiBoYXMgcG9vciBwZXJmb3JtYW5jZSwgdXNlIGl0IHdpdGggcGFyc2ltb255LlxuICAgIGxvY2FsXG4gICAgICBsX3JlZmxlY3RvcjogUkVGTEVDVE9SXG4gICAgICBpLCBuMSxuMjogSU5URUdFUlxuICAgICAgdDEsIHQyOiBUWVBFIFtkZXRhY2hhYmxlIFRVUExFXVxuICAgICAgbF90eXBlX2lkOiBJTlRFR0VSXG4gICAgICBsX2l0ZW1zOiBTUEVDSUFMIFtkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWV1cbiAgICAgIGxfdHlwZV9zdHJpbmc6IFNUUklOR1xuICAgIGRvXG4gICAgICBuMSA6PSBjb3VudFxuICAgICAgbjIgOj0gYV9vdGhlci5jb3VudFxuXG4gICAgICBpZiBuMSA9IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYV9vdGhlci50d2luXG4gICAgICBlbHNlaWYgbjIgPSAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGVsc2VcbiAgICAgICAgY3JlYXRlIGxfdHlwZV9zdHJpbmcubWFrZV9mcm9tX3N0cmluZyAoXCJUVVBMRSBbXCIpXG5cbiAgICAgICAgY3JlYXRlIGxfaXRlbXMubWFrZV9lbXB0eSAobjEgKyBuMilcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHQxIDo9IGdlbmVyYXRpbmdfdHlwZVxuICAgICAgICAgIGNoZWNrIHNhbWVfY291bnQ6IHQxLmdlbmVyaWNfcGFyYW1ldGVyX2NvdW50ID0gbjEgZW5kXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG4xXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpID4gMSB0aGVuXG4gICAgICAgICAgICBsX3R5cGVfc3RyaW5nLmFwcGVuZF9jaGFyYWN0ZXIgKCcsJylcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBsX3R5cGVfc3RyaW5nLmFwcGVuZCAodDEuZ2VuZXJpY19wYXJhbWV0ZXJfdHlwZSAoaSkubmFtZSlcbiAgICAgICAgICBsX2l0ZW1zLmZvcmNlIChpdGVtIChpKSwgaSAtIDEpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHQyIDo9IGFfb3RoZXIuZ2VuZXJhdGluZ190eXBlXG4gICAgICAgICAgY2hlY2sgc2FtZV9jb3VudDogdDIuZ2VuZXJpY19wYXJhbWV0ZXJfY291bnQgPSBuMiBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbjEgKyBuMlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90eXBlX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyICgnLCcpXG4gICAgICAgICAgbF90eXBlX3N0cmluZy5hcHBlbmQgKHQyLmdlbmVyaWNfcGFyYW1ldGVyX3R5cGUgKGkgLSBuMSkubmFtZSlcbiAgICAgICAgICBsX2l0ZW1zLmZvcmNlIChhX290aGVyLml0ZW0gKGkgLSBuMSksIGkgLSAxKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgbF90eXBlX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyICgnXScpXG4gICAgICAgIGNyZWF0ZSBsX3JlZmxlY3RvclxuICAgICAgICBsX3R5cGVfaWQgOj0gbF9yZWZsZWN0b3IuZHluYW1pY190eXBlX2Zyb21fc3RyaW5nIChsX3R5cGVfc3RyaW5nKVxuICAgICAgICBpZiBsX3R5cGVfaWQgPj0gMCB0aGVuXG4gICAgICAgICAgaWYgYXR0YWNoZWQge2xpa2UgcGx1c30gbF9yZWZsZWN0b3IubmV3X3R1cGxlX2Zyb21fc3BlY2lhbCAobF90eXBlX2lkLCBsX2l0ZW1zKSBhcyByZXMgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IHJlc1xuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLXwgSXQgbWF5IGJlIHRoYXQgdGhlIG1heGltdW0gdHVwbGUgY2FwYWNpdHkgd2FzIHJlYWNoZWQuXG4gICAgICAgICAgICAtLXwgYmV0dGVyIHJldHVybiBWb2lkIHRoYW4gYSB0cnVuY2F0ZWQgdHVwbGUuXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBoYXNfZXhwZWN0ZWRfY291bnQ6IFJlc3VsdCAvPSBWb2lkIGltcGxpZXMgUmVzdWx0LmNvdW50ID0gY291bnQgKyBhX290aGVyLmNvdW50XG4gICAgICBoYXNfZXhwZWN0ZWRfaXRlbXM6IFJlc3VsdCAvPSBWb2lkIGltcGxpZXMgKFxuICAgICAgICAgICAgKGFjcm9zcyAxIHwuLnwgY291bnQgYXMgaWNfMSBhbGwgUmVzdWx0W2ljXzEuaXRlbV0gPSBpdGVtIChpY18xLml0ZW0pIGVuZCkgYW5kXG4gICAgICAgICAgICAoYWNyb3NzIDEgfC4ufCBhX290aGVyLmNvdW50IGFzIGljXzIgYWxsIFJlc3VsdFtjb3VudCArIGljXzIuaXRlbV0gPSBhX290aGVyIFtpY18yLml0ZW1dIGVuZClcbiAgICAgICAgICApXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVHlwZSBjb252ZXJzaW9uIHF1ZXJpZXNcblxuICBjb252ZXJ0aWJsZV90b19kb3VibGU6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgY29udmVydGlibGUgdG8gYW4gYXJyYXkgb2YgZG91Ymxlcz9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICBsb2NhbFxuICAgICAgaSwgY250OiBJTlRFR0VSXG4gICAgICB0Y29kZTogbGlrZSBpdGVtX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICAgIGNudCA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNudCBvciBlbHNlIG5vdCBSZXN1bHRcbiAgICAgIGxvb3BcbiAgICAgICAgdGNvZGUgOj0gZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGkpXG4gICAgICAgIGluc3BlY3QgdGNvZGVcbiAgICAgICAgd2hlblxuICAgICAgICAgIGludGVnZXJfOF9jb2RlLCBpbnRlZ2VyXzE2X2NvZGUsIGludGVnZXJfMzJfY29kZSxcbiAgICAgICAgICBpbnRlZ2VyXzY0X2NvZGUsIHJlYWxfMzJfY29kZSwgcmVhbF82NF9jb2RlXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBjb252ZXJ0aWJsZV90b19yZWFsOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGNvbnZlcnRpYmxlIHRvIGFuIGFycmF5IG9mIHJlYWxzP1xuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICAgIHRjb2RlOiBsaWtlIGl0ZW1fY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250IG9yIGVsc2Ugbm90IFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICB0Y29kZSA6PSBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaSlcbiAgICAgICAgaW5zcGVjdCB0Y29kZVxuICAgICAgICB3aGVuXG4gICAgICAgICAgaW50ZWdlcl84X2NvZGUsIGludGVnZXJfMTZfY29kZSwgaW50ZWdlcl8zMl9jb2RlLFxuICAgICAgICAgIGludGVnZXJfNjRfY29kZSwgcmVhbF8zMl9jb2RlXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXJyYXllZDogQVJSQVkgW2RldGFjaGFibGUgc2VwYXJhdGUgQU5ZXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKFZvaWQsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAoaXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgYm9vbGVhbl9hcnJheWVkOiBBUlJBWSBbQk9PTEVBTl1cbiAgICAgIC0tIEl0ZW1zIG9mIEN1cnJlbnQgYXMgYXJyYXlcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICByZXF1aXJlXG4gICAgICBpc191bmlmb3JtX2Jvb2xlYW46IGlzX3VuaWZvcm1fYm9vbGVhblxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKEZhbHNlLCAxLCBjbnQpXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdC5wdXQgKGJvb2xlYW5faXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzhfYXJyYXllZCwgY2hhcmFjdGVyX2FycmF5ZWQ6IEFSUkFZIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIEl0ZW1zIG9mIEN1cnJlbnQgYXMgYXJyYXlcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICByZXF1aXJlXG4gICAgICBpc191bmlmb3JtX2NoYXJhY3RlcjogaXNfdW5pZm9ybV9jaGFyYWN0ZXJcbiAgICBsb2NhbFxuICAgICAgaSwgY250OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICAgIGNudCA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZmlsbGVkICgnICcsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAoY2hhcmFjdGVyXzhfaXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgZG91YmxlX2FycmF5ZWQ6IEFSUkFZIFtSRUFMXzY0XVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIHJlcXVpcmVcbiAgICAgIGNvbnZlcnRpYmxlOiBjb252ZXJ0aWJsZV90b19kb3VibGVcbiAgICBsb2NhbFxuICAgICAgaSwgY250OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICAgIGNudCA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZmlsbGVkICh7UkVBTF82NH0gMC4wLCAxLCBjbnQpXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdC5wdXQgKGRvdWJsZV9pdGVtIChpKSwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9pdGVtczogLS0gSXRlbXMgYXJlIHRoZSBzYW1lIGluIHNhbWUgb3JkZXJcbiAgICBlbmRcblxuICBpbnRlZ2VyX2FycmF5ZWQ6IEFSUkFZIFtJTlRFR0VSXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX3VuaWZvcm1faW50ZWdlcjogaXNfdW5pZm9ybV9pbnRlZ2VyXG4gICAgbG9jYWxcbiAgICAgIGksIGNudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgICBjbnQgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoe0lOVEVHRVJ9IDAsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAoaW50ZWdlcl8zMl9pdGVtIChpKSwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9pdGVtczogLS0gSXRlbXMgYXJlIHRoZSBzYW1lIGluIHNhbWUgb3JkZXJcbiAgICBlbmRcblxuICBwb2ludGVyX2FycmF5ZWQ6IEFSUkFZIFtQT0lOVEVSXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX3VuaWZvcm1fcG9pbnRlcjogaXNfdW5pZm9ybV9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGksIGNudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgICBjbnQgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoRGVmYXVsdF9wb2ludGVyLCAxLCBjbnQpXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdC5wdXQgKHBvaW50ZXJfaXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgcmVhbF9hcnJheWVkOiBBUlJBWSBbUkVBTF8zMl1cbiAgICAgIC0tIEl0ZW1zIG9mIEN1cnJlbnQgYXMgYXJyYXlcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICByZXF1aXJlXG4gICAgICBjb252ZXJ0aWJsZTogY29udmVydGlibGVfdG9fcmVhbFxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKHtSRUFMXzMyfSAwLjAsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAocmVhbF9pdGVtIChpKSwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9pdGVtczogLS0gSXRlbXMgYXJlIHRoZSBzYW1lIGluIHNhbWUgb3JkZXJcbiAgICBlbmRcblxuICBzdHJpbmdfYXJyYXllZDogQVJSQVkgW2RldGFjaGFibGUgU1RSSU5HXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgICAgLS0gTk9URTogSXRlbXMgd2l0aCBhIHR5cGUgbm90IGNjb25mb3JtaW5nIHRvXG4gICAgICAtLSAgICAgICB0eXBlIFNUUklORyBhcmUgc2V0IHRvIFZvaWQuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiV2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlc1wiXG4gICAgbG9jYWxcbiAgICAgIGksIGNudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgICBjbnQgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoVm9pZCwgMSwgY250KVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNudFxuICAgICAgbG9vcFxuICAgICAgICBpZiBhdHRhY2hlZCB7U1RSSU5HfSBpdGVtIChpKSBhcyBzIHRoZW5cbiAgICAgICAgICBSZXN1bHQucHV0IChzLCBpKVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJldHJpZXZhbFxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYW55OiBBTllcbiAgICBkb1xuICAgICAgICAtLSBPbGQgdmVyc2lvbiBvZiBUVVBMRSBoYWQgYSBTUEVDSUFMIFtBTlldIHRvIHN0b3JlIGFsbCB2YWx1ZXMuXG4gICAgICAgIC0tIElmIHdlIGNhbiBnZXQgYWNjZXNzIHRvIGl0LCB0aGVuIG1vc3QgbGlrZWx5IHdlIGNhbiByZWNvdmVyIHRoaXNcbiAgICAgICAgLS0gb2xkIFRVUExFIGltcGxlbWVudGF0aW9uLlxuICAgICAgaWYgYXR0YWNoZWQge1NQRUNJQUwgW0FOWV19IE1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKGFyZWFfbmFtZSkgYXMgbF9hcmVhIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICAgIG5iIDo9IGxfYXJlYS5jb3VudFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hbnkgOj0gbF9hcmVhLml0ZW0gKGkgLSAxKVxuICAgICAgICAgIGlmIHZhbGlkX3R5cGVfZm9yX2luZGV4IChsX2FueSwgaSkgdGhlblxuICAgICAgICAgICAgcHV0IChsX2FueSwgaSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFdlIGZvdW5kIGFuIHVuZXhwZWN0ZWQgdHlwZSBpbiBvbGQgc3BlY2lhbC4gV2UgY2Fubm90IGdvIG9uLlxuICAgICAgICAgICAgUHJlY3Vyc29yIHtNSVNNQVRDSF9DT1JSRUNUT1J9XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtNSVNNQVRDSF9DT1JSRUNUT1J9XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtX2NvZGUgKGluZGV4OiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBUeXBlIGNvZGUgb2YgaXRlbSBhdCBgaW5kZXgnLiBVc2VkIGZvclxuICAgICAgLS0gYXJndW1lbnQgcHJvY2Vzc2luZyBpbiBST1VUSU5FXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICByZWZlcmVuY2VfY29kZTogTkFUVVJBTF84ID0gMHgwMFxuICBib29sZWFuX2NvZGU6IE5BVFVSQUxfOCA9IDB4MDFcbiAgY2hhcmFjdGVyXzhfY29kZSwgY2hhcmFjdGVyX2NvZGU6IE5BVFVSQUxfOCA9IDB4MDJcbiAgcmVhbF82NF9jb2RlOiBOQVRVUkFMXzggPSAweDAzXG4gIHJlYWxfMzJfY29kZTogTkFUVVJBTF84ID0gMHgwNFxuICBwb2ludGVyX2NvZGU6IE5BVFVSQUxfOCA9IDB4MDVcbiAgaW50ZWdlcl84X2NvZGU6IE5BVFVSQUxfOCA9IDB4MDZcbiAgaW50ZWdlcl8xNl9jb2RlOiBOQVRVUkFMXzggPSAweDA3XG4gIGludGVnZXJfMzJfY29kZTogTkFUVVJBTF84ID0gMHgwOFxuICBpbnRlZ2VyXzY0X2NvZGU6IE5BVFVSQUxfOCA9IDB4MDlcbiAgbmF0dXJhbF84X2NvZGU6IE5BVFVSQUxfOCA9IDB4MEFcbiAgbmF0dXJhbF8xNl9jb2RlOiBOQVRVUkFMXzggPSAweDBCXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF84ID0gMHgwQ1xuICBuYXR1cmFsXzY0X2NvZGU6IE5BVFVSQUxfOCA9IDB4MERcbiAgY2hhcmFjdGVyXzMyX2NvZGUsIHdpZGVfY2hhcmFjdGVyX2NvZGU6IE5BVFVSQUxfOCA9IDB4MEVcbiAgYW55X2NvZGU6IE5BVFVSQUxfOCA9IDB4RkZcbiAgICAgIC0tIENvZGUgdXNlZCB0byBpZGVudGlmeSB0eXBlIGluIFRVUExFLlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFyZWFfbmFtZTogU1RSSU5HID0gXCJhcmVhXCJcbiAgICAgIC0tIE5hbWUgb2YgYXR0cmlidXRlcyB3aGVyZSBUVVBMRSBlbGVtZW50cyB3ZXJlIHN0b3JlZC5cblxuICBpc190dXBsZV91bmlmb3JtIChjb2RlOiBsaWtlIGl0ZW1fY29kZSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBgY29kZSc/XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvZGU6IGxpa2UgaXRlbV9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgICBpZiBjb2RlID0gYW55X2NvZGUgdGhlblxuICAgICAgICAgICAgICAtLSBXZSB0YWtlIGZpcnN0IHR5cGUgY29kZSBhbmQgY29tcGFyZSBhbGwgdGhlIHJlbWFpbmluZyBvbmVzXG4gICAgICAgICAgICAgIC0tIGFnYWluc3QgaXQuXG4gICAgICAgICAgICBpIDo9IDJcbiAgICAgICAgICAgIGxfY29kZSA6PSBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICAgIGxfY29kZSA6PSBjb2RlXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIG5vdCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2NvZGUgPSBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfcHJpbWVzOiBQUklNRVNcbiAgICAgIC0tIEZvciBxdWljayBhY2Nlc3MgdG8gcHJpbWUgbnVtYmVycy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEV4dGVybmFsczogQWNjZXNzXG5cbiAgZWlmX2l0ZW1fdHlwZSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIENvZGUgZm9yIGdlbmVyaWMgcGFyYW1ldGVyIGBwb3MnIGluIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJlaWZfaXRlbV90eXBlXCJcbiAgICBlbmRcblxuICBlaWZfYm9vbGVhbl9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX2NoYXJhY3Rlcl84X2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfY2hhcmFjdGVyXzMyX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBXaWRlIGNoYXJhY3RlciBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcmVhbF82NF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IFJFQUxfNjRcbiAgICAgIC0tIERvdWJsZSBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcmVhbF8zMl9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IFJFQUxfMzJcbiAgICAgIC0tIFJlYWwgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3BvaW50ZXJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBQb2ludGVyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9uYXR1cmFsXzhfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIE5BVFVSQUxfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfbmF0dXJhbF8xNl9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6ICBOQVRVUkFMXzE2XG4gICAgICAtLSBOQVRVUkFMXzE2IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9uYXR1cmFsXzMyX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogIE5BVFVSQUxfMzJcbiAgICAgIC0tIE5BVFVSQUxfMzIgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX25hdHVyYWxfNjRfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiAgTkFUVVJBTF82NFxuICAgICAgLS0gTkFUVVJBTF82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfaW50ZWdlcl84X2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBJTlRFR0VSXzggaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX2ludGVnZXJfMTZfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBJTlRFR0VSXzE2IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9pbnRlZ2VyXzMyX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gSU5URUdFUl8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfaW50ZWdlcl82NF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIElOVEVHRVJfNjQgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3JlZmVyZW5jZV9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IGRldGFjaGFibGUgQU5ZXG4gICAgICAtLSBSZWZlcmVuY2UgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEV4dGVybmFsczogU2V0dGluZ1xuXG4gIGVpZl9wdXRfYm9vbGVhbl9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBib29sZWFuIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfY2hhcmFjdGVyXzhfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgY2hhcmFjdGVyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfY2hhcmFjdGVyXzMyX2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IHdpZGUgY2hhcmFjdGVyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfcmVhbF82NF9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBkb3VibGUgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9yZWFsXzMyX2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IHJlYWwgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9wb2ludGVyX2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IHBvaW50ZXIgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9uYXR1cmFsXzhfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgTkFUVVJBTF84IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfbmF0dXJhbF8xNl9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBOQVRVUkFMXzE2IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfbmF0dXJhbF8zMl9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBOQVRVUkFMXzMyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfbmF0dXJhbF82NF9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBOQVRVUkFMXzY0IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfaW50ZWdlcl84X2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IGludGVnZXJfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMTZfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8xNiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMzJfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X3JlZmVyZW5jZV9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCByZWZlcmVuY2UgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9ib29sZWFuX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBCT09MRUFOKVxuICAgICAgLS0gU2V0IGJvb2xlYW4gaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9jaGFyYWN0ZXJfOF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBTZXQgY2hhcmFjdGVyXzggaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9jaGFyYWN0ZXJfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFNldCBjaGFyYWN0ZXJfMzIgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9yZWFsXzY0X2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBSRUFMXzY0KVxuICAgICAgLS0gU2V0IGRvdWJsZSBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X3JlYWxfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFJFQUxfMzIpXG4gICAgICAtLSBTZXQgcmVhbCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X3BvaW50ZXJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgcG9pbnRlciBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfOF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogTkFUVVJBTF84KVxuICAgICAgLS0gU2V0IE5BVFVSQUxfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfMTZfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IE5BVFVSQUxfMTYpXG4gICAgICAtLSBTZXQgTkFUVVJBTF8xNiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBTZXQgTkFUVVJBTF8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfNjRfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IE5BVFVSQUxfNjQpXG4gICAgICAtLSBTZXQgTkFUVVJBTF82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfOF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogSU5URUdFUl84KVxuICAgICAgLS0gU2V0IGludGVnZXJfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMTZfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IElOVEVHRVJfMTYpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8xNiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IElOVEVHRVJfMzIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IElOVEVHRVJfNjQpXG4gICAgICAtLSBTZXQgaW50ZWdlcl82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlcHJlc2VudGF0aW9uIG9mIGFuIEVpZmZlbCB0eXBlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wOS0wNSAwMzoyOToyNCAtMDcwMCAoVGh1LCAwNSBTZXAgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI5MTMgJFwiXG5cbmNsYXNzXG4gIFRZUEUgW0ddXG5cbmluaGVyaXRcbiAgSEFTSEFCTEVcbiAgICByZW5hbWVcbiAgICAgIGRlZmF1bHQgYXMgYW55X2RlZmF1bHRcbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIFBBUlRfQ09NUEFSQUJMRVxuICAgIHJlbmFtZVxuICAgICAgZGVmYXVsdCBhcyBhbnlfZGVmYXVsdCxcbiAgICAgIGlzX2xlc3MgYXMgaXNfc3RyaWN0bHlfY29uZm9ybWluZ190byBhbGlhcyBcIjxcIixcbiAgICAgIGlzX2xlc3NfZXF1YWwgYXMgaXNfY29uZm9ybWluZ190byBhbGlhcyBcIjw9XCJcbiAgICByZWRlZmluZVxuICAgICAgaXNfY29uZm9ybWluZ190bywgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIERFQlVHX09VVFBVVFxuICAgIHJlbmFtZVxuICAgICAgZGVmYXVsdCBhcyBhbnlfZGVmYXVsdFxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmNyZWF0ZSB7Tk9ORX1cbiAgLS0gQ3JlYXRpb24gaXMgZG9uZSBlaXRoZXIgYnkgdXNpbmcgbWFuaWZlc3QgdHlwZXNcbiAgLS0gb3IgYnkgY2FsbGluZyBBTlkuZ2VuZXJhdGluZ190eXBlLlxuXG5jb252ZXJ0XG4gICAgLS0gQ29udmVyc2lvbiB1c2VmdWwgZm9yIHRoZSB0cmFuc2l0aW9uIHBlcmlvZCBiZWNhdXNlIG9mIHRoZVxuICAgIC0tIG1vZGlmaWNhdGlvbiBpbiBBTlk6XG4gICAgLS0gICAgZ2VuZXJhdGluZ190eXBlOiBTVFJJTkdcbiAgICAtLSBiZWNvbWVzOlxuICAgIC0tICAgIGdlbmVyYXRpbmdfdHlwZTogVFlQRSBbbGlrZSBDdXJyZW50XVxuICB0b19zdHJpbmdfODoge1NUUklOR184LCBTVFJJTkdfR0VORVJBTCwgUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwsIFJFQURBQkxFX1NUUklOR184fSxcbiAgdG9fc3RyaW5nXzMyOiB7U1RSSU5HXzMyLCBSRUFEQUJMRV9TVFJJTkdfMzJ9XG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbmFtZTogSU1NVVRBQkxFX1NUUklOR184XG4gICAgICAtLSBOYW1lIG9mIEVpZmZlbCB0eXBlIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50JywgdXNpbmcgRWlmZmVsIHN0eWxlIGd1aWRlbGluZXNcbiAgICAgIC0tIGFzIHNwZWNpZmllZCBpbiBPT1NDMiAoZS5nLiBDT01QQVJBQkxFLCBIQVNIX1RBQkxFIFtGT08sIEJBUl0sIC4uLilcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgaW50ZXJuYWxfbmFtZSBhcyBsX25hbWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9uYW1lXG4gICAgICBlbHNlXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAocnVudGltZV9uYW1lKVxuICAgICAgICBpbnRlcm5hbF9uYW1lIDo9IFJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuYW1lX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGdlbmVyaWNfcGFyYW1ldGVyX3R5cGUgKGk6IElOVEVHRVIpOiBUWVBFIFtkZXRhY2hhYmxlIEFOWV1cbiAgICAgIC0tIGBpJy10aCBnZW5lcmljIHBhcmFtZXRlciBvZiBFaWZmZWwgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCdcbiAgICByZXF1aXJlXG4gICAgICBpX2xhcmdlX2Vub3VnaDogaSA+PSAxXG4gICAgICBpX3NtYWxsX2Vub3VnaDogaSA8PSBnZW5lcmljX3BhcmFtZXRlcl9jb3VudFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGdlbmVyaWNfcGFyYW1ldGVyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHR5cGVfaWQ6IElOVEVHRVJcbiAgICAgIC0tIElkIG9mIHRoZSBFaWZmZWwgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCdcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICB0eXBlX2lkX25vdF9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHlwZV9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgZ2VuZXJpY19wYXJhbWV0ZXJfY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBnZW5lcmljIHBhcmFtZXRlcnMgaW4gRWlmZmVsIHR5cGUgcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZ2VuZXJpY19wYXJhbWV0ZXJfY291bnRfbm90X25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBoYXNfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0eXBlIGEgdHlwZSB0aGF0IGhhcyBhIGRlZmF1bHQgdmFsdWU/XG4gICAgICAtLSBJLmUuIGEgZGV0YWNoYWJsZSB0eXBlIG9yIGFuIGV4cGFuZGVkIHR5cGUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlzX2V4cGFuZGVkOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHR5cGUgYW4gZXhwYW5kZWQgdHlwZT9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaXNfYXR0YWNoZWQ6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdHlwZSBhdHRhY2hlZD9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3QgY29uc2lkZXJlZFxuICAgICAgLS0gZXF1YWwgdG8gY3VycmVudCBvYmplY3Q/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0eXBlX2lkID0gb3RoZXIudHlwZV9pZFxuICAgIGVuZFxuXG4gIGlzX3N0cmljdGx5X2NvbmZvcm1pbmdfdG8gYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHR5cGUgcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnIGNvbmZvcm0gdG8gdHlwZSByZXByZXNlbnRlZCBieSBgb3RoZXInIGFuZCBkaWZmZXIgZnJvbSBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR5cGVfaWQgLz0gb3RoZXIudHlwZV9pZCBhbmQgdGhlbiBpc19jb25mb3JtaW5nX3RvIChvdGhlcilcbiAgICBlbmRcblxuICBpc19jb25mb3JtaW5nX3RvIGFsaWFzIFwiPD1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCcgY29uZm9ybSB0byB0eXBlIHJlcHJlc2VudGVkIGJ5IGBvdGhlcic/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwibWFnaWNcIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0udHlwZV9jb25mb3Jtc190byAodHlwZV9pZCwgb3RoZXIudHlwZV9pZClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYWRhcHQgYWxpYXMgXCJbXVwiIChnOiBkZXRhY2hhYmxlIEcpOiBkZXRhY2hhYmxlIEdcbiAgICAgIC0tIEFkYXB0cyBgZycgb3IgY2FsbHMgbmVjZXNzYXJ5IGNvbnZlcnNpb24gcm91dGluZSB0byBhZGFwdCBgZydcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGdcbiAgICBlbnN1cmVcbiAgICAgIGFkYXB0ZWQ6IFJlc3VsdCB+IGdcbiAgICBlbmRcblxuICBhdHRlbXB0IGFsaWFzIFwiIz9cIiAob2JqOiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWSk6IGRldGFjaGFibGUgR1xuICAgICAgLS0gUmVzdWx0IG9mIGFzc2lnbm1lbnQgYXR0ZW1wdCBvZiBgb2JqJyB0byBlbnRpdHkgb2YgdHlwZSBHXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtHfSBvYmogYXMgbF9nIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZ1xuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc3NpZ25lZF9vcl92b2lkOiBSZXN1bHQgPSBvYmogb3IgUmVzdWx0ID0gZGVmYXVsdF9kZXRhY2hhYmxlX3ZhbHVlXG4gICAgZW5kXG5cbiAgZGVmYXVsdF9kZXRhY2hhYmxlX3ZhbHVlOiBkZXRhY2hhYmxlIEdcbiAgICBkb1xuICAgIGVuZFxuXG4gIGRlZmF1bHQ6IEdcbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdDogaGFzX2RlZmF1bHRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAobmFtZSlcbiAgICBlbmRcblxuICBkZWJ1Z19vdXRwdXQ6IFNUUklOR1xuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChuYW1lKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEZlYXR1cmVzIGZyb20gU1RSSU5HIG5lZWRlZCBoZXJlIGZvciB0aGUgdHJhbnNpdGlvbiBwZXJpb2QgKHNlZSBjb252ZXJ0IGNsYXVzZSlcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogU1RSSU5HKTogU1RSSU5HXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mICdzJyBhdCB0aGUgZW5kIG9mIGEgY29weSBvZiB0aGUgbmFtZSBvZiB0aGVcbiAgICAgIC0tIEVpZmZlbCB0eXBlIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50JywgdGhlbiByZXR1cm4gdGhlIFJlc3VsdC5cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBmcm9tIFNUUklORyBpcyBuZWVkZWQgaGVyZSBmb3IgdGhlXG4gICAgICAtLSB0cmFuc2l0aW9uIHBlcmlvZCAoc2VlIGNvbnZlcnQgY2xhdXNlKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDcwODEzXSBVc2UgJ25hbWUgKyBvdGhlcicgaW5zdGVhZCAob3IgJ291dCArIG90aGVyJyBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kKS5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobmFtZS5jb3VudCArIG90aGVyLmNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAobmFtZSlcbiAgICAgIFJlc3VsdC5hcHBlbmQgKG90aGVyKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdC5zYW1lX3N0cmluZyAobmFtZSArIG90aGVyKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogU1RSSU5HKTogQk9PTEVBTlxuICAgICAgLS0gRG8gdGhlIG5hbWUgb2YgdGhlIEVpZmZlbCB0eXBlIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50J1xuICAgICAgLS0gYW5kIGBvdGhlcicgaGF2ZSBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZT9cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBmcm9tIFNUUklORyBpcyBuZWVkZWQgaGVyZSBmb3IgdGhlXG4gICAgICAtLSB0cmFuc2l0aW9uIHBlcmlvZCAoc2VlIGNvbnZlcnQgY2xhdXNlKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDcwODEzXSBVc2UgJ25hbWUuc2FtZV9zdHJpbmcgKG90aGVyKScgaW5zdGVhZCAob3IgJ291dC5zYW1lX3N0cmluZyAob3RoZXIpJyBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kKS5cIlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYW1lLnNhbWVfc3RyaW5nIChvdGhlcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IG5hbWUuc2FtZV9zdHJpbmcgKG90aGVyKVxuICAgIGVuZFxuXG4gIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyOiBTVFJJTkcpOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGUgbmFtZSBvZiB0aGUgRWlmZmVsIHR5cGUgcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnXG4gICAgICAtLSBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcicgcmVnYXJkbGVzc1xuICAgICAgLS0gb2YgY2FzaW5nIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBmcm9tIFNUUklORyBpcyBuZWVkZWQgaGVyZSBmb3IgdGhlXG4gICAgICAtLSB0cmFuc2l0aW9uIHBlcmlvZCAoc2VlIGNvbnZlcnQgY2xhdXNlKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDcwODEzXSBVc2UgJ25hbWUuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIpJyBpbnN0ZWFkIChvciAnb3V0LmlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyKScgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHBlcmlvZCkuXCJcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmFtZS5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IG5hbWUuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIpXG4gICAgZW5kXG5cbiAgYXNfbG93ZXI6IFNUUklOR1xuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIG9mIHRoZSBuYW1lIG9mIHRoZSBFaWZmZWwgdHlwZVxuICAgICAgLS0gcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnIGluIGxvd2VyIGNhc2UuXG4gICAgICAtLSBUaGlzIGZlYXR1cmUgZnJvbSBTVFJJTkcgaXMgbmVlZGVkIGhlcmUgZm9yIHRoZVxuICAgICAgLS0gdHJhbnNpdGlvbiBwZXJpb2QgKHNlZSBjb252ZXJ0IGNsYXVzZSkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiWzA3MDgxM10gVXNlICduYW1lLmFzX2xvd2VyJyBpbnN0ZWFkIChvciAnb3V0LmFzX2xvd2VyJyBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kKS5cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9zdHJpbmcgKG5hbWUpXG4gICAgICBSZXN1bHQudG9fbG93ZXJcbiAgICBlbnN1cmVcbiAgICAgIGFzX2xvd2VyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0LnNhbWVfc3RyaW5nIChuYW1lLmFzX2xvd2VyKVxuICAgIGVuZFxuXG4gIGFzX3VwcGVyOiBTVFJJTkdcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBvZiB0aGUgbmFtZSBvZiB0aGUgRWlmZmVsIHR5cGVcbiAgICAgIC0tIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50JyBpbiB1cHBlciBjYXNlLlxuICAgICAgLS0gVGhpcyBmZWF0dXJlIGZyb20gU1RSSU5HIGlzIG5lZWRlZCBoZXJlIGZvciB0aGVcbiAgICAgIC0tIHRyYW5zaXRpb24gcGVyaW9kIChzZWUgY29udmVydCBjbGF1c2UpLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlswNzA4MTNdIFVzZSAnbmFtZS5hc191cHBlcicgaW5zdGVhZCAob3IgJ291dC5hc191cHBlcicgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHBlcmlvZCkuXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChuYW1lKVxuICAgICAgUmVzdWx0LnRvX3VwcGVyXG4gICAgZW5zdXJlXG4gICAgICBhc191cHBlcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdC5zYW1lX3N0cmluZyAobmFtZS5hc191cHBlcilcbiAgICBlbmRcblxuICB0b19zdHJpbmdfODogU1RSSU5HXzhcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG5hbWUnIGluc3RlYWQgKG9yIGBvdXQnIGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2QpLlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAobmFtZSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3N0cmluZ184X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3N0cmluZ18zMjogU1RSSU5HXzMyXG4gICAgICAtLSBOYW1lIG9mIHR5cGVcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDgwNzE3XSBVc2UgJ25hbWUnIGluc3RlYWQgKG9yICdvdXQnIGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2QpLlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChuYW1lKVxuICAgIGVuc3VyZVxuICAgICAgdG9fc3RyaW5nXzMyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvbjogQWNjZXNzXG5cbiAgaW50ZXJuYWxfbmFtZTogZGV0YWNoYWJsZSBJTU1VVEFCTEVfU1RSSU5HXzhcbiAgICAgIC0tIFN0b3JhZ2UgZm9yIG9uY2UgcGVyIG9iamVjdCBgbmFtZSdcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBydW50aW1lX25hbWU6IFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiBFaWZmZWwgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCcsIHVzaW5nIEVpZmZlbCBzdHlsZSBndWlkZWxpbmVzXG4gICAgICAtLSBhcyBzcGVjaWZpZWQgaW4gT09TQzIgKGUuZy4gQ09NUEFSQUJMRSwgSEFTSF9UQUJMRSBbRk9PLCBCQVJdLCAuLi4pXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgbmFtZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkZpbml0ZSBzdHJ1Y3R1cmVzIHdob3NlIGl0ZW0gY291bnQgaXMgbm90IGJvdW5kZWRcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiB1bmJvdW5kZWQsIHN0b3JhZ2U7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBVTkJPVU5ERUQgW0ddIGluaGVyaXRcblxuICBGSU5JVEUgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIC0tZXh0ZW5kaWJsZTogQk9PTEVBTiBpcyB0cnVlO1xuICAgIC0tIENhbiBuZXcgaXRlbXMgYmUgYWRkZWQ/IChBbnN3ZXI6IHllcylcblxuLS0gaW52YXJpYW50XG5cbiAgLS0gZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgICAgQ29udmVydGVyIGZyb20vdG8gVVRGLTgsIFVURi0xNiBhbmQgVVRGLTMyIGVuY29kaW5ncy5cblxuICAgICAgSGFuZGxpbmcgb2YgaW52YWxpZCBlbmNvZGluZ3NcbiAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgIFdoZW5ldmVyIGEgVVRGLTggb3IgVVRGLTE2IHNlcXVlbmNlIGlzIGRlY29kZWQsIHRoZSBkZWNvZGluZyByb3V0aW5lcyBhbHNvIGNoZWNrXG4gICAgICB0aGF0IHRoZSBzZXF1ZW5jZSBpcyB2YWxpZC4gSWYgaXQgaXMgbm90LCBpdCB3aWxsIHJlcGxhY2UgdGhlIGludmFsaWQgdW5pdCAoZS5nLiBhIGJ5dGVcbiAgICAgIGZvciBVVEYtOCBhbmQgYSAyLWJ5dGUgZm9yIFVURi0xNiBieSB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIFUrRkZGRCBhcyBkZXNjcmliZWQgYnlcbiAgICAgIHZhcmlhbnQgIzMgb2YgdGhlIHJlY29tbWVuZGVkIHByYWN0aWNlIGZvciByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW4gVW5pY29kZSAoc2VlXG4gICAgICBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3Jldmlldy9wci0xMjEuaHRtbCBmb3IgbW9yZSBkZXRhaWxzKS5cblxuICAgICAgSG93ZXZlciBpdCBtZWFucyB0aGF0IHlvdSBjYW5ub3Qgcm91bmR0cmlwIGluY29ycmVjdGx5IGVuY29kZWQgc2VxdWVuY2UgYmFjayBhbmQgZm9ydGhcbiAgICAgIGJldHdlZW4gdGhlIGVuY29kZWQgdmVyc2lvbiBhbmQgdGhlIGRlY29kZWQgU1RSSU5HXzMyIHZlcnNpb24uIFRvIGFsbG93IHJvdW5kdHJpcCwgYW5cbiAgICAgIGVzY2FwZWQgcmVwcmVzZW50YXRpb24gb2YgYSBiYWQgZW5jb2RlZCBzZXF1ZW5jZSBoYXMgYmVlbiBpbnRyb2R1Y2VkLiBJdCBpcyBhZGRpbmcgYVxuICAgICAgYSBmb3VydGggdmFyaWFudCAod2hpY2ggaXMgYSBzbGlnaHQgbW9kaWZpY2F0aW9uIG9mIHZhcmlhbnQgIzMpIHRvIHRoZSByZWNvbW1lbmRlZFxuICAgICAgcHJhY3RpY2Ugd2hlcmUgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBmb2xsb3dlZCBieSB0aGUgcHJpbnRlZCBoZXhhZGVjaW1hbCB2YWx1ZVxuICAgICAgb2YgdGhlIGludmFsaWQgYnl0ZSBvciB0aGUgaW52YWxpZCAyLWJ5dGUgc2VxdWVuY2UuXG5cbiAgICAgIFRvIHByb3ZpZGUgYW4gZXhhbXBsZSAoYXNzdW1pbmcgdGhhdCB0aGUgVW5pY29kZSBjaGFyYWN0ZXIgVStGRkZEIGlzIHJlcHJlc2VudGVkIGFzXG4gICAgICA/IHRleHR1YWxseSk6XG4gICAgICAxIC0gb24gVU5JWCwgYW55IGludmFsaWQgVVRGLTggYnl0ZSBzZXF1ZW5jZSBzdWNoIGFzIDB4OEYgMHg4RiBpcyBlbmNvZGVkIGFzIHRoZVxuICAgICAgZm9sbG93aW5nIFVuaWNvZGUgc2VxdWVuY2U6IFUrRkZGRCBVKzAwMzggVSswMDQ2IFUrRkZGRiBVKzAwMzggVSswMDQ2LCBhbmQgdGV4dHVhbGx5XG4gICAgICBpdCBsb29rcyBsaWtlIFwiPzhGPzhGXCIuXG4gICAgICAyIC0gb24gV2luZG93cywgYW55IGludmFsaWQgVVRGLTE2IDItYnl0ZSBzZXF1ZW5jZSBzdWNoIGFzIDB4RDgwMCAweDAwNTQgaXMgZW5jb2RlZCBhcyB0aGVcbiAgICAgIGZvbGxvd2luZyBVbmljb2RlIHNlcXVlbmNlOiBVK0ZGRkQgVSswMDc1IFUrMDA0NCBVKzAwMzggVSswMDMwIFUrMDAzMCBVK0ZGRkQgVSswMDM1IFUrMDAzMyxcbiAgICAgIGFuZCB0ZXh0dWFsbHkgaXQgbG9va3MgbGlrZSBcIj91RDgwMD81NFwiLiBUaGUgcnVsZSBpcyB0aGF0IGlmIHRoZSAyLWJ5dGUgc2VxdWVuY2UgZG9lcyBub3QgZml0XG4gICAgICBpbnRvIDEgYnl0ZSwgaXQgdXNlcyB0aGUgbGV0dGVyIGB1JyBmb2xsb3dlZCBieSB0aGUgaGV4YWRlY2ltYWwgdmFsdWUgb2YgdGhlIDItYnl0ZSBzZXF1ZW5jZSxcbiAgICAgIG90aGVyd2lzZSBpdCBzaW1wbHkgdXNlcyB0aGUgMS1ieXRlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICAgIF1cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA0LTI5IDE0OjI2OjM4IC0wNzAwIChUdWUsIDI5IEFwciAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDkyMCAkXCJcblxuZXhwYW5kZWQgY2xhc3NcbiAgVVRGX0NPTlZFUlRFUlxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGVzY2FwZV9jaGFyYWN0ZXI6IENIQVJBQ1RFUl8zMiA9ICclLzB4RkZGRC8nXG4gICAgICAtLSBVbmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlciB0byBlc2NhcGUgaW52YWxpZCBVVEYtOCBvciBVVEYtMTYgZW5jb2RpbmcuXG4gICAgICAtLSBVVEYtOCBlbmNvZGluZzogMHhFRiAweEJGIDB4QkRcbiAgICAgIC0tIEJpbmFyeSBVVEYtOCBlbmNvZGluZzogMTExMDExMTEgMTAxMTExMTEgMTAxMTExMDFcbiAgICAgIC0tIFVURi0xNiBlbmNvZGluZzogMHhGRkZEXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX3ZhbGlkX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBzJyBhIHZhbGlkIFVURi04IFVuaWNvZGUgc2VxdWVuY2U/XG4gICAgbG9jYWxcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gcy5jb3VudFxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMTI3IHRoZW5cbiAgICAgICAgICAgIC0tIEZvcm0gMHh4eHh4eHguXG4gICAgICAgIGVsc2VpZiAoYyAmIDB4RTApID0gMHhDMCBhbmQgaSA8IG5iIHRoZW5cbiAgICAgICAgICAgIC0tIEZvcm0gMTEweHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIFJlc3VsdCA6PSAocy5jb2RlIChpKSAmIDB4QzApID0gMHg4MFxuICAgICAgICBlbHNlaWYgKGMgJiAweEYwKSA9IDB4RTAgYW5kIGkgKyAxIDwgbmIgdGhlblxuICAgICAgICAgIC0tIEZvcm0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIFJlc3VsdCA6PSAocy5jb2RlIChpIC0gMSkgJiAweEMwKSA9IDB4ODAgYW5kXG4gICAgICAgICAgICAocy5jb2RlIChpKSAmIDB4QzApID0gMHg4MFxuICAgICAgICBlbHNlaWYgKGMgJiAweEY4KSA9IDB4RjAgYW5kIGkgKyAyIDwgbmIgdGhlblxuICAgICAgICAgIC0tIEZvcm0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgaSA6PSBpICsgM1xuICAgICAgICAgIFJlc3VsdCA6PSAocy5jb2RlIChpIC0gMikgJiAweEMwKSA9IDB4ODAgYW5kXG4gICAgICAgICAgICAocy5jb2RlIChpIC0gMSkgJiAweEMwKSA9IDB4ODAgYW5kXG4gICAgICAgICAgICAocy5jb2RlIChpKSAmIDB4QzApID0gMHg4MFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBBbnl0aGluZyBlbHNlIGlzIG5vdCBhIHZhbGlkIFVURi04IHNlcXVlbmNlIHRoYXQgd291bGQgeWllbGQgYSB2YWxpZCBVbmljb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc192YWxpZF91dGZfMTZsZV9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgcycgYSB2YWxpZCBVVEYtMTZMRSBVbmljb2RlIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBjMSwgYzI6IE5BVFVSQUxfMzJcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IHMuY291bnRcbiAgICAgICAgLS0gSWYgYG5iJyBpcyBub3QgZXZlbiwgdGhlbiBjbGVhcmx5IG5vdCBhIHZhbGlkIFVURi0xNiBzdHJpbmcuXG4gICAgICBpZiAobmIgXFxcXCAyKSA9IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID49IG5iIG9yIG5vdCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDJcbiAgICAgICAgICBjMSA6PSBzLmNvZGUgKGkgLSAxKSB8IChzLmNvZGUgKGkpIHw8PCA4KVxuICAgICAgICAgIGlmIGMxIDwgMHhEODAwIG9yIGMxID49IDB4RTAwMCB0aGVuXG4gICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LCB0aGlzIGlzIHZhbGlkIFVuaWNvZGUuXG4gICAgICAgICAgZWxzZWlmIGMxIDw9IDB4REJGRiB0aGVuXG4gICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICBpZiBpIDw9IG5iIHRoZW5cbiAgICAgICAgICAgICAgYzIgOj0gcy5jb2RlIChpIC0gMSkgfCAocy5jb2RlIChpKSB8PDwgOClcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IDB4REMwMCA8PSBjMiBhbmQgYzIgPD0gMHhERkZcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBTdXJyb2dhdGUgcGFpciBpcyBpbmNvbXBsZXRlLCBjbGVhcmx5IG5vdCBhIHZhbGlkIFVURi0xNiBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgc3RhcnRpbmcgc3Vycm9nYXRlIHBhaXIgd2hpY2ggc2hvdWxkIGJlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc192YWxpZF91dGZfMTZfc3VicG9pbnRlciAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHAnIGEgdmFsaWQgVVRGLTE2IFVuaWNvZGUgc2VxdWVuY2UgYmV0d2VlbiBjb2RlIHVuaXQgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJz9cbiAgICAgIC0tIElmIGBhX3N0b3BfYXRfbnVsbCcgd2Ugc3RvcCBjaGVja2luZyBhZnRlciBmaW5kaW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBpZiBwLmNvdW50ID49IDIgYW5kIHN0YXJ0X3BvcyA+PSAwIGFuZCBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDEgYW5kIGVuZF9wb3MgPCAocC5jb3VudCAvLyAyKSB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHN0YXJ0X3BvcyAqIDJcbiAgICAgICAgICBuIDo9IGVuZF9wb3MgKiAyXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbiBvciBub3QgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjMSA6PSBwLnJlYWRfbmF0dXJhbF8xNiAoaSlcbiAgICAgICAgICBpZiBjMSA9IDAgYW5kIGFfc3RvcF9hdF9udWxsIHRoZW5cbiAgICAgICAgICAgICAgLS0gV2UgaGl0IG91ciBudWxsIHRlcm1pbmF0aW5nIGNoYXJhY3Rlciwgd2UgY2FuIHN0b3BcbiAgICAgICAgICAgIGkgOj0gbiArIDFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjMSA8IDB4RDgwMCBvciBjMSA+PSAweEUwMDAgdGhlblxuICAgICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LCB0aGlzIGlzIHZhbGlkIFVuaWNvZGUuXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVsc2VpZiBjMSA8PSAweERCRkYgdGhlblxuICAgICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICAgICAgYzIgOj0gcC5yZWFkX25hdHVyYWxfMTYgKGkpXG4gICAgICAgICAgICAgICAgUmVzdWx0IDo9IDB4REMwMCA8PSBjMiBhbmQgYzIgPD0gMHhERkZcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgLS0gU3Vycm9nYXRlIHBhaXIgaXMgaW5jb21wbGV0ZSwgY2xlYXJseSBub3QgYSB2YWxpZCBVVEYtMTYgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgc3RhcnRpbmcgc3Vycm9nYXRlIHBhaXIgd2hpY2ggc2hvdWxkIGJlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfdXRmXzE2IChzOiBTUEVDSUFMIFtOQVRVUkFMXzE2XSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBzJyBhIHZhbGlkIFVURi0xNiBVbmljb2RlIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBpLCBuOiBJTlRFR0VSXG4gICAgICBjMSwgYzI6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDBcbiAgICAgICAgbiA6PSBzLmNvdW50XG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIGMxIDo9IHMuaXRlbSAoaSlcbiAgICAgICAgaWYgYzEgPSAwIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhpdCBvdXIgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIsIHdlIGNhbiBzdG9wXG4gICAgICAgICAgaSA6PSBuICsgMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgYzEgPCAweEQ4MDAgb3IgYzEgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQsIHRoaXMgaXMgdmFsaWQgVW5pY29kZS5cbiAgICAgICAgICBlbHNlaWYgYzEgPD0gMHhEQkZGIHRoZW5cbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICAgIGMyIDo9IHMuaXRlbSAoaSlcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IDB4REMwMCA8PSBjMiBhbmQgYzIgPD0gMHhERkZcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBTdXJyb2dhdGUgcGFpciBpcyBpbmNvbXBsZXRlLCBjbGVhcmx5IG5vdCBhIHZhbGlkIFVURi0xNiBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgc3RhcnRpbmcgc3Vycm9nYXRlIHBhaXIgd2hpY2ggc2hvdWxkIGJlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIHV0Zl84X2J5dGVzX2NvdW50IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIG5lY2Vzc2FyeSB0byBlbmNvZGUgaW4gVVRGLTggYHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpJy5cbiAgICAgIC0tIE5vdGUgdGhhdCB0aGlzIGZlYXR1cmUgY2FuIGJlIHVzZWQgZm9yIGJvdGggZXNjYXBlZCBhbmQgbm9uLWVzY2FwZWQgc3RyaW5nLlxuICAgICAgLS0gSW4gdGhlIGNhc2Ugb2YgZXNjYXBlZCBzdHJpbmdzLCB0aGUgcmVzdWx0IHdpbGwgYmUgcG9zc2libHkgaGlnaGVyIHRoYW4gcmVhbGx5IG5lZWRlZC5cbiAgICAgIC0tIEl0IGRvZXMgbm90IGluY2x1ZGUgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBzLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X3Bvc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9wb3NcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMHg3RiB0aGVuXG4gICAgICAgICAgICAtLSAweHh4eHh4eC5cbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICBlbHNlaWYgYyA8PSAweDdGRiB0aGVuXG4gICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAyXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAtLSAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIGMgPD0gMUZGRkZGIC0gdGhlcmUgYXJlIG5vIGhpZ2hlciBjb2RlIHBvaW50c1xuICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgNFxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2X2NoYXJhY3RlcnNfY291bnRfZm9ybV9wb2ludGVyIChtOiBNQU5BR0VEX1BPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRoZSBVVEYtMTYgZW5jb2RlZCBgbScgc3RhcnRpbmcgYXQgYHN0YXJ0X3BvcycgaW4gYG0nIHVwIHRvIGBlbmRfcG9zIC0gMScuXG4gICAgICAtLSBJdCBkb2VzIG5vdCBpbmNsdWRlIHRoZSB0ZXJtaW5hdGluZyBudWxsIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMFxuICAgICAgZW5kX3Bvc2l0aW9uOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDJcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdodDogZW5kX3BvcyA8IG0uY291bnRcbiAgICAgIGV2ZW5fc3RhcnRfcG9zaXRpb246IHN0YXJ0X3BvcyBcXFxcIDIgPSAwXG4gICAgICBldmVuX2VuZF9wb3NpdGlvbjogZW5kX3BvcyBcXFxcIDIgPSAwXG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X3Bvc1xuICAgICAgICBuIDo9IGVuZF9wb3NcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gZW5kX3Bvc1xuICAgICAgbG9vcFxuICAgICAgICBjIDo9IG0ucmVhZF9uYXR1cmFsXzE2IChpKVxuICAgICAgICBpZiBjIDwgMHhEODAwIG9yIGMgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICBlbHNlaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgaSA6PSBpICsgNFxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHV0Zl8xNl9ieXRlc19jb3VudCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBuZWNlc3NhcnkgYXQgdGhlIHZlcnkgbGVhc3QgdG8gZW5jb2RlIGluIFVURi0xNiBgcy5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcyknLlxuICAgICAgLS0gTm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBjYW4gYmUgdXNlZCBmb3IgYm90aCBlc2NhcGVkIGFuZCBub24tZXNjYXBlZCBzdHJpbmcuXG4gICAgICAtLSBJbiB0aGUgY2FzZSBvZiBlc2NhcGVkIHN0cmluZ3MsIHRoZSByZXN1bHQgd2lsbCBiZSBwb3NzaWJseSBoaWdoZXIgdGhhbiByZWFsbHkgbmVlZGVkLlxuICAgICAgLS0gSXQgZG9lcyBub3QgaW5jbHVkZSB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDw9IHMuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfcG9zXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gZW5kX3Bvc1xuICAgICAgbG9vcFxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweEZGRkYgdGhlblxuICAgICAgICAgICAgLS0gQ29kZSBwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyA0XG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB1dGZfOF90b19zdHJpbmdfMzJfY291bnQgKHM6IFNQRUNJQUwgW0NIQVJBQ1RFUl07IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENvdW50IG9mIGNoYXJhY3RlcnMgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcy5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBuOiBJTlRFR0VSXG4gICAgICBjOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9wb3NcbiAgICAgICAgbiA6PSBlbmRfcG9zXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gblxuICAgICAgbG9vcFxuICAgICAgICBjIDo9IHMgW2ldLmNvZGVcbiAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4REYgdGhlblxuICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RUYgdGhlblxuICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBpIDo9IGkgKyAzXG4gICAgICAgICAgaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RjcgdGhlblxuICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBpIDo9IGkgKyA0XG4gICAgICAgICAgaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVVRGLTMyIHRvIFVURi04XG5cbiAgc3RyaW5nXzMyX3RvX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKFJlc3VsdCkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgc3RyaW5nXzMyX2ludG9fdXRmXzhfc3RyaW5nXzggKHM6IFJFQURBQkxFX1NUUklOR18zMjsgYV9yZXN1bHQ6IFNUUklOR184KVxuICAgICAgLS0gQ29weSB0aGUgVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgYXBwZW5kZWQgaW50byBgYV9yZXN1bHQnLlxuICAgIGRvXG4gICAgICB1dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfc3RyaW5nXzggKHMsIGFfcmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IFNUUklOR184XG4gICAgICAtLSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZS5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChzLmNvdW50KVxuICAgICAgdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84X3N0cmluZ184IChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAoUmVzdWx0KS5zYW1lX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIHV0Zl8zMl9zdHJpbmdfaW50b191dGZfOF9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IGFfcmVzdWx0OiBTVFJJTkdfOClcbiAgICAgIC0tIENvcHkgdGhlIFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgbG9jYWxcbiAgICAgIGk6IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyBuKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMHg3RiB0aGVuXG4gICAgICAgICAgICAtLSAweHh4eHh4eFxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoYy50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgZWxzZWlmIGMgPD0gMHg3RkYgdGhlblxuICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyB8Pj4gNikgfCAweEMwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAtLSAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjIHw+PiAxMikgfCAweEUwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIGMgPD0gMUZGRkZGIC0gdGhlcmUgYXJlIG5vIGhpZ2hlciBjb2RlIHBvaW50c1xuICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyB8Pj4gMTgpIHwgMHhGMCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKChjIHw+PiAxMikgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKCgoYyB8Pj4gNikgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogdXRmXzhfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBlc2NhcGVkX3V0Zl8zMl9zdWJzdHJpbmdfaW50b191dGZfOF8wX3BvaW50ZXIgKFxuICAgICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSOyBwOiBNQU5BR0VEX1BPSU5URVI7XG4gICAgICAgIHBfb2Zmc2V0OiBJTlRFR0VSOyBhX25ld191cHBlcjogZGV0YWNoYWJsZSBDRUxMIFtJTlRFR0VSXVxuICAgIClcbiAgICAgIC0tIFdyaXRlIFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnLCBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSB0aGF0IGNvdWxkXG4gICAgICAtLSBiZSBlc2NhcGVkLCB3aXRoIHRlcm1pbmF0aW5nIHplcm8gdG8gYWRkcmVzcyBgcCArIHBfb2Zmc2V0JyBhbmQgdXBkYXRlIHRoZSBzaXplIG9mIGBwJyB0byB0aGVcbiAgICAgIC0tIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgemVyby10ZXJtaW5hdGVkLlxuICAgICAgLS0gSWYgYHMnIGNvbnRhaW5zIHRoZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWQgYnkgZWl0aGVyIFwiSEhcIiBvciBcInVISEhIXCIgd2hlcmUgSCBzdGFuZHNcbiAgICAgIC0tIGZvciBhbiBoZXhhZGVjaW1hbCBkaWdpdCwgdGhlbiBgcycgaGFzIGJlZW4gZXNjYXBlZCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gd2hhdCBpc1xuICAgICAgLS0gZXhwZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAtLSBPdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGFuZCBpdCB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gICAgICAtLSBTZWUgdGhlIG5vdGUgY2xhdXNlIGZvciB0aGUgY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZW5jb2RpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDw9IHMuY291bnRcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBpLCBuLCBtLCBsX2NvdW50OiBJTlRFR0VSXG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBsX2VuY29kZWRfdmFsdWU6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICBsX2RlY29kZWQsIGxfcmVzaXplZDogQk9PTEVBTlxuICAgIGRvXG4gICAgICAgIC0tIEJhc2ljIGFzc3VtcHRpb25zIHRoYXQgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZS1ieXRlIGNvZGUgdW5pdHMuXG4gICAgICBuIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBsX2NvdW50IDo9IHAuY291bnRcbiAgICAgICAgLS0gQ2hlY2sgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBgbicgYnl0ZXMgYXZhaWxhYmxlIHBsdXMgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLlxuICAgICAgaWYgbF9jb3VudCAtIHBfb2Zmc2V0IDwgKG4gKyAxKSB0aGVuXG4gICAgICAgICAgLS0gT3B0aW1pemUgcmVzaXppbmcsIG9uY2Ugd2UgaGF2ZSB0byByZXNpemUsIHdlIGFjdHVhbGx5IHBlcmZvcm0gdGhlIHJlc2l6aW5nXG4gICAgICAgICAgLS0gb25seSBvbmNlLlxuICAgICAgICBsX2NvdW50IDo9IHBfb2Zmc2V0ICsgdXRmXzhfYnl0ZXNfY291bnQgKHMsIHN0YXJ0X3BvcywgZW5kX3BvcykgKyAxXG4gICAgICAgIHAucmVzaXplIChsX2NvdW50KVxuICAgICAgICBsX3Jlc2l6ZWQgOj0gVHJ1ZVxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgbSA6PSBwX29mZnNldFxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gZW5kX3Bvc1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGMgOj0gcy5jb2RlIChpKVxuXG4gICAgICAgIGlmIGMgPSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBtaWdodCBiZSBmYWNpbmcgYSBjaGFyYWN0ZXIgdGhhdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICAgIC0tIEluIHRoZSBVbml4IGNhc2UsIHdlIG9ubHkgYWNjZXB0IHRoZSAxLWJ5dGUgZW5jb2RlZCBmb3JtYXQuXG4gICAgICAgICAgaWYgaSA8IG4gYW5kIHRoZW4gcy5pdGVtIChpICsgMSkgPSBlc2NhcGVfY2hhcmFjdGVyIHRoZW5cbiAgICAgICAgICAgICAgLS0gVGhlIGBlc2NhcGVfY2hhcmFjdGVyJyB3YXMgZXNjYXBlZCwgaXQgbWVhbnQgdGhleSByZWFsbHkgd2FudGVkIGFuIGBlc2NhcGVfY2hhcmFjdGVyJy5cbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbHNlaWYgaSArIDEgPCBuIHRoZW5cbiAgICAgICAgICAgICAgLS0gV2UgaGF2ZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgdG8gcmVhZCwgbWFrZSBzdXJlIHRoZXkgcmVwcmVzZW50IGFuIGhleGFkZWNpbWFsXG4gICAgICAgICAgICAgIC0tIHZhbHVlLlxuICAgICAgICAgICAgbF9lbmNvZGVkX3ZhbHVlIDo9IHMuc3Vic3RyaW5nIChpICsgMSwgaSArIDIpXG4gICAgICAgICAgICBpZiBpc19oZXhhX2RlY2ltYWwgKGxfZW5jb2RlZF92YWx1ZSkgdGhlblxuICAgICAgICAgICAgICBjIDo9IHRvX25hdHVyYWxfMzIgKGxfZW5jb2RlZF92YWx1ZSlcbiAgICAgICAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgICAgICAgIC0tIFZhbHVlIHdhcyBlbmNvZGVkIHdoZW4gaXQgc2hvdWxkIG5vdCBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAgIC0tIGRvIG5vdGhpbmcsIHdlIGxlYXZlIHRoZSBvcmlnaW5hbCBjb250ZW50IGFzIGlzLlxuICAgICAgICAgICAgICAgIGMgOj0gZXNjYXBlX2NoYXJhY3Rlci5uYXR1cmFsXzMyX2NvZGVcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxfZGVjb2RlZCA6PSBUcnVlXG4gICAgICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gTm90IGFuIGhleGFkZWNpbWFsIHZhbHVlLCBpdCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBOb3QgZW5vdWdoIHRvIHJlYWQgdG8gbWFrZSBpdCB2YWxpZCwgaXQgd2FzIG5vdCBlc2NhcGVkLlxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICBpZiBub3QgbF9kZWNvZGVkIHRoZW5cbiAgICAgICAgICBpZiBjIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgICAtLSAweHh4eHh4eFxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84IChjLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICAgIG0gOj0gbSArIDFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIE1ha2Ugc3VyZSB0aGVyZSBpcyBzdWZmaWNpZW50IHJvb20gZm9yIGFsbCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYW5kXG4gICAgICAgICAgICAgIC0tIGF0IGxlYXN0IDUgYnl0ZXMsIGkuZS4gNCBieXRlcyBmb3IgdGhlIG1heGltdW0gVVRGLTggZW5jb2RpbmcsXG4gICAgICAgICAgICAgIC0tIGFuZCBvbmUgYnl0ZSBmb3IgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLiBOb3RlIHRoYXQgd2UgZG8gbm90XG4gICAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgICAgLS0gTm90ZSB0aGF0IGBlbmRfcG9zIC0gaScgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgIC0tIHRvIHByb2Nlc3MgaW4gdGhlIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDUgKyAoZW5kX3BvcyAtIGkpID4gbF9jb3VudCkgdGhlblxuICAgICAgICAgICAgICAgIC0tIE9wdGltaXplIHJlc2l6aW5nLCBvbmNlIHdlIGhhdmUgdG8gcmVzaXplLCB3ZSBhY3R1YWxseSBwZXJmb3JtIHRoZSByZXNpemluZ1xuICAgICAgICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgICAgICAgbF9jb3VudCA6PSBtICsgdXRmXzhfYnl0ZXNfY291bnQgKHMsIGksIGVuZF9wb3MpICsgMVxuICAgICAgICAgICAgICBwLnJlc2l6ZSAobF9jb3VudClcbiAgICAgICAgICAgICAgbF9yZXNpemVkIDo9IFRydWVcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaWYgYyA8PSAweDdGRiB0aGVuXG4gICAgICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgfD4+IDYpIHwgMHhDMCkudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMSlcbiAgICAgICAgICAgICAgbSA6PSBtICsgMlxuICAgICAgICAgICAgZWxzZWlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgICAtLSAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyB8Pj4gMTIpIHwgMHhFMCkudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMilcbiAgICAgICAgICAgICAgbSA6PSBtICsgM1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIGMgPD0gMUZGRkZGIC0gdGhlcmUgYXJlIG5vIGhpZ2hlciBjb2RlIHBvaW50c1xuICAgICAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKChjIHw+PiAxOCkgfCAweEYwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKCgoYyB8Pj4gMTIpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAyKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMylcbiAgICAgICAgICAgICAgbSA6PSBtICsgNFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2RlY29kZWQgOj0gRmFsc2VcbiAgICAgICAgICAgIC0tIFNpbXBseSBwdXQgZGVjb2RlZCB2YWx1ZSBkaXJlY3RseSBpbiBzdHJlYW0uXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF84IChjLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBtIDo9IG0gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiBsX3Jlc2l6ZWQgdGhlblxuICAgICAgICAgIC0tIGBwJyB3YXMgcmVzaXplZCBzbyB3ZSBhZGp1c3QgaXQgdG8gYWNjb21tb2RhdGUgdXAgdG8gdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLlxuICAgICAgICBwLnJlc2l6ZSAobSArIDEpXG4gICAgICBlbmRcbiAgICAgIHAucHV0X25hdHVyYWxfOCAoMCwgbSlcbiAgICAgIGlmIGFfbmV3X3VwcGVyIC89IFZvaWQgdGhlblxuICAgICAgICBhX25ld191cHBlci5wdXQgKG0pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYV9uZXdfdXBwZXIgLz0gVm9pZCBpbXBsaWVzIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIGFfbmV3X3VwcGVyLml0ZW0gLSAxLCBGYWxzZSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocy5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykpXG4gICAgICByb3VuZHRyaXA6IChhX25ld191cHBlciA9IFZvaWQgYW5kIHRoZW4gbm90IHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpLmhhcyAoJyVVJykpIGltcGxpZXNcbiAgICAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIHAuY291bnQsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfOF9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UgdGhhdCBjb3VsZCBiZSBlc2NhcGVkLlxuICAgICAgLS0gSWYgYHMnIGNvbnRhaW5zIHRoZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWQgYnkgZWl0aGVyIFwiSEhcIiBvciBcInVISEhIXCIgd2hlcmUgSCBzdGFuZHNcbiAgICAgIC0tIGZvciBhbiBoZXhhZGVjaW1hbCBkaWdpdCwgdGhlbiBgcycgaGFzIGJlZW4gZXNjYXBlZCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gd2hhdCBpc1xuICAgICAgLS0gZXhwZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAtLSBPdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGFuZCBpdCB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gICAgICAtLSBTZWUgdGhlIG5vdGUgY2xhdXNlIGZvciB0aGUgY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZW5jb2RpbmcuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIGVzY2FwZWRfdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84X3N0cmluZ184IChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl84X3N0cmluZ184X3RvX2VzY2FwZWRfc3RyaW5nXzMyIChSZXN1bHQpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgZXNjYXBlZF91dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfc3RyaW5nXzggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBhX3Jlc3VsdDogU1RSSU5HXzgpXG4gICAgICAtLSBDb3B5IHRoZSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSB0aGF0IGNvdWxkXG4gICAgICAtLSBiZSBlc2NhcGVkIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICAgIC0tIElmIGBzJyBjb250YWlucyB0aGUgYGVzY2FwZV9jaGFyYWN0ZXInIGZvbGxvd2VkIGJ5IGVpdGhlciBcIkhIXCIgb3IgXCJ1SEhISFwiIHdoZXJlIEggc3RhbmRzXG4gICAgICAtLSBmb3IgYW4gaGV4YWRlY2ltYWwgZGlnaXQsIHRoZW4gYHMnIGhhcyBiZWVuIGVzY2FwZWQgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIHdoYXQgaXNcbiAgICAgIC0tIGV4cGVjdGVkIGJ5IHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAgLS0gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZCBhbmQgaXQgd2lsbCBiZSBsZWZ0IGFzIGlzLlxuICAgICAgLS0gU2VlIHRoZSBub3RlIGNsYXVzZSBmb3IgdGhlIGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdGhlIGVuY29kaW5nLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBuOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBsX2VuY29kZWRfdmFsdWU6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICBsX2RlY29kZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyBuKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG5cbiAgICAgICAgaWYgYyA9IGVzY2FwZV9jaGFyYWN0ZXIubmF0dXJhbF8zMl9jb2RlIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG1pZ2h0IGJlIGZhY2luZyBhIGNoYXJhY3RlciB0aGF0IHdhcyBlc2NhcGVkLlxuICAgICAgICAgICAgLS0gSW4gdGhlIFVuaXggY2FzZSwgd2Ugb25seSBhY2NlcHQgdGhlIDEtYnl0ZSBlbmNvZGVkIGZvcm1hdC5cbiAgICAgICAgICBpZiBpIDwgbiBhbmQgdGhlbiBzLml0ZW0gKGkgKyAxKSA9IGVzY2FwZV9jaGFyYWN0ZXIgdGhlblxuICAgICAgICAgICAgICAtLSBUaGUgYGVzY2FwZV9jaGFyYWN0ZXInIHdhcyBlc2NhcGVkLCBpdCBtZWFudCB0aGV5IHJlYWxseSB3YW50ZWQgYW4gYGVzY2FwZV9jaGFyYWN0ZXInLlxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVsc2VpZiBpICsgMSA8IG4gdGhlblxuICAgICAgICAgICAgICAtLSBXZSBoYXZlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyB0byByZWFkLCBtYWtlIHN1cmUgdGhleSByZXByZXNlbnQgYW4gaGV4YWRlY2ltYWxcbiAgICAgICAgICAgICAgLS0gdmFsdWUuXG4gICAgICAgICAgICBsX2VuY29kZWRfdmFsdWUgOj0gcy5zdWJzdHJpbmcgKGkgKyAxLCBpICsgMilcbiAgICAgICAgICAgIGlmIGlzX2hleGFfZGVjaW1hbCAobF9lbmNvZGVkX3ZhbHVlKSB0aGVuXG4gICAgICAgICAgICAgIGMgOj0gdG9fbmF0dXJhbF8zMiAobF9lbmNvZGVkX3ZhbHVlKVxuICAgICAgICAgICAgICBpZiBjIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgICAgICAgLS0gVmFsdWUgd2FzIGVuY29kZWQgd2hlbiBpdCBzaG91bGQgbm90IGhhdmUgYmVlblxuICAgICAgICAgICAgICAgICAgLS0gZG8gbm90aGluZywgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIGNvbnRlbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgYyA6PSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbF9kZWNvZGVkIDo9IFRydWVcbiAgICAgICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBOb3QgYW4gaGV4YWRlY2ltYWwgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIE5vdCBlbm91Z2ggdG8gcmVhZCB0byBtYWtlIGl0IHZhbGlkLCBpdCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGlmIG5vdCBsX2RlY29kZWQgdGhlblxuICAgICAgICAgIGlmIGMgPD0gMHg3RiB0aGVuXG4gICAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgZWxzZWlmIGMgPD0gMHg3RkYgdGhlblxuICAgICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgfD4+IDYpIHwgMHhDMCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgZWxzZWlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjIHw+PiAxMikgfCAweEUwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKCgoYyB8Pj4gNikgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gYyA8PSAxRkZGRkYgLSB0aGVyZSBhcmUgbm8gaGlnaGVyIGNvZGUgcG9pbnRzXG4gICAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyB8Pj4gMTgpIHwgMHhGMCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoKGMgfD4+IDEyKSAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfZGVjb2RlZCA6PSBGYWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHB1dCBkZWNvZGVkIHZhbHVlIGRpcmVjdGx5IGluIHN0cmVhbS5cbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl84X3N0cmluZ184X3RvX2VzY2FwZWRfc3RyaW5nXzMyIChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBzdHJpbmdfMzJfaW50b191dGZfOF8wX3BvaW50ZXIgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgcDogTUFOQUdFRF9QT0lOVEVSOyBwX29mZnNldDogSU5URUdFUjsgYV9uZXdfdXBwZXI6IGRldGFjaGFibGUgQ0VMTCBbSU5URUdFUl0pXG4gICAgICAtLSBXcml0ZSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyB3aXRoIHRlcm1pbmF0aW5nIHplcm9cbiAgICAgIC0tIHRvIGFkZHJlc3MgYHAgKyBwX29mZnNldCcgYW5kIHVwZGF0ZSB0aGUgc2l6ZSBvZiBgcCcgdG8gdGhlIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgemVyby10ZXJtaW5hdGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGRvXG4gICAgICB1dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfMF9wb2ludGVyIChzLCBwLCBwX29mZnNldCwgYV9uZXdfdXBwZXIpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfOF8wX3N1YnBvaW50ZXJfdG9fZXNjYXBlZF9zdHJpbmdfMzIgKHAsIHBfb2Zmc2V0LCBhX25ld191cHBlci5pdGVtIC0gMSwgRmFsc2UpLnNhbWVfc3RyaW5nIChzKVxuICAgICAgcm91bmR0cmlwOiAoYV9uZXdfdXBwZXIgPSBWb2lkIGFuZCB0aGVuIG5vdCBzLmhhcyAoJyVVJykpIGltcGxpZXNcbiAgICAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIHAuY291bnQsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84XzBfcG9pbnRlciAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHA6IE1BTkFHRURfUE9JTlRFUjsgcF9vZmZzZXQ6IElOVEVHRVI7IGFfbmV3X3VwcGVyOiBkZXRhY2hhYmxlIENFTEwgW0lOVEVHRVJdKVxuICAgICAgLS0gV3JpdGUgVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycsIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlLFxuICAgICAgLS0gd2l0aCB0ZXJtaW5hdGluZyB6ZXJvIHRvIGFkZHJlc3MgYHAgKyBwX29mZnNldCcgYW5kIHVwZGF0ZSB0aGUgc2l6ZSBvZiBgcCcgdG8gdGhlXG4gICAgICAtLSBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcy5cbiAgICAgIC0tIElmIGBhX25ld191cHBlcicgaXMgcHJvdmlkZWQsIHRoZSB1cHBlciBpbmRleCBvZiBgcCcgY29udGFpbmluZyB0aGUgemVyby10ZXJtaW5hdGlvblxuICAgICAgLS0gaXMgd3JpdHRlbiB0byBgYV9uZXdfdXBwZXInLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBwX29mZnNldF9ub25fbmVnYXRpdmU6IHBfb2Zmc2V0ID49IDBcbiAgICBsb2NhbFxuICAgICAgbTogSU5URUdFUlxuICAgICAgaSwgbiwgbF9jb3VudDogSU5URUdFUlxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgICAgbF9yZXNpemVkOiBCT09MRUFOXG4gICAgZG9cbiAgICAgICAgLS0gQmFzaWMgYXNzdW1wdGlvbnMgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lLWJ5dGUgY29kZSB1bml0cy5cbiAgICAgIG4gOj0gcy5jb3VudFxuICAgICAgbF9jb3VudCA6PSBwLmNvdW50XG4gICAgICAgIC0tIENoZWNrIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3QgYG4nIGJ5dGVzIGF2YWlsYWJsZSBwbHVzIHRoZSB0ZXJtaW5hdGluZyBudWxsIGNoYXJhY3Rlci5cbiAgICAgIGlmIGxfY291bnQgLSBwX29mZnNldCA8IChuICsgMSkgdGhlblxuICAgICAgICAgIC0tIE9wdGltaXplIHJlc2l6aW5nLCBvbmNlIHdlIGhhdmUgdG8gcmVzaXplLCB3ZSBhY3R1YWxseSBwZXJmb3JtIHRoZSByZXNpemluZ1xuICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgbF9jb3VudCA6PSBwX29mZnNldCArIHV0Zl84X2J5dGVzX2NvdW50IChzLCAxLCBuKSArIDFcbiAgICAgICAgcC5yZXNpemUgKGxfY291bnQpXG4gICAgICAgIGxfcmVzaXplZCA6PSBUcnVlXG4gICAgICBlbmRcblxuICAgICAgICAtLSBGaWxsIGBwJyB3aXRoIHRoZSBjb252ZXJ0ZWQgZGF0YS5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAwXG4gICAgICAgIG0gOj0gcF9vZmZzZXRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gblxuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGMgOj0gcy5jb2RlIChpKVxuICAgICAgICBpZiBjIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgLS0gMHh4eHh4eHguXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF84IChjLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBtIDo9IG0gKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIE1ha2Ugc3VyZSB0aGVyZSBpcyBzdWZmaWNpZW50IHJvb20gZm9yIGFsbCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYW5kXG4gICAgICAgICAgICAtLSBhdCBsZWFzdCA1IGJ5dGVzLCBpLmUuIDQgYnl0ZXMgZm9yIHRoZSBtYXhpbXVtIFVURi04IGVuY29kaW5nLFxuICAgICAgICAgICAgLS0gYW5kIG9uZSBieXRlIGZvciB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuIE5vdGUgdGhhdCB3ZSBkbyBub3RcbiAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgIC0tIE5vdGUgdGhhdCBgbiAtIGknIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiByZW1haW5pbmcgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLS0gdG8gcHJvY2VzcyBpbiB0aGUgY3VycmVudCBzdHJpbmcuXG4gICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDUgKyAobiAtIGkpID4gbF9jb3VudCkgdGhlblxuICAgICAgICAgICAgICAtLSBPcHRpbWl6ZSByZXNpemluZywgb25jZSB3ZSBoYXZlIHRvIHJlc2l6ZSwgd2UgYWN0dWFsbHkgcGVyZm9ybSB0aGUgcmVzaXppbmdcbiAgICAgICAgICAgICAgLS0gb25seSBvbmNlLlxuICAgICAgICAgICAgbF9jb3VudCA6PSBtICsgdXRmXzhfYnl0ZXNfY291bnQgKHMsIGksIG4pICsgMVxuICAgICAgICAgICAgcC5yZXNpemUgKGxfY291bnQpXG4gICAgICAgICAgICBsX3Jlc2l6ZWQgOj0gVHJ1ZVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgaWYgYyA8PSAweDdGRiB0aGVuXG4gICAgICAgICAgICAgIC0tIDExMHh4eHh4IDEweHh4eHh4LlxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgfD4+IDYpIHwgMHhDMCkudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDEpXG4gICAgICAgICAgICBtIDo9IG0gKyAyXG4gICAgICAgICAgZWxzZWlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKChjIHw+PiAxMikgfCAweEUwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDIpXG4gICAgICAgICAgICBtIDo9IG0gKyAzXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBjIDw9IDFGRkZGRiAtIHRoZXJlIGFyZSBubyBoaWdoZXIgY29kZSBwb2ludHNcbiAgICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKChjIHw+PiAxOCkgfCAweEYwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDEyKSAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMSlcbiAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKCgoYyB8Pj4gNikgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDIpXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMylcbiAgICAgICAgICAgIG0gOj0gbSArIDRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIGxfcmVzaXplZCB0aGVuXG4gICAgICAgICAgLS0gYHAnIHdhcyByZXNpemVkIHNvIHdlIGFkanVzdCBpdCB0byBhY2NvbW1vZGF0ZSB1cCB0byB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuXG4gICAgICAgIHAucmVzaXplIChtICsgMSlcbiAgICAgIGVuZFxuICAgICAgcC5wdXRfbmF0dXJhbF84ICgwLCBtKVxuICAgICAgaWYgYV9uZXdfdXBwZXIgLz0gVm9pZCB0aGVuXG4gICAgICAgIGFfbmV3X3VwcGVyLnB1dCAobSlcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhX25ld191cHBlciAvPSBWb2lkIGltcGxpZXMgdXRmXzhfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBwX29mZnNldCwgYV9uZXdfdXBwZXIuaXRlbSAtIDEsIEZhbHNlKS5zYW1lX3N0cmluZ19nZW5lcmFsIChzKVxuICAgICAgcm91bmR0cmlwOiAoYV9uZXdfdXBwZXIgPSBWb2lkIGFuZCB0aGVuIG5vdCBzLmhhcyAoJyVVJykpIGltcGxpZXNcbiAgICAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIHAuY291bnQsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ190b191dGZfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTUEVDSUFMIFtOQVRVUkFMXzhdXG4gICAgICAtLSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJywgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfMCAocylcbiAgICAgIFJlc3VsdCA6PSBSZXN1bHQuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgwLCBSZXN1bHQuY291bnQgLSAxKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzKSBhcyBsX3JlZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgUmVzdWx0IGFzIGxfc3BlYyBhbGwgbF9zcGVjLml0ZW0gPSBsX3JlZi5jb2RlIChsX3NwZWMuY3Vyc29yX2luZGV4KSBlbmRcbiAgICBlbmRcblxuICB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84XzAgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycsIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICBsb2NhbFxuICAgICAgbTogSU5URUdFUlxuICAgICAgaSwgbjogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBuIDo9IHMuY291bnRcblxuICAgICAgICAtLSBGaXJzdCBjb21wdXRlIGhvdyBtYW55IGJ5dGVzIHdlIG5lZWQgdG8gY29udmVydCBgcycgdG8gVVRGLTguXG4gICAgICBtIDo9IHV0Zl84X2J5dGVzX2NvdW50IChzLCAxLCBuKVxuXG4gICAgICAgIC0tIEZpbGwgYFJlc3VsdCcgd2l0aCB0aGUgY29udmVydGVkIGRhdGEuXG4gICAgICBmcm9tXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKDAsIG0gKyAxKVxuICAgICAgICBpIDo9IDBcbiAgICAgICAgbSA6PSAwXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4LlxuICAgICAgICAgIFJlc3VsdC5wdXQgKGMudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgIG0gOj0gbSArIDFcbiAgICAgICAgZWxzZWlmIGMgPD0gMHg3RkYgdGhlblxuICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgUmVzdWx0LnB1dCAoKChjIHw+PiA2KSB8IDB4QzApLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDEpXG4gICAgICAgICAgbSA6PSBtICsgMlxuICAgICAgICBlbHNlaWYgYyA8PSAweEZGRkYgdGhlblxuICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKGMgfD4+IDEyKSB8IDB4RTApLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKChjIHw+PiA2KSAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMSlcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDIpXG4gICAgICAgICAgbSA6PSBtICsgM1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBjIDw9IDFGRkZGRiAtIHRoZXJlIGFyZSBubyBoaWdoZXIgY29kZSBwb2ludHNcbiAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgUmVzdWx0LnB1dCAoKChjIHw+PiAxOCkgfCAweEYwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgUmVzdWx0LnB1dCAoKCgoYyB8Pj4gMTIpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgIFJlc3VsdC5wdXQgKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAyKVxuICAgICAgICAgIFJlc3VsdC5wdXQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMylcbiAgICAgICAgICBtIDo9IG0gKyA0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBSZXN1bHQucHV0ICgwLCBtKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzKSBhcyBsX3JlZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgUmVzdWx0IGFzIGxfc3BlYyBhbGwgbF9zcGVjLml0ZW0gPSBsX3JlZi5jb2RlIChsX3NwZWMuY3Vyc29yX2luZGV4KSBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBVVEYtOCB0byBVVEYtMzJcblxuICB1dGZfOF8wX3BvaW50ZXJfdG9fZXNjYXBlZF9zdHJpbmdfMzIgKHA6IE1BTkFHRURfUE9JTlRFUik6IFNUUklOR18zMlxuICAgICAgLS0ge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHAnIHdoaWNoIGlzIHplcm8tdGVybWluYXRlZCxcbiAgICAgIC0tIHdoZXJlIGludmFsaWQgVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLlxuICAgIGRvXG4gICAgICAgIC0tIEFsbG9jYXRlIFJlc3VsdCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBieXRlcyBhcyBgcCcuXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKHAuY291bnQpXG4gICAgICB1dGZfOF8wX3BvaW50ZXJfaW50b19lc2NhcGVkX3N0cmluZ18zMiAocCwgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkgYXMgbF9zdHIgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIGxfc3RyIGFzIGxfY2hhciBhbGwgbF9jaGFyLml0ZW0gPSBwLnJlYWRfbmF0dXJhbF84IChsX2NoYXIuY3Vyc29yX2luZGV4IC0gMSkudG9fY2hhcmFjdGVyXzggZW5kXG4gICAgZW5kXG5cbiAgdXRmXzhfMF9wb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHA6IE1BTkFHRURfUE9JTlRFUjsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHAnIHdoaWNoIGlzIHplcm8tdGVybWluYXRlZCxcbiAgICAgIC0tIHdoZXJlIGludmFsaWQgVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLCBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgZG9cbiAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCAwLCBwLmNvdW50IC0gMSwgVHJ1ZSwgYV9yZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfOF9zdHJpbmdfOCAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpIGFzIGxfc3RyIGFuZCB0aGVuXG4gICAgICAgIGFjcm9zcyBsX3N0ciBhcyBsX2NoYXIgYWxsIGxfY2hhci5pdGVtID0gcC5yZWFkX25hdHVyYWxfOCAobF9jaGFyLmN1cnNvcl9pbmRleCAtIDEpLnRvX2NoYXJhY3Rlcl84IGVuZFxuICAgIGVuZFxuXG4gIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOKTogU1RSSU5HXzMyXG4gICAgICAtLSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcCcgYmV0d2VlbiBpbmRleGVzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIG9yIHRoZSBmaXJzdCBudWxsIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBpZiBgYV9zdG9wX2F0X251bGwnLCB3aGVyZSBpbnZhbGlkXG4gICAgICAtLSBVVEYtOCBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudFxuICAgIGRvXG4gICAgICAgIC0tIEFsbG9jYXRlIFJlc3VsdCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBieXRlcyBhcyBgcCcuXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKHAuY291bnQpXG4gICAgICB1dGZfOF8wX3N1YnBvaW50ZXJfaW50b19lc2NhcGVkX3N0cmluZ18zMiAocCwgc3RhcnRfcG9zLCBlbmRfcG9zLCBhX3N0b3BfYXRfbnVsbCwgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkgYXMgbF9zdHIgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIGxfc3RyIGFzIGxfY2hhciBhbGwgbF9jaGFyLml0ZW0gPSBwLnJlYWRfbmF0dXJhbF84IChzdGFydF9wb3MgKyBsX2NoYXIuY3Vyc29yX2luZGV4IC0gMSkudG9fY2hhcmFjdGVyXzggZW5kXG4gICAgZW5kXG5cbiAgdXRmXzhfMF9zdWJwb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHA6IE1BTkFHRURfUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSOyBhX3N0b3BfYXRfbnVsbDogQk9PTEVBTjsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHAnIGJldHdlZW4gaW5kZXhlcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyBvciB0aGUgZmlyc3QgbnVsbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQgaWYgYGFfc3RvcF9hdF9udWxsJywgd2hlcmUgaW52YWxpZFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLCBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfOH0uY291bnRcbiAgICAgIGMxLCBjMiwgYzMsIGM0OiBOQVRVUkFMXzhcbiAgICAgIGxfbGFzdF9jaGFyOiBDSEFSQUNURVJfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBpIDo9IHN0YXJ0X3Bvc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9wb3NcbiAgICAgIGxvb3BcbiAgICAgICAgYzEgOj0gcC5yZWFkX25hdHVyYWxfOCAoaSlcbiAgICAgICAgaWYgYzEgPSAwIGFuZCBhX3N0b3BfYXRfbnVsbCB0aGVuXG4gICAgICAgICAgICAtLSBXZSBoaXQgb3VyIG51bGwgdGVybWluYXRpbmcgY2hhcmFjdGVyLCB3ZSBjYW4gc3RvcFxuICAgICAgICAgIGkgOj0gZW5kX3BvcyArIDFcbiAgICAgICAgZWxzZWlmIGMxIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgLS0gMHh4eHh4eHhcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMxLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEUwKSA9IDB4QzAgdGhlblxuICAgICAgICAgIGlmIGkgPCBlbmRfcG9zIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHAucmVhZF9uYXR1cmFsXzggKGkgKyAxKVxuICAgICAgICAgICAgaWYgKGMyICYgMHhDMCkgPSAweDgwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBWYWxpZCBVVEYtOCBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgICAoKGMxLmFzX25hdHVyYWxfMzIgJiAweDFGKSB8PDwgNikgfFxuICAgICAgICAgICAgICAgIChjMi5hc19uYXR1cmFsXzMyICYgMHgzRilcbiAgICAgICAgICAgICAgICApLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZVxuICAgICAgICAgICAgICAgIC0tIGFuZCB0cnkgd2l0aCB0aGUgbmV4dCBvbmUgdG8gc2VlIGlmIGl0IGlzIHRoZSBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC0tIGJ5dGUgb2YgYSB2YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxKVxuICAgICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZWlmIChjMSAmIDB4RjApID0gMHhFMCB0aGVuXG4gICAgICAgICAgaWYgaSArIDEgPCBlbmRfcG9zIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHAucmVhZF9uYXR1cmFsXzggKGkgKyAxKVxuICAgICAgICAgICAgYzMgOj0gcC5yZWFkX25hdHVyYWxfOCAoaSArIDIpXG4gICAgICAgICAgICBpZiAoYzIgJiAweEMwKSA9IDB4ODAgYW5kIChjMyAmIDB4QzApID0gMHg4MCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gVmFsaWQgVVRGLTggc2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgbF9sYXN0X2NoYXIgOj0gKCgoYzEuYXNfbmF0dXJhbF8zMiAmIDB4RikgfDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgKChjMi5hc19uYXR1cmFsXzMyICYgMHgzRikgfDw8IDYpIHxcbiAgICAgICAgICAgICAgICAoYzMuYXNfbmF0dXJhbF8zMiAmIDB4M0YpXG4gICAgICAgICAgICAgICAgKS50b19jaGFyYWN0ZXJfMzJcbiAgICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChsX2xhc3RfY2hhcilcbiAgICAgICAgICAgICAgaSA6PSBpICsgM1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZVxuICAgICAgICAgICAgICAgIC0tIGFuZCB0cnkgd2l0aCB0aGUgbmV4dCBvbmUgdG8gc2VlIGlmIGl0IGlzIHRoZSBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC0tIGJ5dGUgb2YgYSB2YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxKVxuICAgICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UuXG4gICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEY4KSA9IDB4RjAgdGhlblxuICAgICAgICAgIGlmIGkgKyAyIDwgZW5kX3BvcyB0aGVuXG4gICAgICAgICAgICBjMiA6PSBwLnJlYWRfbmF0dXJhbF84IChpICsgMSlcbiAgICAgICAgICAgIGMzIDo9IHAucmVhZF9uYXR1cmFsXzggKGkgKyAyKVxuICAgICAgICAgICAgYzQgOj0gcC5yZWFkX25hdHVyYWxfOCAoaSArIDMpXG4gICAgICAgICAgICBpZiAoYzIgJiAweEMwKSA9IDB4ODAgYW5kIChjMyAmIDB4QzApID0gMHg4MCBhbmQgKGM0ICYgMHhDMCkgPSAweDgwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBWYWxpZCBVVEYtOCBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAtLSAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgICAoKGMxLmFzX25hdHVyYWxfMzIgJiAweDcpIHw8PCAxOCkgfFxuICAgICAgICAgICAgICAgICgoYzIuYXNfbmF0dXJhbF8zMiAmIDB4M0YpIHw8PCAxMikgfFxuICAgICAgICAgICAgICAgICgoYzMuYXNfbmF0dXJhbF8zMiAmIDB4M0YpIHw8PCA2KSB8XG4gICAgICAgICAgICAgICAgKGM0LmFzX25hdHVyYWxfMzIgJiAweDNGKVxuICAgICAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgICAgICBpIDo9IGkgKyA0XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZSwgd2UgZXNjYXBlIHRoZSBmaXJzdCBieXRlXG4gICAgICAgICAgICAgICAgLS0gYW5kIHRyeSB3aXRoIHRoZSBuZXh0IG9uZSB0byBzZWUgaWYgaXQgaXMgdGhlIHN0YXJ0aW5nXG4gICAgICAgICAgICAgICAgLS0gYnl0ZSBvZiBhIHZhbGlkIFVURi04IHNlcXVlbmNlLlxuICAgICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBDbGVhcmx5IGludmFsaWQgVVRGLThcbiAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3N0ciBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF9zdHIgYXMgbF9jaGFyIGFsbCBsX2NoYXIuaXRlbSA9IHAucmVhZF9uYXR1cmFsXzggKHN0YXJ0X3BvcyArIGxfY2hhci5jdXJzb3JfaW5kZXggLSAxKS50b19jaGFyYWN0ZXJfOCBlbmRcbiAgICBlbmRcblxuICB1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKHM6IFJFQURBQkxFX1NUUklOR184KTogU1RSSU5HXzMyXG4gICAgICAtLSBTVFJJTkdfMzIgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl84X3N0cmluZ184X2ludG9fc3RyaW5nXzMyIChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl84X3N0cmluZ184IChzKSBpbXBsaWVzIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzhfc3RyaW5nXzhfaW50b19zdHJpbmdfMzIgKHM6IFJFQURBQkxFX1NUUklOR184OyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSBTVFJJTkdfMzIgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycgYXBwZW5kZWQgaW50byBgYV9yZXN1bHQnLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfOH0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR184fS5jb3VudFxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG4gOj0gcy5jb3VudFxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4pXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgZWxzZWlmIGMgPD0gMHhERiB0aGVuXG4gICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBpZiBpIDw9IG4gdGhlblxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoXG4gICAgICAgICAgICAgICgoYyAmIDB4MUYpIHw8PCA2KSB8XG4gICAgICAgICAgICAgIChzLmNvZGUgKGkpICYgMHgzRilcbiAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgYyA8PSAweEVGIHRoZW5cbiAgICAgICAgICAgIC0tIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgKChjICYgMHhGKSB8PDwgMTIpIHxcbiAgICAgICAgICAgICAgKChzLmNvZGUgKGkgLSAxKSAmIDB4M0YpIHw8PCA2KSB8XG4gICAgICAgICAgICAgIChzLmNvZGUgKGkpICYgMHgzRilcbiAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgYyA8PSAweEY3IHRoZW5cbiAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgaSA6PSBpICsgM1xuICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgKChjICYgMHg3KSB8PDwgMTgpIHxcbiAgICAgICAgICAgICAgKChzLmNvZGUgKGkgLSAyKSAmIDB4M0YpIHw8PCAxMikgfFxuICAgICAgICAgICAgICAoKHMuY29kZSAoaSAtIDEpICYgMHgzRikgfDw8IDYpIHxcbiAgICAgICAgICAgICAgKHMuY29kZSAoaSkgJiAweDNGKVxuICAgICAgICAgICAgKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl84X3N0cmluZ184IChzKSBpbXBsaWVzIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfOF9zdHJpbmdfOF90b19lc2NhcGVkX3N0cmluZ18zMiAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBTVFJJTkdfMzJcbiAgICAgIC0tIFNUUklOR18zMiBjb3JyZXNwb25kaW5nIHRvIFVURi04IHNlcXVlbmNlIGBzJywgd2hlcmUgaW52YWxpZCBVVEYtOCBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl84X3N0cmluZ184X2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHMsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogZXNjYXBlZF91dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChSZXN1bHQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHV0Zl84X3N0cmluZ184X2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHM6IFJFQURBQkxFX1NUUklOR184OyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSBTVFJJTkdfMzIgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycsIHdoZXJlIGludmFsaWQgVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLFxuICAgICAgLS0gYXBwZW5kZWQgaW50byBgYV9yZXN1bHQnLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfOH0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR184fS5jb3VudFxuICAgICAgYzEsIGMyLCBjMywgYzQ6IE5BVFVSQUxfOFxuICAgICAgbF9sYXN0X2NoYXI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG4gOj0gcy5jb3VudFxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4pXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjMSA6PSBzLmNvZGUgKGkpLmFzX25hdHVyYWxfOFxuICAgICAgICBpZiBjMSA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjMS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEUwKSA9IDB4QzAgdGhlblxuICAgICAgICAgIGlmIGkgPCBuIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHMuY29kZSAoaSArIDEpLmFzX25hdHVyYWxfOFxuICAgICAgICAgICAgaWYgKGMyICYgMHhDMCkgPSAweDgwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBWYWxpZCBVVEYtOCBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgICAoKGMxLmFzX25hdHVyYWxfMzIgJiAweDFGKSB8PDwgNikgfFxuICAgICAgICAgICAgICAgIChjMi5hc19uYXR1cmFsXzMyICYgMHgzRilcbiAgICAgICAgICAgICAgICApLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZVxuICAgICAgICAgICAgICAgIC0tIGFuZCB0cnkgd2l0aCB0aGUgbmV4dCBvbmUgdG8gc2VlIGlmIGl0IGlzIHRoZSBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC0tIGJ5dGUgb2YgYSB2YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBJbnZhbGlkIFVURi04IHNlcXVlbmNlLCB3ZSBlc2NhcGUgdGhlIGZpcnN0IGJ5dGUuXG4gICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEYwKSA9IDB4RTAgdGhlblxuICAgICAgICAgIGlmIGkgKyAxIDwgbiB0aGVuXG4gICAgICAgICAgICBjMiA6PSBzLmNvZGUgKGkgKyAxKS5hc19uYXR1cmFsXzhcbiAgICAgICAgICAgIGMzIDo9IHMuY29kZSAoaSArIDIpLmFzX25hdHVyYWxfOFxuICAgICAgICAgICAgaWYgKGMyICYgMHhDMCkgPSAweDgwIGFuZCAoYzMgJiAweEMwKSA9IDB4ODAgdGhlblxuICAgICAgICAgICAgICAgIC0tIFZhbGlkIFVURi04IHNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIC0tIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgIGxfbGFzdF9jaGFyIDo9ICgoKGMxLmFzX25hdHVyYWxfMzIgJiAweEYpIHw8PCAxMikgfFxuICAgICAgICAgICAgICAgICgoYzIuYXNfbmF0dXJhbF8zMiAmIDB4M0YpIHw8PCA2KSB8XG4gICAgICAgICAgICAgICAgKGMzLmFzX25hdHVyYWxfMzIgJiAweDNGKVxuICAgICAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyXG4gICAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAobF9sYXN0X2NoYXIpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBJbnZhbGlkIFVURi04IHNlcXVlbmNlLCB3ZSBlc2NhcGUgdGhlIGZpcnN0IGJ5dGVcbiAgICAgICAgICAgICAgICAtLSBhbmQgdHJ5IHdpdGggdGhlIG5leHQgb25lIHRvIHNlZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmdcbiAgICAgICAgICAgICAgICAtLSBieXRlIG9mIGEgdmFsaWQgVVRGLTggc2VxdWVuY2UuXG4gICAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZWlmIChjMSAmIDB4RjgpID0gMHhGMCB0aGVuXG4gICAgICAgICAgaWYgaSArIDIgPCBuIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHMuY29kZSAoaSArIDEpLmFzX25hdHVyYWxfOFxuICAgICAgICAgICAgYzMgOj0gcy5jb2RlIChpICsgMikuYXNfbmF0dXJhbF84XG4gICAgICAgICAgICBjNCA6PSBzLmNvZGUgKGkgKyAzKS5hc19uYXR1cmFsXzhcbiAgICAgICAgICAgIGlmIChjMiAmIDB4QzApID0gMHg4MCBhbmQgKGMzICYgMHhDMCkgPSAweDgwIGFuZCAoYzQgJiAweEMwKSA9IDB4ODAgdGhlblxuICAgICAgICAgICAgICAgIC0tIFZhbGlkIFVURi04IHNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKFxuICAgICAgICAgICAgICAgICgoYzEuYXNfbmF0dXJhbF8zMiAmIDB4NykgfDw8IDE4KSB8XG4gICAgICAgICAgICAgICAgKChjMi5hc19uYXR1cmFsXzMyICYgMHgzRikgfDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgKChjMy5hc19uYXR1cmFsXzMyICYgMHgzRikgfDw8IDYpIHxcbiAgICAgICAgICAgICAgICAoYzQuYXNfbmF0dXJhbF8zMiAmIDB4M0YpXG4gICAgICAgICAgICAgICAgKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDNcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBJbnZhbGlkIFVURi04IHNlcXVlbmNlLCB3ZSBlc2NhcGUgdGhlIGZpcnN0IGJ5dGVcbiAgICAgICAgICAgICAgICAtLSBhbmQgdHJ5IHdpdGggdGhlIG5leHQgb25lIHRvIHNlZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmdcbiAgICAgICAgICAgICAgICAtLSBieXRlIG9mIGEgdmFsaWQgVVRGLTggc2VxdWVuY2UuXG4gICAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICBlbmRcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBDbGVhcmx5IGludmFsaWQgVVRGLThcbiAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfOF9zdHJpbmdfOCAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFVURi0zMiB0byBVVEYtMTZcblxuICBzdHJpbmdfMzJfdG9fdXRmXzE2IChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIG5vdCB6ZXJvLXRlcm1pbmF0ZWQuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1dGZfMzJfc3RyaW5nX3RvX3V0Zl8xNiAocylcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYXR0YWNoZWQgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAocykgYXMgbF9yZWYgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIFJlc3VsdCBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCAxNikpIGVuZFxuICAgIGVuZFxuXG4gIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IFNQRUNJQUwgW05BVFVSQUxfMTZdXG4gICAgICAtLSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2XzAgKHMpXG4gICAgICBSZXN1bHQgOj0gUmVzdWx0LmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYXR0YWNoZWQgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAocykgYXMgbF9yZWYgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIFJlc3VsdCBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCA4KSkgZW5kXG4gICAgZW5kXG5cbiAgc3RyaW5nXzMyX3RvX3V0Zl8xNl8wIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnIHdpdGggdGVybWluYXRpbmcgemVyby5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2XzAgKHMpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKHMpIGFzIGxfcmVmIGFuZCB0aGVuXG4gICAgICAgIGFjcm9zcyBSZXN1bHQucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50IC0gMSkgYXMgbF9zcGVjIGFsbFxuICAgICAgICAgIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCA4KSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ190b191dGZfMTZfMCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnLCBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSxcbiAgICAgIC0tIHdpdGggdGVybWluYXRpbmcgemVyby5cbiAgICBsb2NhbFxuICAgICAgaTogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgbjogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgbTogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgcDogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG0gOj0gMFxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgcCA6PSBuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAocCArIDEpXG4gICAgICBpbnZhcmlhbnRcbiAgICAgICAgbSA9IFJlc3VsdC5jb3VudFxuICAgICAgICBwICsgMSA9IFJlc3VsdC5jYXBhY2l0eVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAtLSBNYWtlIHN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCByb29tIGZvciBhdCBsZWFzdCAyIGNvZGUgdW5pdHMuXG4gICAgICAgIGlmIHAgPCBtICsgMiB0aGVuXG4gICAgICAgICAgcCA6PSBtICsgKG4gLSBpKSArIDJcbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0LmFsaWFzZWRfcmVzaXplZF9hcmVhIChwICsgMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGMgOj0gcy5jb2RlIChpKVxuICAgICAgICBpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LlxuICAgICAgICAgIFJlc3VsdC5leHRlbmQgKGMudG9fbmF0dXJhbF8xNilcbiAgICAgICAgICBtIDo9IG0gKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgUmVzdWx0LmV4dGVuZCAoKDB4RDdDMCArIChjIHw+PiAxMCkpLnRvX25hdHVyYWxfMTYpXG4gICAgICAgICAgUmVzdWx0LmV4dGVuZCAoKDB4REMwMCArIChjICYgMHgzRkYpKS50b19uYXR1cmFsXzE2KVxuICAgICAgICAgIG0gOj0gbSArIDJcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdC5leHRlbmQgKDApXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKHMpIGFzIGxfcmVmIGFuZCB0aGVuXG4gICAgICAgIGFjcm9zcyBSZXN1bHQucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50IC0gMSkgYXMgbF9zcGVjIGFsbFxuICAgICAgICAgIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCA4KSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc3RyaW5nXzMyX2ludG9fdXRmXzE2X3BvaW50ZXIgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgcDogTUFOQUdFRF9QT0lOVEVSOyBwX29mZnNldDogSU5URUdFUjsgYV9uZXdfdXBwZXI6IGRldGFjaGFibGUgQ0VMTCBbSU5URUdFUl0pXG4gICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgdG8gYWRkcmVzcyBgcCArIHBfb2Zmc2V0J1xuICAgICAgLS0gYW5kIHVwZGF0ZSB0aGUgc2l6ZSBvZiBgcCcgdG8gdGhlIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBldmVuX3Bfb2Zmc2V0OiAocF9vZmZzZXQgXFxcXCAyKSA9IDBcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGRvXG4gICAgICB1dGZfMzJfc3Vic3RyaW5nX2ludG9fdXRmXzE2X3BvaW50ZXIgKHMsIDEsIHMuY291bnQsIHAsIHBfb2Zmc2V0LCBhX25ld191cHBlcilcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYV9uZXdfdXBwZXIgLz0gVm9pZCBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAoYV9uZXdfdXBwZXIuaXRlbSAvLyAyKSAtIDEsIEZhbHNlKS5zYW1lX3N0cmluZyAocylcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5oYXMgKCclVScpKSBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHN0cmluZ18zMl9pbnRvX3V0Zl8xNl8wX3BvaW50ZXIgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgcDogTUFOQUdFRF9QT0lOVEVSOyBwX29mZnNldDogSU5URUdFUjsgYV9uZXdfdXBwZXI6IGRldGFjaGFibGUgQ0VMTCBbSU5URUdFUl0pXG4gICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgd2l0aCB0ZXJtaW5hdGluZyB6ZXJvXG4gICAgICAtLSB0byBhZGRyZXNzIGBwICsgcF9vZmZzZXQnIGFuZCB1cGRhdGUgdGhlIHNpemUgb2YgYHAnIHRvIHRoZSBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcy5cbiAgICAgIC0tIElmIGBhX25ld191cHBlcicgaXMgcHJvdmlkZWQsIHRoZSB1cHBlciBpbmRleCBvZiBgcCcgY29udGFpbmluZyB0aGUgemVyby10ZXJtaW5hdGlvblxuICAgICAgLS0gaXMgd3JpdHRlbiB0byBgYV9uZXdfdXBwZXInLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBldmVuX3Bfb2Zmc2V0OiAocF9vZmZzZXQgXFxcXCAyKSA9IDBcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGRvXG4gICAgICB1dGZfMzJfc3Vic3RyaW5nX2ludG9fdXRmXzE2XzBfcG9pbnRlciAocywgMSwgcy5jb3VudCwgcCwgcF9vZmZzZXQsIGFfbmV3X3VwcGVyKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhX25ld191cHBlciAvPSBWb2lkIGltcGxpZXMgdXRmXzE2XzBfc3VicG9pbnRlcl90b19zdHJpbmdfMzIgKHAsIHBfb2Zmc2V0IC8vIDIsIChhX25ld191cHBlci5pdGVtIC8vIDIpIC0gMSwgRmFsc2UpLnNhbWVfc3RyaW5nIChzKVxuICAgICAgcm91bmR0cmlwOiAoYV9uZXdfdXBwZXIgPSBWb2lkIGFuZCB0aGVuIG5vdCBzLmhhcyAoJyVVJykpIGltcGxpZXMgdXRmXzE2XzBfc3VicG9pbnRlcl90b19zdHJpbmdfMzIgKHAsIHBfb2Zmc2V0IC8vIDIsIChwLmNvdW50IC8vIDIpIC0gMSwgVHJ1ZSkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N1YnN0cmluZ19pbnRvX3V0Zl8xNl9wb2ludGVyXG4gICAgICAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7XG4gICAgICBzdGFydF9wb3MsIGVuZF9wb3M6IGxpa2Uge1JFQURBQkxFX1NUUklOR18zMn0uY291bnQ7XG4gICAgICBwOiBNQU5BR0VEX1BPSU5URVI7IHBfb2Zmc2V0OiBJTlRFR0VSOyBhX25ld191cHBlcjogZGV0YWNoYWJsZSBDRUxMIFtJTlRFR0VSXSlcbiAgICAgIC0tIFdyaXRlIFVURi0xNiBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdWJzdHJpbmcgb2YgYHMnLFxuICAgICAgLS0gaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UsIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydF9wb3MnXG4gICAgICAtLSBhbmQgZW5kaW5nIGF0IGluZGV4IGBlbmRfcG9zJyB0byBhZGRyZXNzIGBwICsgcF9vZmZzZXQnIGFuZCB1cGRhdGUgdGhlXG4gICAgICAtLSBzaXplIG9mIGBwJyB0byB0aGUgbnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXMuXG4gICAgICAtLSBJZiBgYV9uZXdfdXBwZXInIGlzIHByb3ZpZGVkLCB0aGUgdXBwZXIgaW5kZXggb2YgYHAnIGNvbnRhaW5pbmcgdGhlIHplcm8tdGVybWluYXRpb25cbiAgICAgIC0tIGlzIHdyaXR0ZW4gdG8gYGFfbmV3X3VwcGVyJy5cbiAgICAgIC0tIFRoZSBzZXF1ZW5jZSBpcyBub3QgemVyby10ZXJtaW5hdGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBzLmNvdW50XG4gICAgICBldmVuX3Bfb2Zmc2V0OiAocF9vZmZzZXQgXFxcXCAyKSA9IDBcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBtOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG0gOj0gcC5jb3VudFxuICAgICAgdXRmXzMyX3N1YnN0cmluZ19pbnRvX3V0Zl8xNl8wX3BvaW50ZXIgKHMsIHN0YXJ0X3BvcywgZW5kX3BvcywgcCwgcF9vZmZzZXQsIGFfbmV3X3VwcGVyKVxuICAgICAgaWYgbSA8IHAuY291bnQgdGhlblxuICAgICAgICAgIC0tIFJlbW92ZSB0aGUgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIuXG4gICAgICAgIHAucmVzaXplIChwLmNvdW50IC0gMilcbiAgICAgICAgaWYgYV9uZXdfdXBwZXIgLz0gVm9pZCB0aGVuXG4gICAgICAgICAgYV9uZXdfdXBwZXIucHV0IChwLmNvdW50IC0gMilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHBfY291bnRfbWF5X2luY3JlYXNlOiBwLmNvdW50ID49IG9sZCBwLmNvdW50XG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX3N0cmluZ18zMiAocCwgcF9vZmZzZXQgLy8gMiwgKGFfbmV3X3VwcGVyLml0ZW0gLy8gMikgLSAxLCBGYWxzZSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5oYXMgKCclVScpKSBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N1YnN0cmluZ19pbnRvX3V0Zl8xNl8wX3BvaW50ZXJcbiAgICAgIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDtcbiAgICAgIHN0YXJ0X3BvcywgZW5kX3BvczogbGlrZSB7UkVBREFCTEVfU1RSSU5HXzMyfS5jb3VudDtcbiAgICAgIHA6IE1BTkFHRURfUE9JTlRFUjsgcF9vZmZzZXQ6IElOVEVHRVI7IGFfbmV3X3VwcGVyOiBkZXRhY2hhYmxlIENFTEwgW0lOVEVHRVJdKVxuICAgICAgLS0gV3JpdGUgVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN1YnN0cmluZyBvZiBgcycsXG4gICAgICAtLSBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSwgc3RhcnRpbmcgYXQgaW5kZXggYHN0YXJ0X3BvcydcbiAgICAgIC0tIGFuZCBlbmRpbmcgYXQgaW5kZXggYGVuZF9wb3MnIHRvIGFkZHJlc3MgYHAgKyBwX29mZnNldCcgYW5kIHVwZGF0ZSB0aGVcbiAgICAgIC0tIHNpemUgb2YgYHAnIHRvIHRoZSBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcy5cbiAgICAgIC0tIElmIGBhX25ld191cHBlcicgaXMgcHJvdmlkZWQsIHRoZSB1cHBlciBpbmRleCBvZiBgcCcgY29udGFpbmluZyB0aGUgemVyby10ZXJtaW5hdGlvblxuICAgICAgLS0gaXMgd3JpdHRlbiB0byBgYV9uZXdfdXBwZXInLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gcy5jb3VudFxuICAgICAgZXZlbl9wX29mZnNldDogKHBfb2Zmc2V0IFxcXFwgMikgPSAwXG4gICAgICBwX29mZnNldF9ub25fbmVnYXRpdmU6IHBfb2Zmc2V0ID49IDBcbiAgICBsb2NhbFxuICAgICAgaTogbGlrZSB7UkVBREFCTEVfU1RSSU5HX0dFTkVSQUx9LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBtLCBsX2NvdW50OiBsaWtlIHtNQU5BR0VEX1BPSU5URVJ9LmNvdW50XG4gICAgICBsX3Jlc2l6ZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UuXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgICAgbF9jb3VudCA6PSBwLmNvdW50XG4gICAgICAgICAgLS0gQ2hlY2sgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBgaSAqIDInIGJ5dGVzIGF2YWlsYWJsZSBwbHVzIHRoZSB0ZXJtaW5hdGluZyBudWxsIGNoYXJhY3Rlci5cbiAgICAgICAgaWYgbF9jb3VudCAtIHBfb2Zmc2V0IDwgKGkgKyAxKSAqIDIgIHRoZW5cbiAgICAgICAgICAgIC0tIE9wdGltaXplIHJlc2l6aW5nLCBvbmNlIHdlIGhhdmUgdG8gcmVzaXplLCB3ZSBhY3R1YWxseSBwZXJmb3JtIHRoZSByZXNpemluZ1xuICAgICAgICAgICAgLS0gb25seSBvbmNlLlxuICAgICAgICAgIGxfY291bnQgOj0gcF9vZmZzZXQgKyB1dGZfMTZfYnl0ZXNfY291bnQgKHMsIHN0YXJ0X3BvcywgZW5kX3BvcykgKyAyXG4gICAgICAgICAgcC5yZXNpemUgKGxfY291bnQpXG4gICAgICAgICAgbF9yZXNpemVkIDo9IFRydWVcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gc3RhcnRfcG9zIC0gMVxuICAgICAgICBtIDo9IHBfb2Zmc2V0XG4gICAgICB1bnRpbFxuICAgICAgICBpID49IGVuZF9wb3NcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweEZGRkYgdGhlblxuICAgICAgICAgICAgLS0gQ29kZXBvaW50IGZyb20gQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lOiBvbmUgMTYtYml0IGNvZGUgdW5pdC5cbiAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2IChjLnRvX25hdHVyYWxfMTYsIG0pXG4gICAgICAgICAgbSA6PSBtICsgMlxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBNYWtlIHN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCByb29tIGZvciBhbGwgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFuZFxuICAgICAgICAgICAgLS0gYXQgbGVhc3QgMyBjb2RlIHVuaXRzIG9mIDIgYnl0ZXMgZWFjaCwgaS5lLiAyIGNvZGUgdW5pdCBmb3IgdGhlIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgLS0gcGFpciwgYW5kIG9uZSB1bml0IGZvciB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuIE5vdGUgdGhhdCB3ZSBkbyBub3RcbiAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgIC0tIE5vdGUgdGhhdCBgZW5kX3BvcyAtIGknIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiByZW1haW5pbmcgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLS0gdG8gcHJvY2VzcyBpbiB0aGUgY3VycmVudCBzdHJpbmcuXG4gICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDYgKyAoZW5kX3BvcyAtIGkpICogMiA+IGxfY291bnQpIHRoZW5cbiAgICAgICAgICAgICAgLS0gT3B0aW1pemUgcmVzaXppbmcsIG9uY2Ugd2UgaGF2ZSB0byByZXNpemUsIHdlIGFjdHVhbGx5IHBlcmZvcm0gdGhlIHJlc2l6aW5nXG4gICAgICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgICAgIGxfY291bnQgOj0gbSArIHV0Zl8xNl9ieXRlc19jb3VudCAocywgaSwgZW5kX3BvcykgKyAyXG4gICAgICAgICAgICBwLnJlc2l6ZSAobF9jb3VudClcbiAgICAgICAgICAgIGxfcmVzaXplZCA6PSBUcnVlXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoKDB4RDdDMCArIChjIHw+PiAxMCkpLnRvX25hdHVyYWxfMTYsIG0pXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoKDB4REMwMCArIChjICYgMHgzRkYpKS50b19uYXR1cmFsXzE2LCBtICsgMilcbiAgICAgICAgICBtIDo9IG0gKyA0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICAgIC0tIEFkanVzdCBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcyBhbmQgYWRkIHRlcm1pbmF0aW5nIHplcm8gYXQgdGhlIGVuZC5cbiAgICAgIGlmIGxfcmVzaXplZCB0aGVuXG4gICAgICAgICAgLS0gV2UgaGFkIHRvIGFkZCBhIGNvZGUgdW5pdCBvbiA0IGJ5dGVzLiBXZSBhZGp1c3QgdGhlIHNpemUuXG4gICAgICAgIHAucmVzaXplIChtICsgMilcbiAgICAgIGVuZFxuICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoMCwgbSlcbiAgICAgIGlmIGFfbmV3X3VwcGVyIC89IFZvaWQgdGhlblxuICAgICAgICBhX25ld191cHBlci5wdXQgKG0pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHBfY291bnRfbWF5X2luY3JlYXNlOiBwLmNvdW50ID49IG9sZCBwLmNvdW50XG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX3N0cmluZ18zMiAocCwgcF9vZmZzZXQgLy8gMiwgKGFfbmV3X3VwcGVyLml0ZW0gLy8gMikgLSAxLCBGYWxzZSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5oYXMgKCclVScpKSBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTE2TEUgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2VcbiAgICBkb1xuICAgICAgICAtLSBXZSB3b3VsZCBuZWVkIGF0IGxlYXN0IDItYnl0ZXMgcGVyIGNoYXJhY3RlcnMgaW4gYHMnLlxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChzLmNvdW50ICogMilcbiAgICAgIHV0Zl8zMl9zdHJpbmdfaW50b191dGZfMTZsZV9zdHJpbmdfOCAocywgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfMTZsZV9zdHJpbmdfOF90b19zdHJpbmdfMzIgKFJlc3VsdCkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICB1dGZfMzJfc3RyaW5nX2ludG9fdXRmXzE2bGVfc3RyaW5nXzggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBhX3Jlc3VsdDogU1RSSU5HXzgpXG4gICAgICAtLSBDb3B5IFVURi0xNkxFIHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgbG9jYWxcbiAgICAgIGk6IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICAgIGxfbmF0MTY6IE5BVFVSQUxfMTZcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBXZSB3b3VsZCBuZWVkIGF0IGxlYXN0IDItYnl0ZXMgcGVyIGNoYXJhY3RlcnMgaW4gYHMnLlxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4gKiAyKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoYyAmIDB4MDBGRikudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgJiAweEZGMDApIHw+PiA4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gV3JpdGUgdGhlIGxlYWQgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgbF9uYXQxNiA6PSAoMHhEN0MwICsgKGMgfD4+IDEwKSkudG9fbmF0dXJhbF8xNlxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGxfbmF0MTYgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChsX25hdDE2ICYgMHhGRjAwKSB8Pj4gOCkudG9fY2hhcmFjdGVyXzgpXG5cbiAgICAgICAgICAgIC0tIFdyaXRlIHRoZSB0cmFpbCBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICBsX25hdDE2IDo9ICgweERDMDAgKyAoYyAmIDB4M0ZGKSkudG9fbmF0dXJhbF8xNlxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGxfbmF0MTYgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChsX25hdDE2ICYgMHhGRjAwKSB8Pj4gOCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl8xNmxlX3N0cmluZ184X3RvX3N0cmluZ18zMiAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgZXNjYXBlZF91dGZfMzJfc3Vic3RyaW5nX2ludG9fdXRmXzE2XzBfcG9pbnRlciAoXG4gICAgICAgIHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IGxpa2Uge1JFQURBQkxFX1NUUklOR18zMn0uY291bnQ7XG4gICAgICAgIHA6IE1BTkFHRURfUE9JTlRFUjsgcF9vZmZzZXQ6IElOVEVHRVI7IGFfbmV3X3VwcGVyOiBkZXRhY2hhYmxlIENFTEwgW0lOVEVHRVJdXG4gICAgICApXG4gICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byB0aGUgc3Vic3RyaW5nIG9mIGBzJyxcbiAgICAgIC0tIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlLCBzdGFydGluZyBhdCBpbmRleCBgc3RhcnRfcG9zJ1xuICAgICAgLS0gYW5kIGVuZGluZyBhdCBpbmRleCBgZW5kX3BvcycgdG8gYWRkcmVzcyBgcCArIHBfb2Zmc2V0JyBhbmQgdXBkYXRlIHRoZVxuICAgICAgLS0gc2l6ZSBvZiBgcCcgdG8gdGhlIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gcy5jb3VudFxuICAgICAgZXZlbl9wX29mZnNldDogKHBfb2Zmc2V0IFxcXFwgMikgPSAwXG4gICAgICBwX29mZnNldF9ub25fbmVnYXRpdmU6IHBfb2Zmc2V0ID49IDBcbiAgICBsb2NhbFxuICAgICAgaSwgbiwgbSwgbF9jb3VudDogSU5URUdFUlxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgICAgbF9lbmNvZGVkX3ZhbHVlOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgICAgbF9kZWNvZGVkOiBCT09MRUFOXG4gICAgICBsX3Jlc2l6ZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAgIGxfY291bnQgOj0gcC5jb3VudFxuICAgICAgICAgIC0tIENoZWNrIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3QgYGkgKiAyJyBieXRlcyBhdmFpbGFibGUgcGx1cyB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIGxfY291bnQgLSBwX29mZnNldCA8IChuICsgMSkgKiAyICB0aGVuXG4gICAgICAgICAgICAtLSBPcHRpbWl6ZSByZXNpemluZywgb25jZSB3ZSBoYXZlIHRvIHJlc2l6ZSwgd2UgYWN0dWFsbHkgcGVyZm9ybSB0aGUgcmVzaXppbmdcbiAgICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgICBsX2NvdW50IDo9IHBfb2Zmc2V0ICsgdXRmXzE2X2J5dGVzX2NvdW50IChzLCBzdGFydF9wb3MsIGVuZF9wb3MpICsgMlxuICAgICAgICAgIHAucmVzaXplIChsX2NvdW50KVxuICAgICAgICAgIGxfcmVzaXplZCA6PSBUcnVlXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgbSA6PSBwX29mZnNldFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBlbmRfcG9zXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBtaWdodCBiZSBmYWNpbmcgYSBjaGFyYWN0ZXIgdGhhdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICBpZiBpIDwgbiB0aGVuXG4gICAgICAgICAgICBpZiBzLml0ZW0gKGkgKyAxKSA9IGVzY2FwZV9jaGFyYWN0ZXIgdGhlblxuICAgICAgICAgICAgICAgIC0tIFRoZSBgZXNjYXBlX2NoYXJhY3Rlcicgd2FzIGVzY2FwZWQsIGl0IG1lYW50IHRoZXkgcmVhbGx5IHdhbnRlZCBhbiBgZXNjYXBlX2NoYXJhY3RlcicuXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVsc2VpZiBzLml0ZW0gKGkgKyAxKSA9ICd1JyB0aGVuXG4gICAgICAgICAgICAgIGlmIGkgKyA0IDwgbiB0aGVuXG4gICAgICAgICAgICAgICAgbF9lbmNvZGVkX3ZhbHVlIDo9IHMuc3Vic3RyaW5nIChpICsgMiwgaSArIDUpXG4gICAgICAgICAgICAgICAgaWYgaXNfaGV4YV9kZWNpbWFsIChsX2VuY29kZWRfdmFsdWUpIHRoZW5cbiAgICAgICAgICAgICAgICAgIGMgOj0gdG9fbmF0dXJhbF8zMiAobF9lbmNvZGVkX3ZhbHVlKVxuICAgICAgICAgICAgICAgICAgaWYgYyA8IDB4RDgwMCBvciBjID4gMHhERkZGIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAtLSBWYWx1ZSB3YXMgZW5jb2RlZCB3aGVuIGl0IHNob3VsZCBub3QgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgICAgICAgLS0gZG8gbm90aGluZywgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIGNvbnRlbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgIGMgOj0gZXNjYXBlX2NoYXJhY3Rlci5uYXR1cmFsXzMyX2NvZGVcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbF9kZWNvZGVkIDo9IFRydWVcbiAgICAgICAgICAgICAgICAgICAgaSA6PSBpICsgNVxuICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAtLSBOb3QgYW4gaGV4YWRlY2ltYWwgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIE5vdCBlbm91Z2ggY2hhcmFjdGVycyB0byBtYWtlIGEgMi1ieXRlIHZhbHVlLCBpdCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBWYWx1ZSB3YXMgbW9zdCBsaWtlbHkgbm90IGVuY29kZWQsIGJlY2F1c2UgaWYgaXQgZGlkLCBpdCB3b3VsZCBiZSB0aGVcbiAgICAgICAgICAgICAgLS0gaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlIHdoaWNoIGNsZWFybHkgZGlkIG5vdCBuZWVkIHRvXG4gICAgICAgICAgICAgIC0tIGJlIGVzY2FwZWRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gTm90aGluZyBtb3JlIHRvIHJlYWQsIGNsZWFybHkgaXQgd2FzIG5vdCBlbmNvZGVkLlxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICBpZiBub3QgbF9kZWNvZGVkIHRoZW5cbiAgICAgICAgICBpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2IChjLnRvX25hdHVyYWxfMTYsIG0pXG4gICAgICAgICAgICBtIDo9IG0gKyAyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBNYWtlIHN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCByb29tIGZvciBhbGwgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFuZFxuICAgICAgICAgICAgICAtLSBhdCBsZWFzdCAzIGNvZGUgdW5pdHMgb2YgMiBieXRlcyBlYWNoLCBpLmUuIDIgY29kZSB1bml0IGZvciB0aGUgc3Vycm9nYXRlXG4gICAgICAgICAgICAgIC0tIHBhaXIsIGFuZCBvbmUgdW5pdCBmb3IgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLiBOb3RlIHRoYXQgd2UgZG8gbm90XG4gICAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgICAgLS0gTm90ZSB0aGF0IGBlbmRfcG9zIC0gaScgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgIC0tIHRvIHByb2Nlc3MgaW4gdGhlIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDYgKyAoZW5kX3BvcyAtIGkpICogMiA+IGxfY291bnQpIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBPcHRpbWl6ZSByZXNpemluZywgb25jZSB3ZSBoYXZlIHRvIHJlc2l6ZSwgd2UgYWN0dWFsbHkgcGVyZm9ybSB0aGUgcmVzaXppbmdcbiAgICAgICAgICAgICAgICAtLSBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgIGxfY291bnQgOj0gbSArIHV0Zl8xNl9ieXRlc19jb3VudCAocywgaSwgZW5kX3BvcykgKyAyXG4gICAgICAgICAgICAgIHAucmVzaXplIChsX2NvdW50KVxuICAgICAgICAgICAgICBsX3Jlc2l6ZWQgOj0gVHJ1ZVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgICAgICAgLS0gV3JpdGUgdGhlIGxlYWQgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2ICgoMHhEN0MwICsgKGMgfD4+IDEwKSkudG9fbmF0dXJhbF8xNiwgbSlcblxuICAgICAgICAgICAgICAtLSBXcml0ZSB0aGUgdHJhaWwgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2ICgoMHhEQzAwICsgKGMgJiAweDNGRikpLnRvX25hdHVyYWxfMTYsIG0gKyAyKVxuXG4gICAgICAgICAgICBtIDo9IG0gKyA0XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2RlY29kZWQgOj0gRmFsc2VcbiAgICAgICAgICAgIC0tIFNpbXBseSBwdXQgZGVjb2RlZCB2YWx1ZSBkaXJlY3RseSBpbiBzdHJlYW0uXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoYy50b19uYXR1cmFsXzE2LCBtKVxuICAgICAgICAgIG0gOj0gbSArIDJcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIGxfcmVzaXplZCB0aGVuXG4gICAgICAgICAgLS0gV2UgaGFkIHRvIGFkZCBhIGNvZGUgdW5pdCBvbiA0IGJ5dGVzLiBXZSBhZGp1c3QgdGhlIHNpemUuXG4gICAgICAgIHAucmVzaXplIChtICsgMilcbiAgICAgIGVuZFxuICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoMCwgbSlcbiAgICAgIGlmIGFfbmV3X3VwcGVyIC89IFZvaWQgdGhlblxuICAgICAgICBhX25ld191cHBlci5wdXQgKG0pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHBfY291bnRfbWF5X2luY3JlYXNlOiBwLmNvdW50ID49IG9sZCBwLmNvdW50XG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAoYV9uZXdfdXBwZXIuaXRlbSAvLyAyKSAtIDEsIEZhbHNlKS5zYW1lX3N0cmluZ19nZW5lcmFsIChzLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykuaGFzICgnJVUnKSkgaW1wbGllc1xuICAgICAgICB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTE2TEUgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UgdGhhdCBjb3VsZCBiZSBlc2NhcGVkLlxuICAgICAgLS0gSWYgYHMnIGNvbnRhaW5zIHRoZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWQgYnkgZWl0aGVyIFwiSEhcIiBvciBcInVISEhIXCIgd2hlcmUgSCBzdGFuZHNcbiAgICAgIC0tIGZvciBhbiBoZXhhZGVjaW1hbCBkaWdpdCwgdGhlbiBgcycgaGFzIGJlZW4gZXNjYXBlZCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gd2hhdCBpc1xuICAgICAgLS0gZXhwZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAtLSBPdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGFuZCBpdCB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gICAgICAtLSBTZWUgdGhlIG5vdGUgY2xhdXNlIGZvciB0aGUgY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZW5jb2RpbmcuXG4gICAgZG9cbiAgICAgICAgLS0gV2Ugd291bGQgbmVlZCBhdCBsZWFzdCAyLWJ5dGVzIHBlciBjaGFyYWN0ZXJzIGluIGBzJy5cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudCAqIDIpXG4gICAgICBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfaW50b191dGZfMTZsZV9zdHJpbmdfOCAocywgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfMTZsZV9zdHJpbmdfOF90b19lc2NhcGVkX3N0cmluZ18zMiAoUmVzdWx0KS5zYW1lX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGVzY2FwZWRfdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl8xNmxlX3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgYV9yZXN1bHQ6IFNUUklOR184KVxuICAgICAgLS0gQ29weSBVVEYtMTZMRSBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSB0aGF0IGNvdWxkIGJlXG4gICAgICAtLSBlc2NhcGVkIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICAgIC0tIElmIGBzJyBjb250YWlucyB0aGUgYGVzY2FwZV9jaGFyYWN0ZXInIGZvbGxvd2VkIGJ5IGVpdGhlciBcIkhIXCIgb3IgXCJ1SEhISFwiIHdoZXJlIEggc3RhbmRzXG4gICAgICAtLSBmb3IgYW4gaGV4YWRlY2ltYWwgZGlnaXQsIHRoZW4gYHMnIGhhcyBiZWVuIGVzY2FwZWQgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIHdoYXQgaXNcbiAgICAgIC0tIGV4cGVjdGVkIGJ5IHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAgLS0gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZCBhbmQgaXQgd2lsbCBiZSBsZWZ0IGFzIGlzLlxuICAgICAgLS0gU2VlIHRoZSBub3RlIGNsYXVzZSBmb3IgdGhlIGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdGhlIGVuY29kaW5nLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBuOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBsX25hdDE2OiBOQVRVUkFMXzE2XG4gICAgICBsX2VuY29kZWRfdmFsdWU6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICBsX2RlY29kZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBXZSB3b3VsZCBuZWVkIGF0IGxlYXN0IDItYnl0ZXMgcGVyIGNoYXJhY3RlcnMgaW4gYHMnLlxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4gKiAyKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBtaWdodCBiZSBmYWNpbmcgYSBjaGFyYWN0ZXIgdGhhdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICBpZiBpIDwgbiB0aGVuXG4gICAgICAgICAgICBpZiBzLml0ZW0gKGkgKyAxKSA9IGVzY2FwZV9jaGFyYWN0ZXIgdGhlblxuICAgICAgICAgICAgICAgIC0tIFRoZSBgZXNjYXBlX2NoYXJhY3Rlcicgd2FzIGVzY2FwZWQsIGl0IG1lYW50IHRoZXkgcmVhbGx5IHdhbnRlZCBhbiBgZXNjYXBlX2NoYXJhY3RlcicuXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVsc2VpZiBzLml0ZW0gKGkgKyAxKSA9ICd1JyB0aGVuXG4gICAgICAgICAgICAgIGlmIGkgKyA0IDwgbiB0aGVuXG4gICAgICAgICAgICAgICAgbF9lbmNvZGVkX3ZhbHVlIDo9IHMuc3Vic3RyaW5nIChpICsgMiwgaSArIDUpXG4gICAgICAgICAgICAgICAgaWYgaXNfaGV4YV9kZWNpbWFsIChsX2VuY29kZWRfdmFsdWUpIHRoZW5cbiAgICAgICAgICAgICAgICAgIGMgOj0gdG9fbmF0dXJhbF8zMiAobF9lbmNvZGVkX3ZhbHVlKVxuICAgICAgICAgICAgICAgICAgaWYgYyA8IDB4RDgwMCBvciBjID4gMHhERkZGIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAtLSBWYWx1ZSB3YXMgZW5jb2RlZCB3aGVuIGl0IHNob3VsZCBub3QgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgICAgICAgLS0gZG8gbm90aGluZywgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIGNvbnRlbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgIGMgOj0gZXNjYXBlX2NoYXJhY3Rlci5uYXR1cmFsXzMyX2NvZGVcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbF9kZWNvZGVkIDo9IFRydWVcbiAgICAgICAgICAgICAgICAgICAgaSA6PSBpICsgNVxuICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAtLSBOb3QgYW4gaGV4YWRlY2ltYWwgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgLS0gTm90IGVub3VnaCBjaGFyYWN0ZXJzIHRvIG1ha2UgYSAyLWJ5dGUgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFZhbHVlIHdhcyBtb3N0IGxpa2VseSBub3QgZW5jb2RlZCwgYmVjYXVzZSBpZiBpdCBkaWQsIGl0IHdvdWxkIGJlIHRoZVxuICAgICAgICAgICAgICAtLSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhIGJ5dGUgd2hpY2ggY2xlYXJseSBkaWQgbm90IG5lZWQgdG9cbiAgICAgICAgICAgICAgLS0gYmUgZXNjYXBlZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBOb3RoaW5nIG1vcmUgdG8gcmVhZCwgY2xlYXJseSBpdCB3YXMgbm90IGVuY29kZWQuXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGlmIG5vdCBsX2RlY29kZWQgdGhlblxuICAgICAgICAgIGlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgLS0gQ29kZXBvaW50IGZyb20gQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lOiBvbmUgMTYtYml0IGNvZGUgdW5pdC5cbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGMgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgJiAweEZGMDApIHw+PiA4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFdyaXRlIHRoZSBsZWFkIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgbF9uYXQxNiA6PSAoMHhEN0MwICsgKGMgfD4+IDEwKSkudG9fbmF0dXJhbF8xNlxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgobF9uYXQxNiAmIDB4MDBGRikudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgobF9uYXQxNiAmIDB4RkYwMCkgfD4+IDgpLnRvX2NoYXJhY3Rlcl84KVxuXG4gICAgICAgICAgICAgICAgLS0gV3JpdGUgdGhlIHRyYWlsIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgbF9uYXQxNiA6PSAoMHhEQzAwICsgKGMgJiAweDNGRikpLnRvX25hdHVyYWxfMTZcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGxfbmF0MTYgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGxfbmF0MTYgJiAweEZGMDApIHw+PiA4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfZGVjb2RlZCA6PSBGYWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHB1dCBkZWNvZGVkIHZhbHVlIGRpcmVjdGx5IGluIHN0cmVhbS5cbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChjICYgMHgwMEZGKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4RkYwMCkgfD4+IDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfMTZsZV9zdHJpbmdfOF90b19lc2NhcGVkX3N0cmluZ18zMiAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVVRGLTE2IHRvIFVURi0zMlxuXG4gIHV0Zl8xNl8wX3BvaW50ZXJfdG9fc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVIpOiBTVFJJTkdfMzJcbiAgICAgIC0tIHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgd2hpY2ggaXMgemVyby10ZXJtaW5hdGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIG1pbmltdW1fc2l6ZTogcC5jb3VudCA+PSAyXG4gICAgICB2YWxpZF9jb3VudDogcC5jb3VudCBcXFxcIDIgPSAwXG4gICAgZG9cbiAgICAgICAgLS0gQWxsb2NhdGUgUmVzdWx0IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJ5dGVzIGFzIGBwJy5cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocC5jb3VudClcbiAgICAgIHV0Zl8xNl8wX3BvaW50ZXJfaW50b19zdHJpbmdfMzIgKHAsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2X3N1YnBvaW50ZXIgKHAsIDAsIHAuY291bnQgLy8gMiwgVHJ1ZSkgaW1wbGllc1xuICAgICAgICBhY3Jvc3Mgc3RyaW5nXzMyX3RvX3V0Zl8xNiAoUmVzdWx0KSBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gcC5yZWFkX25hdHVyYWxfMTYgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyKSBlbmRcbiAgICBlbmRcblxuICB1dGZfMTZfMF9wb2ludGVyX2ludG9fc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IGFfcmVzdWx0OiBTVFJJTkdfMzIpXG4gICAgICAtLSBDb3B5IHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgd2hpY2ggaXMgemVyby10ZXJtaW5hdGVkXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgbWluaW11bV9zaXplOiBwLmNvdW50ID49IDJcbiAgICAgIHZhbGlkX2NvdW50OiBwLmNvdW50IFxcXFwgMiA9IDBcbiAgICBkb1xuICAgICAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX3N0cmluZ18zMiAocCwgMCwgcC5jb3VudCAvLyAyIC0gMSwgVHJ1ZSwgYV9yZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNl9zdWJwb2ludGVyIChwLCAwLCBwLmNvdW50IC8vIDIsIFRydWUpIGltcGxpZXNcbiAgICAgICAgYWNyb3NzIHN0cmluZ18zMl90b191dGZfMTYgKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gcC5yZWFkX25hdHVyYWxfMTYgKGxfc3BlYy50YXJnZXRfaW5kZXggKiAyKSBlbmRcbiAgICBlbmRcblxuICB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOKTogU1RSSU5HXzMyXG4gICAgICAtLSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHAnIGJldHdlZW4gY29kZSB1bml0cyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyBvciB0aGUgZmlyc3QgbnVsbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQgaWYgYGFfc3RvcF9hdF9udWxsJy5cbiAgICByZXF1aXJlXG4gICAgICBtaW5pbXVtX3NpemU6IHAuY291bnQgPj0gMlxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudCAvLyAyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocC5jb3VudClcbiAgICAgIHV0Zl8xNl8wX3N1YnBvaW50ZXJfaW50b19zdHJpbmdfMzIgKHAsIHN0YXJ0X3BvcywgZW5kX3BvcywgYV9zdG9wX2F0X251bGwsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2X3N1YnBvaW50ZXIgKHAsIHN0YXJ0X3BvcywgZW5kX3BvcywgYV9zdG9wX2F0X251bGwpIGltcGxpZXNcbiAgICAgICAgYWNyb3NzIHN0cmluZ18zMl90b191dGZfMTYgKFJlc3VsdCkgYXMgbF9zcGVjIGFsbCBsX3NwZWMuaXRlbSA9IHAucmVhZF9uYXR1cmFsXzE2IChsX3NwZWMudGFyZ2V0X2luZGV4ICogMikgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOOyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHAnIGJldHdlZW4gY29kZSB1bml0cyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyBvciB0aGUgZmlyc3QgbnVsbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQgaWYgYGFfc3RvcF9hdF9udWxsJyBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgbWluaW11bV9zaXplOiBwLmNvdW50ID49IDJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAwXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8IHAuY291bnQgLy8gMlxuICAgIGxvY2FsXG4gICAgICBpLCBuOiBJTlRFR0VSXG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgICAtLSBBbGxvY2F0ZSBSZXN1bHQgd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYnl0ZXMgYXMgY29waWVkIGZyb20gYHAnLlxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAqIDJcbiAgICAgICAgbiA6PSBlbmRfcG9zICogMlxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5cbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBwLnJlYWRfbmF0dXJhbF8xNiAoaSlcbiAgICAgICAgaWYgYyA9IDAgYW5kIGFfc3RvcF9hdF9udWxsIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhpdCBvdXIgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIsIHdlIGNhbiBzdG9wXG4gICAgICAgICAgaSA6PSBuICsgMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGlmIGMgPCAweEQ4MDAgb3IgYyA+PSAweEUwMDAgdGhlblxuICAgICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LlxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICBpZiBpIDw9IG4gdGhlblxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYy5hc19uYXR1cmFsXzMyIHw8PCAxMCkgKyBwLnJlYWRfbmF0dXJhbF8xNiAoaSkgLSAweDM1RkRDMDApLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNl9zdWJwb2ludGVyIChwLCBzdGFydF9wb3MsIGVuZF9wb3MsIGFfc3RvcF9hdF9udWxsKSBpbXBsaWVzXG4gICAgICAgIGFjcm9zcyBzdHJpbmdfMzJfdG9fdXRmXzE2IChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkgYXMgbF9zcGVjIGFsbCBsX3NwZWMuaXRlbSA9IHAucmVhZF9uYXR1cmFsXzE2IChsX3NwZWMudGFyZ2V0X2luZGV4ICogMikgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfcG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSKTogU1RSSU5HXzMyXG4gICAgICAtLSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHAnIHdoaWNoIGlzIHplcm8tdGVybWluYXRlZCxcbiAgICAgIC0tIHdoZXJlIGludmFsaWQgVVRGLTE2TEUgc2VxdWVuY2VzIGFyZSBlc2NhcGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIG1pbmltdW1fc2l6ZTogcC5jb3VudCA+PSAyXG4gICAgICB2YWxpZF9jb3VudDogcC5jb3VudCBcXFxcIDIgPSAwXG4gICAgZG9cbiAgICAgICAgLS0gQWxsb2NhdGUgUmVzdWx0IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJ5dGVzIGFzIGBwJy5cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocC5jb3VudClcbiAgICAgIHV0Zl8xNl8wX3BvaW50ZXJfaW50b19lc2NhcGVkX3N0cmluZ18zMiAocCwgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKFJlc3VsdCkgYXMgbF91dGYgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIGxfdXRmLm5ld19jdXJzb3IuaW5jcmVtZW50ZWQgKDEpIGFzIGxfc3RyIGFsbFxuICAgICAgICAgIChsX3V0Zi5jb2RlIChsX3N0ci5jdXJzb3JfaW5kZXgpIHwgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCArIDEpIHw8PCA4KSkgPSBwLnJlYWRfbmF0dXJhbF8xNiAobF9zdHIuY3Vyc29yX2luZGV4IC0gMSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfcG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IGFfcmVzdWx0OiBTVFJJTkdfMzIpXG4gICAgICAtLSBDb3B5IHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgd2hpY2ggaXMgemVyby10ZXJtaW5hdGVkLFxuICAgICAgLS0gd2hlcmUgaW52YWxpZCBVVEYtMTZMRSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQsIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICByZXF1aXJlXG4gICAgICBtaW5pbXVtX3NpemU6IHAuY291bnQgPj0gMlxuICAgICAgdmFsaWRfY291bnQ6IHAuY291bnQgXFxcXCAyID0gMFxuICAgIGRvXG4gICAgICB1dGZfMTZfMF9zdWJwb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHAsIDAsIHAuY291bnQgLy8gMiAtIDEsIFRydWUsIGFfcmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3V0ZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF91dGYubmV3X2N1cnNvci5pbmNyZW1lbnRlZCAoMSkgYXMgbF9zdHIgYWxsXG4gICAgICAgICAgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCkgfCAobF91dGYuY29kZSAobF9zdHIuY3Vyc29yX2luZGV4ICsgMSkgfDw8IDgpKSA9IHAucmVhZF9uYXR1cmFsXzE2IChsX3N0ci5jdXJzb3JfaW5kZXggLSAxKVxuICAgICAgICBlbmRcbiAgICBlbmRcblxuICB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUjsgYV9zdG9wX2F0X251bGw6IEJPT0xFQU4pOiBTVFJJTkdfMzJcbiAgICAgIC0tIHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgYmV0d2VlbiBjb2RlIHVuaXRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIG9yIHRoZSBmaXJzdCBudWxsIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBpZiBgYV9zdG9wX2F0X251bGwnLCB3aGVyZSBpbnZhbGlkXG4gICAgICAtLSBVVEYtMTZMRSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgcmVxdWlyZVxuICAgICAgbWluaW11bV9zaXplOiBwLmNvdW50ID49IDJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAwXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8IHAuY291bnQgLy8gMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBzdGFydF9wb3MsIGVuZF9wb3MsIGFfc3RvcF9hdF9udWxsLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoUmVzdWx0KSBhcyBsX3V0ZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF91dGYubmV3X2N1cnNvci5pbmNyZW1lbnRlZCAoMSkgYXMgbF9zdHIgYWxsXG4gICAgICAgICAgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCkgfCAobF91dGYuY29kZSAobF9zdHIuY3Vyc29yX2luZGV4ICsgMSkgfDw8IDgpKSA9IHAucmVhZF9uYXR1cmFsXzE2IChzdGFydF9wb3MgKiAyICsgbF9zdHIuY3Vyc29yX2luZGV4IC0gMSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUjsgYV9zdG9wX2F0X251bGw6IEJPT0xFQU47IGFfcmVzdWx0OiBTVFJJTkdfMzIpXG4gICAgICAtLSBDb3B5IHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgYmV0d2VlbiBjb2RlIHVuaXRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIG9yIHRoZSBmaXJzdCBudWxsIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBpZiBgYV9zdG9wX2F0X251bGwnLCB3aGVyZSBpbnZhbGlkXG4gICAgICAtLSBVVEYtMTZMRSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQsIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICByZXF1aXJlXG4gICAgICBtaW5pbXVtX3NpemU6IHAuY291bnQgPj0gMlxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudCAvLyAyXG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgICAgLS0gQWxsb2NhdGUgUmVzdWx0IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJ5dGVzIGFzIGNvcGllZCBmcm9tIGBwJy5cbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgaSA6PSBzdGFydF9wb3MgKiAyXG4gICAgICAgIG4gOj0gZW5kX3BvcyAqIDJcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuXG4gICAgICBsb29wXG4gICAgICAgIGMxIDo9IHAucmVhZF9uYXR1cmFsXzE2IChpKVxuICAgICAgICBpZiBjMSA9IDAgYW5kIGFfc3RvcF9hdF9udWxsIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhpdCBvdXIgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIsIHdlIGNhbiBzdG9wXG4gICAgICAgICAgaSA6PSBuICsgMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGlmIGMxIDwgMHhEODAwIG9yIGMxID49IDB4RTAwMCB0aGVuXG4gICAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMxLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBlbHNlaWYgYzEgPD0gMHhEQkZGIGFuZCB0aGVuIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICAgIC0tIENoZWNrIGlmIGEgbGVhZCBzdXJyb2dhdGUgKHZhbHVlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYpIGlzIGZvbGxvd2VkIGJ5IGEgdHJhaWwgc3Vycm9nYXRlLlxuICAgICAgICAgICAgYzIgOj0gcC5yZWFkX25hdHVyYWxfMTYgKGkpXG4gICAgICAgICAgICBpZiBjMiA+PSAweERDMDAgYW5kIGMyIDw9IDB4REZGRiB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3VwcGxlbWVudGFyeSBQbGFuZXM6IHN1cnJvZ2F0ZSBwYWlyIHdpdGggbGVhZCBhbmQgdHJhaWwgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMxIHw8PCAxMCkgKyBjMiAtIDB4MzVGREMwMCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLS0gRXNjYXBlIGEgbGVhZCBzdXJyb2dhdGUgbm90IGZvbGxvd2VkIGJ5IGEgdHJhaWwgb25lLlxuICAgICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEuYXNfbmF0dXJhbF8xNilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gRXNjYXBlIGEgdHJhaWwgc3Vycm9nYXRlIG5vdCBmb2xsb3dpbmcgYSBsZWFkIG9uZSBvclxuICAgICAgICAgICAgICAtLSBhIGxlYWQgc3Vycm9nYXRlIG5vdCBmb2xsb3dlZCBieSBhIHRyYWlsIG9uZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMS5hc19uYXR1cmFsXzE2KVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3V0ZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF91dGYubmV3X2N1cnNvci5pbmNyZW1lbnRlZCAoMSkgYXMgbF9zdHIgYWxsXG4gICAgICAgICAgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCkgfCAobF91dGYuY29kZSAobF9zdHIuY3Vyc29yX2luZGV4ICsgMSkgfDw8IDgpKSA9IHAucmVhZF9uYXR1cmFsXzE2IChzdGFydF9wb3MgKiAyICsgbF9zdHIuY3Vyc29yX2luZGV4IC0gMSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2X3RvX3N0cmluZ18zMiAoczogU1BFQ0lBTCBbTkFUVVJBTF8xNl0pOiBTVFJJTkdfMzJcbiAgICAgIC0tIHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcycuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl8xNl9pbnRvX3N0cmluZ18zMiAocywgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBpc192YWxpZF91dGZfMTYgKHMpIGltcGxpZXMgc3RyaW5nXzMyX3RvX3V0Zl8xNiAoUmVzdWx0KS5pc19lcXVhbCAocylcbiAgICBlbmRcblxuICB1dGZfMTZfaW50b19zdHJpbmdfMzIgKHM6IFNQRUNJQUwgW05BVFVSQUxfMTZdOyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHMnXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgbG9jYWxcbiAgICAgIGk6IGxpa2Uge1NQRUNJQUwgW05BVFVSQUxfMTZdfS5jb3VudFxuICAgICAgbjogbGlrZSB7U1BFQ0lBTCBbTkFUVVJBTF8xNl19LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbiA6PSBzLmNvdW50XG4gICAgICAgIGFfcmVzdWx0Lmdyb3cgKGFfcmVzdWx0LmNvdW50ICsgbilcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gblxuICAgICAgbG9vcFxuICAgICAgICBjIDo9IHMgW2ldXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgaWYgYyA8IDB4RDgwMCBvciBjID49IDB4RTAwMCB0aGVuXG4gICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LlxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoYy50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgaWYgaSA8IG4gdGhlblxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgfDw8IDEwKSArIHMgW2ldIC0gMHgzNUZEQzAwKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNiAocykgaW1wbGllcyBzdHJpbmdfMzJfdG9fdXRmXzE2IChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkuaXNfZXF1YWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzE2bGVfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IFNUUklOR18zMlxuICAgICAgLS0ge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnLlxuICAgIGRvXG4gICAgICAgIC0tIFRoZXJlIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChzLmNvdW50IHw+PiAxKVxuICAgICAgdXRmXzE2bGVfc3RyaW5nXzhfaW50b19zdHJpbmdfMzIgKHMsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2bGVfc3RyaW5nXzggKHMpIGltcGxpZXMgZXNjYXBlZF91dGZfMzJfc3RyaW5nX3RvX3V0Zl8xNmxlX3N0cmluZ184IChSZXN1bHQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHV0Zl8xNmxlX3N0cmluZ184X2ludG9fc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBUaGVyZSBpcyBhdCBsZWFzdCBoYWxmIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyAobmIgfD4+IDEpKVxuICAgICAgdW50aWxcbiAgICAgICAgaSArIDEgPj0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIC0tIEV4dHJhY3QgdGhlIGZpcnN0IDItYnl0ZXNcbiAgICAgICAgYzEgOj0gcy5jb2RlIChpIC0gMSkgfCAocy5jb2RlIChpKSB8PDwgOClcbiAgICAgICAgaWYgYzEgPCAweEQ4MDAgb3IgYzEgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQsIHRoaXMgaXMgdmFsaWQgVW5pY29kZS5cbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMxLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGkgOj0gaSArIDJcbiAgICAgICAgICBpZiBpIDw9IG5iIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHMuY29kZSAoaSAtIDEpIHwgKHMuY29kZSAoaSkgfDw8IDgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYzEgfDw8IDEwKSArIGMyIC0gMHgzNUZEQzAwKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNmxlX3N0cmluZ184IChzKSBpbXBsaWVzIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHV0Zl8xNmxlX3N0cmluZ184X3RvX2VzY2FwZWRfc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IFNUUklOR18zMlxuICAgICAgLS0ge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnLCB3aGVyZSBpbnZhbGlkIFVURi0xNkxFXG4gICAgICAtLSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgZG9cbiAgICAgICAgLS0gVGhlcmUgaXMgYXQgbGVhc3QgaGFsZiB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKHMuY291bnQgfD4+IDEpXG4gICAgICB1dGZfMTZsZV9zdHJpbmdfOF9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoUmVzdWx0KS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfMTZsZV9zdHJpbmdfOF9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnLCB3aGVyZSBpbnZhbGlkIFVURi0xNkxFXG4gICAgICAtLSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQsIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBUaGVyZSBpcyBhdCBsZWFzdCBoYWxmIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyAobmIgfD4+IDEpKVxuICAgICAgdW50aWxcbiAgICAgICAgaSArIDEgPj0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIC0tIEV4dHJhY3QgdGhlIGZpcnN0IDItYnl0ZXNcbiAgICAgICAgYzEgOj0gcy5jb2RlIChpIC0gMSkgfCAocy5jb2RlIChpKSB8PDwgOClcbiAgICAgICAgaWYgYzEgPCAweEQ4MDAgb3IgYzEgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjMS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgIGVsc2VpZiBjMSA8PSAweERCRkYgYW5kIGkgKyAyIDw9IG5iIHRoZW5cbiAgICAgICAgICAgIC0tIENoZWNrIGlmIGEgbGVhZCBzdXJyb2dhdGUgaXMgZm9sbG93ZWQgYnkgYSB0cmFpbCBzdXJyb2dhdGUuXG4gICAgICAgICAgYzIgOj0gcy5jb2RlIChpICsgMSkgfCAocy5jb2RlIChpICsgMikgfDw8IDgpXG4gICAgICAgICAgaWYgYzIgPj0gMHhEQzAwIGFuZCBjMiA8PSAweERGRkYgdGhlblxuICAgICAgICAgICAgICAtLSBTdXBwbGVtZW50YXJ5IFBsYW5lczogc3Vycm9nYXRlIHBhaXIgd2l0aCBsZWFkIGFuZCB0cmFpbCBzdXJyb2dhdGVzLlxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMxIHw8PCAxMCkgKyBjMiAtIDB4MzVGREMwMCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gRXNjYXBlIGEgbGVhZCBzdXJyb2dhdGUgbm90IGZvbGxvd2VkIGJ5IGEgdHJhaWwgb25lLlxuICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxLmFzX25hdHVyYWxfMTYpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEVzY2FwZSBhIHRyYWlsIHN1cnJvZ2F0ZSBub3QgZm9sbG93aW5nIGEgbGVhZCBvbmUgb3JcbiAgICAgICAgICAgIC0tIGEgbGVhZCBzdXJyb2dhdGUgbm90IGZvbGxvd2VkIGJ5IGEgdHJhaWwgb25lLlxuICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMS5hc19uYXR1cmFsXzE2KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBVVEYtMTYgdG8gVVRGLThcblxuICB1dGZfMTZfdG9fdXRmXzhfc3RyaW5nXzggKHM6IFNQRUNJQUwgW05BVFVSQUxfMTZdKTogU1RSSU5HXzhcbiAgICAgIC0tIFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2IHNlcXVlbmNlIGBzJy5cbiAgICBkb1xuICAgICAgZGVidWcgKFwidG9faW1wbGVtZW50XCIpXG4gICAgICAgIChjcmVhdGUge1JFRkFDVE9SSU5HX0hFTFBFUn0pLnRvX2ltcGxlbWVudCAoXCJDb252ZXJ0IGRpcmVjdGx5IGZyb20gVVRGLTE2IHRvIFVURi04LlwiKVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nXzMyX3RvX3V0Zl84X3N0cmluZ184ICh1dGZfMTZfdG9fc3RyaW5nXzMyIChzKSlcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2IChzKSBpbXBsaWVzIHN0cmluZ18zMl90b191dGZfMTYgKHV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAoUmVzdWx0KSkuaXNfZXF1YWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzE2X2ludG9fdXRmXzhfc3RyaW5nXzggKHM6IFNQRUNJQUwgW05BVFVSQUxfMTZdOyBhX3Jlc3VsdDogU1RSSU5HXzgpXG4gICAgICAtLSBDb3B5IFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2IHNlcXVlbmNlIGBzJyBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgZG9cbiAgICAgIGRlYnVnIChcInRvX2ltcGxlbWVudFwiKVxuICAgICAgICAoY3JlYXRlIHtSRUZBQ1RPUklOR19IRUxQRVJ9KS50b19pbXBsZW1lbnQgKFwiQ29udmVydCBkaXJlY3RseSBmcm9tIFVURi0xNiB0byBVVEYtOC5cIilcbiAgICAgIGVuZFxuICAgICAgc3RyaW5nXzMyX2ludG9fdXRmXzhfc3RyaW5nXzggKHV0Zl8xNl90b19zdHJpbmdfMzIgKHMpLCBhX3Jlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2IChzKSBpbXBsaWVzIHN0cmluZ18zMl90b191dGZfMTYgKHV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpKS5pc19lcXVhbCAocylcbiAgICBlbmRcblxuICB1dGZfMTZsZV9zdHJpbmdfOF90b191dGZfOF9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBVVEYtMTZMRSBzZXF1ZW5jZSBgcycuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl8xNmxlX3N0cmluZ184X2ludG9fdXRmXzhfc3RyaW5nXzggKHMsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2bGVfc3RyaW5nXzggKHMpIGltcGxpZXMgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAodXRmXzhfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChSZXN1bHQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfMTZsZV9zdHJpbmdfOF9pbnRvX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfODsgYV9yZXN1bHQ6IFNUUklOR184KVxuICAgICAgLS0gQ29weSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIFVURi0xNkxFIHNlcXVlbmNlIGBzJyBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgZXZlbl9jb3VudDogKHMuY291bnQgJiAxKSA9IDBcbiAgICBsb2NhbFxuICAgICAgdjogU1BFQ0lBTCBbTkFUVVJBTF8xNl1cbiAgICAgIGk6IGxpa2Uge1NUUklOR184fS5jb3VudFxuICAgICAgbjogbGlrZSB7U1RSSU5HXzh9LmNvdW50XG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbiA6PSBzLmNvdW50XG4gICAgICAgIGNyZWF0ZSB2Lm1ha2VfZW1wdHkgKG4gfD4+IDEpXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICBjaGVja1xuICAgICAgICAgIHZhbGlkX2luZGV4OiAxIDw9IGkgLSAxIGFuZCBpIDw9IHMuY291bnRcbiAgICAgICAgZW5kXG4gICAgICAgIHYuZXh0ZW5kIChzIFtpIC0gMV0uY29kZS5hc19uYXR1cmFsXzE2IHwgKHMgW2ldLmNvZGUuYXNfbmF0dXJhbF8xNiB8PDwgOCkpXG4gICAgICBlbmRcbiAgICAgIHV0Zl8xNl9pbnRvX3V0Zl84X3N0cmluZ184ICh2LCBhX3Jlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2bGVfc3RyaW5nXzggKHMpIGltcGxpZXMgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAodXRmXzhfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFVURi04IHRvIFVURi0xNlxuXG4gIHV0Zl84X3N0cmluZ184X3RvX3V0Zl8xNiAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHMnLlxuICAgIGRvXG4gICAgICBkZWJ1ZyAoXCJ0b19pbXBsZW1lbnRcIilcbiAgICAgICAgKGNyZWF0ZSB7UkVGQUNUT1JJTkdfSEVMUEVSfSkudG9faW1wbGVtZW50IChcIkNvbnZlcnQgZGlyZWN0bHkgZnJvbSBVVEYtOCB0byBVVEYtMTYuXCIpXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfMzJfdG9fdXRmXzE2ICh1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKHMpKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBpc192YWxpZF91dGZfOF9zdHJpbmdfOCAocykgaW1wbGllcyB1dGZfMTZfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzhfc3RyaW5nXzhfdG9fdXRmXzE2XzAgKHM6IFJFQURBQkxFX1NUUklOR184KTogU1BFQ0lBTCBbTkFUVVJBTF8xNl1cbiAgICAgIC0tIFVURi0xNiBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIFVURi04IHNlcXVlbmNlIGBzJyB3aXRoIHRlcm1pbmF0aW5nIHplcm8uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1dGZfOF9zdHJpbmdfOF90b191dGZfMTYgKHMpXG4gICAgICBSZXN1bHQgOj0gUmVzdWx0LmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50ICsgMSlcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzhfc3RyaW5nXzggKHMpIGltcGxpZXMgdXRmXzE2X3RvX3V0Zl84X3N0cmluZ184IChSZXN1bHQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJ5dGUgT3JkZXIgTWFyayAoQk9NKVxuXG4gIHV0Zl84X2JvbV90b19zdHJpbmdfODogU1RSSU5HXzggPSBcIiUvMjM5LyUvMTg3LyUvMTkxL1wiXG4gICAgICAtLSBVVEYtOCBCT00gc2VxdWVuY2UuXG5cbiAgdXRmXzE2YmVfYm9tX3RvX3N0cmluZ184OiBTVFJJTkdfOCA9IFwiJS8yNTQvJS8yNTUvXCJcbiAgICAgIC0tIFVURi0xNkJFIEJPTSBzZXF1ZW5jZS5cblxuICB1dGZfMTZsZV9ib21fdG9fc3RyaW5nXzg6IFNUUklOR184ID0gXCIlLzI1NS8lLzI1NC9cIlxuICAgICAgLS0gVVRGLTE2TEUgQk9NIHNlcXVlbmNlLlxuXG4gIHV0Zl8zMmJlX2JvbV90b19zdHJpbmdfODogU1RSSU5HXzggPSBcIiVVJVUlLzI1NC8lLzI1NS9cIlxuICAgICAgLS0gVVRGLTMyQkUgQk9NIHNlcXVlbmNlLlxuXG4gIHV0Zl8zMmxlX2JvbV90b19zdHJpbmdfODogU1RSSU5HXzggPSBcIiUvMjU1LyUvMjU0LyVVJVVcIlxuICAgICAgLS0gVVRGLTMyTEUgQk9NIHNlcXVlbmNlLlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVzY2FwZV9jb2RlX2ludG8gKGFfc3RyaW5nOiBTVFJJTkdfMzI7IGFfY29kZTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEVzY2FwZSBgYV9jb2RlJyBhcyBkb2N1bWVudGVkIGluIHRoZSBub3RlIGNsYXVzZSBvZiB0aGUgY2xhc3MgaW50byBgYV9zdHJpbmcnLlxuICAgICAgLS0gSWYgYGFfY29kZScgZml0cyBpbnRvIGEgTkFUVVJBTF84LCBpdCB3aWxsIGJlIGp1c3QgdGhlIGBlc2NhcGVfY2hhcmFjdGVyJyBmb2xsb3dlZFxuICAgICAgLS0gYnkgdGhlIDItZGlnaXQgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24sIG90aGVyd2lzZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWRcbiAgICAgIC0tIGJ5IHRoZSBsZXR0ZXIgYHUnIGZvbGxvd2VkIGJ5IHRoZSA0LWRpZ2l0IGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICAgIGRvXG4gICAgICBhX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyIChlc2NhcGVfY2hhcmFjdGVyKVxuICAgICAgaWYgYV9jb2RlIDw9IHtOQVRVUkFMXzh9Lm1heF92YWx1ZSB0aGVuXG4gICAgICAgIGFfc3RyaW5nLmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYV9jb2RlLmFzX25hdHVyYWxfOC50b19oZXhfc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBhX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyICgndScpXG4gICAgICAgIGFfc3RyaW5nLmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYV9jb2RlLnRvX2hleF9zdHJpbmcpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19oZXhhX2RlY2ltYWwgKGFfc3RyaW5nOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBhX3N0cmluZycgYSB2YWxpZCBoZXhhZGVjaW1hbCBzZXF1ZW5jZT9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3RvaV9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3RvaV9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnJlc2V0ICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9uYXR1cmFsXzMyKVxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoYV9zdHJpbmcsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfMzIpXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IuaXNfaW50ZWdyYWxfaW50ZWdlclxuICAgIGVuZFxuXG4gIHRvX25hdHVyYWxfMzIgKGFfaGV4X3N0cmluZzogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGhleGFkZWNpbWFsIHZhbHVlIGBhX2hleF9zdHJpbmcnIHRvIGl0cyBjb3JyZXNwb25kaW5nIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfaGV4YTogaXNfaGV4YV9kZWNpbWFsIChhX2hleF9zdHJpbmcpXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChhX2hleF9zdHJpbmcsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBjdG9pX2NvbnZlcnRvcjogSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byBpbnRlZ2VyIG9yIG5hdHVyYWxcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKEZhbHNlKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKEZhbHNlKVxuICAgIGVuc3VyZVxuICAgICAgY3RvaV9jb252ZXJ0b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6IFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==