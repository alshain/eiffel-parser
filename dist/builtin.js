var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"abstract_special.e","content":"note\n  description: \"Ancestor of SPECIAL to perform queries on SPECIAL without knowing its actual generic type.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-04-12 16:54:50 -0700 (Fri, 12 Apr 2013) $\"\n  revision: \"$Revision: 92440 $\"\n\ndeferred class\n  ABSTRACT_SPECIAL\n\ninherit\n  DEBUG_OUTPUT\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Count of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    deferred\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      create Result.make (12)\n      Result.append_string (\"count=\")\n      Result.append_integer (count)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"any.e","content":"class\n  ANY\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    external\n      \"built_in\"\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n  frozen dlo_nothing\n      -- Execute a null action.\n    do\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\n\nend\n"});
__eiffel_builtin.push({"filename":"array.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 14:18:20 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92138 $\"\n\nclass ARRAY [G] inherit\n\n  RESIZABLE [G]\n    redefine\n      full, copy, is_equal, resizable\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as item alias \"[]\"\n    redefine\n      copy, is_equal\n    end\n\n  TO_SPECIAL [G]\n    export\n      {ARRAY} set_area\n    redefine\n      copy, is_equal, item, put, at, valid_index\n    end\n\ncreate\n  make_empty,\n  make,\n  make_filled,\n  make_from_array,\n  make_from_special,\n  make_from_cil\n\nconvert\n  to_cil: {NATIVE_ARRAY [G]},\n  to_special: {SPECIAL [G]},\n  make_from_cil ({NATIVE_ARRAY [G]})\n\nfeature -- Initialization\n\n  make_empty\n      -- Allocate empty array starting at `1'.\n    do\n      lower := 1\n      upper := 0\n      make_empty_area (0)\n    ensure\n      lower_set: lower = 1\n      upper_set: upper = 0\n      items_set: all_default\n    end\n\n  make_filled (a_default_value: G; min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    require\n      valid_bounds: min_index <= max_index + 1\n    local\n      n: INTEGER\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        n := max_index - min_index + 1\n      end\n      make_filled_area (a_default_value, n)\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: filled_with (a_default_value)\n    end\n\n  make (min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    obsolete\n      \" `make' is not void-safe statically. Use `make_empty' or `make_filled' instead. [07-2010]\"\n    require\n      valid_bounds: min_index <= max_index + 1\n      has_default: min_index <= max_index implies ({G}).has_default\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        make_filled_area (({G}).default, max_index - min_index + 1)\n      else\n        make_empty_area (0)\n      end\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: all_default\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Initialize from the items of `a'.\n      -- (Useful in proper descendants of class `ARRAY',\n      -- to initialize an array-like object from a manifest array.)\n    require\n      array_exists: a /= Void\n    do\n      set_area (a.area)\n      lower := a.lower\n      upper := a.upper\n    ensure\n      shared: area = a.area\n      lower_set: lower = a.lower\n      upper_set: upper = a.upper\n    end\n\n  make_from_special (a: SPECIAL [G])\n      -- Initialize Current from items of `a'.\n    require\n      special_attached: a /= Void\n    do\n      set_area (a)\n      lower := 1\n      upper := a.count\n    ensure\n      shared: area = a\n      lower_set: lower = 1\n      upper_set: upper = a.count\n    end\n\n  make_from_cil (na: NATIVE_ARRAY [like item])\n      -- Initialize array from `na'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      na_not_void: na /= Void\n    do\n      create area.make_from_native_array (na)\n      lower := 1\n      upper := area.count\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): G assign put\n      -- Entry at index `i', if in index interval\n    do\n      Result := area.item (i - lower)\n    end\n\n  entry (i: INTEGER): G\n      -- Entry at index `i', if in index interval\n    require\n      valid_key: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  has (v: G): BOOLEAN\n      -- Does `v' appear in array?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      l_area := area\n      nb := upper - lower\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) ~ v\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) = v\n          i := i + 1\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER\n      -- Minimum index\n\n  upper: INTEGER\n      -- Maximum index\n\n  count, capacity: INTEGER\n      -- Number of available indices\n    do\n      Result := upper - lower + 1\n    ensure then\n      consistent_with_bounds: Result = upper - lower + 1\n    end\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n    local\n      i: INTEGER\n    do\n      if object_comparison then\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) ~ v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      else\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) = v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    ensure then\n      same_count: Result.count = count\n      same_bounds:\n        ((Result.lower = lower) and (Result.upper = upper))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif lower = other.lower and then upper = other.upper and then\n        object_comparison = other.object_comparison\n      then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := item (i) ~ other.item (i)\n            i := i + 1\n          end\n        else\n          Result := area.same_items (other.area, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    do\n      if count > 0 then\n        Result := ({G}).has_default and then area.filled_with (({G}).default, 0, upper - lower)\n      else\n        Result := True\n      end\n    ensure\n      definition: Result = (count = 0 or else\n        ((not attached item (upper) as i or else i = ({G}).default) and\n        subarray (lower, upper - 1).all_default))\n    end\n\n  filled_with (v: G): BOOLEAN\n      -- Are all items set to `v'?\n    do\n      Result := area.filled_with (v, 0, upper - lower)\n    ensure\n      definition: Result = (count = 0 or else\n        (item (upper) = v and subarray (lower, upper - 1).filled_with (v)))\n    end\n\n  full: BOOLEAN\n      -- Is structure filled to capacity? (Answer: yes)\n    do\n      Result := True\n    end\n\n  same_items (other: like Current): BOOLEAN\n      -- Do `other' and Current have same items?\n    require\n      other_not_void: other /= Void\n    do\n      if count = other.count then\n        Result := area.same_items (other.area, 0, 0, count)\n      end\n    ensure\n      definition: Result = ((count = other.count) and then\n        (count = 0 or else (item (upper) = other.item (other.upper)\n        and subarray (lower, upper - 1).same_items\n        (other.subarray (other.lower, other.upper - 1)))))\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the array?\n    do\n      Result := (lower <= i) and then (i <= upper)\n    end\n\n  extendible: BOOLEAN\n      -- May items be added?\n      -- (Answer: no, although array may be resized.)\n    do\n      Result := False\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: no.)\n    do\n      Result := False\n    end\n\n  resizable: BOOLEAN\n      -- Can array be resized automatically?\n    do\n      Result := ({G}).has_default\n    end\n\n  valid_index_set: BOOLEAN\n    do\n      Result := index_set.count = count\n    end\n\nfeature -- Element change\n\n  put (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area.put (v, i - lower)\n    end\n\n  enter (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_key: valid_index (i)\n    do\n      area.put (v, i - lower)\n    end\n\n  force (v: like item; i: INTEGER)\n      -- Assign item `v' to `i'-th entry.\n      -- Resize the array if `i' falls out of currently defined bounds; preserve existing items.\n      -- In void-safe mode, if ({G}).has_default does not hold, then you can only insert between\n      -- `lower - 1' or `upper + 1' position in the ARRAY.\n    require\n      has_default_if_too_low:\n        (i < lower - 1 and lower /= {like lower}.min_value) implies ({G}).has_default\n      has_default_if_too_high:\n        (i > upper + 1 and upper /= {like upper}.max_value) implies ({G}).has_default\n    local\n      old_size, new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      l_count, l_offset: INTEGER\n      l_increased_by_one: BOOLEAN\n    do\n      new_lower := lower.min (i)\n      new_upper := upper.max (i)\n      new_size := new_upper - new_lower + 1\n      l_increased_by_one := (i = upper + 1) or (i = lower - 1)\n      if empty_area then\n          -- List is empty. First we create an empty SPECIAL of the right capacity.\n        make_empty_area (new_size.max (additional_space))\n        if not l_increased_by_one then\n            -- We need to fill the SPECIAL for `0' to `new_size - 2' with the default value.\n          area.fill_with (({G}).default, 0, new_size - 2)\n        end\n        area.extend (v)\n      else\n        old_size := area.capacity\n        if new_size > old_size then\n          set_area (area.aliased_resized_area (new_size.max (old_size + additional_space)))\n        end\n        if new_lower < lower then\n            -- We have inserted below the previous `lower'. We need to shift entries to the right\n            -- before we can insert `v'.\n          l_offset := lower - new_lower\n          l_count := capacity\n          if not l_increased_by_one and l_offset > l_count then\n              -- With the `new_lower' given, the data has to move\n              -- beyond the `area''s count which requires us to fill\n              -- the gap between the old data's location and the new one\n              -- with the default value.\n            area.fill_with (({G}).default, l_count, l_offset - 1)\n          end\n          area.move_data (0, l_offset, l_count)\n          if not l_increased_by_one then\n              -- We start at `1' and not `0' because next instruction\n              -- will update the item at position `0'.\n            area.fill_with (({G}).default, 1, l_offset - 1)\n          end\n            -- Insert `v' at the new lower position.\n          area.put (v, 0)\n        else\n          if new_size > area.count then\n              -- We are adding to the new `upper' position. First we fill the non-initialized\n              -- elements if any up to `new_size - 2' (i.e. up the the item prior to `upper').\n            if not l_increased_by_one then\n              area.fill_with (({G}).default, area.count, new_size - 2)\n            end\n              -- Add `v' at upper position.\n            area.extend (v)\n          else\n              -- Here `lower' hasn't changed\n            area.put (v, i - lower)\n          end\n        end\n      end\n      lower := new_lower\n      upper := new_upper\n    ensure\n      inserted: item (i) = v\n      higher_count: count >= old count\n      lower_set: lower = (old lower).min (i)\n      upper_set: upper = (old upper).max (i)\n    end\n\n  fill_with (v: G)\n      -- Set items between `lower' and `upper' with `v'.\n    do\n      area.fill_with (v, 0, upper - lower)\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = old count\n      filled: filled_with (v)\n    end\n\n  subcopy (other: ARRAY [like item]; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy items of `other' within bounds `start_pos' and `end_pos'\n      -- to current array starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: start_pos >= other.lower\n      valid_end_pos: end_pos <= other.upper\n      valid_bounds: start_pos <= end_pos + 1\n      valid_index_pos: index_pos >= lower\n      enough_space: (upper - index_pos) >= (end_pos - start_pos)\n    do\n      area.copy_data (other.area, start_pos - other.lower, index_pos - lower, end_pos - start_pos + 1)\n    ensure\n      -- copied: forall `i' in 0 .. (`end_pos'-`start_pos'),\n      --     item (index_pos + i) = other.item (start_pos + i)\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    do\n      area.do_all_in_bounds (action, 0, count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    do\n      area.do_if_in_bounds (action, test, 0, count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.there_exists_in_bounds (test, 0, count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.for_all_in_bounds (test, 0, count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Removal\n\n  wipe_out\n      -- Make array empty.\n    obsolete\n      \"Not applicable since not `prunable'. Use `discard_items' instead.\"\n    do\n      discard_items\n    end\n\n  discard_items\n      -- Reset all items to default values with reallocation.\n    require\n      has_default: ({G}).has_default\n    do\n      create area.make_filled (({G}).default, capacity)\n    ensure\n      default_items: all_default\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    require\n      has_default: ({G}).has_default\n    do\n      area.fill_with (({G}).default, 0, area.count - 1)\n    ensure\n      stable_lower: lower = old lower\n      stable_upper: upper = old upper\n      default_items: all_default\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all items except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    do\n      if n < count then\n        upper := lower + n - 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_lower: lower = old lower\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all items except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        lower := upper - n + 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_upper: upper = old upper\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_upper: upper = old upper\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_head (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_lower: lower = old lower\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > capacity then\n        conservative_resize_with_default (({G}).default, lower, upper + i - capacity)\n      end\n    end\n\n  conservative_resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \" `conservative_resize' is not void-safe statically. Use `conservative_resize_with_default' instead. [07-2010]\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  conservative_resize_with_default (a_default_value: G; min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    require\n      good_indices: min_index <= max_index\n    local\n      new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      offset: INTEGER\n    do\n      if empty_area then\n        set_area (area.aliased_resized_area_with_default (a_default_value, max_index - min_index + 1))\n        lower := min_index\n        upper := max_index\n      else\n        new_lower := min_index.min (lower)\n        new_upper := max_index.max (upper)\n        new_size := new_upper - new_lower + 1\n        if new_size > area.count then\n          set_area (area.aliased_resized_area_with_default (a_default_value, new_size))\n        end\n        if new_lower < lower then\n          offset := lower - new_lower\n          area.move_data (0, offset, upper - lower + 1)\n          area.fill_with (a_default_value, 0, offset - 1)\n        end\n        lower := new_lower\n        upper := new_upper\n      end\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \"Use `conservative_resize_with_default' instead as future versions will implement `resize' as specified in ELKS.\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area.capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: same_items (old twin)\n    end\n\n  rebase (a_lower: like lower)\n      -- Without changing the actual content of `Current' we set `lower' to `a_lower'\n      -- and `upper' accordingly to `a_lower + count - 1'.\n    local\n      l_old_lower: like lower\n    do\n      l_old_lower := lower\n      lower := a_lower\n      upper := a_lower + (upper - l_old_lower)\n    ensure\n      lower_set: lower = a_lower\n      upper_set: upper = a_lower + old count - 1\n    end\n\nfeature -- Conversion\n\n  to_c: ANY\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    do\n      Result := area\n    end\n\n  to_cil: NATIVE_ARRAY [G]\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := area.native_array\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_special: SPECIAL [G]\n      -- 'area'.\n    do\n      Result := area\n    ensure\n      to_special_not_void: Result /= Void\n    end\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [G]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := lower\n      until\n        i > upper\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area.twin)\n      end\n    ensure then\n      equal_areas: area ~ other.area\n    end\n\n  subarray (start_pos, end_pos: INTEGER): ARRAY [G]\n      -- Array made of items of current array within\n      -- bounds `start_pos' and `end_pos'.\n    require\n      valid_start_pos: valid_index (start_pos)\n      valid_end_pos: end_pos <= upper\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n    do\n      if start_pos <= end_pos then\n        create Result.make_filled (item (start_pos), start_pos, end_pos)\n          -- Only copy elements if needed.\n        Result.subcopy (Current, start_pos, end_pos, start_pos)\n      else\n          -- make empty\n        create Result.make_empty\n        Result.rebase (start_pos)\n      end\n    ensure\n      lower: Result.lower = start_pos\n      upper: Result.upper = end_pos\n      -- copied: forall `i' in `start_pos' .. `end_pos',\n      --     Result.item (i) = item (i)\n    end\n\nfeature {NONE} -- Inapplicable\n\n  prune (v: G)\n      -- Remove first occurrence of `v' if any.\n      -- (Precondition is False.)\n    do\n    end\n\n  extend (v: G)\n      -- Add `v' to structure.\n      -- (Precondition is False.)\n    do\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: BOOLEAN\n      -- Is `area' empty?\n    do\n      Result := area = Void or else area.capacity = 0\n    end\n\ninvariant\n\n  area_exists: area /= Void\n  consistent_size: capacity = upper - lower + 1\n  non_negative_count: count >= 0\n  index_set_has_same_count: valid_index_set\n-- Internal discussion haven't reached an agreement on this invariant\n--  index_set_has_same_bounds: ((index_set.lower = lower) and\n--        (index_set.upper = lower + count - 1))\n\nend\n"});
__eiffel_builtin.push({"filename":"bag.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bag, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BAG [G] inherit\n\n  COLLECTION [G]\n    redefine\n      extend\n    end\n\nfeature -- Measurement\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      non_negative_occurrences: Result >= 0\n    end\n\nfeature -- Element change\n\n  extend (v: G)\n      -- Add a new occurrence of `v'.\n    deferred\n    ensure then\n        -- Commented due to the expensive nature of the check when inserting a new item\n        -- in a containers with many items.\n      -- one_more_occurrence: occurrences (v) = old (occurrences (v)) + 1\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"boolean.e","content":"note\n  description: \"Truth values, with the boolean operations\"\n  external_name: \"System.Boolean\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class BOOLEAN\n\ninherit\n  BOOLEAN_REF\n    redefine\n      conjuncted,\n      conjuncted_semistrict,\n      disjuncted,\n      disjuncted_semistrict,\n      disjuncted_exclusive,\n      implication,\n      negated\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({BOOLEAN_REF})\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: BOOLEAN): BOOLEAN\n      -- Boolean conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  implication alias \"implies\" (other: BOOLEAN): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    external\n      \"built_in\"\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    external\n      \"built_in\"\n    end\n\n  disjuncted alias \"or\" (other: BOOLEAN): BOOLEAN\n      -- Boolean disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: BOOLEAN): BOOLEAN\n      -- Boolean exclusive or with `other'\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"boolean_ref.e","content":"note\n  description: \"References to objects containing a boolean value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass BOOLEAN_REF inherit\n\n  HASHABLE\n    redefine\n      out\n    end\n\nfeature -- Access\n\n  item: BOOLEAN\n      -- Boolean value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      if item then\n        Result := 1\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: BOOLEAN_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: BOOLEAN_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n      same_item: Result.item = item\n    end\n\n  to_integer: INTEGER\n      -- 1 if `True'\n      -- 0 if `False'\n    do\n      if item then\n        Result := 1\n      end\n    ensure\n      not_item_implies_zero: not item implies Result = 0\n      item_implies_one: item implies Result = 1\n    end\n\nfeature -- Element change\n\n  set_item (b: BOOLEAN)\n      -- Make `b' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: like Current): BOOLEAN\n      -- Boolean conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and other.item\n    ensure\n      de_morgan: Result = not (not Current or not other)\n      commutative: Result = (other and Current)\n      consistent_with_semi_strict: Result implies (Current and then other)\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and then other.item\n    ensure\n      de_morgan: Result = not (not Current or else not other)\n    end\n\n  implication alias \"implies\" (other: like Current): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    require\n      other_exists: other /= Void\n    do\n      Result := item implies other.item\n    ensure\n      definition: Result = (not Current or else other)\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    do\n      Result := not item\n    end\n\n  disjuncted alias \"or\" (other: like Current): BOOLEAN\n      -- Boolean disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or other.item\n    ensure\n      de_morgan: Result = not (not Current and not other)\n      commutative: Result = (other or Current)\n      consistent_with_semi_strict: Result implies (Current or else other)\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or else other.item\n    ensure\n      de_morgan: Result = not (not Current and then not other)\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: like Current): BOOLEAN\n      -- Boolean exclusive or with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item xor other.item\n    ensure\n      definition: Result = ((Current or other) and not (Current and other))\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of boolean\n    do\n      Result := \"False\"\n      if item then\n        Result := \"True\"\n      end\n    end\n\ninvariant\n  involutive_negation: (not (not Current)).item = item\n  non_contradiction: not ((not Current) and Current)\n  completeness: (not Current) or Current\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"bounded.e","content":"note\n  description: \"Bounded data structures, with a notion of capacity.\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bounded, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOUNDED [G] inherit\n\n  FINITE [G]\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Number of items that may be stored\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure full?\n    do\n      Result := (count = capacity)\n    end\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed?\n    deferred\n    end\n\ninvariant\n\n  valid_count: count <= capacity\n  full_definition: full = (count = capacity)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"box.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOX [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure filled to capacity?\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"character_32.e","content":"note\n  description: \"Unicode characters, with comparison operations\"\n  assembly: \"mscorlib\"\n  external_name: \"System.UInt32\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_32\n\ninherit\n  CHARACTER_32_REF\n    redefine\n      code,\n      natural_32_code,\n      to_character_8\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_32_REF})\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"character_32_ref.e","content":"note\n  description: \"References to objects containing a unicode character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  CHARACTER_32_REF\n\ninherit\n  COMPARABLE\n    redefine\n      is_equal, out\n    end\n\n  HASHABLE\n    redefine\n      is_equal, out\n    end\n\nfeature -- Access\n\n  item: CHARACTER_32\n      -- Unicode character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := natural_32_code.as_integer_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.natural_32_code\n    ensure\n      natural_32_code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  min_value: NATURAL_32 = 0\n  max_value: NATURAL_32 = 4294967295\n      -- Bounds for integer representation of CHARACTER_32\n\n  max_unicode_value: NATURAL_32 = 0x10FFFD\n      -- Maximum Unicode characters.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: NATURAL_32): CHARACTER_32\n      -- Add `incr' to the code of `item'.\n    require\n      valid_increment: (item.natural_32_code.to_natural_64 + incr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code + incr).to_character_32\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: NATURAL_32): CHARACTER_32\n      -- Subtract `decr' from the code of `item'.\n    require\n      valid_decrement: (item.natural_32_code.to_integer_64 - decr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code - decr).to_character_32\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_32): INTEGER_64\n      -- Difference between the codes of `item' and `other'.\n    do\n      Result := item.natural_32_code.to_integer_64 - other.natural_32_code.to_integer_64\n    ensure\n      valid_non_negative_result: Result >= 0 implies ((other + Result.to_natural_32) = item)\n      valid_negative_result: Result < 0 implies (other = (item + Result.to_natural_32))\n    end\n\n  next: CHARACTER_32\n      -- Next character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 + 1).is_valid_character_32_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_32\n      -- Previous character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 - 1).is_valid_character_32_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_32)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of wide character.\n    do\n      create Result.make (6)\n      Result.append_character ('U')\n      Result.append_character ('+')\n      Result.append_string (natural_32_code.to_hex_string)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_32_REF\n      -- Associated reference of Current.\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8.\n    require\n      is_character_8_compatible: is_character_8\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Convert current to CHARACTER_32.\n    do\n      Result := item\n    end\n\n  as_upper, upper: CHARACTER_32\n      -- Uppercase value of `item'.\n      -- Returns `item' if not `is_lower'.\n    do\n      Result := properties.to_upper (item)\n    end\n\n  as_lower, lower: CHARACTER_32\n      -- Lowercase value of `item'.\n      -- Returns `item' if not `is_upper'.\n    do\n      Result := properties.to_lower (item)\n    end\n\nfeature -- Status report\n\n  is_character_8: BOOLEAN\n      -- Can current be represented on a CHARACTER_8?\n    do\n      Result := natural_32_code <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'.\n    do\n      Result := properties.is_alpha (item)\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := properties.is_upper (item)\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := properties.is_lower (item)\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789.\n    do\n      Result := '0' <= item and item <= '9'\n    end\n\n  is_unicode_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for Unicode characters?\n    do\n      Result := properties.is_digit (item)\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' a hexadecimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789ABCDEFabcedf.\n    do\n      Result := properties.is_hexa_digit (item)\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := properties.is_space (item)\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := properties.is_punctuation (item)\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := properties.is_alpha (item) or properties.is_digit (item)\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := properties.is_control (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  properties: CHARACTER_PROPERTY\n      -- Property for Unicode characters.\n    once\n      create Result.make\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8.e","content":"note\n  description: \"Characters, with comparison operations and an ASCII code\"\n  external_name: \"System.Char\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_8\n\ninherit\n  CHARACTER_8_REF\n    redefine\n      code,\n      to_character_32\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_8_REF}),\n  to_character_32: {CHARACTER_32}\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8_ref.e","content":"note\n  description: \"References to objects containing a character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass CHARACTER_8_REF inherit\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      out, is_equal\n    end\n\nfeature -- Access\n\n  item: CHARACTER_8\n      -- Character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := item.code\n    ensure\n      code_non_negatif: Result >= 0\n      code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.code.to_natural_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  min_value: INTEGER = 0\n  max_value: INTEGER = 255\n  max_ascii_value: INTEGER = 127\n      -- Bounds for integer representation of characters (ASCII)\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: INTEGER): CHARACTER_8\n      -- Add `incr' to the code of `item'\n    require\n      valid_increment: (item.code + incr).is_valid_character_8_code\n    do\n      Result := (item.code + incr).to_character_8\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: INTEGER): CHARACTER_8\n      -- Subtract `decr' from the code of `item'\n    require\n      valid_decrement: (item.code - decr).is_valid_character_8_code\n    do\n      Result := (item.code - decr).to_character_8\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_8): INTEGER\n      -- Difference between the codes of `item' and `other'\n    do\n      Result := item.code - other.code\n    ensure\n      valid_result: other + Result = item\n    end\n\n  next: CHARACTER_8\n      -- Next character\n    require\n      valid_character: (item.code + 1).is_valid_character_8_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_8\n      -- Previous character\n    require\n      valid_character: (item.code - 1).is_valid_character_8_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_8)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of character\n    do\n      create Result.make (1)\n      Result.append_character (item)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version\n    do\n      Result := item\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    do\n      Result := item.to_character_32\n    end\n\n  as_upper, upper: CHARACTER_8\n      -- Uppercase value of `item'\n      -- Returns `item' if not `is_lower'\n    do\n      if is_lower then\n        Result := (item.code - ('a').code + ('A').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\n  as_lower, lower: CHARACTER_8\n      -- Lowercase value of `item'\n      -- Returns `item' if not `is_upper'\n    do\n      if is_upper then\n        Result := (item.code - ('A').code + ('a').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\nfeature -- Status report\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag)) > 0\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := (character_types (item.code) & is_upper_flag) > 0\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := (character_types (item.code) & is_lower_flag) > 0\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a digit?\n      -- A digit is one of 0123456789\n    do\n      Result := (character_types (item.code) & is_digit_flag) > 0\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' an hexadecimal digit?\n      -- A digit is one of 0123456789ABCDEFabcedf\n    do\n      Result := (character_types (item.code) & (is_hexa_digit_flag | is_digit_flag)) > 0\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := (character_types (item.code) & is_white_space_flag) > 0\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := (character_types (item.code) & is_punctuation_flag) > 0\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag | is_digit_flag)) > 0\n    end\n\n  is_printable: BOOLEAN\n      -- Is `item' a printable character including space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag | is_space_flag)) > 0\n    end\n\n  is_graph: BOOLEAN\n      -- Is `item' a printable character except space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag)) > 0\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := (character_types (item.code) & is_control_flag) > 0\n    end\n\nfeature {NONE} -- Implementation\n\n  character_types (a_code: INTEGER): NATURAL_8\n      -- Associated type for character of code `a_code'\n    do\n        -- For character whose code is above 256, it is as if\n        -- we had no information about it.\n      if a_code < 256 then\n        Result := internal_character_types.item (a_code)\n      end\n    end\n\n  internal_character_types: SPECIAL [NATURAL_8]\n      -- Array which stores the various type for the ASCII characters\n    once\n      create Result.make_empty (256)\n      Result.extend (is_control_flag)             -- 0  null\n      Result.extend (is_control_flag)                         -- 1  start of heading\n      Result.extend (is_control_flag)                         -- 2  start of text\n      Result.extend (is_control_flag)                         -- 3  end of text\n      Result.extend (is_control_flag)                         -- 4  end of transmission\n      Result.extend (is_control_flag)                         -- 5  enquiry\n      Result.extend (is_control_flag)                         -- 6  acknowledge\n      Result.extend (is_control_flag)                         -- 7  bell\n      Result.extend (is_control_flag)                         -- 8  backspace\n      Result.extend (is_control_flag | is_white_space_flag)   -- 9  horizontal tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 10 NL line feed, new line\n      Result.extend (is_control_flag | is_white_space_flag)   -- 11 vertical tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 12 NP form feed, new page\n      Result.extend (is_control_flag | is_white_space_flag)   -- 13 carriage return=CR\n      Result.extend (is_control_flag)                         -- 14 shift out\n      Result.extend (is_control_flag)                         -- 15 shift in\n      Result.extend (is_control_flag)                         -- 16\n      Result.extend (is_control_flag)                         -- 17\n      Result.extend (is_control_flag)                         -- 18\n      Result.extend (is_control_flag)                         -- 19\n      Result.extend (is_control_flag)                         -- 20\n      Result.extend (is_control_flag)                         -- 21\n      Result.extend (is_control_flag)                         -- 22\n      Result.extend (is_control_flag)                         -- 23\n      Result.extend (is_control_flag)                         -- 24\n      Result.extend (is_control_flag)                         -- 25\n      Result.extend (is_control_flag)                         -- 26\n      Result.extend (is_control_flag)                         -- 27 Escape\n      Result.extend (is_control_flag)                         -- 28 file separator\n      Result.extend (is_control_flag)                         -- 29 group separator\n      Result.extend (is_control_flag)                         -- 30 record separator\n      Result.extend (is_control_flag)                         -- 31 unit separator\n      Result.extend (is_white_space_flag | is_space_flag)     -- 32 Space\n      Result.extend (is_punctuation_flag)                     -- 33 !\n      Result.extend (is_punctuation_flag)                     -- 34 \"\n      Result.extend (is_punctuation_flag)                     -- 35 #\n      Result.extend (is_punctuation_flag)                     -- 36 $\n      Result.extend (is_punctuation_flag)                     -- 37 %\n      Result.extend (is_punctuation_flag)                     -- 38 &\n      Result.extend (is_punctuation_flag)                     -- 39 '\n      Result.extend (is_punctuation_flag)                     -- 40 (\n      Result.extend (is_punctuation_flag)                     -- 41 )\n      Result.extend (is_punctuation_flag)                     -- 42 *\n      Result.extend (is_punctuation_flag)                     -- 43 +\n      Result.extend (is_punctuation_flag)                     -- 44 ,\n      Result.extend (is_punctuation_flag)                     -- 45 -\n      Result.extend (is_punctuation_flag)                     -- 46 .\n      Result.extend (is_punctuation_flag)                     -- 47 /\n      Result.extend (is_digit_flag)                           -- 48 0\n      Result.extend (is_digit_flag)                           -- 49 1\n      Result.extend (is_digit_flag)                           -- 50 2\n      Result.extend (is_digit_flag)                           -- 51 3\n      Result.extend (is_digit_flag)                           -- 52 4\n      Result.extend (is_digit_flag)                           -- 53 5\n      Result.extend (is_digit_flag)                           -- 54 6\n      Result.extend (is_digit_flag)                           -- 55 7\n      Result.extend (is_digit_flag)                           -- 56 8\n      Result.extend (is_digit_flag)                           -- 57 9\n      Result.extend (is_punctuation_flag)                     -- 58 :\n      Result.extend (is_punctuation_flag)                     -- 59 ;\n      Result.extend (is_punctuation_flag)                     -- 60 <\n      Result.extend (is_punctuation_flag)                     -- 61 =\n      Result.extend (is_punctuation_flag)                     -- 62 >\n      Result.extend (is_punctuation_flag)                     -- 63 ?\n      Result.extend (is_punctuation_flag)                     -- 64 @\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 65 A\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 66 B\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 67 C\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 68 D\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 69 E\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 70 F\n      Result.extend (is_upper_flag)                           -- 71 G\n      Result.extend (is_upper_flag)                           -- 72 H\n      Result.extend (is_upper_flag)                           -- 73 I\n      Result.extend (is_upper_flag)                           -- 74 J\n      Result.extend (is_upper_flag)                           -- 75 K\n      Result.extend (is_upper_flag)                           -- 76 L\n      Result.extend (is_upper_flag)                           -- 77 M\n      Result.extend (is_upper_flag)                           -- 78 N\n      Result.extend (is_upper_flag)                           -- 79 O\n      Result.extend (is_upper_flag)                           -- 80 P\n      Result.extend (is_upper_flag)                           -- 81 Q\n      Result.extend (is_upper_flag)                           -- 82 R\n      Result.extend (is_upper_flag)                           -- 83 S\n      Result.extend (is_upper_flag)                           -- 84 T\n      Result.extend (is_upper_flag)                           -- 85 U\n      Result.extend (is_upper_flag)                           -- 86 V\n      Result.extend (is_upper_flag)                           -- 87 W\n      Result.extend (is_upper_flag)                           -- 88 X\n      Result.extend (is_upper_flag)                           -- 89 Y\n      Result.extend (is_upper_flag)                           -- 90 Z\n      Result.extend (is_punctuation_flag)                     -- 91 [\n      Result.extend (is_punctuation_flag)                     -- 92 \\\n      Result.extend (is_punctuation_flag)                     -- 93 ]\n      Result.extend (is_punctuation_flag)                     -- 94 ^\n      Result.extend (is_punctuation_flag)                     -- 95 _\n      Result.extend (is_punctuation_flag)                     -- 96 `\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 97 a\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 98 b\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 99 c\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 100  d\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 101  e\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 102  f\n      Result.extend (is_lower_flag)                           -- 103  g\n      Result.extend (is_lower_flag)                           -- 104  h\n      Result.extend (is_lower_flag)                           -- 105  i\n      Result.extend (is_lower_flag)                           -- 106  j\n      Result.extend (is_lower_flag)                           -- 107  k\n      Result.extend (is_lower_flag)                           -- 108  l\n      Result.extend (is_lower_flag)                           -- 109  m\n      Result.extend (is_lower_flag)                           -- 110  n\n      Result.extend (is_lower_flag)                           -- 111  o\n      Result.extend (is_lower_flag)                           -- 112  p\n      Result.extend (is_lower_flag)                           -- 113  q\n      Result.extend (is_lower_flag)                           -- 114  r\n      Result.extend (is_lower_flag)                           -- 115  s\n      Result.extend (is_lower_flag)                           -- 116  t\n      Result.extend (is_lower_flag)                           -- 117  u\n      Result.extend (is_lower_flag)                           -- 118  v\n      Result.extend (is_lower_flag)                           -- 119  w\n      Result.extend (is_lower_flag)                           -- 120  x\n      Result.extend (is_lower_flag)                           -- 121  y\n      Result.extend (is_lower_flag)                           -- 122  z\n      Result.extend (is_punctuation_flag)                     -- 123  {\n      Result.extend (is_punctuation_flag)                     -- 124  |\n      Result.extend (is_punctuation_flag)                     -- 125  }\n      Result.extend (is_punctuation_flag)                     -- 126  ~\n      Result.extend (is_control_flag)                         -- 127  DEL\n      Result.fill_with (0, 128, 255)              -- extended ASCII\n    ensure\n      internal_character_types_not_void: Result /= Void\n    end\n\n  is_upper_flag: NATURAL_8 = 0x01\n\n  is_lower_flag: NATURAL_8 = 0x02\n\n  is_digit_flag: NATURAL_8 = 0x04\n\n  is_white_space_flag: NATURAL_8 = 0x08\n\n  is_punctuation_flag: NATURAL_8 = 0x10\n\n  is_control_flag: NATURAL_8 = 0x20\n\n  is_hexa_digit_flag: NATURAL_8 = 0x40\n\n  is_space_flag: NATURAL_8 = 0x80;\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"collection.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: collection, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class COLLECTION [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  extendible: BOOLEAN\n      -- May new items be added?\n    deferred\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed?\n    deferred\n    end\n\n  is_inserted (v: G): BOOLEAN\n      -- Has `v' been inserted by the most recent insertion?\n      -- (By default, the value returned is equivalent to calling\n      -- `has (v)'. However, descendants might be able to provide more\n      -- efficient implementations.)\n    do\n      Result := has (v)\n    end\n\nfeature -- Element change\n\n  put, extend (v: G)\n      -- Ensure that structure includes `v'.\n    require\n      extendible: extendible\n    deferred\n    ensure\n      item_inserted: is_inserted (v)\n    end\n\n  fill (other: CONTAINER [G])\n      -- Fill with as many items of `other' as possible.\n      -- The representations of `other' and current structure\n      -- need not be the same.\n    require\n      other_not_void: other /= Void\n      extendible: extendible\n    local\n      lin_rep: LINEAR [G]\n    do\n      lin_rep := other.linear_representation\n      from\n        lin_rep.start\n      until\n        not extendible or else lin_rep.off\n      loop\n        extend (lin_rep.item)\n        lin_rep.forth\n      end\n    end\n\nfeature -- Removal\n\n  prune (v: G)\n      -- Remove one occurrence of `v' if any.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    require\n      prunable: prunable\n    deferred\n    end\n\n  prune_all (v: G)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      --|Default implementation, usually inefficient.\n    require\n      prunable: prunable\n    do\n      from\n      until not has (v) loop\n        prune (v)\n      end\n    ensure\n      no_more_occurrences: not has (v)\n    end\n\n  wipe_out\n      -- Remove all items.\n    require\n      prunable: prunable\n    deferred\n    ensure\n      wiped_out: is_empty\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"comparable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class COMPARABLE inherit\n\n  PART_COMPARABLE\n    redefine\n      is_less, is_less_equal,\n      is_greater, is_greater_equal,\n      is_equal\n    end\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    deferred\n    ensure then\n      asymmetric: Result implies not (other < Current)\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    do\n      Result := not (other < Current)\n    ensure then\n      definition: Result = ((Current < other) or (Current ~ other))\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    do\n      Result := other < Current\n    ensure then\n      definition: Result = (other < Current)\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    do\n      Result := not (Current < other)\n    ensure then\n      definition: Result = (other <= Current)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := (not (Current < other) and not (other < Current))\n    ensure then\n      trichotomy: Result = (not (Current < other) and not (other < Current))\n    end\n\n  three_way_comparison (other: like Current): INTEGER\n      -- If current object equal to `other', 0;\n      -- if smaller, -1; if greater, 1\n    require\n      other_exists: other /= Void\n    do\n      if Current < other then\n        Result := -1\n      elseif other < Current then\n        Result := 1\n      end\n    ensure\n      equal_zero: (Result = 0) = (Current ~ other)\n      smaller_negative: (Result = -1) = (Current < other)\n      greater_positive: (Result = 1) = (Current > other)\n    end\n\n  max (other: like Current): like Current\n      -- The greater of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current >= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_smaller: Current >= other implies Result = Current\n      other_if_smaller: Current < other implies Result = other\n    end\n\n  min (other: like Current): like Current\n      -- The smaller of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current <= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_greater: Current <= other implies Result = Current\n      other_if_greater: Current > other implies Result = other\n    end\n\ninvariant\n\n  irreflexive_comparison: not (Current < Current)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"container.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class\n  CONTAINER [G]\n\nfeature -- Access\n\n  has (v: G): BOOLEAN\n      -- Does structure include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      not_found_in_empty: Result implies not is_empty\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is there no element?\n    deferred\n    end\n\n  empty: BOOLEAN\n      -- Is there no element?\n    obsolete\n      \"ELKS 2000: Use `is_empty' instead\"\n    do\n      Result := is_empty\n    end\n\n  object_comparison: BOOLEAN\n      -- Must search operations use `equal' rather than `='\n      -- for comparing references? (Default: no, use `='.)\n\n  changeable_comparison_criterion: BOOLEAN\n      -- May `object_comparison' be changed?\n      -- (Answer: yes by default.)\n    do\n      Result := True\n    end\n\nfeature -- Status setting\n\n  compare_objects\n      -- Ensure that future search operations will use `equal'\n      -- rather than `=' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := True\n    ensure\n      object_comparison\n    end\n\n  compare_references\n      -- Ensure that future search operations will use `='\n      -- rather than `equal' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := False\n    ensure\n      reference_comparison: not object_comparison\n    end\n\nfeature -- Conversion\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"debug_output.e","content":"note\n  description: \"Objects that provide an output in debugger\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-17 11:46:15 -0800 (Thu, 17 Jan 2013) $\"\n  revision: \"$Revision: 92124 $\"\n\ndeferred class\n  DEBUG_OUTPUT\n\nfeature -- Status report\n\n  debug_output: READABLE_STRING_GENERAL\n      -- String that should be displayed in debugger to represent `Current'.\n    deferred\n    ensure\n      result_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"finite.e","content":"note\n  description: \"Structures with a finite item count\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: finite, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class FINITE [G] inherit\n\n  BOX [G]\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of items\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    do\n      Result := (count = 0)\n    end\n\ninvariant\n  empty_definition: is_empty = (count = 0)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"hashable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  HASHABLE\n\nfeature -- Access\n\n  hash_code: INTEGER\n      -- Hash code value\n    deferred\n    ensure\n      good_hash_value: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True by default.)\n    do\n      Result := True\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class INDEXABLE [G, H -> INTEGER] inherit\n\n  TABLE [G, INTEGER]\n    rename\n      valid_key as valid_index,\n      force as put\n    end\n\n  READABLE_INDEXABLE [G]\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      asa_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\n-- convert\n--   make_from_reference ({INTEGER_32_REF}),\n--   to_real: {REAL_32},\n--   to_double: {REAL_64},\n--   to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := item & 0x7FFFFFFF\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_32 = -2147483648\n  Max_value: INTEGER_32 = 2147483647\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_32\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: INTEGER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_small: item >= {INTEGER_16}.Min_value\n      not_too_big: item <= {INTEGER_16}.Max_value\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER_32): INTEGER\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & (1 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | (1 |<< n)\n      else\n        Result := item & (1 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_32): INTEGER_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (11)\n      Result.append_integer (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"iterable.e","content":"note\n  description: \"Structure that can be iterated over using `across...loop...end'.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  ITERABLE [G]\n\nfeature -- Access\n\n  new_cursor: ITERATION_CURSOR [G]\n      -- Fresh cursor associated with current structure\n    deferred\n    ensure\n      result_attached: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"mismatch_corrector.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  MISMATCH_CORRECTOR\n\nfeature -- Correction\n\n  correct_mismatch\n      -- Attempt to correct object mismatch using `mismatch_information'.\n    local\n      l_msg: STRING\n      l_exc: EXCEPTIONS\n    do\n        -- If it is not redefined then we raise an exception.\n      create l_msg.make_from_string (\"Mismatch: \")\n      create l_exc\n      l_msg.append (generating_type)\n      l_exc.raise_retrieval_exception (l_msg)\n    end\n\n  mismatch_information: MISMATCH_INFORMATION\n      -- Original attribute values of mismatched object\n    once\n      create Result\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32.e","content":"note\n  description: \"Unsigned integer values coded on 32 bits.\"\n  external_name: \"System.UInt32\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_32 inherit\n\n  NATURAL_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_32_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_64: {INTEGER_64},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_32): NATURAL_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_32): NATURAL_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_32): NATURAL_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_32): NATURAL_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_32): NATURAL_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_32): NATURAL_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := (item & 0x7FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_32 = 0\n  Max_value: NATURAL_32 = 4294967295\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value.to_natural_32\n    ensure\n      in_bounds: Result = (\n        item >= {CHARACTER_8}.Min_value.to_natural_32 and\n        item <= {CHARACTER_8}.Max_value.to_natural_32)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: NATURAL_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_32\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_32\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_big: item <= {INTEGER_32}.Max_value.to_natural_32\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      a_digit, val: NATURAL_32\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & ((1).to_natural_32 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | ((1).to_natural_32 |<< n)\n      else\n        Result := item & ((1).to_natural_32 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_32): NATURAL_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_natural_32 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_8.e","content":"note\n  description: \"Integer values coded on 8 bits\"\n  external_name: \"System.Byte\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_8 inherit\n\n  NATURAL_8_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_8_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_16: {INTEGER_16},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64},\n  to_natural_16: {NATURAL_16},\n  to_natural_32: {NATURAL_32},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_8): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_8): NATURAL_8\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_8): NATURAL_8\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_8): NATURAL_8\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_8): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_8\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_8): NATURAL_8\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_8): NATURAL_8\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_8): NATURAL_8\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_8\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"natural_8_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 8 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_8_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_8\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead.\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_8 = 0\n  Max_value: NATURAL_8 = 255\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_8)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: NATURAL_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: V /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_8\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := 2\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 15)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      result_not_void: Result /= Void\n      result_valid_count: Result.count = 2\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      Result := tmp.to_hex_character\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_8: n <= 8\n      n_greater_or_equal_to_minus_8: n >= -8\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      Result := item & ((1).to_natural_8 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_8\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      if b then\n        Result := item | ((1).to_natural_8 |<< n)\n      else\n        Result := item & ((1).to_natural_8 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_8): NATURAL_8\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (3)\n      Result.append_natural_8 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"numeric.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n\n  NUMERIC\n\ninherit\n  DEBUG_OUTPUT\n    rename\n      debug_output as out\n    end\n\nfeature -- Access\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    obsolete\n      \"[2008_04_01] Will be removed since not used.\"\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other' (commutative).\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n      commutative: Result ~ (other + Current)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\ninvariant\n\n--  neutral_addition: equal (Current + zero, Current);\n--  self_subtraction: equal (Current - Current, zero);\n--  neutral_multiplication: equal (Current * one, Current);\n--  self_division: divisible (Current) implies equal (Current / Current, one)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"part_comparable.e","content":"note\n  description: \"Objects that may be compared according to a partial order relation\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  PART_COMPARABLE\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (Current < other) or (Current ~ other)\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := other < Current\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (other < Current) or (Current ~ other)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class READABLE_INDEXABLE [G]\n\ninherit\n  ITERABLE [G]\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): G\n      -- Entry at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  new_cursor: INDEXABLE_ITERATION_CURSOR [G]\n      -- <Precursor>\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nfeature -- Measurement\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    deferred\n    ensure\n      not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' a valid index?\n    deferred\n    ensure\n      only_if_in_index_set:\n        Result implies ((i >= index_set.lower) and (i <= index_set.upper))\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"readable_string_32.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:21:19 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95060 $\"\n\ndeferred class\n  READABLE_STRING_32\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    redefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    end\n\n  READABLE_INDEXABLE [CHARACTER_32]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_readable_string_8: {READABLE_STRING_8},\n  as_string_8: {STRING_8},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_32; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_32)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    deferred\n    ensure\n      not_shared_implementation: Current /= s\n      initialized: same_string_general (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_32_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c'.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_32): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_32; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    end\n\n  last_index_of (c: CHARACTER_32; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_32\n      -- New STRING_32 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_32\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_32}\n    do\n      if same_type (create {STRING_32}.make_empty) and then attached {STRING_32} Current as l_s32 then\n        Result := l_s32\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_32]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n        nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n      do\n        if other = Current then\n          Result := True\n        else\n          nb := count\n          if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n          end\n        end\n\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_32): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER_32\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_32): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = False\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = True\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN\n      -- <Precursor>\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      from\n        Result := True\n        i := area_lower\n        nb := count + i\n        l_area := area\n      until\n        i = nb or not Result\n      loop\n        Result := l_area.item (i).code <= {CHARACTER_8}.max_value\n        i := i + 1\n      end\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_prop: like character_properties\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n        l_prop := character_properties\n      until\n        i > n or not l_prop.is_space (l_area.item (i))\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_32): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    end\n\n  starts_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := True\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        Result := is_case_insensitive_equal_general (true_constant)\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        Result := is_case_insensitive_equal_general (false_constant)\n      end\n    end\n\nfeature {READABLE_STRING_32} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_32)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (as_string_8)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies same_string_general (Result)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_32_SEARCHER\n      -- String searcher specialized for READABLE_STRING_32 instances\n    once\n      create Result.make\n    end\n\nfeature {NONE} -- Implementation\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_lower (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_upper (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:22:02 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95061 $\"\n\ndeferred class\n  READABLE_STRING_8\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    redefine\n      copy, is_equal, out\n    end\n\n  READABLE_INDEXABLE [CHARACTER_8]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_string_8: {STRING_8},\n  as_readable_string_32: {READABLE_STRING_32},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_8; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_8)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_8_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c' instead.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8\n      -- Character at position `i'.\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n    obsolete\n      \"For consistency with Unicode string handling, use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_8): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_8; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: CHARACTER_8; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_8\n      -- New STRING_8 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_8\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_8}\n    do\n      if same_type (create {STRING_8}.make_empty) and then attached {STRING_8} Current as l_s8 then\n        Result := l_s8\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_8): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_8]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n        end\n      end\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_8): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then c1.as_lower /= c2.as_lower then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: l_area.upper - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_8): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = False\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n      until\n        i > n or not l_area.item (i).is_space\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_8): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    ensure\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  starts_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := v <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n      l_area: like area\n      i: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 't' and then\n          l_area.item (i + 1).lower = 'r' and then\n          l_area.item (i + 2).lower = 'u' and then\n          l_area.item (i + 3).lower = 'e'\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 'f' and then\n          l_area.item (i + 1).lower = 'a' and then\n          l_area.item (i + 2).lower = 'l' and then\n          l_area.item (i + 3).lower = 's' and then\n          l_area.item (i + 4).lower = 'e'\n      end\n    end\n\nfeature {READABLE_STRING_8} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_8)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (Current)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies Result.same_string (Current)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_8_SEARCHER\n      -- String searcher specialized for READABLE_STRING_8 instances\n    once\n      create Result.make\n    end\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).lower, i)\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).upper, i)\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes. Read-only interface.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 06:27:01 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94630 $\"\n\ndeferred class\n  READABLE_STRING_GENERAL\n\ninherit\n  COMPARABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    end\n\n  HASHABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\n  STRING_HANDLER\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n    require\n      non_negative_size: n >= 0\n    deferred\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\n  make_empty\n      -- Create empty string.\n    do\n      make (0)\n    ensure\n      empty: count = 0\n      area_allocated: capacity >= 0\n    end\n\nfeature -- Access\n\n  code (i: INTEGER): NATURAL_32\n      -- Code at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  item alias \"[]\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  index_of (c: like item; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else item (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: like item; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else item (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  index_of_code (c: like code; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else code (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has_code (c)\n      found_if_present: substring (start_index, count).has_code (c) implies code (Result) = c\n      none_before: substring (start_index, count).has_code (c) implies\n        not substring (start_index, Result - 1).has_code (c)\n    end\n\n  last_index_of_code (c: like code; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else code (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has_code (c)\n      found_if_present: substring (1, start_index_from_end).has_code (c) implies code (Result) = c\n      none_after: substring (1, start_index_from_end).has_code (c) implies\n        not substring (Result + 1, start_index_from_end).has_code (c)\n    end\n\n  false_constant: STRING_8 = \"false\"\n      -- Constant string \"false\"\n\n  true_constant: STRING_8 = \"true\"\n      -- Constant string \"true\"\n\n  hash_code: INTEGER\n      -- Hash code value\n    local\n      i, nb: INTEGER\n    do\n      Result := internal_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + item (i).code\n          i := i + 1\n        end\n        internal_hash_code := Result\n      end\n    end\n\n  case_insensitive_hash_code: INTEGER\n      -- Hash code value of the lower case version of `Current'.\n    local\n      l_props: like character_properties\n      i, nb: INTEGER\n    do\n      Result := internal_case_insensitive_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n          l_props := character_properties\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + l_props.to_lower (item (i)).code\n          i := i + 1\n        end\n        internal_case_insensitive_hash_code := Result\n      end\n    ensure\n      consistent: Result = as_lower.hash_code\n    end\n\nfeature -- Status report\n\n  is_immutable: BOOLEAN\n      -- Can the character sequence of `Current' be not changed?\n    do\n      Result := False\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the string?\n    do\n      Result := (i > 0) and (i <= count)\n    ensure\n      definition: Result = (1 <= i and i <= count)\n    end\n\n  valid_code (v: like code): BOOLEAN\n      -- Is `v' a valid code for Current?\n    deferred\n    end\n\n  is_string_8: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_8?\n    deferred\n    end\n\n  is_string_32: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_32?\n    deferred\n    end\n\n  is_valid_as_string_8: BOOLEAN\n      -- Is `Current' convertible to a sequence of CHARACTER_8 without information loss?\n    deferred\n    end\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    deferred\n    end\n\n  is_whitespace: BOOLEAN\n      -- Is structure containing only whitespace characters?\n    do\n      Result := is_substring_whitespace (1, count)\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- Is substring between `start_index' and `end_index' containing only whitespace characters?\n    require\n      start_index_big_enough: 1 <= start_index\n      end_index_small_enough: end_index <= count\n      consistent_indexes: start_index - 1 <= end_index\n    deferred\n    end\n\n  has (c: like item): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  has_code (c: like code): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (code (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then code (1) = c implies Result\n      recurse: (count > 0 and then code (1) /= c) implies\n        (Result = substring (2, count).has_code (c))\n    end\n\n  is_number_sequence: BOOLEAN\n      -- Does `Current' represent a number sequence?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_no_limitation)\n    ensure\n      syntax_and_range:\n        -- Result is true if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  Current can be produced by \"Integer_literal\":\n        --\n        -- Integer_literal = [Space] [Sign] Integer [Space]\n        -- Space  = \" \" | \" \" Space\n        -- Sign   = \"+\" | \"-\"\n        -- Integer  = Digit | Digit Integer\n        -- Digit  = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n    end\n\n  is_real_sequence: BOOLEAN\n      -- Does `Current' represent a real sequence?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following condition is satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n    end\n\n  is_real, is_real_32: BOOLEAN\n      -- Does `Current' represent a REAL_32?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_real)\n      Result := l_convertor.is_integral_real\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type REAL.\n    end\n\n  is_double, is_real_64: BOOLEAN\n      -- Does `Current' represent a REAL_64?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_double)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type DOUBLE.\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    deferred\n    ensure\n      is_boolean: Result = (true_constant.same_string_general (as_lower) or\n        false_constant.same_string_general (as_lower))\n    end\n\n  is_integer_8: BOOLEAN\n      -- Does `Current' represent an INTEGER_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_8)\n    end\n\n  is_integer_16: BOOLEAN\n      -- Does `Current' represent an INTEGER_16?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_16)\n    end\n\n  is_integer, is_integer_32: BOOLEAN\n      -- Does `Current' represent an INTEGER_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_32)\n    end\n\n  is_integer_64: BOOLEAN\n      -- Does `Current' represent an INTEGER_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_64)\n    end\n\n  is_natural_8: BOOLEAN\n      -- Does `Current' represent a NATURAL_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_8)\n    end\n\n  is_natural_16: BOOLEAN\n      -- Does `Current' represent a NATURAL_16?\n\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_16)\n    end\n\n  is_natural, is_natural_32: BOOLEAN\n      -- Does `Current' represent a NATURAL_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_32)\n    end\n\n  is_natural_64: BOOLEAN\n      -- Does `Current' represent a NATURAL_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_64)\n    end\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of characters in Current\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Number of characters allocated in Current\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          if item (i) = c then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\nfeature -- Comparison\n\n  is_case_insensitive_equal (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      c1,c2: like item\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := item (i)\n          c2 := other.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  has_substring (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `Current' contain `other'?\n    require\n      other_not_void: other /= Void\n    do\n      if other = Current then\n        Result := True\n      elseif other.count <= count then\n        Result := substring_index (other, 1) > 0\n      end\n    ensure\n      false_if_too_small: count < other.count implies not Result\n      true_if_initial: (count >= other.count and then\n        other.same_string (substring (1, other.count))) implies Result\n      recurse: (count >= other.count and then\n        not other.same_string (substring (1, other.count))) implies\n        (Result = substring (2, count).has_substring (other))\n    end\n\n  same_string (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `other' represent the same string as `Current'?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    end\n\n  same_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          if item (i) /= other.item (j) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  starts_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code (i) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code(j) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n            j := j - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start_pos'\n      -- and to or before `end_pos';\n      -- 0 if none.\n    require\n      other_nonvoid: other /= Void\n      other_notempty: not other.is_empty\n      start_pos_large_enough: start_pos >= 1\n      start_pos_small_enough: start_pos <= count\n      end_pos_large_enough: end_pos >= start_pos\n      end_pos_small_enough: end_pos <= count\n    deferred\n    ensure\n      correct_place: Result > 0 implies other.same_string (substring (Result, Result + other.count - 1))\n      -- forall x : start_pos..Result\n      --  not substring (x, x+other.count -1).is_equal (other)\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- Index of first occurrence of other at or after start_index;\n      -- 0 if none\n    require\n      other_not_void: other /= Void\n      valid_start_index: start_index >= 1 and start_index <= count + 1\n    deferred\n    ensure\n      valid_result: Result = 0 or else\n        (start_index <= Result and Result <= count - other.count + 1)\n      zero_if_absent: (Result = 0) =\n        not substring (start_index, count).has_substring (other)\n      at_this_index: Result >= start_index implies\n        other.same_string (substring (Result, Result + other.count - 1))\n      none_before: Result > start_index implies\n        not substring (start_index, Result + other.count - 2).has_substring (other)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start'\n      -- with 0..`fuzz' mismatches between the string and `other'.\n      -- 0 if there are no fuzzy matches\n    require\n      other_exists: other /= Void\n      other_not_empty: not other.is_empty\n      start_large_enough: start >= 1\n      start_small_enough: start <= count\n      acceptable_fuzzy: fuzz <= other.count\n    deferred\n    end\n\nfeature -- Conversion\n\n  frozen to_cil: SYSTEM_STRING\n      -- Create an instance of SYSTEM_STRING using characters\n      -- of Current between indices `1' and `count'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := dotnet_convertor.from_string_to_system_string (Current)\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_string_8: STRING_8\n      -- Convert `Current' as a STRING_8.\n    require\n      is_valid_as_string_8: is_valid_as_string_8\n    do\n      Result := as_string_8\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_8_conversion: STRING_8\n      -- Equivalent to `as_string_8' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the target recipient of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update recipient of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_readable_string_8: READABLE_STRING_8\n      --\n    obsolete\n      \"Use explicit conversion `to_string_8' instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_string_8: STRING_8\n      -- Convert `Current' as a STRING_8. If a code of `Current' is\n      -- not a valid code for a STRING_8 it is replaced with the null\n      -- character.\n    local\n      i, nb: INTEGER\n      l_code: like code\n    do\n      if attached {STRING_8} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          l_code := code (i)\n          if Result.valid_code (l_code) then\n            Result.put_code (l_code, i)\n          else\n            Result.put_code (0, i)\n          end\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_32_conversion: STRING_32\n      -- Equivalent to `as_string_32' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the source of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update target of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_readable_string_32: READABLE_STRING_32\n      --\n    obsolete\n      \"Use explicit conversion `to_string_32' instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_string_32, to_string_32: STRING_32\n      -- Convert `Current' as a STRING_32.\n    local\n      i, nb: INTEGER\n    do\n      if attached {STRING_32} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          Result.put_code (code (i), i)\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_32_not_void: Result /= Void\n      identity: (conforms_to (create {STRING_32}.make_empty) and Result = Current) or (not conforms_to (create {STRING_32}.make_empty) and Result /= Current)\n    end\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    deferred\n    ensure\n      as_lower_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_lower\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    deferred\n    ensure\n      as_upper_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_upper\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_upper\n    end\n\n  to_integer_8: INTEGER_8\n      -- 8-bit integer value\n    require\n      is_integer_8: is_integer_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_8\n    end\n\n  to_integer_16: INTEGER_16\n      -- 16-bit integer value\n    require\n      is_integer_16: is_integer_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_16\n    end\n\n  to_integer, to_integer_32: INTEGER_32\n      -- 32-bit integer value\n    require\n      is_integer: is_integer_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer\n    end\n\n  to_integer_64: INTEGER_64\n      -- 64-bit integer value\n    require\n      is_integer_64: is_integer_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_64\n    end\n\n  to_natural_8: NATURAL_8\n      -- 8-bit natural value\n    require\n      is_natural_8: is_natural_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_8\n    end\n\n  to_natural_16: NATURAL_16\n      -- 16-bit natural value\n    require\n      is_natural_16: is_natural_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_16\n    end\n\n  to_natural, to_natural_32: NATURAL_32\n      -- 32-bit natural value\n    require\n      is_natural: is_natural_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_32\n    end\n\n  to_natural_64: NATURAL_64\n      -- 64-bit natural value\n    require\n      is_natural_64: is_natural_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_64\n    end\n\n  to_real, to_real_32: REAL\n      -- Real value;\n      -- for example, when applied to \"123.0\", will yield 123.0\n    require\n      represents_a_real: is_real\n    do\n      Result := to_double.truncated_to_real\n    end\n\n  to_double, to_real_64: DOUBLE\n      -- \"Double\" value;\n      -- for example, when applied to \"123.0\", will yield 123.0 (double)\n    require\n      represents_a_double: is_double\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_double\n    end\n\n  to_boolean: BOOLEAN\n      -- Boolean value;\n      -- \"True\" yields `True', \"False\" yields `False'\n      -- (case-insensitive)\n    require\n      is_boolean: is_boolean\n    do\n      check true_constant.count = 4 end\n      if count = 4 then\n        Result := True\n      end\n    ensure\n      to_boolean: (Result = as_lower.same_string (true_constant)) or\n        (not Result = as_lower.same_string (false_constant))\n    end\n\nfeature -- Conversion\n\n  split (a_separator: CHARACTER_32): LIST [like Current]\n      -- Split on `a_separator'.\n    local\n      l_list: ARRAYED_LIST [like Current]\n      part: like Current\n      i, j, c: INTEGER\n    do\n      c := count\n        -- Worse case allocation: every character is a separator\n      create l_list.make (c + 1)\n      if c > 0 then\n        from\n          i := 1\n        until\n          i > c\n        loop\n          j := index_of (a_separator, i)\n          if j = 0 then\n              -- No separator was found, we will\n              -- simply create a list with a copy of\n              -- Current in it.\n            j := c + 1\n          end\n          part := substring (i, j - 1)\n          l_list.extend (part)\n          i := j + 1\n        end\n        if j = c then\n          check\n            last_character_is_a_separator: item (j) = a_separator\n          end\n            -- A separator was found at the end of the string\n          l_list.extend (new_string (0))\n        end\n      else\n          -- Extend empty string, since Current is empty.\n        l_list.extend (new_string (0))\n      end\n      Result := l_list\n      check\n        l_list.count = occurrences (a_separator) + 1\n      end\n    ensure\n      Result /= Void\n    end\n\nfeature -- Element change\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    deferred\n    ensure\n      plus_not_void: Result /= Void\n      new_count: Result.count = count + s.count\n      initial: elks_checking implies Result.substring (1, count) ~ Current\n      final: elks_checking implies Result.substring (count + 1, count + s.count).same_string (s)\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    ensure\n      substring_not_void: Result /= Void\n      substring_count: Result.count = end_index - start_index + 1 or Result.count = 0\n      first_code: Result.count > 0 implies Result.item (1) = item (start_index)\n      recurse: Result.count > 0 implies\n        Result.substring (2, Result.count) ~ substring (start_index + 1, end_index)\n    end\n\n  head (n: INTEGER): like Current\n      -- Prefix, retaining first `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (1, n)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\n  tail (n: INTEGER): like Current\n      -- Suffix, retaining last `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (count - n + 1, count)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\nfeature {NONE} -- Assertion helper\n\n  elks_checking: BOOLEAN = False\n      -- Are ELKS checkings verified? Must be True when changing implementation of STRING_GENERAL or descendant.\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    require\n      n_non_negative: n >= 0\n    deferred\n    ensure\n      new_string_not_void: Result /= Void\n      new_string_empty: Result.is_empty\n      new_string_area_big_enough: Result.capacity >= n\n    end\n\n  is_valid_integer_or_natural (type: INTEGER) : BOOLEAN\n      -- Is `Current' a valid number according to given `type'?\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.reset (type)\n      l_convertor.parse_string_with_type (Current, type)\n      Result := l_convertor.is_integral_integer\n    end\n\n  string_searcher: STRING_SEARCHER\n      -- Facilities to search string in another string.\n    deferred\n    ensure\n      string_searcher_not_void: Result /= Void\n    end\n\n  c_string_provider: C_STRING\n      -- To create Eiffel strings from C string.\n    once\n      create Result.make_empty (0)\n    ensure\n      c_string_provider_not_void: Result /= Void\n    end\n\n  ctoi_convertor: STRING_TO_INTEGER_CONVERTOR\n      -- Convertor used to convert string to integer or natural\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctoi_convertor_not_void: Result /= Void\n    end\n\n  ctor_convertor: STRING_TO_REAL_CONVERTOR\n      -- Convertor used to convert string to real or double\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctor_convertor_not_void: Result /= Void\n    end\n\n  dotnet_convertor: SYSTEM_STRING_FACTORY\n      -- Convertor used to convert from and to SYSTEM_STRING.\n    once\n      create Result\n    ensure\n      dotnet_convertor_not_void: Result /= Void\n    end\n\n  character_properties: CHARACTER_PROPERTY\n      -- Access to Unicode character properties\n    once\n      create Result.make\n    end\n\nfeature {READABLE_STRING_GENERAL} -- Implementation\n\n  internal_hash_code: INTEGER\n      -- Cache for `hash_code'.\n\n  internal_case_insensitive_hash_code: INTEGER;\n      -- Cash for `case_insensitive_hash_code'.\n\n\nfeature -- Access: Cursor\n\n  new_character_32_cursor: STRING_ITERATION_CURSOR\n      -- Fresh cursor for this string that iterates over code points (see `code')\n      -- exposed as {CHARACTER_32}.\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"resizable.e","content":"note\n  description: \"Finite structures whose item count is subject to change\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  size: resizable;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class RESIZABLE [G] inherit\n\n  BOUNDED [G]\n\nfeature -- Measurement\n\n  Growth_percentage: INTEGER = 50\n      -- Percentage by which structure will grow automatically\n\n  Minimal_increase: INTEGER = 5\n      -- Minimal number of additional items\n\n  additional_space: INTEGER\n      -- Proposed number of additional items\n      --| Result is a reasonable value, resulting from a space-time tradeoff.\n    do\n        -- To prevent overflow we do not use `growth_percentage' but its known value.\n      Result := (capacity // 2).max (Minimal_increase)\n    ensure\n      At_least_one: Result >= 1\n    end\n\nfeature -- Status report\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed? (Answer: yes.)\n    do\n      Result := True\n    end\n\nfeature -- Resizing\n\n  automatic_grow\n      -- Change the capacity to accommodate at least\n      -- `Growth_percentage' more items.\n      --| Trades space for time:\n      --| allocates fairly large chunks of memory but not very often.\n    require\n      resizable: resizable\n    do\n      grow (capacity + additional_space)\n    ensure\n      increased_capacity: capacity >= old capacity + old additional_space\n    end\n\n  grow (i: INTEGER)\n      -- Ensure that capacity is at least `i'.\n    require\n      resizable: resizable\n    deferred\n    ensure\n      new_capacity: capacity >= i\n    end\n\n  trim\n      -- Decrease `capacity' to the minimum value.\n      -- Apply to reduce allocated storage.\n    deferred\n    ensure\n      same_count: count = old count\n      minimal_capacity: capacity = count\n    end\n\ninvariant\n\n  increase_by_at_least_one: Minimal_increase >= 1\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"special.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-03-04 15:01:25 -0800 (Mon, 04 Mar 2013) $\"\n  revision: \"$Revision: 92178 $\"\n\nfrozen class\n  SPECIAL [T]\n\ninherit\n  ABSTRACT_SPECIAL\n    redefine\n      debug_output\n    end\n\n  READABLE_INDEXABLE [T]\n\ncreate\n  make_empty,\n  make_filled,\n  make_from_native_array\n\nfeature {NONE} -- Initialization\n\n  make_empty (n: INTEGER)\n      -- Create a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    external\n      \"built_in\"\n    ensure\n      capacity_set: capacity = n\n      count_set: count = 0\n    end\n\n  make_filled (v: T; n: INTEGER)\n      -- Create a special object for `n' entries initialized with `v'.\n    require\n      non_negative_argument: n >= 0\n    do\n      make_empty (n)\n      fill_with (v, 0, n - 1)\n    ensure\n      capacity_set: capacity = n\n      count_set: count = n\n      filled: filled_with (v, 0, n - 1)\n    end\n\n  make_from_native_array (an_array: like native_array)\n      -- Create a special object from `an_array'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      an_array_not_void: an_array /= Void\n    do\n    end\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): T assign put\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    external\n      \"built_in\"\n    end\n\n  at alias \"@\" (i: INTEGER): T\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    require\n      valid_index: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  index_of (v: T; start_position: INTEGER): INTEGER\n      -- Index of first occurrence of item identical to `v'.\n      -- -1 if none.\n      -- (Use object equality for comparison.)\n    require\n      valid_start_position: start_position >= 0\n    local\n      nb: INTEGER\n    do\n      from\n        Result := start_position\n        nb := count\n      until\n        Result >= nb or else item (Result) ~ v\n      loop\n        Result := Result + 1\n      end\n      if Result >= nb then\n        Result := -1\n      end\n    ensure\n      found_or_not_found: Result = -1 or else (Result >= 0 and then Result < count)\n    end\n\n  item_address (i: INTEGER): POINTER\n      -- Address of element at position `i'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    do\n      Result := base_address + i * element_size\n    ensure\n      element_address_not_null: Result /= default_pointer\n    end\n\n  base_address: POINTER\n      -- Address of element at position `0'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n    external\n      \"built_in\"\n    ensure\n      base_address_not_null: Result /= default_pointer\n    end\n\n  native_array: NATIVE_ARRAY [T]\n      -- Only for compatibility with .NET\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      create Result\n    end\n\n  to_array: ARRAY [T]\n      -- Build an array representation of Current from `1' to `count'.\n    do\n      create Result.make_from_special (Current)\n    ensure\n      to_array_attached: Result /= Void\n      to_array_lower_set: Result.lower = 1\n      to_array_upper_set: Result.upper = count\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- <Precursor>\n    do\n      create Result.make (lower, upper)\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER = 0\n      -- Minimum index of Current\n\n  upper: INTEGER\n      -- Maximum index of Current\n    do\n      Result := count - 1\n    ensure\n      definition: lower <= Result + 1\n    end\n\n  count: INTEGER\n      -- Count of special area\n    external\n      \"built_in\"\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  filled_with (v: T; start_index, end_index: INTEGER): BOOLEAN\n      -- Are all items between index `start_index' and `end_index'\n      -- set to `v'?\n      -- (Use reference equality for comparison.)\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    local\n      i: INTEGER\n    do\n      from\n        Result := True\n        i := start_index\n      until\n        i > end_index or else not Result\n      loop\n        Result := item (i) = v\n        i := i + 1\n      end\n    end\n\n  same_items (other: like Current; source_index, destination_index, n: INTEGER): BOOLEAN\n      -- Are the `n' elements of `other' from `source_index' position the same as\n      -- the `n' elements of `Current' from `destination_index'?\n      -- (Use reference equality for comparison.)\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= count\n    local\n      i, j, nb: INTEGER\n    do\n      Result := True\n      if other /= Current then\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          if other.item (i) /= item (j) then\n            Result := False\n            i := nb - 1\n          end\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      valid_on_empty_area: (n = 0) implies Result\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := (0 <= i) and (i < count)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    external\n      \"built_in\"\n    ensure\n      inserted: item (i) = v\n      same_count: count = old count\n      same_capacity: capacity = old capacity\n    end\n\n  force (v: T; i: INTEGER)\n      -- If `i' is equal to `count' increase `count' by one and insert `v' at index `count',\n      -- otherwise replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i <= count\n      not_full: i = count implies count < capacity\n    do\n      if i < count then\n        put (v, i)\n      else\n        extend (v)\n      end\n    ensure\n      count_updated: count = (i + 1).max (old count)\n      same_capacity: capacity = old capacity\n      inserted: item (i) = v\n    end\n\n  extend (v: T)\n      -- Add `v' at index `count'.\n    require\n      count_small_enough: count < capacity\n    external\n      \"built_in\"\n    ensure\n      count_increased: count = old count + 1\n      same_capacity: capacity = old capacity\n      inserted: item (count - 1) = v\n    end\n\n  extend_filled (v: T)\n      -- Set items between `count' and `capacity - 1' with `v'.\n    do\n      fill_with (v, count, capacity - 1)\n    ensure\n      same_capacity: capacity = old capacity\n      count_increased: count = capacity\n      filled: filled_with (v, old count, capacity - 1)\n    end\n\n  fill_with (v: T; start_index, end_index: INTEGER)\n      -- Set items between `start_index' and `end_index' with `v'.\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_in_bound: start_index <= count\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < capacity\n    local\n      i, nb: INTEGER\n      l_count: like count\n    do\n      from\n        i := start_index\n        l_count := count.min (end_index + 1)\n        nb := l_count\n      until\n        i = nb\n      loop\n        put (v, i)\n        i := i + 1\n      end\n      from\n        i := l_count\n        nb := end_index + 1\n      until\n        i = nb\n      loop\n        extend (v)\n        i := i + 1\n      end\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = (old count).max (end_index + 1)\n      filled: filled_with (v, start_index, end_index)\n    end\n\n  fill_with_default (start_index, end_index: INTEGER)\n      -- Clear items between `start_index' and `end_index'.\n    require\n      is_self_initializing: ({T}).has_default\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    do\n      fill_with (({T}).default, start_index, end_index)\n    ensure\n      filled: filled_with (({T}).default, start_index, end_index)\n    end\n\n  insert_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Insert `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index' and shift elements between `destination_index' and `count'\n      -- to the right. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: count + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      l_remaining_items, l_offset, l_nb_items_left: INTEGER\n      l_source_index, l_end_index, l_destination_index: INTEGER\n    do\n      l_remaining_items := count - destination_index\n      if l_remaining_items = 0 then\n          -- It is being added at the end of Current, therefore we can simply extend.\n        copy_data (other, source_index, destination_index, n)\n      elseif n <= l_remaining_items then\n          -- Simple case where we can perform a move of the existing items to the end\n          -- and then copy the elements of `other'.\n        move_data (destination_index, destination_index + n, l_remaining_items)\n        copy_data (other, source_index, destination_index, n)\n      else\n          -- Because we cannot have uninitialized items, we cannot move all the remaining items beyond count\n          -- instead we copy by chunks of `l_remaining_items'.\n        from\n          l_source_index := source_index\n          l_destination_index := destination_index\n          l_end_index := source_index + n\n          l_nb_items_left := n\n          l_offset := l_remaining_items\n        until\n          l_source_index >= l_end_index\n        loop\n          move_data (l_destination_index, l_destination_index + l_offset, l_remaining_items)\n          copy_data (other, l_source_index, l_destination_index, l_offset)\n          l_destination_index := l_destination_index + l_offset\n          l_source_index := l_source_index + l_offset\n            -- Compute how many more items we have to copy.\n          l_nb_items_left := l_nb_items_left - l_remaining_items\n          l_offset := l_offset.min (l_nb_items_left)\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = old count + n\n    end\n\n  copy_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Copy `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index'. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      i, j, nb: INTEGER\n    do\n      if other = Current then\n        move_data (source_index, destination_index, n)\n      else\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          force (other.item (i), j)\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  move_data (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    do\n      if source_index = destination_index then\n      elseif source_index > destination_index then\n        if destination_index + n < source_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      else\n        if source_index + n < destination_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      if source_index < destination_index then\n          -- We shift from left to right starting from the end\n          -- due to possible overlapping.\n        from\n          i := source_index + n - 1\n          nb := source_index - 1\n          l_offset := destination_index - source_index\n          if (destination_index + n >= count) then\n              -- Initialize elements above `count' to a dummy item.\n            fill_with (item (source_index), count, destination_index + n - 1)\n          end\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          put (item (i), i + l_offset)\n          i := i - 1\n        end\n      else\n          -- We shift from right to left.\n        from\n          i := source_index\n          nb := source_index + n\n          l_offset := source_index - destination_index\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          force (item (i), i - l_offset)\n          i := i + 1\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  non_overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      non_overlapping:\n        (source_index < destination_index implies source_index + n < destination_index) or\n        (source_index > destination_index implies destination_index + n < source_index)\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      from\n        i := source_index\n        nb := source_index + n\n        l_offset := destination_index - source_index\n      until\n        i = nb\n      loop\n        force (item (i), i + l_offset)\n        i := i + 1\n      end\n    ensure\n      moved: same_items (Current, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\nfeature -- Resizing\n\n  keep_head (n: INTEGER)\n      -- Keep the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, 0, 0, n)\n    end\n\n  keep_tail (n: INTEGER)\n      -- Keep the last `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      overlapping_move (count - n, 0, n)\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, n, 0, n)\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_tail (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, n, 0, count)\n    end\n\n  remove_tail (n: INTEGER)\n      -- Keep the first  `count - n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_head (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, 0, 0, count)\n    end\n\n  resized_area (n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n'\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      Result.copy_data (Current, 0, 0, n.min (count))\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n' where not yet initialized\n      -- entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      if n > count then\n        Result.copy_data (Current, 0, 0, count)\n        Result.fill_with (a_default_value, count, n - 1)\n      else\n        Result.copy_data (Current, 0, 0, n)\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area (n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy\n    require\n      n_non_negative: n >= 0\n    external\n      \"built_in\"\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy. Non yet initialized entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      Result := aliased_resized_area (n)\n      Result.fill_with (a_default_value, Result.count, n - 1)\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\nfeature -- Removal\n\n  replace_all (v: T)\n      -- Replace all items with `v'.\n    local\n      i: INTEGER\n    do\n      from\n        i := count - 1\n      until\n        i < 0\n      loop\n        put (v, i)\n        i := i - 1\n      end\n    ensure\n      cleared: filled_with (v, 0, upper)\n    end\n\n  wipe_out\n      -- Reset count to zero.\n    do\n      set_count (0)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = 0\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    obsolete\n      \"Because of the new precondition, it is recommended to use `fill_with' instead.\"\n    require\n      has_default: ({T}).has_default\n    do\n      fill_with_default (0, upper)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = old count\n    end\n\nfeature -- Iteration\n\n  do_all_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_if_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i)]) then\n          action.call ([item (i)])\n        end\n        i := i + 1\n      end\n    end\n\n  there_exists_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb or Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  for_all_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n        Result := True\n      until\n        i > nb or not Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_all_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; test: FUNCTION [ANY, TUPLE [T, INTEGER], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i), j]) then\n          action.call ([item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      Result := Precursor\n      Result.append_string (\", capacity=\")\n      Result.append_integer (capacity)\n    end\n\nfeature {NONE} -- Implementation\n\n  element_size: INTEGER\n      -- Size of elements\n    external\n      \"built_in\"\n    ensure\n      element_size_non_negative: Result >= 0\n    end\n\n  set_count (n: INTEGER)\n      -- Set `count' with `n'.\n    require\n      n_non_negative: n >= 0\n      valid_new_count: n <= count\n    external\n      \"built_in\"\n    ensure\n      count_set: count = n\n      capacity_preserved: capacity = old capacity\n    end\n\ninvariant\n  count_less_than_capacity: count <= capacity\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    extern\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-26 14:49:40 -0700 (Wed, 26 Mar 2014) $\"\n  revision: \"$Revision: 94721 $\"\n\nclass\n  STRING_8\n\ninherit\n  READABLE_STRING_8\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    redefine\n      area\n    end\n\n  STRING_GENERAL\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    undefine\n      copy, is_equal, out\n    redefine\n      append_string_general,\n      prepend_string_general\n    end\n\n  INDEXABLE [CHARACTER_8, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_8]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_8]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_32: {READABLE_STRING_32, STRING_32}\n\nfeature -- Initialization\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_8): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8 assign put\n      -- Character at position `i'.\n    do\n      Result := area.item (i - 1)\n    end\n\n  character_32_item (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    do\n        -- We should be using `area.item (i - 1).to_character_32'\n        -- but some descendants of STRING that have their content encoded\n        -- in UTF-8 for example relies on `code' to get the corresponding\n        -- CHARACTER_32 by reading more than one byte. Once they have\n        -- been updated to use `character_32_item' we can revert the code\n        -- back to using `area' directly.\n      Result := code (i).to_character_32\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Numeric code of character at position `i'.\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n      -- Use `code' instead for consistency with Unicode handling.\n      --| Not obsolete because old code using just ASCII is safe.\n    do\n      Result := area.item (i - 1).code\n    end\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters.\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_8; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_8\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_8)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    local\n      l_first_pos, l_next_pos: INTEGER\n      l_orig_count, l_new_count, l_new_lower, l_count, i, l_index_count: INTEGER\n      l_src_index, l_dest_index, l_prev_index, l_copy_delta: INTEGER\n      l_area, l_new_area: like area\n      l_offset: INTEGER\n      l_string_searcher: like string_searcher\n      l_index_list: SPECIAL [INTEGER]\n    do\n      if not is_empty then\n        l_count := count\n        l_string_searcher := string_searcher\n        l_string_searcher.initialize_deltas (original)\n        l_orig_count := original.count\n        l_new_count := new.count\n        if l_orig_count >= l_new_count then\n          l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, 1, l_count)\n          if l_first_pos > 0 then\n            if l_orig_count = l_new_count then\n                -- String will not be resized, simply perform character substitution\n              from\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_first_pos = 0\n              loop\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1, l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_new_count, l_count)\n                else\n                  l_first_pos := 0\n                end\n              end\n            elseif l_orig_count > l_new_count then\n                -- New string is smaller than previous string, we can optimize\n                -- substitution by only moving block between two occurrences of `orginal'.\n              from\n                l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_next_pos = 0\n              loop\n                  -- Copy new string into Current\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                  -- Shift characters between `l_first_pos' and `l_next_pos'\n                l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                  l_first_pos + l_new_count - 1 - l_offset, l_next_pos - l_first_pos - l_orig_count)\n                l_first_pos := l_next_pos\n                l_offset := l_offset + (l_orig_count - l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                else\n                  l_next_pos := 0\n                end\n              end\n                -- Perform final substitution:\n                -- Copy new string into Current\n              l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                -- Shift characters between `l_first_pos' and the end of the string\n              l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                l_first_pos + l_new_count - 1 - l_offset, l_count + 1 - l_first_pos - l_orig_count)\n                  -- Perform last substitution\n              l_offset := l_offset + (l_orig_count - l_new_count)\n\n                -- Update `count'\n              set_count (l_count - l_offset)\n            end\n              -- String was modified we need to recompute the `hash_code'.\n            internal_hash_code := 0\n          end\n        elseif attached l_string_searcher.substring_index_list_with_deltas (Current, original, 1, l_count) as l_list then\n            -- Get the number of substitution to be performed by getting a list\n            -- of location where `original' appears.\n          l_index_list := l_list.area\n          l_index_count := l_index_list.count\n            -- Store the index of the last character up to which we need to move\n            -- characters in the reallocated string.\n          l_prev_index := l_count\n            -- Resize Current with the appropriate number of characters\n          l_copy_delta := l_new_count - l_orig_count\n          l_count := l_count + (l_index_count * l_copy_delta)\n          l_area := area.resized_area_with_default ('%U', l_count + 1)\n          area := l_area\n            -- Perform the substitution starting from the end.\n          from\n            i := l_index_count\n            l_new_lower := new.area_lower\n            l_new_area := new.area\n          until\n            i = 0\n          loop\n            i := i - 1\n            l_src_index := l_index_list.item (i)\n            l_dest_index := l_src_index + i * l_copy_delta\n              -- Shift non-matching characters to the right of the newly replaced string.\n            l_area.overlapping_move (l_src_index + l_orig_count - 1, l_dest_index + l_new_count - 1, l_prev_index - l_src_index - l_orig_count + 1)\n              -- Store new end of string where characters will be moved.\n            l_prev_index := l_src_index - 1\n\n              -- Copy `new' to its appropriate position\n            l_area.copy_data (l_new_area, l_new_lower, l_dest_index - 1, l_new_count)\n          end\n            -- Update the new `count' which also resets the `hash_code'.\n          set_count (l_count)\n        end\n      end\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_area.item (nb_space).is_space\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0 or else not l_area.item (i).is_space\n      loop\n        nb_space := nb_space + 1\n        i := i - 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_8)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_8; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_8, i - 1)\n      internal_hash_code := 0\n    end\n\n  precede, prepend_character (c: CHARACTER_8)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        prepend (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  prepend (s: READABLE_STRING_8)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_8)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        append (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_8)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_8)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_8)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append (b.out)\n    end\n\n  insert (s: READABLE_STRING_8; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_8; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_8; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_8)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_8)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_8\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_8)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_8)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_area.item (left_nb_space).is_space\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_area.item (i).is_space\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_8; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_8]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_8]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n      -- Nothing to be done because we only added `internal_hash_code' that will\n      -- be recomputed next time we query `hash_code'.\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: SPECIAL [CHARACTER_8]\n      -- Empty `area' to avoid useless creation of empty areas when wiping out a STRING.\n    obsolete\n      \"Simply create `area' directly.\"\n    do\n      create Result.make_empty (1)\n      Result.extend ('%U')\n    ensure\n      empty_area_not_void: Result /= Void\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 07:36:10 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94633 $\"\n\ndeferred class\n  STRING_GENERAL\n\ninherit\n  READABLE_STRING_GENERAL\n    export\n      {ANY} copy, standard_copy, deep_copy\n    end\n\nconvert\n  as_string_32: {READABLE_STRING_32, STRING_32},\n  to_cil: {SYSTEM_STRING}\n\nfeature -- Settings\n\n  put_code (v: like code; i: INTEGER)\n      -- Put code `v' at position `i'.\n    require\n      valid_code: valid_code (v)\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      inserted: code (i) = v\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\nfeature {STRING_HANDLER} -- Settings\n\n  set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    require\n      valid_count: 0 <= number and number <= capacity\n    deferred\n    ensure\n      new_count: count = number\n    end\n\n  set_internal_hash_code (v: like internal_hash_code)\n      -- Set `internal_hash_code' with `v'.\n    require\n      v_nonnegative: v >= 0\n    do\n      internal_hash_code := v\n    ensure\n      internal_hash_code_set: internal_hash_code = v\n    end\n\nfeature -- Element change\n\n  append_code (c: like code)\n      -- Append `c' at end.\n    require\n      valid_code: valid_code (c)\n    local\n      current_count: INTEGER\n    do\n      current_count := count + 1\n      if current_count > capacity then\n        resize (current_count)\n      end\n      set_count (current_count)\n      put_code (c, current_count)\n    ensure then\n      item_inserted: code (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (to_string_32 + s))\n    end\n\n  append_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := start_index\n        until\n          i > end_index\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      appended: elks_checking implies same_string (old (to_string_32 + s.substring (start_index, end_index)))\n    end\n\n  prepend (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          put_code (s.code (i), i)\n          i := i + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s.to_string_32 + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i, j: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := start_index\n          j := 1\n        until\n          i > end_index\n        loop\n          put_code (s.code (i), j)\n          i := i + 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index).to_string_32 + Current))\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (1, n.min (count)))\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (count - n.min(count) + 1, count))\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (1).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (old count - count + 1, old count))\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (count).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (1, count))\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\n  adjust\n      -- Remove leading and/or trailing whitespace.\n    do\n      left_adjust\n      right_adjust\n    ensure\n      valid_count: count <= old count\n      new_count_left: not is_empty implies not item (1).is_space\n      new_count_right: not is_empty implies not item (count).is_space\n      kept: elks_checking implies (old twin).has_substring (Current)\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    require\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      new_count: count = old count - 1\n      removed: elks_checking implies\n        to_string_32 ~ (old substring (1, i - 1).to_string_32 + old substring (i + 1, count).to_string_32)\n    end\n\nfeature -- Resizing\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    require\n      new_size_large_enough: newsize >= count\n    deferred\n    ensure\n      same_count: count = old count\n      capacity_large_enough: capacity >= newsize\n      same_content: elks_checking implies same_string (old twin)\n    end\n\ninvariant\n  mutable: not is_immutable\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_handler.e","content":"note\n  description: \"Objects that can access `set_count' from STRING\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  STRING_HANDLER\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"table.e","content":"note\n  description: \"Containers whose items are accessible through keys\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: table, access;\n  access: key, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class TABLE [G, H] inherit\n\n  BAG [G]\n    rename\n      put as bag_put\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (k: H): G assign force\n      -- Entry of key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\nfeature -- Status report\n\n  valid_key (k: H): BOOLEAN\n      -- Is `k' a valid key?\n    deferred\n    end\n\nfeature -- Element change\n\n  put (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\n  force (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    ensure\n      inserted: item (k) = v\n    end\n\nfeature {NONE} -- Inapplicable\n\n  bag_put (v: G)\n    do\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"to_special.e","content":"note\n  description: \"References to special objects, for direct access to arrays and strings\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass TO_SPECIAL [T]\n\ncreate\n  make_empty_area,\n  make_filled_area\n\nfeature -- Access\n\n  area: SPECIAL [T]\n      -- Special data zone\n\nfeature {NONE} -- Initialization\n\n  make_empty_area (n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_empty (n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = 0\n    end\n\n  make_filled_area (a_default_value: T; n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_filled (a_default_value, n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = n\n      area_filled: area.filled_with (a_default_value, 0, n - 1)\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): T assign put\n      -- Entry at index `i', if in index interval\n    require\n      valid_index: valid_index (i)\n    do\n      Result := area.item (i)\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := area.valid_index (i)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_index: valid_index (i)\n    do\n      area.put (v, i)\n    ensure\n      inserted: item (i) = v\n    end\n\nfeature {NONE} -- Element change\n\n  set_area (other: like area)\n      -- Make `other' the new `area'\n    do\n      area := other\n    ensure\n      area_set: area = other\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFic3RyYWN0X3NwZWNpYWwuZSIsImFueS5lIiwiYXJyYXkuZSIsImJhZy5lIiwiYm9vbGVhbi5lIiwiYm9vbGVhbl9yZWYuZSIsImJvdW5kZWQuZSIsImJveC5lIiwiY2hhcmFjdGVyXzMyLmUiLCJjaGFyYWN0ZXJfMzJfcmVmLmUiLCJjaGFyYWN0ZXJfOC5lIiwiY2hhcmFjdGVyXzhfcmVmLmUiLCJjb2xsZWN0aW9uLmUiLCJjb21wYXJhYmxlLmUiLCJjb250YWluZXIuZSIsImRlYnVnX291dHB1dC5lIiwiZmluaXRlLmUiLCJoYXNoYWJsZS5lIiwiaW5kZXhhYmxlLmUiLCJpbnRlZ2VyLmUiLCJpbnRlZ2VyXzMyX3JlZi5lIiwiaXRlcmFibGUuZSIsIm1pc21hdGNoX2NvcnJlY3Rvci5lIiwibmF0dXJhbF8zMi5lIiwibmF0dXJhbF8zMl9yZWYuZSIsIm5hdHVyYWxfOC5lIiwibmF0dXJhbF84X3JlZi5lIiwibnVtZXJpYy5lIiwicGFydF9jb21wYXJhYmxlLmUiLCJyZWFkYWJsZV9pbmRleGFibGUuZSIsInJlYWRhYmxlX3N0cmluZ18zMi5lIiwicmVhZGFibGVfc3RyaW5nXzguZSIsInJlYWRhYmxlX3N0cmluZ19nZW5lcmFsLmUiLCJyZXNpemFibGUuZSIsInNwZWNpYWwuZSIsInN0cmluZy5lIiwic3RyaW5nXzguZSIsInN0cmluZ19nZW5lcmFsLmUiLCJzdHJpbmdfaGFuZGxlci5lIiwidGFibGUuZSIsInRvX3NwZWNpYWwuZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FDREE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQW5jZXN0b3Igb2YgU1BFQ0lBTCB0byBwZXJmb3JtIHF1ZXJpZXMgb24gU1BFQ0lBTCB3aXRob3V0IGtub3dpbmcgaXRzIGFjdHVhbCBnZW5lcmljIHR5cGUuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA0LTEyIDE2OjU0OjUwIC0wNzAwIChGcmksIDEyIEFwciAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjQ0MCAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgQUJTVFJBQ1RfU1BFQ0lBTFxuXG5pbmhlcml0XG4gIERFQlVHX09VVFBVVFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIENvdW50IG9mIHNwZWNpYWwgYXJlYVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIENhcGFjaXR5IG9mIHNwZWNpYWwgYXJlYVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIEN1cnJlbnQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBkZWJ1Z19vdXRwdXQ6IFNUUklOR1xuICAgICAgLS0gU3RyaW5nIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBkZWJ1Z2dlciB0byByZXByZXNlbnQgYEN1cnJlbnQnLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEyKVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmcgKFwiY291bnQ9XCIpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXIgKGNvdW50KVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsImNsYXNzXG4gIEFOWVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBjb25mb3Jtc190byAob3RoZXI6IEFOWSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBjb25mb3JtIHRvIHR5cGVcbiAgICAgIC0tIG9mIGBvdGhlcicgKGFzIHBlciBFaWZmZWw6IFRoZSBMYW5ndWFnZSwgY2hhcHRlciAxMyk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgc2FtZV90eXBlIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBpZGVudGljYWwgdG8gdHlwZSBvZiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvbmZvcm1zX3RvIChvdGhlcikgYW5kXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkXG4gICAgICAtLSBlcXVhbCB0byBjdXJyZW50IG9iamVjdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIgfiBDdXJyZW50XG4gICAgICBjb25zaXN0ZW50OiBzdGFuZGFyZF9pc19lcXVhbCAob3RoZXIpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QsIGFuZCBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3R5cGU6IFJlc3VsdCBpbXBsaWVzIHNhbWVfdHlwZSAob3RoZXIpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG90aGVyLnN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBlcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkXG4gICAgICAtLSB0byBvYmplY3RzIGNvbnNpZGVyZWQgZXF1YWw/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkIHRvXG4gICAgICAtLSBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlP1xuICAgICAgLS0gQWx3YXlzIHVzZXMgZGVmYXVsdCBvYmplY3QgY29tcGFyaXNvbiBjcml0ZXJpb24uXG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuc3RhbmRhcmRfaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19kZWVwX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBDdXJyZW50JyBhbmQgYG90aGVyJyBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfZGVlcF9lcXVhbCAoQ3VycmVudClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkXG4gICAgICAtLSBvciBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIGRvXG4gICAgICBpZiBhID0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiID0gVm9pZFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYiAvPSBWb2lkIGFuZCB0aGVuIGEuaXNfZGVlcF9lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2VxdWFsIChhLCBiKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgYm90aF9vcl9ub25lX3ZvaWQ6IChhID0gVm9pZCkgaW1wbGllcyAoUmVzdWx0ID0gKGIgPSBWb2lkKSlcbiAgICAgIHNhbWVfdHlwZTogKFJlc3VsdCBhbmQgKGEgLz0gVm9pZCkpIGltcGxpZXMgKGIgLz0gVm9pZCBhbmQgdGhlbiBhLnNhbWVfdHlwZSAoYikpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIGRlZXBfZXF1YWwgKGIsIGEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgaW86IFNURF9GSUxFU1xuICAgICAgLS0gSGFuZGxlIHRvIHN0YW5kYXJkIGZpbGUgc2V0dXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpb19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gTmV3IHN0cmluZyBjb250YWluaW5nIHRlcnNlIHByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRhZ2dlZF9vdXRcbiAgICBlbnN1cmVcbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdGFnZ2VkX291dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHRhZ2dlZF9vdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcHJpbnQgKG86IGRldGFjaGFibGUgQU5ZKVxuICAgICAgLS0gV3JpdGUgdGVyc2UgZXh0ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYG8nXG4gICAgICAtLSBvbiBzdGFuZGFyZCBvdXRwdXQuXG4gICAgZG9cbiAgICAgIGlmIG8gLz0gVm9pZCB0aGVuXG4gICAgICAgIGlvLnB1dF9zdHJpbmcgKG8ub3V0KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgZGVmYXVsdF9jcmVhdGVcbiAgICAgIC0tIFByb2Nlc3MgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBubyBjcmVhdGlvbiBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG4gIGZyb3plbiBkbG9fbm90aGluZ1xuICAgICAgLS0gRXhlY3V0ZSBhIG51bGwgYWN0aW9uLlxuICAgIGRvXG4gICAgZW5kXG5cbmludmFyaWFudFxuICByZWZsZXhpdmVfZXF1YWxpdHk6IHN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICByZWZsZXhpdmVfY29uZm9ybWFuY2U6IGNvbmZvcm1zX3RvIChDdXJyZW50KVxuXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDEtMjUgMTQ6MTg6MjAgLTA4MDAgKEZyaSwgMjUgSmFuIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTM4ICRcIlxuXG5jbGFzcyBBUlJBWSBbR10gaW5oZXJpdFxuXG4gIFJFU0laQUJMRSBbR11cbiAgICByZWRlZmluZVxuICAgICAgZnVsbCwgY29weSwgaXNfZXF1YWwsIHJlc2l6YWJsZVxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIGl0ZW0gYXMgaXRlbSBhbGlhcyBcIltdXCJcbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtHXVxuICAgIGV4cG9ydFxuICAgICAge0FSUkFZfSBzZXRfYXJlYVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgaXRlbSwgcHV0LCBhdCwgdmFsaWRfaW5kZXhcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2VfZW1wdHksXG4gIG1ha2UsXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fYXJyYXksXG4gIG1ha2VfZnJvbV9zcGVjaWFsLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7TkFUSVZFX0FSUkFZIFtHXX0sXG4gIHRvX3NwZWNpYWw6IHtTUEVDSUFMIFtHXX0sXG4gIG1ha2VfZnJvbV9jaWwgKHtOQVRJVkVfQVJSQVkgW0ddfSlcblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHlcbiAgICAgIC0tIEFsbG9jYXRlIGVtcHR5IGFycmF5IHN0YXJ0aW5nIGF0IGAxJy5cbiAgICBkb1xuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gMFxuICAgICAgbWFrZV9lbXB0eV9hcmVhICgwKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAwXG4gICAgICBpdGVtc19zZXQ6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBhcnJheTsgc2V0IGluZGV4IGludGVydmFsIHRvXG4gICAgICAtLSBgbWluX2luZGV4JyAuLiBgbWF4X2luZGV4Jzsgc2V0IGFsbCB2YWx1ZXMgdG8gZGVmYXVsdC5cbiAgICAgIC0tIChNYWtlIGFycmF5IGVtcHR5IGlmIGBtaW5faW5kZXgnID0gYG1heF9pbmRleCcgKyAxKS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9ib3VuZHM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG46IElOVEVHRVJcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBuIDo9IG1heF9pbmRleCAtIG1pbl9pbmRleCArIDFcbiAgICAgIGVuZFxuICAgICAgbWFrZV9maWxsZWRfYXJlYSAoYV9kZWZhdWx0X3ZhbHVlLCBuKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IG1pbl9pbmRleFxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IG1heF9pbmRleFxuICAgICAgaXRlbXNfc2V0OiBmaWxsZWRfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlKVxuICAgIGVuZFxuXG4gIG1ha2UgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgYXJyYXk7IHNldCBpbmRleCBpbnRlcnZhbCB0b1xuICAgICAgLS0gYG1pbl9pbmRleCcgLi4gYG1heF9pbmRleCc7IHNldCBhbGwgdmFsdWVzIHRvIGRlZmF1bHQuXG4gICAgICAtLSAoTWFrZSBhcnJheSBlbXB0eSBpZiBgbWluX2luZGV4JyA9IGBtYXhfaW5kZXgnICsgMSkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiIGBtYWtlJyBpcyBub3Qgdm9pZC1zYWZlIHN0YXRpY2FsbHkuIFVzZSBgbWFrZV9lbXB0eScgb3IgYG1ha2VfZmlsbGVkJyBpbnN0ZWFkLiBbMDctMjAxMF1cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2JvdW5kczogbWluX2luZGV4IDw9IG1heF9pbmRleCArIDFcbiAgICAgIGhhc19kZWZhdWx0OiBtaW5faW5kZXggPD0gbWF4X2luZGV4IGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBtYWtlX2ZpbGxlZF9hcmVhICgoe0d9KS5kZWZhdWx0LCBtYXhfaW5kZXggLSBtaW5faW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlX2VtcHR5X2FyZWEgKDApXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBtaW5faW5kZXhcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBtYXhfaW5kZXhcbiAgICAgIGl0ZW1zX3NldDogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYXJyYXkgKGE6IEFSUkFZIFtHXSlcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgaXRlbXMgb2YgYGEnLlxuICAgICAgLS0gKFVzZWZ1bCBpbiBwcm9wZXIgZGVzY2VuZGFudHMgb2YgY2xhc3MgYEFSUkFZJyxcbiAgICAgIC0tIHRvIGluaXRpYWxpemUgYW4gYXJyYXktbGlrZSBvYmplY3QgZnJvbSBhIG1hbmlmZXN0IGFycmF5LilcbiAgICByZXF1aXJlXG4gICAgICBhcnJheV9leGlzdHM6IGEgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfYXJlYSAoYS5hcmVhKVxuICAgICAgbG93ZXIgOj0gYS5sb3dlclxuICAgICAgdXBwZXIgOj0gYS51cHBlclxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYS5hcmVhXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gYS5sb3dlclxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IGEudXBwZXJcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3BlY2lhbCAoYTogU1BFQ0lBTCBbR10pXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgZnJvbSBpdGVtcyBvZiBgYScuXG4gICAgcmVxdWlyZVxuICAgICAgc3BlY2lhbF9hdHRhY2hlZDogYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9hcmVhIChhKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYS5jb3VudFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhLmNvdW50XG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAobmE6IE5BVElWRV9BUlJBWSBbbGlrZSBpdGVtXSlcbiAgICAgIC0tIEluaXRpYWxpemUgYXJyYXkgZnJvbSBgbmEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIG5hX25vdF92b2lkOiBuYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZnJvbV9uYXRpdmVfYXJyYXkgKG5hKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYXJlYS5jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IEcgYXNzaWduIHB1dFxuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gbG93ZXIpXG4gICAgZW5kXG5cbiAgZW50cnkgKGk6IElOVEVHRVIpOiBHXG4gICAgICAtLSBFbnRyeSBhdCBpbmRleCBgaScsIGlmIGluIGluZGV4IGludGVydmFsXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpXG4gICAgZW5kXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgdicgYXBwZWFyIGluIGFycmF5P1xuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBuYiA6PSB1cHBlciAtIGxvd2VyXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiBhbmQgdiAvPSBWb2lkIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgfiB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgPSB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgbG93ZXI6IElOVEVHRVJcbiAgICAgIC0tIE1pbmltdW0gaW5kZXhcblxuICB1cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuXG4gIGNvdW50LCBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGF2YWlsYWJsZSBpbmRpY2VzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjb25zaXN0ZW50X3dpdGhfYm91bmRzOiBSZXN1bHQgPSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuZFxuXG4gIG9jY3VycmVuY2VzICh2OiBHKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGB2JyBhcHBlYXJzIGluIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gdXBwZXJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpIH4gdiB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IHVwcGVyXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSA9IHYgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW5kZXhfc2V0OiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBSYW5nZSBvZiBhY2NlcHRhYmxlIGluZGV4ZXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsb3dlciwgdXBwZXIpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICBzYW1lX2JvdW5kczpcbiAgICAgICAgKChSZXN1bHQubG93ZXIgPSBsb3dlcikgYW5kIChSZXN1bHQudXBwZXIgPSB1cHBlcikpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYXJyYXkgbWFkZSBvZiB0aGUgc2FtZSBpdGVtcyBhcyBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlaWYgbG93ZXIgPSBvdGhlci5sb3dlciBhbmQgdGhlbiB1cHBlciA9IG90aGVyLnVwcGVyIGFuZCB0aGVuXG4gICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb25cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIG5vdCBSZXN1bHQgb3IgaSA+IHVwcGVyXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpIH4gb3RoZXIuaXRlbSAoaSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBhcmVhLnNhbWVfaXRlbXMgKG90aGVyLmFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBhbGxfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBzZXQgdG8gZGVmYXVsdCB2YWx1ZXM/XG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAoe0d9KS5oYXNfZGVmYXVsdCBhbmQgdGhlbiBhcmVhLmZpbGxlZF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY291bnQgPSAwIG9yIGVsc2VcbiAgICAgICAgKChub3QgYXR0YWNoZWQgaXRlbSAodXBwZXIpIGFzIGkgb3IgZWxzZSBpID0gKHtHfSkuZGVmYXVsdCkgYW5kXG4gICAgICAgIHN1YmFycmF5IChsb3dlciwgdXBwZXIgLSAxKS5hbGxfZGVmYXVsdCkpXG4gICAgZW5kXG5cbiAgZmlsbGVkX3dpdGggKHY6IEcpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIHNldCB0byBgdic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLmZpbGxlZF93aXRoICh2LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvdW50ID0gMCBvciBlbHNlXG4gICAgICAgIChpdGVtICh1cHBlcikgPSB2IGFuZCBzdWJhcnJheSAobG93ZXIsIHVwcGVyIC0gMSkuZmlsbGVkX3dpdGggKHYpKSlcbiAgICBlbmRcblxuICBmdWxsOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZmlsbGVkIHRvIGNhcGFjaXR5PyAoQW5zd2VyOiB5ZXMpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgc2FtZV9pdGVtcyAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBvdGhlcicgYW5kIEN1cnJlbnQgaGF2ZSBzYW1lIGl0ZW1zP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCAwLCAwLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChjb3VudCA9IG90aGVyLmNvdW50KSBhbmQgdGhlblxuICAgICAgICAoY291bnQgPSAwIG9yIGVsc2UgKGl0ZW0gKHVwcGVyKSA9IG90aGVyLml0ZW0gKG90aGVyLnVwcGVyKVxuICAgICAgICBhbmQgc3ViYXJyYXkgKGxvd2VyLCB1cHBlciAtIDEpLnNhbWVfaXRlbXNcbiAgICAgICAgKG90aGVyLnN1YmFycmF5IChvdGhlci5sb3dlciwgb3RoZXIudXBwZXIgLSAxKSkpKSlcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgYXJyYXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobG93ZXIgPD0gaSkgYW5kIHRoZW4gKGkgPD0gdXBwZXIpXG4gICAgZW5kXG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIGFkZGVkP1xuICAgICAgLS0gKEFuc3dlcjogbm8sIGFsdGhvdWdoIGFycmF5IG1heSBiZSByZXNpemVkLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiBuby4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgIGVuZFxuXG4gIHJlc2l6YWJsZTogQk9PTEVBTlxuICAgICAgLS0gQ2FuIGFycmF5IGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXhfc2V0OiBCT09MRUFOXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpbmRleF9zZXQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBlbnRlciAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBmb3JjZSAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQXNzaWduIGl0ZW0gYHYnIHRvIGBpJy10aCBlbnRyeS5cbiAgICAgIC0tIFJlc2l6ZSB0aGUgYXJyYXkgaWYgYGknIGZhbGxzIG91dCBvZiBjdXJyZW50bHkgZGVmaW5lZCBib3VuZHM7IHByZXNlcnZlIGV4aXN0aW5nIGl0ZW1zLlxuICAgICAgLS0gSW4gdm9pZC1zYWZlIG1vZGUsIGlmICh7R30pLmhhc19kZWZhdWx0IGRvZXMgbm90IGhvbGQsIHRoZW4geW91IGNhbiBvbmx5IGluc2VydCBiZXR3ZWVuXG4gICAgICAtLSBgbG93ZXIgLSAxJyBvciBgdXBwZXIgKyAxJyBwb3NpdGlvbiBpbiB0aGUgQVJSQVkuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHRfaWZfdG9vX2xvdzpcbiAgICAgICAgKGkgPCBsb3dlciAtIDEgYW5kIGxvd2VyIC89IHtsaWtlIGxvd2VyfS5taW5fdmFsdWUpIGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICAgIGhhc19kZWZhdWx0X2lmX3Rvb19oaWdoOlxuICAgICAgICAoaSA+IHVwcGVyICsgMSBhbmQgdXBwZXIgLz0ge2xpa2UgdXBwZXJ9Lm1heF92YWx1ZSkgaW1wbGllcyAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGxvY2FsXG4gICAgICBvbGRfc2l6ZSwgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIG5ld19sb3dlciwgbmV3X3VwcGVyOiBJTlRFR0VSXG4gICAgICBsX2NvdW50LCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lOiBCT09MRUFOXG4gICAgZG9cbiAgICAgIG5ld19sb3dlciA6PSBsb3dlci5taW4gKGkpXG4gICAgICBuZXdfdXBwZXIgOj0gdXBwZXIubWF4IChpKVxuICAgICAgbmV3X3NpemUgOj0gbmV3X3VwcGVyIC0gbmV3X2xvd2VyICsgMVxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lIDo9IChpID0gdXBwZXIgKyAxKSBvciAoaSA9IGxvd2VyIC0gMSlcbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICAgIC0tIExpc3QgaXMgZW1wdHkuIEZpcnN0IHdlIGNyZWF0ZSBhbiBlbXB0eSBTUEVDSUFMIG9mIHRoZSByaWdodCBjYXBhY2l0eS5cbiAgICAgICAgbWFrZV9lbXB0eV9hcmVhIChuZXdfc2l6ZS5tYXggKGFkZGl0aW9uYWxfc3BhY2UpKVxuICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG5lZWQgdG8gZmlsbCB0aGUgU1BFQ0lBTCBmb3IgYDAnIHRvIGBuZXdfc2l6ZSAtIDInIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIG5ld19zaXplIC0gMilcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuZXh0ZW5kICh2KVxuICAgICAgZWxzZVxuICAgICAgICBvbGRfc2l6ZSA6PSBhcmVhLmNhcGFjaXR5XG4gICAgICAgIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlblxuICAgICAgICAgIHNldF9hcmVhIChhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuZXdfc2l6ZS5tYXggKG9sZF9zaXplICsgYWRkaXRpb25hbF9zcGFjZSkpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgICAgLS0gV2UgaGF2ZSBpbnNlcnRlZCBiZWxvdyB0aGUgcHJldmlvdXMgYGxvd2VyJy4gV2UgbmVlZCB0byBzaGlmdCBlbnRyaWVzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgLS0gYmVmb3JlIHdlIGNhbiBpbnNlcnQgYHYnLlxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxvd2VyIC0gbmV3X2xvd2VyXG4gICAgICAgICAgbF9jb3VudCA6PSBjYXBhY2l0eVxuICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgYW5kIGxfb2Zmc2V0ID4gbF9jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdpdGggdGhlIGBuZXdfbG93ZXInIGdpdmVuLCB0aGUgZGF0YSBoYXMgdG8gbW92ZVxuICAgICAgICAgICAgICAtLSBiZXlvbmQgdGhlIGBhcmVhJydzIGNvdW50IHdoaWNoIHJlcXVpcmVzIHVzIHRvIGZpbGxcbiAgICAgICAgICAgICAgLS0gdGhlIGdhcCBiZXR3ZWVuIHRoZSBvbGQgZGF0YSdzIGxvY2F0aW9uIGFuZCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAtLSB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIGxfY291bnQsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBhcmVhLm1vdmVfZGF0YSAoMCwgbF9vZmZzZXQsIGxfY291bnQpXG4gICAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIHN0YXJ0IGF0IGAxJyBhbmQgbm90IGAwJyBiZWNhdXNlIG5leHQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgLS0gd2lsbCB1cGRhdGUgdGhlIGl0ZW0gYXQgcG9zaXRpb24gYDAnLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDEsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEluc2VydCBgdicgYXQgdGhlIG5ldyBsb3dlciBwb3NpdGlvbi5cbiAgICAgICAgICBhcmVhLnB1dCAodiwgMClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIG5ld19zaXplID4gYXJlYS5jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIGFyZSBhZGRpbmcgdG8gdGhlIG5ldyBgdXBwZXInIHBvc2l0aW9uLiBGaXJzdCB3ZSBmaWxsIHRoZSBub24taW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgLS0gZWxlbWVudHMgaWYgYW55IHVwIHRvIGBuZXdfc2l6ZSAtIDInIChpLmUuIHVwIHRoZSB0aGUgaXRlbSBwcmlvciB0byBgdXBwZXInKS5cbiAgICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgdGhlblxuICAgICAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgYXJlYS5jb3VudCwgbmV3X3NpemUgLSAyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIC0tIEFkZCBgdicgYXQgdXBwZXIgcG9zaXRpb24uXG4gICAgICAgICAgICBhcmVhLmV4dGVuZCAodilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEhlcmUgYGxvd2VyJyBoYXNuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGxvd2VyIDo9IG5ld19sb3dlclxuICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgICBoaWdoZXJfY291bnQ6IGNvdW50ID49IG9sZCBjb3VudFxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IChvbGQgbG93ZXIpLm1pbiAoaSlcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAob2xkIHVwcGVyKS5tYXggKGkpXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoICh2OiBHKVxuICAgICAgLS0gU2V0IGl0ZW1zIGJldHdlZW4gYGxvd2VyJyBhbmQgYHVwcGVyJyB3aXRoIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5maWxsX3dpdGggKHYsIDAsIHVwcGVyIC0gbG93ZXIpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfZGVmaW5pdGlvbjogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYpXG4gICAgZW5kXG5cbiAgc3ViY29weSAob3RoZXI6IEFSUkFZIFtsaWtlIGl0ZW1dOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgaXRlbXMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIHRvIGN1cnJlbnQgYXJyYXkgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogc3RhcnRfcG9zID49IG90aGVyLmxvd2VyXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IG90aGVyLnVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiBpbmRleF9wb3MgPj0gbG93ZXJcbiAgICAgIGVub3VnaF9zcGFjZTogKHVwcGVyIC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBkb1xuICAgICAgYXJlYS5jb3B5X2RhdGEgKG90aGVyLmFyZWEsIHN0YXJ0X3BvcyAtIG90aGVyLmxvd2VyLCBpbmRleF9wb3MgLSBsb3dlciwgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgZW5zdXJlXG4gICAgICAtLSBjb3BpZWQ6IGZvcmFsbCBgaScgaW4gMCAuLiAoYGVuZF9wb3MnLWBzdGFydF9wb3MnKSxcbiAgICAgIC0tICAgICBpdGVtIChpbmRleF9wb3MgKyBpKSA9IG90aGVyLml0ZW0gKHN0YXJ0X3BvcyArIGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uLCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZG9faWYgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9faWZfaW5fYm91bmRzIChhY3Rpb24sIHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLnRoZXJlX2V4aXN0c19pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBmb3JfYWxsICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGFsbCBpdGVtcz9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuZm9yX2FsbF9pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBkb19hbGxfd2l0aF9pbmRleCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0csIElOVEVHRVJdXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIHJlY2VpdmVzIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl0sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIGFuZCBgdGVzdCcgcmVjZWl2ZSB0aGUgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2xfYXJlYS5pdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2xfYXJlYS5pdGVtIChpKSwgal0pXG4gICAgICAgIGVuZFxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICB3aXBlX291dFxuICAgICAgLS0gTWFrZSBhcnJheSBlbXB0eS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJOb3QgYXBwbGljYWJsZSBzaW5jZSBub3QgYHBydW5hYmxlJy4gVXNlIGBkaXNjYXJkX2l0ZW1zJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGRpc2NhcmRfaXRlbXNcbiAgICBlbmRcblxuICBkaXNjYXJkX2l0ZW1zXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMgd2l0aCByZWFsbG9jYXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgoe0d9KS5kZWZhdWx0LCBjYXBhY2l0eSlcbiAgICBlbnN1cmVcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCBhcmVhLmNvdW50IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHN0YWJsZV9sb3dlcjogbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIHN0YWJsZV91cHBlcjogdXBwZXIgPSBvbGQgdXBwZXJcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyICsgbiAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBsb3dlciA6PSB1cHBlciAtIG4gKyAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBpdGVtcztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICB1cHBlciA6PSBsb3dlciAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhICgwKVxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IChvbGQgY291bnQgLSBuKS5tYXggKDApXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGl0ZW1zO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyIC0gMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKDApXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCAtIG4pLm1heCAoMClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhdCBsZWFzdCBgaScuXG4gICAgZG9cbiAgICAgIGlmIGkgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0ICgoe0d9KS5kZWZhdWx0LCBsb3dlciwgdXBwZXIgKyBpIC0gY2FwYWNpdHkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjb25zZXJ2YXRpdmVfcmVzaXplIChtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBhcnJheSBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gaW5kaWNlcyBkb3duIHRvIGBtaW5faW5kZXgnIGFuZCB1cCB0byBgbWF4X2luZGV4Jy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgaXRlbS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCIgYGNvbnNlcnZhdGl2ZV9yZXNpemUnIGlzIG5vdCB2b2lkLXNhZmUgc3RhdGljYWxseS4gVXNlIGBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCcgaW5zdGVhZC4gWzA3LTIwMTBdXCJcbiAgICByZXF1aXJlXG4gICAgICBnb29kX2luZGljZXM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXhcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoKHtHfSkuZGVmYXVsdCwgbWluX2luZGV4LCBtYXhfaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBub19sb3dfbG9zdDogbG93ZXIgPSBtaW5faW5kZXggb3IgZWxzZSBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgbm9faGlnaF9sb3N0OiB1cHBlciA9IG1heF9pbmRleCBvciBlbHNlIHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2UgYXJyYXkgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGluZGljZXMgZG93biB0byBgbWluX2luZGV4JyBhbmQgdXAgdG8gYG1heF9pbmRleCcuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBuZXdfbG93ZXIsIG5ld191cHBlcjogSU5URUdFUlxuICAgICAgb2Zmc2V0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbWF4X2luZGV4IC0gbWluX2luZGV4ICsgMSkpXG4gICAgICAgIGxvd2VyIDo9IG1pbl9pbmRleFxuICAgICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGVsc2VcbiAgICAgICAgbmV3X2xvd2VyIDo9IG1pbl9pbmRleC5taW4gKGxvd2VyKVxuICAgICAgICBuZXdfdXBwZXIgOj0gbWF4X2luZGV4Lm1heCAodXBwZXIpXG4gICAgICAgIG5ld19zaXplIDo9IG5ld191cHBlciAtIG5ld19sb3dlciArIDFcbiAgICAgICAgaWYgbmV3X3NpemUgPiBhcmVhLmNvdW50IHRoZW5cbiAgICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbmV3X3NpemUpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgIG9mZnNldCA6PSBsb3dlciAtIG5ld19sb3dlclxuICAgICAgICAgIGFyZWEubW92ZV9kYXRhICgwLCBvZmZzZXQsIHVwcGVyIC0gbG93ZXIgKyAxKVxuICAgICAgICAgIGFyZWEuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIDAsIG9mZnNldCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBsb3dlciA6PSBuZXdfbG93ZXJcbiAgICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vX2xvd19sb3N0OiBsb3dlciA9IG1pbl9pbmRleCBvciBlbHNlIGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBub19oaWdoX2xvc3Q6IHVwcGVyID0gbWF4X2luZGV4IG9yIGVsc2UgdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICByZXNpemUgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIGFycmF5IHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBpbmRpY2VzIGRvd24gdG8gYG1pbl9pbmRleCcgYW5kIHVwIHRvIGBtYXhfaW5kZXgnLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBpdGVtLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQnIGluc3RlYWQgYXMgZnV0dXJlIHZlcnNpb25zIHdpbGwgaW1wbGVtZW50IGByZXNpemUnIGFzIHNwZWNpZmllZCBpbiBFTEtTLlwiXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKCh7R30pLmRlZmF1bHQsIG1pbl9pbmRleCwgbWF4X2luZGV4KVxuICAgIGVuc3VyZVxuICAgICAgbm9fbG93X2xvc3Q6IGxvd2VyID0gbWluX2luZGV4IG9yIGVsc2UgbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIG5vX2hpZ2hfbG9zdDogdXBwZXIgPSBtYXhfaW5kZXggb3IgZWxzZSB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGFyZWEuY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9pdGVtczogc2FtZV9pdGVtcyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgcmViYXNlIChhX2xvd2VyOiBsaWtlIGxvd2VyKVxuICAgICAgLS0gV2l0aG91dCBjaGFuZ2luZyB0aGUgYWN0dWFsIGNvbnRlbnQgb2YgYEN1cnJlbnQnIHdlIHNldCBgbG93ZXInIHRvIGBhX2xvd2VyJ1xuICAgICAgLS0gYW5kIGB1cHBlcicgYWNjb3JkaW5nbHkgdG8gYGFfbG93ZXIgKyBjb3VudCAtIDEnLlxuICAgIGxvY2FsXG4gICAgICBsX29sZF9sb3dlcjogbGlrZSBsb3dlclxuICAgIGRvXG4gICAgICBsX29sZF9sb3dlciA6PSBsb3dlclxuICAgICAgbG93ZXIgOj0gYV9sb3dlclxuICAgICAgdXBwZXIgOj0gYV9sb3dlciArICh1cHBlciAtIGxfb2xkX2xvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IGFfbG93ZXJcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhX2xvd2VyICsgb2xkIGNvdW50IC0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jOiBBTllcbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFcbiAgICBlbmRcblxuICB0b19jaWw6IE5BVElWRV9BUlJBWSBbR11cbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLm5hdGl2ZV9hcnJheVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3NwZWNpYWw6IFNQRUNJQUwgW0ddXG4gICAgICAtLSAnYXJlYScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhXG4gICAgZW5zdXJlXG4gICAgICB0b19zcGVjaWFsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtHXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbR11cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbG93ZXJcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiB1cHBlclxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBSZWluaXRpYWxpemUgYnkgY29weWluZyBhbGwgdGhlIGl0ZW1zIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYGNsb25lJy4pXG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgc2V0X2FyZWEgKG90aGVyLmFyZWEudHdpbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBlcXVhbF9hcmVhczogYXJlYSB+IG90aGVyLmFyZWFcbiAgICBlbmRcblxuICBzdWJhcnJheSAoc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogQVJSQVkgW0ddXG4gICAgICAtLSBBcnJheSBtYWRlIG9mIGl0ZW1zIG9mIGN1cnJlbnQgYXJyYXkgd2l0aGluXG4gICAgICAtLSBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IHZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IHVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgIGRvXG4gICAgICBpZiBzdGFydF9wb3MgPD0gZW5kX3BvcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKGl0ZW0gKHN0YXJ0X3BvcyksIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICAgICAgICAtLSBPbmx5IGNvcHkgZWxlbWVudHMgaWYgbmVlZGVkLlxuICAgICAgICBSZXN1bHQuc3ViY29weSAoQ3VycmVudCwgc3RhcnRfcG9zLCBlbmRfcG9zLCBzdGFydF9wb3MpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gbWFrZSBlbXB0eVxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHlcbiAgICAgICAgUmVzdWx0LnJlYmFzZSAoc3RhcnRfcG9zKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcjogUmVzdWx0Lmxvd2VyID0gc3RhcnRfcG9zXG4gICAgICB1cHBlcjogUmVzdWx0LnVwcGVyID0gZW5kX3Bvc1xuICAgICAgLS0gY29waWVkOiBmb3JhbGwgYGknIGluIGBzdGFydF9wb3MnIC4uIGBlbmRfcG9zJyxcbiAgICAgIC0tICAgICBSZXN1bHQuaXRlbSAoaSkgPSBpdGVtIChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBwcnVuZSAodjogRylcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2JyBpZiBhbnkuXG4gICAgICAtLSAoUHJlY29uZGl0aW9uIGlzIEZhbHNlLilcbiAgICBkb1xuICAgIGVuZFxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBgdicgdG8gc3RydWN0dXJlLlxuICAgICAgLS0gKFByZWNvbmRpdGlvbiBpcyBGYWxzZS4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBlbXB0eV9hcmVhOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYXJlYScgZW1wdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhID0gVm9pZCBvciBlbHNlIGFyZWEuY2FwYWNpdHkgPSAwXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGFyZWFfZXhpc3RzOiBhcmVhIC89IFZvaWRcbiAgY29uc2lzdGVudF9zaXplOiBjYXBhY2l0eSA9IHVwcGVyIC0gbG93ZXIgKyAxXG4gIG5vbl9uZWdhdGl2ZV9jb3VudDogY291bnQgPj0gMFxuICBpbmRleF9zZXRfaGFzX3NhbWVfY291bnQ6IHZhbGlkX2luZGV4X3NldFxuLS0gSW50ZXJuYWwgZGlzY3Vzc2lvbiBoYXZlbid0IHJlYWNoZWQgYW4gYWdyZWVtZW50IG9uIHRoaXMgaW52YXJpYW50XG4tLSAgaW5kZXhfc2V0X2hhc19zYW1lX2JvdW5kczogKChpbmRleF9zZXQubG93ZXIgPSBsb3dlcikgYW5kXG4tLSAgICAgICAgKGluZGV4X3NldC51cHBlciA9IGxvd2VyICsgY291bnQgLSAxKSlcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGJhZywgYWNjZXNzO1xuICBhY2Nlc3M6IG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQkFHIFtHXSBpbmhlcml0XG5cbiAgQ09MTEVDVElPTiBbR11cbiAgICByZWRlZmluZVxuICAgICAgZXh0ZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBvY2N1cnJlbmNlcyAodjogRyk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycyBpbiBzdHJ1Y3R1cmVcbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9vY2N1cnJlbmNlczogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBhIG5ldyBvY2N1cnJlbmNlIG9mIGB2Jy5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICAgIC0tIENvbW1lbnRlZCBkdWUgdG8gdGhlIGV4cGVuc2l2ZSBuYXR1cmUgb2YgdGhlIGNoZWNrIHdoZW4gaW5zZXJ0aW5nIGEgbmV3IGl0ZW1cbiAgICAgICAgLS0gaW4gYSBjb250YWluZXJzIHdpdGggbWFueSBpdGVtcy5cbiAgICAgIC0tIG9uZV9tb3JlX29jY3VycmVuY2U6IG9jY3VycmVuY2VzICh2KSA9IG9sZCAob2NjdXJyZW5jZXMgKHYpKSArIDFcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlRydXRoIHZhbHVlcywgd2l0aCB0aGUgYm9vbGVhbiBvcGVyYXRpb25zXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uQm9vbGVhblwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIEJPT0xFQU5cblxuaW5oZXJpdFxuICBCT09MRUFOX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBjb25qdW5jdGVkLFxuICAgICAgY29uanVuY3RlZF9zZW1pc3RyaWN0LFxuICAgICAgZGlzanVuY3RlZCxcbiAgICAgIGRpc2p1bmN0ZWRfc2VtaXN0cmljdCxcbiAgICAgIGRpc2p1bmN0ZWRfZXhjbHVzaXZlLFxuICAgICAgaW1wbGljYXRpb24sXG4gICAgICBuZWdhdGVkXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtCT09MRUFOX1JFRn0pXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGNvbmp1bmN0ZWQgYWxpYXMgXCJhbmRcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGNvbmp1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjb25qdW5jdGVkX3NlbWlzdHJpY3QgYWxpYXMgXCJhbmQgdGhlblwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gc2VtaS1zdHJpY3QgY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGltcGxpY2F0aW9uIGFsaWFzIFwiaW1wbGllc1wiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gaW1wbGljYXRpb24gb2YgYG90aGVyJ1xuICAgICAgLS0gKHNlbWktc3RyaWN0KVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBuZWdhdGVkIGFsaWFzIFwibm90XCI6IEJPT0xFQU5cbiAgICAgIC0tIE5lZ2F0aW9uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWQgYWxpYXMgXCJvclwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZGlzanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWRfc2VtaXN0cmljdCBhbGlhcyBcIm9yIGVsc2VcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHNlbWktc3RyaWN0IGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkX2V4Y2x1c2l2ZSBhbGlhcyBcInhvclwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZXhjbHVzaXZlIG9yIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhIGJvb2xlYW4gdmFsdWVcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBCT09MRUFOX1JFRiBpbmhlcml0XG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IEJPT0xFQU5fUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogQk9PTEVBTl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9pdGVtOiBSZXN1bHQuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuICB0b19pbnRlZ2VyOiBJTlRFR0VSXG4gICAgICAtLSAxIGlmIGBUcnVlJ1xuICAgICAgLS0gMCBpZiBgRmFsc2UnXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3RfaXRlbV9pbXBsaWVzX3plcm86IG5vdCBpdGVtIGltcGxpZXMgUmVzdWx0ID0gMFxuICAgICAgaXRlbV9pbXBsaWVzX29uZTogaXRlbSBpbXBsaWVzIFJlc3VsdCA9IDFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChiOiBCT09MRUFOKVxuICAgICAgLS0gTWFrZSBgYicgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGNvbmp1bmN0ZWQgYWxpYXMgXCJhbmRcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIGFuZCBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZV9tb3JnYW46IFJlc3VsdCA9IG5vdCAobm90IEN1cnJlbnQgb3Igbm90IG90aGVyKVxuICAgICAgY29tbXV0YXRpdmU6IFJlc3VsdCA9IChvdGhlciBhbmQgQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnRfd2l0aF9zZW1pX3N0cmljdDogUmVzdWx0IGltcGxpZXMgKEN1cnJlbnQgYW5kIHRoZW4gb3RoZXIpXG4gICAgZW5kXG5cbiAgY29uanVuY3RlZF9zZW1pc3RyaWN0IGFsaWFzIFwiYW5kIHRoZW5cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gc2VtaS1zdHJpY3QgY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIGFuZCB0aGVuIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlX21vcmdhbjogUmVzdWx0ID0gbm90IChub3QgQ3VycmVudCBvciBlbHNlIG5vdCBvdGhlcilcbiAgICBlbmRcblxuICBpbXBsaWNhdGlvbiBhbGlhcyBcImltcGxpZXNcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gaW1wbGljYXRpb24gb2YgYG90aGVyJ1xuICAgICAgLS0gKHNlbWktc3RyaWN0KVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBpbXBsaWVzIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChub3QgQ3VycmVudCBvciBlbHNlIG90aGVyKVxuICAgIGVuZFxuXG4gIG5lZ2F0ZWQgYWxpYXMgXCJub3RcIjogQk9PTEVBTlxuICAgICAgLS0gTmVnYXRpb25cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBpdGVtXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZCBhbGlhcyBcIm9yXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBvciBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZV9tb3JnYW46IFJlc3VsdCA9IG5vdCAobm90IEN1cnJlbnQgYW5kIG5vdCBvdGhlcilcbiAgICAgIGNvbW11dGF0aXZlOiBSZXN1bHQgPSAob3RoZXIgb3IgQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnRfd2l0aF9zZW1pX3N0cmljdDogUmVzdWx0IGltcGxpZXMgKEN1cnJlbnQgb3IgZWxzZSBvdGhlcilcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkX3NlbWlzdHJpY3QgYWxpYXMgXCJvciBlbHNlXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHNlbWktc3RyaWN0IGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBvciBlbHNlIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlX21vcmdhbjogUmVzdWx0ID0gbm90IChub3QgQ3VycmVudCBhbmQgdGhlbiBub3Qgb3RoZXIpXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZF9leGNsdXNpdmUgYWxpYXMgXCJ4b3JcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZXhjbHVzaXZlIG9yIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSB4b3Igb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChDdXJyZW50IG9yIG90aGVyKSBhbmQgbm90IChDdXJyZW50IGFuZCBvdGhlcikpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBib29sZWFuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBcIkZhbHNlXCJcbiAgICAgIGlmIGl0ZW0gdGhlblxuICAgICAgICBSZXN1bHQgOj0gXCJUcnVlXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgaW52b2x1dGl2ZV9uZWdhdGlvbjogKG5vdCAobm90IEN1cnJlbnQpKS5pdGVtID0gaXRlbVxuICBub25fY29udHJhZGljdGlvbjogbm90ICgobm90IEN1cnJlbnQpIGFuZCBDdXJyZW50KVxuICBjb21wbGV0ZW5lc3M6IChub3QgQ3VycmVudCkgb3IgQ3VycmVudFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJCb3VuZGVkIGRhdGEgc3RydWN0dXJlcywgd2l0aCBhIG5vdGlvbiBvZiBjYXBhY2l0eS5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBib3VuZGVkLCBzdG9yYWdlO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQk9VTkRFRCBbR10gaW5oZXJpdFxuXG4gIEZJTklURSBbR11cblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgaXRlbXMgdGhhdCBtYXkgYmUgc3RvcmVkXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZnVsbDogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGZ1bGw/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY291bnQgPSBjYXBhY2l0eSlcbiAgICBlbmRcblxuICByZXNpemFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgY2FwYWNpdHknIGJlIGNoYW5nZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgdmFsaWRfY291bnQ6IGNvdW50IDw9IGNhcGFjaXR5XG4gIGZ1bGxfZGVmaW5pdGlvbjogZnVsbCA9IChjb3VudCA9IGNhcGFjaXR5KVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogc3RvcmFnZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEJPWCBbR10gaW5oZXJpdFxuXG4gIENPTlRBSU5FUiBbR11cblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZnVsbDogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGZpbGxlZCB0byBjYXBhY2l0eT9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlVuaWNvZGUgY2hhcmFjdGVycywgd2l0aCBjb21wYXJpc29uIG9wZXJhdGlvbnNcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlVJbnQzMlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzc1xuICBDSEFSQUNURVJfMzJcblxuaW5oZXJpdFxuICBDSEFSQUNURVJfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvZGUsXG4gICAgICBuYXR1cmFsXzMyX2NvZGUsXG4gICAgICB0b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Q0hBUkFDVEVSXzMyX1JFRn0pXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZTogSU5URUdFUlxuICAgICAgLS0gQXNzb2NpYXRlZCBpbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfOFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhIHVuaWNvZGUgY2hhcmFjdGVyIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgQ0hBUkFDVEVSXzMyX1JFRlxuXG5pbmhlcml0XG4gIENPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFVuaWNvZGUgY2hhcmFjdGVyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGNvZGU6IElOVEVHRVJcbiAgICAgIC0tIEFzc29jaWF0ZWQgaW50ZWdlciB2YWx1ZVxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbmF0dXJhbF8zMl9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgbmF0dXJhbF8zMl9jb2RlOiBOQVRVUkFMXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIG5hdHVyYWwgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0ubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5zdXJlXG4gICAgICBuYXR1cmFsXzMyX2NvZGVfaW5fcmFuZ2U6IFJlc3VsdCA+PSBtaW5fdmFsdWUgYW5kIFJlc3VsdCA8PSBtYXhfdmFsdWVcbiAgICBlbmRcblxuICBtaW5fdmFsdWU6IE5BVFVSQUxfMzIgPSAwXG4gIG1heF92YWx1ZTogTkFUVVJBTF8zMiA9IDQyOTQ5NjcyOTVcbiAgICAgIC0tIEJvdW5kcyBmb3IgaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBDSEFSQUNURVJfMzJcblxuICBtYXhfdW5pY29kZV92YWx1ZTogTkFUVVJBTF8zMiA9IDB4MTBGRkZEXG4gICAgICAtLSBNYXhpbXVtIFVuaWNvZGUgY2hhcmFjdGVycy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgZ3JlYXRlciB0aGFuIGN1cnJlbnQgY2hhcmFjdGVyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChuYXR1cmFsXzMyX2NvZGUgPCBvdGhlci5uYXR1cmFsXzMyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyByb3V0aW5lc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKGluY3I6IE5BVFVSQUxfMzIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFkZCBgaW5jcicgdG8gdGhlIGNvZGUgb2YgYGl0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luY3JlbWVudDogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgKyBpbmNyKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0ubmF0dXJhbF8zMl9jb2RlICsgaW5jcikudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IGluY3JcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAoZGVjcjogTkFUVVJBTF8zMik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gU3VidHJhY3QgYGRlY3InIGZyb20gdGhlIGNvZGUgb2YgYGl0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2RlY3JlbWVudDogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjQgLSBkZWNyKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0ubmF0dXJhbF8zMl9jb2RlIC0gZGVjcikudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IGl0ZW0gfC18IFJlc3VsdCA9IGRlY3JcbiAgICBlbmRcblxuICBkaWZmZXJlbmNlIGFsaWFzIFwifC18XCIgKG90aGVyOiBDSEFSQUNURVJfMzIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBEaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNvZGVzIG9mIGBpdGVtJyBhbmQgYG90aGVyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjQgLSBvdGhlci5uYXR1cmFsXzMyX2NvZGUudG9faW50ZWdlcl82NFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfbm9uX25lZ2F0aXZlX3Jlc3VsdDogUmVzdWx0ID49IDAgaW1wbGllcyAoKG90aGVyICsgUmVzdWx0LnRvX25hdHVyYWxfMzIpID0gaXRlbSlcbiAgICAgIHZhbGlkX25lZ2F0aXZlX3Jlc3VsdDogUmVzdWx0IDwgMCBpbXBsaWVzIChvdGhlciA9IChpdGVtICsgUmVzdWx0LnRvX25hdHVyYWxfMzIpKVxuICAgIGVuZFxuXG4gIG5leHQ6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gTmV4dCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5uYXR1cmFsXzMyX2NvZGUudG9fbmF0dXJhbF82NCArIDEpLmlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICsgMVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgfC18IGl0ZW0gPSAxXG4gICAgZW5kXG5cbiAgcHJldmlvdXM6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gUHJldmlvdXMgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgLSAxKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAtIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gLTFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBNYWtlIGBjJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHdpZGUgY2hhcmFjdGVyLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDYpXG4gICAgICBSZXN1bHQuYXBwZW5kX2NoYXJhY3RlciAoJ1UnKVxuICAgICAgUmVzdWx0LmFwcGVuZF9jaGFyYWN0ZXIgKCcrJylcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nIChuYXR1cmFsXzMyX2NvZGUudG9faGV4X3N0cmluZylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBDSEFSQUNURVJfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogQ0hBUkFDVEVSXzMyX1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQ29udmVydCBjdXJyZW50IHRvIENIQVJBQ1RFUl84LlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2NoYXJhY3Rlcl84X2NvbXBhdGlibGU6IGlzX2NoYXJhY3Rlcl84XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfMzIuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgYXNfdXBwZXIsIHVwcGVyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFVwcGVyY2FzZSB2YWx1ZSBvZiBgaXRlbScuXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX2xvd2VyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMudG9fdXBwZXIgKGl0ZW0pXG4gICAgZW5kXG5cbiAgYXNfbG93ZXIsIGxvd2VyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIExvd2VyY2FzZSB2YWx1ZSBvZiBgaXRlbScuXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX3VwcGVyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMudG9fbG93ZXIgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2NoYXJhY3Rlcl84OiBCT09MRUFOXG4gICAgICAtLSBDYW4gY3VycmVudCBiZSByZXByZXNlbnRlZCBvbiBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlIDw9IHtDSEFSQUNURVJfOH0ubWF4X3ZhbHVlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpc19hbHBoYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWM/XG4gICAgICAtLSBBbHBoYWJldGljIGlzIGBpc191cHBlcicgb3IgYGlzX2xvd2VyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfYWxwaGEgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfdXBwZXI6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyB1cHBlcmNhc2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3VwcGVyIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2xvd2VyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgbG93ZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc19sb3dlciAoaXRlbSlcbiAgICBlbmRcblxuICBpc19kaWdpdDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgZGVjaW1hbCBkaWdpdCBhcyBleHBlY3RlZCBmb3IgQVNDSUkgY2hhcmFjdGVycz9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODkuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAnMCcgPD0gaXRlbSBhbmQgaXRlbSA8PSAnOSdcbiAgICBlbmRcblxuICBpc191bmljb2RlX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBkZWNpbWFsIGRpZ2l0IGFzIGV4cGVjdGVkIGZvciBVbmljb2RlIGNoYXJhY3RlcnM/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2RpZ2l0IChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2hleGFfZGlnaXQ6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIGhleGFkZWNpbWFsIGRpZ2l0IGFzIGV4cGVjdGVkIGZvciBBU0NJSSBjaGFyYWN0ZXJzP1xuICAgICAgLS0gQSBkaWdpdCBpcyBvbmUgb2YgMDEyMzQ1Njc4OUFCQ0RFRmFiY2VkZi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfaGV4YV9kaWdpdCAoaXRlbSlcbiAgICBlbmRcblxuICBpc19zcGFjZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgd2hpdGUgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3NwYWNlIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX3B1bmN0dWF0aW9uOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBwdW5jdHVhdGlvbj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfcHVuY3R1YXRpb24gKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfYWxwaGFfbnVtZXJpYzogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWMgb3IgYSBkaWdpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfYWxwaGEgKGl0ZW0pIG9yIHByb3BlcnRpZXMuaXNfZGlnaXQgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfY29udHJvbDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgY29udHJvbCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2NvbnRyb2wgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgcHJvcGVydGllczogQ0hBUkFDVEVSX1BST1BFUlRZXG4gICAgICAtLSBQcm9wZXJ0eSBmb3IgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ2hhcmFjdGVycywgd2l0aCBjb21wYXJpc29uIG9wZXJhdGlvbnMgYW5kIGFuIEFTQ0lJIGNvZGVcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5DaGFyXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTAtMzAgMDg6MzI6NDYgLTA3MDAgKFR1ZSwgMzAgT2N0IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDIyICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3NcbiAgQ0hBUkFDVEVSXzhcblxuaW5oZXJpdFxuICBDSEFSQUNURVJfOF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgY29kZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Q0hBUkFDVEVSXzhfUkVGfSksXG4gIHRvX2NoYXJhY3Rlcl8zMjoge0NIQVJBQ1RFUl8zMn1cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvblxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGEgY2hhcmFjdGVyIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3MgQ0hBUkFDVEVSXzhfUkVGIGluaGVyaXRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG5hdHVyYWxfMzJfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5jb2RlXG4gICAgZW5zdXJlXG4gICAgICBjb2RlX25vbl9uZWdhdGlmOiBSZXN1bHQgPj0gMFxuICAgICAgY29kZV9pbl9yYW5nZTogUmVzdWx0ID49IG1pbl92YWx1ZSBhbmQgUmVzdWx0IDw9IG1heF92YWx1ZVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmNvZGUudG9fbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgbWluX3ZhbHVlOiBJTlRFR0VSID0gMFxuICBtYXhfdmFsdWU6IElOVEVHRVIgPSAyNTVcbiAgbWF4X2FzY2lpX3ZhbHVlOiBJTlRFR0VSID0gMTI3XG4gICAgICAtLSBCb3VuZHMgZm9yIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVycyAoQVNDSUkpXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGNoYXJhY3Rlcj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5hdHVyYWxfMzJfY29kZSA8IG90aGVyLm5hdHVyYWxfMzJfY29kZVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAobmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgcm91dGluZXNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChpbmNyOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFkZCBgaW5jcicgdG8gdGhlIGNvZGUgb2YgYGl0ZW0nXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5jcmVtZW50OiAoaXRlbS5jb2RlICsgaW5jcikuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0uY29kZSArIGluY3IpLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IGluY3JcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAoZGVjcjogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBTdWJ0cmFjdCBgZGVjcicgZnJvbSB0aGUgY29kZSBvZiBgaXRlbSdcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9kZWNyZW1lbnQ6IChpdGVtLmNvZGUgLSBkZWNyKS5pc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoaXRlbS5jb2RlIC0gZGVjcikudG9fY2hhcmFjdGVyXzhcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogaXRlbSB8LXwgUmVzdWx0ID0gZGVjclxuICAgIGVuZFxuXG4gIGRpZmZlcmVuY2UgYWxpYXMgXCJ8LXxcIiAob3RoZXI6IENIQVJBQ1RFUl84KTogSU5URUdFUlxuICAgICAgLS0gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb2RlcyBvZiBgaXRlbScgYW5kIGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uY29kZSAtIG90aGVyLmNvZGVcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogb3RoZXIgKyBSZXN1bHQgPSBpdGVtXG4gICAgZW5kXG5cbiAgbmV4dDogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIE5leHQgY2hhcmFjdGVyXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5jb2RlICsgMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSArIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gMVxuICAgIGVuZFxuXG4gIHByZXZpb3VzOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUHJldmlvdXMgY2hhcmFjdGVyXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5jb2RlIC0gMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAtIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gLTFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIE1ha2UgYGMnIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSlcbiAgICAgIFJlc3VsdC5hcHBlbmRfY2hhcmFjdGVyIChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IENIQVJBQ1RFUl84X1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IENIQVJBQ1RFUl84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG4gIGFzX3VwcGVyLCB1cHBlcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFVwcGVyY2FzZSB2YWx1ZSBvZiBgaXRlbSdcbiAgICAgIC0tIFJldHVybnMgYGl0ZW0nIGlmIG5vdCBgaXNfbG93ZXInXG4gICAgZG9cbiAgICAgIGlmIGlzX2xvd2VyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgLSAoJ2EnKS5jb2RlICsgKCdBJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFzX2xvd2VyLCBsb3dlcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIExvd2VyY2FzZSB2YWx1ZSBvZiBgaXRlbSdcbiAgICAgIC0tIFJldHVybnMgYGl0ZW0nIGlmIG5vdCBgaXNfdXBwZXInXG4gICAgZG9cbiAgICAgIGlmIGlzX3VwcGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgLSAoJ0EnKS5jb2RlICsgKCdhJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19hbHBoYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWM/XG4gICAgICAtLSBBbHBoYWJldGljIGlzIGBpc191cHBlcicgb3IgYGlzX2xvd2VyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX3VwcGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgdXBwZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3VwcGVyX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2xvd2VyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgbG93ZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX2xvd2VyX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBkaWdpdD9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiBpc19kaWdpdF9mbGFnKSA+IDBcbiAgICBlbmRcblxuICBpc19oZXhhX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYW4gaGV4YWRlY2ltYWwgZGlnaXQ/XG4gICAgICAtLSBBIGRpZ2l0IGlzIG9uZSBvZiAwMTIzNDU2Nzg5QUJDREVGYWJjZWRmXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgKGlzX2hleGFfZGlnaXRfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcpKSA+IDBcbiAgICBlbmRcblxuICBpc19zcGFjZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgd2hpdGUgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfd2hpdGVfc3BhY2VfZmxhZykgPiAwXG4gICAgZW5kXG5cbiAgaXNfcHVuY3R1YXRpb246IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHB1bmN0dWF0aW9uP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3B1bmN0dWF0aW9uX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2FscGhhX251bWVyaWM6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhbHBoYWJldGljIG9yIGEgZGlnaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgKGlzX3VwcGVyX2ZsYWcgfCBpc19sb3dlcl9mbGFnIHwgaXNfZGlnaXRfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX3ByaW50YWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBpbmNsdWRpbmcgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICZcbiAgICAgICAgKGlzX3VwcGVyX2ZsYWcgfCBpc19sb3dlcl9mbGFnIHwgaXNfZGlnaXRfZmxhZyB8IGlzX3B1bmN0dWF0aW9uX2ZsYWcgfCBpc19zcGFjZV9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfZ3JhcGg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHByaW50YWJsZSBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmXG4gICAgICAgIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcgfCBpc19wdW5jdHVhdGlvbl9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfY29udHJvbDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgY29udHJvbCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfY29udHJvbF9mbGFnKSA+IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBjaGFyYWN0ZXJfdHlwZXMgKGFfY29kZTogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gQXNzb2NpYXRlZCB0eXBlIGZvciBjaGFyYWN0ZXIgb2YgY29kZSBgYV9jb2RlJ1xuICAgIGRvXG4gICAgICAgIC0tIEZvciBjaGFyYWN0ZXIgd2hvc2UgY29kZSBpcyBhYm92ZSAyNTYsIGl0IGlzIGFzIGlmXG4gICAgICAgIC0tIHdlIGhhZCBubyBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAgICAgIGlmIGFfY29kZSA8IDI1NiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlcm5hbF9jaGFyYWN0ZXJfdHlwZXMuaXRlbSAoYV9jb2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfY2hhcmFjdGVyX3R5cGVzOiBTUEVDSUFMIFtOQVRVUkFMXzhdXG4gICAgICAtLSBBcnJheSB3aGljaCBzdG9yZXMgdGhlIHZhcmlvdXMgdHlwZSBmb3IgdGhlIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDI1NilcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgLS0gMCAgbnVsbFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxICBzdGFydCBvZiBoZWFkaW5nXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDIgIHN0YXJ0IG9mIHRleHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMyAgZW5kIG9mIHRleHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNCAgZW5kIG9mIHRyYW5zbWlzc2lvblxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1ICBlbnF1aXJ5XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDYgIGFja25vd2xlZGdlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDcgIGJlbGxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gOCAgYmFja3NwYWNlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDkgIGhvcml6b250YWwgdGFiXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEwIE5MIGxpbmUgZmVlZCwgbmV3IGxpbmVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZyB8IGlzX3doaXRlX3NwYWNlX2ZsYWcpICAgLS0gMTEgdmVydGljYWwgdGFiXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEyIE5QIGZvcm0gZmVlZCwgbmV3IHBhZ2VcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZyB8IGlzX3doaXRlX3NwYWNlX2ZsYWcpICAgLS0gMTMgY2FycmlhZ2UgcmV0dXJuPUNSXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDE0IHNoaWZ0IG91dFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNSBzaGlmdCBpblxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxN1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxOFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxOVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyM1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNyBFc2NhcGVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjggZmlsZSBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjkgZ3JvdXAgc2VwYXJhdG9yXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDMwIHJlY29yZCBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMzEgdW5pdCBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3doaXRlX3NwYWNlX2ZsYWcgfCBpc19zcGFjZV9mbGFnKSAgICAgLS0gMzIgU3BhY2VcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzMgIVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNCBcIlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNSAjXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM2ICRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzcgJVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzOCAmXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM5ICdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDAgKFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0MSApXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQyICpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDMgK1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NCAsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQ1IC1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDYgLlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NyAvXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDQ4IDBcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNDkgMVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MCAyXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDUxIDNcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTIgNFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MyA1XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU0IDZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTUgN1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1NiA4XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU3IDlcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNTggOlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA1OSA7XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYwIDxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjEgPVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA2MiA+XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYzID9cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjQgQFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2NSBBXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY2IEJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNjcgQ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2OCBEXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY5IEVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNzAgRlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3MSBHXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDcyIEhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzMgSVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NCBKXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc1IEtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzYgTFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NyBNXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc4IE5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzkgT1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MCBQXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDgxIFFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODIgUlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MyBTXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg0IFRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODUgVVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4NiBWXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg3IFdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODggWFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4OSBZXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDkwIFpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTEgW1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5MiBcXFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5MyBdXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDk0IF5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTUgX1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5NiBgXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDk3IGFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gOTggYlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA5OSBjXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDEwMCAgZFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSAxMDEgIGVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gMTAyICBmXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwMyAgZ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDQgIGhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA1ICBpXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwNiAgalxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDcgIGtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA4ICBsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwOSAgbVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTAgIG5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTExICBvXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExMiAgcFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTMgIHFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE0ICByXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExNSAgc1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTYgIHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE3ICB1XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExOCAgdlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTkgIHdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTIwICB4XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyMSAgeVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMjIgIHpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTIzICB7XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDEyNCAgfFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAxMjUgIH1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTI2ICB+XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyNyAgREVMXG4gICAgICBSZXN1bHQuZmlsbF93aXRoICgwLCAxMjgsIDI1NSkgICAgICAgICAgICAgIC0tIGV4dGVuZGVkIEFTQ0lJXG4gICAgZW5zdXJlXG4gICAgICBpbnRlcm5hbF9jaGFyYWN0ZXJfdHlwZXNfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgaXNfdXBwZXJfZmxhZzogTkFUVVJBTF84ID0gMHgwMVxuXG4gIGlzX2xvd2VyX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MDJcblxuICBpc19kaWdpdF9mbGFnOiBOQVRVUkFMXzggPSAweDA0XG5cbiAgaXNfd2hpdGVfc3BhY2VfZmxhZzogTkFUVVJBTF84ID0gMHgwOFxuXG4gIGlzX3B1bmN0dWF0aW9uX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MTBcblxuICBpc19jb250cm9sX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MjBcblxuICBpc19oZXhhX2RpZ2l0X2ZsYWc6IE5BVFVSQUxfOCA9IDB4NDBcblxuICBpc19zcGFjZV9mbGFnOiBOQVRVUkFMXzggPSAweDgwO1xuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGNvbGxlY3Rpb24sIGFjY2VzcztcbiAgYWNjZXNzOiBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIENPTExFQ1RJT04gW0ddIGluaGVyaXRcblxuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc19pbnNlcnRlZCAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIEhhcyBgdicgYmVlbiBpbnNlcnRlZCBieSB0aGUgbW9zdCByZWNlbnQgaW5zZXJ0aW9uP1xuICAgICAgLS0gKEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZSByZXR1cm5lZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmdcbiAgICAgIC0tIGBoYXMgKHYpJy4gSG93ZXZlciwgZGVzY2VuZGFudHMgbWlnaHQgYmUgYWJsZSB0byBwcm92aWRlIG1vcmVcbiAgICAgIC0tIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbnMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaGFzICh2KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0LCBleHRlbmQgKHY6IEcpXG4gICAgICAtLSBFbnN1cmUgdGhhdCBzdHJ1Y3R1cmUgaW5jbHVkZXMgYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9pbnNlcnRlZDogaXNfaW5zZXJ0ZWQgKHYpXG4gICAgZW5kXG5cbiAgZmlsbCAob3RoZXI6IENPTlRBSU5FUiBbR10pXG4gICAgICAtLSBGaWxsIHdpdGggYXMgbWFueSBpdGVtcyBvZiBgb3RoZXInIGFzIHBvc3NpYmxlLlxuICAgICAgLS0gVGhlIHJlcHJlc2VudGF0aW9ucyBvZiBgb3RoZXInIGFuZCBjdXJyZW50IHN0cnVjdHVyZVxuICAgICAgLS0gbmVlZCBub3QgYmUgdGhlIHNhbWUuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICBsb2NhbFxuICAgICAgbGluX3JlcDogTElORUFSIFtHXVxuICAgIGRvXG4gICAgICBsaW5fcmVwIDo9IG90aGVyLmxpbmVhcl9yZXByZXNlbnRhdGlvblxuICAgICAgZnJvbVxuICAgICAgICBsaW5fcmVwLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBub3QgZXh0ZW5kaWJsZSBvciBlbHNlIGxpbl9yZXAub2ZmXG4gICAgICBsb29wXG4gICAgICAgIGV4dGVuZCAobGluX3JlcC5pdGVtKVxuICAgICAgICBsaW5fcmVwLmZvcnRoXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcHJ1bmUgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgb25lIG9jY3VycmVuY2Ugb2YgYHYnIGlmIGFueS5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgcmVxdWlyZVxuICAgICAgcHJ1bmFibGU6IHBydW5hYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGB2Jy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgICAtLXxEZWZhdWx0IGltcGxlbWVudGF0aW9uLCB1c3VhbGx5IGluZWZmaWNpZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbCBub3QgaGFzICh2KSBsb29wXG4gICAgICAgIHBydW5lICh2KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub19tb3JlX29jY3VycmVuY2VzOiBub3QgaGFzICh2KVxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zLlxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB3aXBlZF9vdXQ6IGlzX2VtcHR5XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBDT01QQVJBQkxFIGluaGVyaXRcblxuICBQQVJUX0NPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcywgaXNfbGVzc19lcXVhbCxcbiAgICAgIGlzX2dyZWF0ZXIsIGlzX2dyZWF0ZXJfZXF1YWwsXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgYXN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgbm90IChvdGhlciA8IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfbGVzc19lcXVhbCBhbGlhcyBcIjw9XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCAob3RoZXIgPCBDdXJyZW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoKEN1cnJlbnQgPCBvdGhlcikgb3IgKEN1cnJlbnQgfiBvdGhlcikpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlciBhbGlhcyBcIj5cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgb2JqZWN0IGdyZWF0ZXIgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIgPCBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChvdGhlciA8IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlcl9lcXVhbCBhbGlhcyBcIj49XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCAoQ3VycmVudCA8IG90aGVyKVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAob3RoZXIgPD0gQ3VycmVudClcbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobm90IChDdXJyZW50IDwgb3RoZXIpIGFuZCBub3QgKG90aGVyIDwgQ3VycmVudCkpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHRyaWNob3RvbXk6IFJlc3VsdCA9IChub3QgKEN1cnJlbnQgPCBvdGhlcikgYW5kIG5vdCAob3RoZXIgPCBDdXJyZW50KSlcbiAgICBlbmRcblxuICB0aHJlZV93YXlfY29tcGFyaXNvbiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IElOVEVHRVJcbiAgICAgIC0tIElmIGN1cnJlbnQgb2JqZWN0IGVxdWFsIHRvIGBvdGhlcicsIDA7XG4gICAgICAtLSBpZiBzbWFsbGVyLCAtMTsgaWYgZ3JlYXRlciwgMVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50IDwgb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVsc2VpZiBvdGhlciA8IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBlcXVhbF96ZXJvOiAoUmVzdWx0ID0gMCkgPSAoQ3VycmVudCB+IG90aGVyKVxuICAgICAgc21hbGxlcl9uZWdhdGl2ZTogKFJlc3VsdCA9IC0xKSA9IChDdXJyZW50IDwgb3RoZXIpXG4gICAgICBncmVhdGVyX3Bvc2l0aXZlOiAoUmVzdWx0ID0gMSkgPSAoQ3VycmVudCA+IG90aGVyKVxuICAgIGVuZFxuXG4gIG1heCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVGhlIGdyZWF0ZXIgb2YgY3VycmVudCBvYmplY3QgYW5kIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA+PSBvdGhlciB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBvdGhlclxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjdXJyZW50X2lmX25vdF9zbWFsbGVyOiBDdXJyZW50ID49IG90aGVyIGltcGxpZXMgUmVzdWx0ID0gQ3VycmVudFxuICAgICAgb3RoZXJfaWZfc21hbGxlcjogQ3VycmVudCA8IG90aGVyIGltcGxpZXMgUmVzdWx0ID0gb3RoZXJcbiAgICBlbmRcblxuICBtaW4gKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRoZSBzbWFsbGVyIG9mIGN1cnJlbnQgb2JqZWN0IGFuZCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPD0gb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gb3RoZXJcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY3VycmVudF9pZl9ub3RfZ3JlYXRlcjogQ3VycmVudCA8PSBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IEN1cnJlbnRcbiAgICAgIG90aGVyX2lmX2dyZWF0ZXI6IEN1cnJlbnQgPiBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IG90aGVyXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGlycmVmbGV4aXZlX2NvbXBhcmlzb246IG5vdCAoQ3VycmVudCA8IEN1cnJlbnQpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBhY2Nlc3M7XG4gIGFjY2VzczogbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJ1Y3R1cmUgaW5jbHVkZSBgdic/XG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBub3RfZm91bmRfaW5fZW1wdHk6IFJlc3VsdCBpbXBsaWVzIG5vdCBpc19lbXB0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gZWxlbWVudD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGVtcHR5OiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyBlbGVtZW50P1xuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMDogVXNlIGBpc19lbXB0eScgaW5zdGVhZFwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc19lbXB0eVxuICAgIGVuZFxuXG4gIG9iamVjdF9jb21wYXJpc29uOiBCT09MRUFOXG4gICAgICAtLSBNdXN0IHNlYXJjaCBvcGVyYXRpb25zIHVzZSBgZXF1YWwnIHJhdGhlciB0aGFuIGA9J1xuICAgICAgLS0gZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzPyAoRGVmYXVsdDogbm8sIHVzZSBgPScuKVxuXG4gIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgb2JqZWN0X2NvbXBhcmlzb24nIGJlIGNoYW5nZWQ/XG4gICAgICAtLSAoQW5zd2VyOiB5ZXMgYnkgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHNldHRpbmdcblxuICBjb21wYXJlX29iamVjdHNcbiAgICAgIC0tIEVuc3VyZSB0aGF0IGZ1dHVyZSBzZWFyY2ggb3BlcmF0aW9ucyB3aWxsIHVzZSBgZXF1YWwnXG4gICAgICAtLSByYXRoZXIgdGhhbiBgPScgZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzLlxuICAgIHJlcXVpcmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBkb1xuICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gVHJ1ZVxuICAgIGVuc3VyZVxuICAgICAgb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuICBjb21wYXJlX3JlZmVyZW5jZXNcbiAgICAgIC0tIEVuc3VyZSB0aGF0IGZ1dHVyZSBzZWFyY2ggb3BlcmF0aW9ucyB3aWxsIHVzZSBgPSdcbiAgICAgIC0tIHJhdGhlciB0aGFuIGBlcXVhbCcgZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzLlxuICAgIHJlcXVpcmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBkb1xuICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIHJlZmVyZW5jZV9jb21wYXJpc29uOiBub3Qgb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0ddXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIk9iamVjdHMgdGhhdCBwcm92aWRlIGFuIG91dHB1dCBpbiBkZWJ1Z2dlclwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0xNyAxMTo0NjoxNSAtMDgwMCAoVGh1LCAxNyBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMjQgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIERFQlVHX09VVFBVVFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkZWJ1Z19vdXRwdXQ6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICAtLSBTdHJpbmcgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRlYnVnZ2VyIHRvIHJlcHJlc2VudCBgQ3VycmVudCcuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZXMgd2l0aCBhIGZpbml0ZSBpdGVtIGNvdW50XCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogZmluaXRlLCBzdG9yYWdlO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgRklOSVRFIFtHXSBpbmhlcml0XG5cbiAgQk9YIFtHXVxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBpdGVtc1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2VtcHR5OiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZW1wdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY291bnQgPSAwKVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZW1wdHlfZGVmaW5pdGlvbjogaXNfZW1wdHkgPSAoY291bnQgPSAwKVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgSEFTSEFCTEVcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBnb29kX2hhc2hfdmFsdWU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgYnkgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJUYWJsZXMgd2hvc2Uga2V5cyBhcmUgaW50ZWdlcnMgaW4gYSBjb250aWd1b3VzIGludGVydmFsXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogaW5kZXhhYmxlLCBhY2Nlc3M7XG4gIGFjY2VzczogaW5kZXgsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgSU5ERVhBQkxFIFtHLCBIIC0+IElOVEVHRVJdIGluaGVyaXRcblxuICBUQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIHZhbGlkX2tleSBhcyB2YWxpZF9pbmRleCxcbiAgICAgIGZvcmNlIGFzIHB1dFxuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbR11cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuXG5lbmRcblxuXG5cbiIsImV4cGFuZGVkIGNsYXNzIElOVEVHRVJfMzIgaW5oZXJpdFxuXG4gIElOVEVHRVJfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc2FfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbCxcbiAgICAgIHRvX2RvdWJsZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbi0tIGNvbnZlcnRcbi0tICAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0lOVEVHRVJfMzJfUkVGfSksXG4tLSAgIHRvX3JlYWw6IHtSRUFMXzMyfSxcbi0tICAgdG9fZG91YmxlOiB7UkVBTF82NH0sXG4tLSAgIHRvX2ludGVnZXJfNjQ6IHtJTlRFR0VSXzY0fVxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogSU5URUdFUl8zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IElOVEVHRVJfMzIpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBJTlRFR0VSXzMyXG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBJTlRFR0VSXzMyXG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogSU5URUdFUl8zMlxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiAzMiBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgSU5URUdFUl8zMl9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIlxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgICAgLS0gQ2xlYXIgc2lnbiBiaXQuXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmIDB4N0ZGRkZGRkZcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgdG9fY2hhcmFjdGVyXzggaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IElOVEVHRVJfMzIgPSAtMjE0NzQ4MzY0OFxuICBNYXhfdmFsdWU6IElOVEVHRVJfMzIgPSAyMTQ3NDgzNjQ3XG4gICAgICAtLSBNaW5pbXVtIGFuZCBNYXhpbXVtIHZhbHVlIGhvbGQgaW4gYGl0ZW0nLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGk6IElOVEVHRVJfMzIpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSAwXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IDAgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGFiczogSU5URUdFUl8zMlxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFic19yZWYuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCA9IGl0ZW0pIG9yIChSZXN1bHQgPSAtaXRlbSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgtIGl0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSBcXFxcIG90aGVyLml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpbnRlcnZhbCBhbGlhcyBcInwuLnxcIiAob3RoZXI6IElOVEVHRVIpOiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBJbnRlcnZhbCBmcm9tIGN1cnJlbnQgZWxlbWVudCB0byBgb3RoZXInXG4gICAgICAtLSAoZW1wdHkgaWYgYG90aGVyJyBsZXNzIHRoYW4gY3VycmVudCBpbnRlZ2VyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGl0ZW0sIG90aGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IElOVEVHRVJfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogSU5URUdFUl8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19zbWFsbDogaXRlbSA+PSB7SU5URUdFUl84fS5NaW5fdmFsdWVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX3NtYWxsOiBpdGVtID49IHtJTlRFR0VSXzE2fS5NaW5fdmFsdWVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzE2fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlciwgZnJvemVuIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJldHVybiBgaXRlbScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19kb3VibGVcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8zMl9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHhGKVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8zMl9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbVxuICAgICAgaWYgdG1wIDw9IDkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gKHRtcCArICgnMCcpLmNvZGUpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAoKCdBJykuY29kZSArICh0bXAgLSAxMCkpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X2FuZCAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfYW5kX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9vciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2Vfb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfeG9yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV94b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X25vdDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfbm90KVxuICAgIGVuc3VyZVxuICAgICAgYml0X25vdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3NoaWZ0IChuOiBJTlRFR0VSXzMyKTogSU5URUdFUlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodCBpZiBgbicgcG9zaXRpdmUsXG4gICAgICAtLSB0byBsZWZ0IG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICAgIG5fZ3JlYXRlcl9vcl9lcXVhbF90b19taW51c18zMjogbiA+PSAtMzJcbiAgICBkb1xuICAgICAgaWYgbiA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X3JpZ2h0IChuKS5pdGVtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfbGVmdCAoLSBuKS5pdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9sZWZ0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9sZWZ0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzMyOiBuIDw9IDMyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfcmlnaHQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X3JpZ2h0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfdGVzdCAobjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRlc3QgYG4nLXRoIHBvc2l0aW9uIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl8zMjogbiA8IDMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICYgKDEgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKDEgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKDEgfDw8IG4pLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0X3dpdGhfbWFzayAoYjogQk9PTEVBTjsgbTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGFsbCAxIGJpdHMgb2YgbSBzZXQgdG8gMVxuICAgICAgLS0gaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmIG0uYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMTEpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXIgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYWJzX3JlZjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtID49IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIHNpZ25fdGltZXNfYWJzOiBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmUgdGhhdCBjYW4gYmUgaXRlcmF0ZWQgb3ZlciB1c2luZyBgYWNyb3NzLi4ubG9vcC4uLmVuZCcuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgSVRFUkFCTEUgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbmV3X2N1cnNvcjogSVRFUkFUSU9OX0NVUlNPUiBbR11cbiAgICAgIC0tIEZyZXNoIGN1cnNvciBhc3NvY2lhdGVkIHdpdGggY3VycmVudCBzdHJ1Y3R1cmVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2F0dGFjaGVkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3NcbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG5cbmZlYXR1cmUgLS0gQ29ycmVjdGlvblxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBsb2NhbFxuICAgICAgbF9tc2c6IFNUUklOR1xuICAgICAgbF9leGM6IEVYQ0VQVElPTlNcbiAgICBkb1xuICAgICAgICAtLSBJZiBpdCBpcyBub3QgcmVkZWZpbmVkIHRoZW4gd2UgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgY3JlYXRlIGxfbXNnLm1ha2VfZnJvbV9zdHJpbmcgKFwiTWlzbWF0Y2g6IFwiKVxuICAgICAgY3JlYXRlIGxfZXhjXG4gICAgICBsX21zZy5hcHBlbmQgKGdlbmVyYXRpbmdfdHlwZSlcbiAgICAgIGxfZXhjLnJhaXNlX3JldHJpZXZhbF9leGNlcHRpb24gKGxfbXNnKVxuICAgIGVuZFxuXG4gIG1pc21hdGNoX2luZm9ybWF0aW9uOiBNSVNNQVRDSF9JTkZPUk1BVElPTlxuICAgICAgLS0gT3JpZ2luYWwgYXR0cmlidXRlIHZhbHVlcyBvZiBtaXNtYXRjaGVkIG9iamVjdFxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiVW5zaWduZWQgaW50ZWdlciB2YWx1ZXMgY29kZWQgb24gMzIgYml0cy5cIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5VSW50MzJcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzMyIGluaGVyaXRcblxuICBOQVRVUkFMXzMyX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWxfMzIsXG4gICAgICB0b19yZWFsXzY0LFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7TkFUVVJBTF8zMl9SRUZ9KSxcbiAgdG9fcmVhbF8zMjoge1JFQUxfMzJ9LFxuICB0b19yZWFsXzY0OiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfNjQ6IHtJTlRFR0VSXzY0fSxcbiAgdG9fbmF0dXJhbF82NDoge05BVFVSQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQ0hBUkFDVEVSXzMyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogTkFUVVJBTF8zMlxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiAzMiBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgTkFUVVJBTF8zMl9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIixcbiAgICAgIG9wcG9zaXRlIGFzIHVuYXBwbGljYWJsZV9vcHBvc2l0ZVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBOQVRVUkFMXzMyXG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgICAgLS0gQ2xlYXIgc2lnbiBiaXQuXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0gJiAweDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBOQVRVUkFMXzMyID0gMFxuICBNYXhfdmFsdWU6IE5BVFVSQUxfMzIgPSA0Mjk0OTY3Mjk1XG4gICAgICAtLSBNaW5pbXVtIGFuZCBNYXhpbXVtIHZhbHVlIGhvbGQgaW4gYGl0ZW0nLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoXG4gICAgICAgIGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUudG9fbmF0dXJhbF8zMiBhbmRcbiAgICAgICAgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIHVuYXBwbGljYWJsZV9vcHBvc2l0ZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBub3RfYXBwbGljYWJsZTogRmFsc2VcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IE5BVFVSQUxfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzE2fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMzJ9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXzMyXG4gICAgZW5kXG5cbiAgdG9fcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF82NFxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQsIHZhbDogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAweEYpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtLnRvX2ludGVnZXJfMzJcbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQ0hBUkFDVEVSXzMyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzMyOiBuID49IC0zMlxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfMzIgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzMyIHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF8zMiB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgyMClcbiAgICAgIFJlc3VsdC5hcHBlbmRfbmF0dXJhbF8zMiAoaXRlbSlcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDggYml0c1wiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLkJ5dGVcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzggaW5oZXJpdFxuXG4gIE5BVFVSQUxfOF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsXzMyLFxuICAgICAgdG9fcmVhbF82NCxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe05BVFVSQUxfOF9SRUZ9KSxcbiAgdG9fcmVhbF8zMjoge1JFQUxfMzJ9LFxuICB0b19yZWFsXzY0OiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfMTY6IHtJTlRFR0VSXzE2fSxcbiAgdG9faW50ZWdlcl8zMjoge0lOVEVHRVJfMzJ9LFxuICB0b19pbnRlZ2VyXzY0OiB7SU5URUdFUl82NH0sXG4gIHRvX25hdHVyYWxfMTY6IHtOQVRVUkFMXzE2fSxcbiAgdG9fbmF0dXJhbF8zMjoge05BVFVSQUxfMzJ9LFxuICB0b19uYXR1cmFsXzY0OiB7TkFUVVJBTF82NH1cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IE5BVFVSQUxfOCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IE5BVFVSQUxfOCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfOFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogTkFUVVJBTF84XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGFuIGludGVnZXIgdmFsdWUgY29kZWQgb24gOCBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgTkFUVVJBTF84X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfOFxuICAgICAgLS0gSW50ZWdlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIHNpZ246IElOVEVHRVJcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVsc2VpZiBpdGVtIDwgMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDEpXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDApXG4gICAgZW5kXG5cbiAgYXNjaWlfY2hhcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0b19jaGFyYWN0ZXJfOCBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IE5BVFVSQUxfOCA9IDBcbiAgTWF4X3ZhbHVlOiBOQVRVUkFMXzggPSAyNTVcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogTkFUVVJBTF84KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIHVuYXBwbGljYWJsZV9vcHBvc2l0ZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBub3RfYXBwbGljYWJsZTogRmFsc2VcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBOQVRVUkFMXzhfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiBWIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDJcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMTUpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gMlxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtXG4gICAgICBSZXN1bHQgOj0gdG1wLnRvX2hleF9jaGFyYWN0ZXJcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X2FuZCAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfYW5kX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9vciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2Vfb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfeG9yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV94b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X25vdDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfbm90KVxuICAgIGVuc3VyZVxuICAgICAgYml0X25vdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3NoaWZ0IChuOiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b184OiBuIDw9IDhcbiAgICAgIG5fZ3JlYXRlcl9vcl9lcXVhbF90b19taW51c184OiBuID49IC04XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzg6IG4gPD0gOFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fODogbiA8PSA4XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfcmlnaHQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X3JpZ2h0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfdGVzdCAobjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRlc3QgYG4nLXRoIHBvc2l0aW9uIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl84OiBuIDwgOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKSAvPSAwXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXQgKGI6IEJPT0xFQU47IG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzg6IG4gPCA4XG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8ICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgzKVxuICAgICAgUmVzdWx0LmFwcGVuZF9uYXR1cmFsXzggKGl0ZW0pXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG5cbiAgTlVNRVJJQ1xuXG5pbmhlcml0XG4gIERFQlVHX09VVFBVVFxuICAgIHJlbmFtZVxuICAgICAgZGVidWdfb3V0cHV0IGFzIG91dFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIG9ic29sZXRlXG4gICAgICBcIlsyMDA4XzA0XzAxXSBXaWxsIGJlIHJlbW92ZWQgc2luY2Ugbm90IHVzZWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInIChjb21tdXRhdGl2ZSkuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBjb21tdXRhdGl2ZTogUmVzdWx0IH4gKG90aGVyICsgQ3VycmVudClcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuLS0gIG5ldXRyYWxfYWRkaXRpb246IGVxdWFsIChDdXJyZW50ICsgemVybywgQ3VycmVudCk7XG4tLSAgc2VsZl9zdWJ0cmFjdGlvbjogZXF1YWwgKEN1cnJlbnQgLSBDdXJyZW50LCB6ZXJvKTtcbi0tICBuZXV0cmFsX211bHRpcGxpY2F0aW9uOiBlcXVhbCAoQ3VycmVudCAqIG9uZSwgQ3VycmVudCk7XG4tLSAgc2VsZl9kaXZpc2lvbjogZGl2aXNpYmxlIChDdXJyZW50KSBpbXBsaWVzIGVxdWFsIChDdXJyZW50IC8gQ3VycmVudCwgb25lKVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiT2JqZWN0cyB0aGF0IG1heSBiZSBjb21wYXJlZCBhY2NvcmRpbmcgdG8gYSBwYXJ0aWFsIG9yZGVyIHJlbGF0aW9uXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgUEFSVF9DT01QQVJBQkxFXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX2xlc3NfZXF1YWwgYWxpYXMgXCI8PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoQ3VycmVudCA8IG90aGVyKSBvciAoQ3VycmVudCB+IG90aGVyKVxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXIgYWxpYXMgXCI+XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyIDwgQ3VycmVudFxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXJfZXF1YWwgYWxpYXMgXCI+PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAob3RoZXIgPCBDdXJyZW50KSBvciAoQ3VycmVudCB+IG90aGVyKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiVGFibGVzIHdob3NlIGtleXMgYXJlIGludGVnZXJzIGluIGEgY29udGlndW91cyBpbnRlcnZhbFwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGluZGV4YWJsZSwgYWNjZXNzO1xuICBhY2Nlc3M6IGluZGV4LCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzIFJFQURBQkxFX0lOREVYQUJMRSBbR11cblxuaW5oZXJpdFxuICBJVEVSQUJMRSBbR11cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiAoaTogSU5URUdFUik6IEdcbiAgICAgIC0tIEVudHJ5IGF0IHBvc2l0aW9uIGBpJ1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIG5ld19jdXJzb3I6IElOREVYQUJMRV9JVEVSQVRJT05fQ1VSU09SIFtHXVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChDdXJyZW50KVxuICAgICAgUmVzdWx0LnN0YXJ0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgYSB2YWxpZCBpbmRleD9cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgb25seV9pZl9pbl9pbmRleF9zZXQ6XG4gICAgICAgIFJlc3VsdCBpbXBsaWVzICgoaSA+PSBpbmRleF9zZXQubG93ZXIpIGFuZCAoaSA8PSBpbmRleF9zZXQudXBwZXIpKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuXG5cblxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTQgMjI6MjE6MTkgLTA3MDAgKFdlZCwgMTQgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MDYwICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBSRUFEQUJMRV9TVFJJTkdfMzJcblxuaW5oZXJpdFxuICBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgIHJlbmFtZVxuICAgICAgc2FtZV9zdHJpbmcgYXMgc2FtZV9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfY2hhcmFjdGVycyBhcyBzYW1lX2NoYXJhY3RlcnNfZ2VuZXJhbCxcbiAgICAgIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyBhcyBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnNfZ2VuZXJhbCxcbiAgICAgIHN0YXJ0c193aXRoIGFzIHN0YXJ0c193aXRoX2dlbmVyYWwsXG4gICAgICBlbmRzX3dpdGggYXMgZW5kc193aXRoX2dlbmVyYWwsXG4gICAgICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIGFzIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbFxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBoYXMsIGluZGV4X29mLCBsYXN0X2luZGV4X29mLCBvY2N1cnJlbmNlc1xuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbQ0hBUkFDVEVSXzMyXVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIGFzX3JlYWRhYmxlX3N0cmluZ184OiB7UkVBREFCTEVfU1RSSU5HXzh9LFxuICBhc19zdHJpbmdfODoge1NUUklOR184fSxcbiAgYXNfc3RyaW5nXzMyOiB7U1RSSU5HXzMyfVxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoJyUvMDAwLycsIG4gKyAxKVxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkIChjOiBDSEFSQUNURVJfMzI7IG46IElOVEVHRVIpXG4gICAgICAtLSBDcmVhdGUgc3RyaW5nIG9mIGxlbmd0aCBgbicgZmlsbGVkIHdpdGggYGMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NvdW50OiBuID49IDBcbiAgICBkb1xuICAgICAgbWFrZSAobilcbiAgICAgIGZpbGxfY2hhcmFjdGVyIChjKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgICBmaWxsZWQ6IG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX3N0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBpZiBDdXJyZW50IC89IHMgdGhlblxuICAgICAgICBjcmVhdGUgYXJlYS5tYWtlX2VtcHR5IChjb3VudCArIDEpXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgMCwgY291bnQgKyAxKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3Rfc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBDdXJyZW50IC89IHMgaW1wbGllcyBub3Qgc2hhcmVkX3dpdGggKHMpXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9zaGFyZWRfaW1wbGVtZW50YXRpb246IEN1cnJlbnQgLz0gc1xuICAgICAgaW5pdGlhbGl6ZWQ6IHNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKCclLzAwMC8nLCBsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvX2NoYXJhY3Rlcl8zMl9hcmVhIChhcmVhLCAxLCBsX2NvdW50KVxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jX3BvaW50ZXIgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gQ3JlYXRlIG5ldyBpbnN0YW5jZSBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvblxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZV9mcm9tX2MnLlwiXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBkb1xuICAgICAgbWFrZV9mcm9tX2MgKGNfc3RyaW5nKVxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jaWwgKGFfc3lzdGVtX3N0cmluZzogZGV0YWNoYWJsZSBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IHdpdGggYGFfc3lzdGVtX3N0cmluZycuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1lcmljIGNvZGUgb2YgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIG9ic29sZXRlXG4gICAgICBcIkR1ZSB0byBwb3RlbnRpYWwgdHJ1bmNhdGlvbiBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYGNvZGUgKGkpJyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50XG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPiAwXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBzaGFyZWRfd2l0aCAob3RoZXI6IFJFQURBQkxFX1NUUklOR18zMik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAob3RoZXIgLz0gVm9pZCkgYW5kIHRoZW4gKGFyZWEgPSBvdGhlci5hcmVhKVxuICAgIGVuZFxuXG4gIGluZGV4X29mIChjOiBDSEFSQUNURVJfMzI7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycgYXQgb3IgYWZ0ZXIgYHN0YXJ0X2luZGV4JztcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBuYiwgbF9sb3dlcl9hcmVhOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBzdGFydF9pbmRleCA8PSBuYiB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICAgIGkgOj0gc3RhcnRfaW5kZXggLSAxICsgbF9sb3dlcl9hcmVhXG4gICAgICAgICAgbmIgOj0gbmIgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgICBhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmIgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgaSA8IG5iIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGFkZCArMSBkdWUgdG8gdGhlIGFyZWEgc3RhcnRpbmcgYXQgMCBhbmQgbm90IGF0IDFcbiAgICAgICAgICAgIC0tIGFuZCBzdWJzdHJhY3QgYGFyZWFfbG93ZXInXG4gICAgICAgICAgUmVzdWx0IDo9IGkgKyAxIC0gbF9sb3dlcl9hcmVhXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZiAoYzogQ0hBUkFDVEVSXzMyOyBzdGFydF9pbmRleF9mcm9tX2VuZDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGxhc3Qgb2NjdXJyZW5jZSBvZiBgYycsXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgaSwgbF9sb3dlcl9hcmVhOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbF9sb3dlcl9hcmVhIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgaSA6PSBzdGFydF9pbmRleF9mcm9tX2VuZCAtIDEgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpIDwgbF9sb3dlcl9hcmVhIG9yIGVsc2UgYS5pdGVtIChpKSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgICAgIC0tIFdlIGFkZCArMSBkdWUgdG8gdGhlIGFyZWEgc3RhcnRpbmcgYXQgMCBhbmQgbm90IGF0IDEuXG4gICAgICBSZXN1bHQgOj0gaSArIDEgLSBsX2xvd2VyX2FyZWFcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXhfaW5fYm91bmRzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnRfcG9zLCBlbmRfcG9zKVxuICAgIGVuZFxuXG4gIHN0cmluZzogU1RSSU5HXzMyXG4gICAgICAtLSBOZXcgU1RSSU5HXzMyIGhhdmluZyBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgQ3VycmVudCcuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHN0cmluZ190eXBlOiBSZXN1bHQuc2FtZV90eXBlIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSlcbiAgICAgIGZpcnN0X2l0ZW06IGNvdW50ID4gMCBpbXBsaWVzIFJlc3VsdC5pdGVtICgxKSA9IGl0ZW0gKDEpXG4gICAgICByZWN1cnNlOiBjb3VudCA+IDEgaW1wbGllcyBSZXN1bHQuc3Vic3RyaW5nICgyLCBjb3VudCkgfiBzdWJzdHJpbmcgKDIsIGNvdW50KS5zdHJpbmdcbiAgICBlbmRcblxuICBzdHJpbmdfcmVwcmVzZW50YXRpb246IFNUUklOR18zMlxuICAgICAgLS0gU2ltaWxhciB0byBgc3RyaW5nJyBidXQgb25seSBjcmVhdGUgYSBuZXcgb2JqZWN0IGlmIGBDdXJyZW50JyBpcyBub3Qgb2YgZHluYW1pYyB0eXBlIHtTVFJJTkdfMzJ9XG4gICAgZG9cbiAgICAgIGlmIHNhbWVfdHlwZSAoY3JlYXRlIHtTVFJJTkdfMzJ9Lm1ha2VfZW1wdHkpIGFuZCB0aGVuIGF0dGFjaGVkIHtTVFJJTkdfMzJ9IEN1cnJlbnQgYXMgbF9zMzIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9zMzJcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHN0cmluZ1xuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBjb3JyZWN0X3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnRfaW5kZXgsIGNvdW50KVxuICAgIGVuZFxuXG4gIGZ1enp5X2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0OiBJTlRFR0VSOyBmdXp6OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5mdXp6eV9pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0LCBjb3VudCwgZnV6eilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBBbGxvY2F0ZWQgc3BhY2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuY291bnQgLSAxXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIEFjdHVhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBtYWtpbmcgdXAgdGhlIHN0cmluZ1xuXG4gIG9jY3VycmVuY2VzIChjOiBDSEFSQUNURVJfMzIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgdGltZXMgYGMnIGFwcGVhcnMgaW4gdGhlIHN0cmluZ1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBuYiA6PSBjb3VudCArIGlcbiAgICAgICAgYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaWYgYS5pdGVtIChpKSA9IGMgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgemVyb19pZl9lbXB0eTogY291bnQgPSAwIGltcGxpZXMgUmVzdWx0ID0gMFxuICAgICAgcmVjdXJzZV9pZl9ub3RfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgICAgcmVjdXJzZV9pZl9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSAxICsgc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgZW5kXG5cbiAgaW5kZXhfc2V0OiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBSYW5nZSBvZiBhY2NlcHRhYmxlIGluZGV4ZXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxLCBjb3VudClcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaW5kZXhfc2V0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgaW5kZXhfc2V0X2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cmluZyBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcidcbiAgICAgIC0tIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICBsb2NhbFxuICAgICAgICBuYjogSU5URUdFUlxuICAgICAgbF9oYXNoLCBsX290aGVyX2hhc2g6IGxpa2UgaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgICBkb1xuICAgICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgICAgLS0gTGV0J3MgY29tcGFyZSB0aGUgY29udGVudCBpZiBhbmQgb25seSBpZiB0aGUgaGFzaF9jb2RlIGFyZSB0aGUgc2FtZSBvciBub3QgeWV0IGNvbXB1dGVkLlxuICAgICAgICAgIGxfaGFzaCA6PSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBsX290aGVyX2hhc2ggOj0gb3RoZXIuaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgICAgICAgaWYgbF9oYXNoID0gMCBvciBlbHNlIGxfb3RoZXJfaGFzaCA9IDAgb3IgZWxzZSBsX2hhc2ggPSBsX290aGVyX2hhc2ggdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgbmIpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgZW5kXG5cbiAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXI6IFJFQURBQkxFX1NUUklOR18zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cmluZyBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcicgcmVnYXJkbGVzcyBvZiBjYXNpbmdcbiAgICAgIC0tIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG90aGVyLmlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKEN1cnJlbnQpXG4gICAgICBjb25zaXN0ZW50OiBhdHRhY2hlZCB7bGlrZSBDdXJyZW50fSBvdGhlciBhcyBsX290aGVyIGltcGxpZXMgKHN0YW5kYXJkX2lzX2VxdWFsIChsX290aGVyKSBpbXBsaWVzIFJlc3VsdClcbiAgICAgIHZhbGlkX3Jlc3VsdDogYXNfbG93ZXIgfiBvdGhlci5hc19sb3dlciBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXI6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgbF9hcmVhLCBsX290aGVyX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgYzEsYzI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9vdGhlcl9hcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIGkgOj0gYXJlYV9sb3dlciArIGluZGV4X3BvcyAtIDFcbiAgICAgICAgICBqIDo9IG90aGVyLmFyZWFfbG93ZXIgKyBzdGFydF9wb3MgLSAxXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjMSA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgICBjMiA6PSBsX290aGVyX2FyZWEuaXRlbSAoailcbiAgICAgICAgICBpZiBjMSAvPSBjMiBhbmQgdGhlbiBsX3Byb3AudG9fbG93ZXIgKGMxKSAvPSBsX3Byb3AudG9fbG93ZXIgKGMyKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGluY3JlYXNpbmdfaW5kZXg6IG5iIC0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLmlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBzYW1lX3N0cmluZyAob3RoZXI6IFJFQURBQkxFX1NUUklOR18zMik6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBDdXJyZW50JyBhbmQgYG90aGVyJyBoYXZlIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBuYiA9IDAgb3IgZWxzZSBzYW1lX2NoYXJhY3RlcnMgKG90aGVyLCAxLCBuYiwgMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChzdHJpbmcgfiBvdGhlci5zdHJpbmcpXG4gICAgZW5kXG5cbiAgc2FtZV9jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDEsIGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxLCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3Bvcykuc2FtZV9zdHJpbmcgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIGxleGljb2dyYXBoaWNhbGx5IGxvd2VyIHRoYW4gYG90aGVyJz9cbiAgICBsb2NhbFxuICAgICAgb3RoZXJfY291bnQ6IElOVEVHRVJcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIG90aGVyX2NvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgICAgaWYgb3RoZXJfY291bnQgPSBjdXJyZW50X2NvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGN1cnJlbnRfY291bnQgPCBvdGhlcl9jb3VudCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIGN1cnJlbnRfY291bnQpID49IDBcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU4gPSBGYWxzZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuICBpc19zdHJpbmdfMzI6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3ZhbGlkX2FzX3N0cmluZ184OiBCT09MRUFOXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgKyBpXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmIgb3Igbm90IFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpLmNvZGUgPD0ge0NIQVJBQ1RFUl84fS5tYXhfdmFsdWVcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBpLCBuOiBJTlRFR0VSXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICAgIG4gOj0gYXJlYV9sb3dlciArIGVuZF9pbmRleCAtIDFcbiAgICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbiBvciBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAoaSkpXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IGkgPiBuXG4gICAgZW5kXG5cbiAgaGFzIChjOiBDSEFSQUNURVJfMzIpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBpbmNsdWRlIGBjJz9cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBuYiA6PSBuYiArIGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmIgb3IgZWxzZSAobF9hcmVhLml0ZW0gKGkpID0gYylcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIFJlc3VsdCA6PSAoaSA8IG5iKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc3RhcnRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR18zMik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGJlZ2luIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9zX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBpZiBpIDw9IGNvdW50IHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgICAgbF9zX2FyZWEgOj0gcy5hcmVhXG4gICAgICAgICAgICBqIDo9IGFyZWFfbG93ZXIgKyBpXG4gICAgICAgICAgICBpIDo9IHMuYXJlYV91cHBlciArIDFcbiAgICAgICAgICAgIG5iIDo9IHMuYXJlYV9sb3dlclxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgaSA9IG5iXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgICAgaiA6PSBqIC0gMVxuICAgICAgICAgICAgaWYgbF9hcmVhLml0ZW0gKGopIC89IGxfc19hcmVhLml0ZW0gKGkpIHRoZW5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICAgIGkgOj0gbmIgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKDEsIHMuY291bnQpKVxuICAgIGVuZFxuXG4gIGVuZHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgZmluaXNoIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9zX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBqIDo9IGNvdW50XG4gICAgICAgIGlmIGkgPD0gaiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChjb3VudCAtIHMuY291bnQgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgdmFsaWRfY29kZSAodjogTkFUVVJBTF8zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB2JyBhIHZhbGlkIGNvZGUgZm9yIGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG4gIGlzX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIEJPT0xFQU4/XG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA9IDQgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYHRydWVfY29uc3RhbnQnXG4gICAgICAgIFJlc3VsdCA6PSBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwgKHRydWVfY29uc3RhbnQpXG4gICAgICBlbHNlaWYgbmIgPSA1IHRoZW5cbiAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIGlzIGBmYWxzZV9jb25zdGFudCdcbiAgICAgICAgUmVzdWx0IDo9IGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbCAoZmFsc2VfY29uc3RhbnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HXzMyfSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBSZWluaXRpYWxpemUgYnkgY29weWluZyB0aGUgY2hhcmFjdGVycyBvZiBgb3RoZXInLlxuICAgICAgLS0gKFRoaXMgaXMgYWxzbyB1c2VkIGJ5IGB0d2luJy4pXG4gICAgbG9jYWxcbiAgICAgIG9sZF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIG9sZF9hcmVhIDo9IGFyZWFcbiAgICAgICAgc3RhbmRhcmRfY29weSAob3RoZXIpXG4gICAgICAgICAgLS0gTm90ZTogPD0gaXMgbmVlZGVkIGFzIGFsbCBFaWZmZWwgc3RyaW5nIHNob3VsZCBoYXZlIGFuXG4gICAgICAgICAgLS0gZXh0cmEgY2hhcmFjdGVyIHRvIGluc2VydCBudWxsIGNoYXJhY3RlciBhdCB0aGUgZW5kLlxuICAgICAgICBpZiBvbGRfYXJlYSA9IFZvaWQgb3IgZWxzZSBvbGRfYXJlYSA9IG90aGVyLmFyZWEgb3IgZWxzZSBvbGRfYXJlYS5jb3VudCA8PSBjb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBQcmV2ZW50IGNvcHlpbmcgb2YgbGFyZ2UgYGFyZWEnIGlmIG9ubHkgYSBmZXcgY2hhcmFjdGVycyBhcmUgYWN0dWFsbHkgdXNlZC5cbiAgICAgICAgICBhcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhIChjb3VudCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvbGRfYXJlYS5jb3B5X2RhdGEgKGFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgICAgIGFyZWEgOj0gb2xkX2FyZWFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X3Jlc3VsdF9jb3VudDogY291bnQgPSBvdGhlci5jb3VudFxuICAgICAgLS0gc2FtZV9jaGFyYWN0ZXJzOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IGBvdGhlcicuYGl0ZW0nIChgaScpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgZmlsbF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEZpbGwgd2l0aCBgY2FwYWNpdHknIGNoYXJhY3RlcnMgYWxsIGVxdWFsIHRvIGBjJy5cbiAgICBsb2NhbFxuICAgICAgbF9jYXA6IGxpa2UgY2FwYWNpdHlcbiAgICBkb1xuICAgICAgbF9jYXAgOj0gY2FwYWNpdHlcbiAgICAgIGlmIGxfY2FwIC89IDAgdGhlblxuICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYywgMCwgbF9jYXAgLSAxKVxuICAgICAgICBjb3VudCA6PSBsX2NhcFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBmaWxsZWQ6IGNvdW50ID0gY2FwYWNpdHlcbiAgICAgIHNhbWVfc2l6ZTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIC0tIGFsbF9jaGFyOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjYXBhY2l0eScsIGBpdGVtJyAoYGknKSA9IGBjJ1xuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBtaXJyb3JlZDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBNaXJyb3IgaW1hZ2Ugb2Ygc3RyaW5nO1xuICAgICAgLS0gUmVzdWx0IGZvciBcIkhlbGxvIHdvcmxkXCIgaXMgXCJkbHJvdyBvbGxlSFwiLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgLS0gcmV2ZXJzZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYFJlc3VsdCcuYGl0ZW0nIChgaScpID0gYGl0ZW0nIChgY291bnQnKzEtYGknKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb25cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChjb3VudClcbiAgICAgIFJlc3VsdC5hcHBlbmQgKGFzX3N0cmluZ184KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBvdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2l0ZW1zOiBzYW1lX3R5cGUgKFwiXCIpIGltcGxpZXMgc2FtZV9zdHJpbmdfZ2VuZXJhbCAoUmVzdWx0KVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cmluZ19zZWFyY2hlcjogU1RSSU5HXzMyX1NFQVJDSEVSXG4gICAgICAtLSBTdHJpbmcgc2VhcmNoZXIgc3BlY2lhbGl6ZWQgZm9yIFJFQURBQkxFX1NUUklOR18zMiBpbnN0YW5jZXNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBzdHJfc3RyaWN0X2NtcCAodGhpcywgb3RoZXI6IGxpa2UgYXJlYTsgdGhpc19pbmRleCwgb3RoZXJfaW5kZXgsIG46IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBDb21wYXJlIGBuJyBjaGFyYWN0ZXJzIGZyb20gYHRoaXMnIHN0YXJ0aW5nIGF0IGB0aGlzX2luZGV4JyB3aXRoXG4gICAgICAtLSBgbicgY2hhcmFjdGVycyBmcm9tIGFuZCBgb3RoZXInIHN0YXJ0aW5nIGF0IGBvdGhlcl9pbmRleCcuXG4gICAgICAtLSAwIGlmIGVxdWFsLCA8IDAgaWYgYHRoaXMnIDwgYG90aGVyJyxcbiAgICAgIC0tID4gMCBpZiBgdGhpcycgPiBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgdGhpc19ub3Rfdm9pZDogdGhpcyAvPSBWb2lkXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl92YWxpZDogbiA8PSAodGhpcy51cHBlciAtIHRoaXNfaW5kZXggKyAxKSBhbmQgbiA8PSAob3RoZXIudXBwZXIgLSBvdGhlcl9pbmRleCArIDEpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iLCBsX2N1cnJlbnRfY29kZSwgbF9vdGhlcl9jb2RlOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSB0aGlzX2luZGV4XG4gICAgICAgIG5iIDo9IGkgKyBuXG4gICAgICAgIGogOj0gb3RoZXJfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBsX2N1cnJlbnRfY29kZSA6PSB0aGlzLml0ZW0gKGkpLmNvZGVcbiAgICAgICAgbF9vdGhlcl9jb2RlIDo9IG90aGVyLml0ZW0gKGopLmNvZGVcbiAgICAgICAgaWYgbF9jdXJyZW50X2NvZGUgLz0gbF9vdGhlcl9jb2RlIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbF9jdXJyZW50X2NvZGUgLSBsX290aGVyX2NvZGVcbiAgICAgICAgICBpIDo9IG5iIC0gMSAtLSBKdW1wIG91dCBvZiBsb29wXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX2xvd2VyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgbG93ZXIgdmVyc2lvbiB3aGVuIGF2YWlsYWJsZS5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBjMSwgYzI6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYzEgOj0gYS5pdGVtIChpKVxuICAgICAgICBjMiA6PSBsX3Byb3AudG9fbG93ZXIgKGMxKVxuICAgICAgICAgIC0tIExldCdzIGF2b2lkIGEgd3JpdGUgYWNjZXNzIGlmIG5vdCBuZWVkZWQuXG4gICAgICAgIGlmIGMxIC89IGMyIHRoZW5cbiAgICAgICAgICBhLnB1dCAoYzIsIGkpXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b191cHBlcl9hcmVhIChhOiBsaWtlIGFyZWE7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgICAtLSB3aXRoIHRoZWlyIHVwcGVyIHZlcnNpb24gd2hlbiBhdmFpbGFibGUuXG4gICAgcmVxdWlyZVxuICAgICAgYV9ub3Rfdm9pZDogYSAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGEuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgYzEsIGMyOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gZW5kX2luZGV4XG4gICAgICBsb29wXG4gICAgICAgIGMxIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgYzIgOj0gbF9wcm9wLnRvX3VwcGVyIChjMSlcbiAgICAgICAgICAtLSBMZXQncyBhdm9pZCBhIHdyaXRlIGFjY2VzcyBpZiBub3QgbmVlZGVkLlxuICAgICAgICBpZiBjMSAvPSBjMiB0aGVuXG4gICAgICAgICAgYS5wdXQgKGMyLCBpKVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIE1pcnJvciBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA8PSBqXG4gICAgICBsb29wXG4gICAgICAgIGMgOj0gYS5pdGVtIChpKVxuICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgYS5wdXQgKGMsIGopXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmVcbiAge1JFQURBQkxFX1NUUklOR184LCBSRUFEQUJMRV9TVFJJTkdfMzIsXG4gIFNUUklOR184X1NFQVJDSEVSLCBTVFJJTkdfMzJfU0VBUkNIRVIsXG4gIEhFWEFERUNJTUFMX1NUUklOR19UT19JTlRFR0VSX0NPTlZFUlRFUixcbiAgU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVE9SLFxuICBTVFJJTkdfVE9fUkVBTF9DT05WRVJUT1J9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gU3RvcmFnZSBmb3IgY2hhcmFjdGVyc1xuXG4gIGFyZWFfbG93ZXI6IElOVEVHRVJcbiAgICAgIC0tIE1pbmltdW0gaW5kZXhcbiAgICBkb1xuICAgIGVuc3VyZVxuICAgICAgYXJlYV9sb3dlcl9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBhcmVhX2xvd2VyX3ZhbGlkOiBSZXN1bHQgPD0gYXJlYS51cHBlclxuICAgIGVuZFxuXG4gIGFyZWFfdXBwZXI6IElOVEVHRVJcbiAgICAgIC0tIE1heGltdW0gaW5kZXhcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfbG93ZXIgKyBjb3VudCAtIDFcbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfdXBwZXJfdmFsaWQ6IFJlc3VsdCA8PSBhcmVhLnVwcGVyXG4gICAgICBhcmVhX3VwcGVyX2luX2JvdW5kOiBhcmVhX2xvd2VyIDw9IFJlc3VsdCArIDFcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGFyZWFfbm90X3ZvaWQ6IGFyZWEgLz0gVm9pZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTQgMjI6MjI6MDIgLTA3MDAgKFdlZCwgMTQgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MDYxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBSRUFEQUJMRV9TVFJJTkdfOFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVuYW1lXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsLFxuICAgICAgaXRlbSBhcyBjaGFyYWN0ZXJfMzJfaXRlbSxcbiAgICAgIGhhcyBhcyBjaGFyYWN0ZXJfMzJfaGFzLFxuICAgICAgaW5kZXhfb2YgYXMgY2hhcmFjdGVyXzMyX2luZGV4X29mLFxuICAgICAgbGFzdF9pbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfbGFzdF9pbmRleF9vZixcbiAgICAgIG9jY3VycmVuY2VzIGFzIGNoYXJhY3Rlcl8zMl9vY2N1cnJlbmNlc1xuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtDSEFSQUNURVJfOF1cbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG5jb252ZXJ0XG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9LFxuICBhc19zdHJpbmdfODoge1NUUklOR184fSxcbiAgYXNfcmVhZGFibGVfc3RyaW5nXzMyOiB7UkVBREFCTEVfU1RSSU5HXzMyfSxcbiAgYXNfc3RyaW5nXzMyOiB7U1RSSU5HXzMyfVxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoJyUvMDAwLycsIG4gKyAxKVxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkIChjOiBDSEFSQUNURVJfODsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBzdHJpbmcgb2YgbGVuZ3RoIGBuJyBmaWxsZWQgd2l0aCBgYycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgICAgZmlsbF9jaGFyYWN0ZXIgKGMpXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICAgIGZpbGxlZDogb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gcy5hcmVhXG4gICAgICBjb3VudCA6PSBzLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgaWYgQ3VycmVudCAvPSBzIHRoZW5cbiAgICAgICAgY3JlYXRlIGFyZWEubWFrZV9lbXB0eSAoY291bnQgKyAxKVxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIDAsIGNvdW50ICsgMSlcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbm90X3NoYXJlZF9pbXBsZW1lbnRhdGlvbjogQ3VycmVudCAvPSBzIGltcGxpZXMgbm90IHNoYXJlZF93aXRoIChzKVxuICAgICAgaW5pdGlhbGl6ZWQ6IHNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jIChjX3N0cmluZzogUE9JTlRFUilcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSBjb250ZW50cyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb25cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyIChjX3N0cmluZylcbiAgICAgIGxfY291bnQgOj0gY19zdHJpbmdfcHJvdmlkZXIuY291bnRcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdWJzdHJpbmdfaW50b19jaGFyYWN0ZXJfOF9hcmVhIChhcmVhLCAxLCBsX2NvdW50KVxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jX3BvaW50ZXIgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gQ3JlYXRlIG5ldyBpbnN0YW5jZSBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvblxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZV9mcm9tX2MnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBtYWtlX2Zyb21fYyAoY19zdHJpbmcpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfOFxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkZvciBjb25zaXN0ZW5jeSB3aXRoIFVuaWNvZGUgc3RyaW5nIGhhbmRsaW5nLCB1c2UgYGNvZGUgKGkpJyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50XG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPiAwXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBzaGFyZWRfd2l0aCAob3RoZXI6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChvdGhlciAvPSBWb2lkKSBhbmQgdGhlbiAoYXJlYSA9IG90aGVyLmFyZWEpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IENIQVJBQ1RFUl84OyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnIGF0IG9yIGFmdGVyIGBzdGFydF9pbmRleCc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBzdGFydF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4IDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGksIG5iLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfbG93ZXJfYXJlYSA6PSBhcmVhX2xvd2VyXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleCAtIDEgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgICBuYiA6PSBuYiArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIGEuaXRlbSAoaSkgPSBjXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMVxuICAgICAgICAgICAgLS0gYW5kIHN1YnN0cmFjdCBgYXJlYV9sb3dlcidcbiAgICAgICAgICBSZXN1bHQgOj0gaSArIDEgLSBsX2xvd2VyX2FyZWFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0ID0gMCBvciAoc3RhcnRfaW5kZXggPD0gUmVzdWx0IGFuZCBSZXN1bHQgPD0gY291bnQpXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpXG4gICAgICBmb3VuZF9pZl9wcmVzZW50OiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKSBpbXBsaWVzIGl0ZW0gKFJlc3VsdCkgPSBjXG4gICAgICBub25lX2JlZm9yZTogc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0IC0gMSkuaGFzIChjKVxuICAgIGVuZFxuXG4gIGxhc3RfaW5kZXhfb2YgKGM6IENIQVJBQ1RFUl84OyBzdGFydF9pbmRleF9mcm9tX2VuZDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGxhc3Qgb2NjdXJyZW5jZSBvZiBgYycsXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleF9mcm9tX2VuZCA8PSBjb3VudFxuICAgICAgc3RhcnRfaW5kZXhfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleF9mcm9tX2VuZCA+PSAxXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgaSwgbF9sb3dlcl9hcmVhOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbF9sb3dlcl9hcmVhIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgaSA6PSBzdGFydF9pbmRleF9mcm9tX2VuZCAtIDEgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpIDwgbF9sb3dlcl9hcmVhIG9yIGVsc2UgYS5pdGVtIChpKSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgICAgIC0tIFdlIGFkZCArMSBkdWUgdG8gdGhlIGFyZWEgc3RhcnRpbmcgYXQgMCBhbmQgbm90IGF0IDEuXG4gICAgICBSZXN1bHQgOj0gaSArIDEgLSBsX2xvd2VyX2FyZWFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogMCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBzdGFydF9pbmRleF9mcm9tX2VuZFxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgICBmb3VuZF9pZl9wcmVzZW50OiBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpIGltcGxpZXMgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYWZ0ZXI6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChSZXN1bHQgKyAxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKVxuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleF9pbl9ib3VuZHMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9wb3MsIGVuZF9wb3MpXG4gICAgZW5kXG5cbiAgc3RyaW5nOiBTVFJJTkdfOFxuICAgICAgLS0gTmV3IFNUUklOR184IGhhdmluZyBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgQ3VycmVudCcuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHN0cmluZ190eXBlOiBSZXN1bHQuc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN0cmluZ19yZXByZXNlbnRhdGlvbjogU1RSSU5HXzhcbiAgICAgIC0tIFNpbWlsYXIgdG8gYHN0cmluZycgYnV0IG9ubHkgY3JlYXRlIGEgbmV3IG9iamVjdCBpZiBgQ3VycmVudCcgaXMgbm90IG9mIGR5bmFtaWMgdHlwZSB7U1RSSU5HXzh9XG4gICAgZG9cbiAgICAgIGlmIHNhbWVfdHlwZSAoY3JlYXRlIHtTVFJJTkdfOH0ubWFrZV9lbXB0eSkgYW5kIHRoZW4gYXR0YWNoZWQge1NUUklOR184fSBDdXJyZW50IGFzIGxfczggdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9zOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGNvcnJlY3RfdHlwZTogUmVzdWx0LnNhbWVfdHlwZSAoY3JlYXRlIHtTVFJJTkdfOH0ubWFrZV9lbXB0eSlcbiAgICAgIGZpcnN0X2l0ZW06IGNvdW50ID4gMCBpbXBsaWVzIFJlc3VsdC5pdGVtICgxKSA9IGl0ZW0gKDEpXG4gICAgICByZWN1cnNlOiBjb3VudCA+IDEgaW1wbGllcyBSZXN1bHQuc3Vic3RyaW5nICgyLCBjb3VudCkgfiBzdWJzdHJpbmcgKDIsIGNvdW50KS5zdHJpbmdcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0X2luZGV4LCBjb3VudClcbiAgICBlbmRcblxuICBmdXp6eV9pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydDogSU5URUdFUjsgZnV6ejogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfc2VhcmNoZXIuZnV6enlfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydCwgY291bnQsIGZ1enopXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gQWxsb2NhdGVkIHNwYWNlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLmNvdW50IC0gMVxuICAgIGVuZFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBBY3R1YWwgbnVtYmVyIG9mIGNoYXJhY3RlcnMgbWFraW5nIHVwIHRoZSBzdHJpbmdcblxuICBvY2N1cnJlbmNlcyAoYzogQ0hBUkFDVEVSXzgpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgdGltZXMgYGMnIGFwcGVhcnMgaW4gdGhlIHN0cmluZ1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzhdXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50ICsgaVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiBhLml0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB6ZXJvX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBSZXN1bHQgPSAwXG4gICAgICByZWN1cnNlX2lmX25vdF9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSAvPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgICByZWN1cnNlX2lmX2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpID0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IDEgKyBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEsIGNvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpbmRleF9zZXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpbmRleF9zZXRfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgICAgbF9oYXNoLCBsX290aGVyX2hhc2g6IGxpa2UgaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgICAgLS0gTGV0J3MgY29tcGFyZSB0aGUgY29udGVudCBpZiBhbmQgb25seSBpZiB0aGUgaGFzaF9jb2RlIGFyZSB0aGUgc2FtZSBvciBub3QgeWV0IGNvbXB1dGVkLlxuICAgICAgICAgIGxfaGFzaCA6PSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBsX290aGVyX2hhc2ggOj0gb3RoZXIuaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgICAgICAgaWYgbF9oYXNoID0gMCBvciBlbHNlIGxfb3RoZXJfaGFzaCA9IDAgb3IgZWxzZSBsX2hhc2ggPSBsX290aGVyX2hhc2ggdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgbmIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXI6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJyByZWdhcmRsZXNzIG9mIGNhc2luZ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBuYiA9IDAgb3IgZWxzZSBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyLCAxLCBuYiwgMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAoQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnQ6IGF0dGFjaGVkIHtsaWtlIEN1cnJlbnR9IG90aGVyIGFzIGxfb3RoZXIgaW1wbGllcyAoc3RhbmRhcmRfaXNfZXF1YWwgKGxfb3RoZXIpIGltcGxpZXMgUmVzdWx0KVxuICAgICAgdmFsaWRfcmVzdWx0OiBhc19sb3dlciB+IG90aGVyLmFzX2xvd2VyIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGNhc2VsZXNzIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfb3RoZXJfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjMSxjMjogQ0hBUkFDVEVSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgaW5kZXhfcG9zIC0gMVxuICAgICAgICAgIGogOj0gb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgICBuYiA6PSBuYiArIGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMxIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGMyIDo9IGxfb3RoZXJfYXJlYS5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGMxLmFzX2xvd2VyIC89IGMyLmFzX2xvd2VyIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbF9hcmVhLnVwcGVyIC0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLmlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBzYW1lX3N0cmluZyAob3RoZXI6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gRG8gYEN1cnJlbnQnIGFuZCBgb3RoZXInIGhhdmUgc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2U/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKHN0cmluZyB+IG90aGVyLnN0cmluZylcbiAgICBlbmRcblxuICBzYW1lX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGlmIG5iIDw9IGNvdW50IC0gaW5kZXhfcG9zICsgMSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBhcmVhLnNhbWVfaXRlbXMgKG90aGVyLmFyZWEsIG90aGVyLmFyZWFfbG93ZXIgKyBzdGFydF9wb3MgLSAxLCBhcmVhX2xvd2VyICsgaW5kZXhfcG9zIC0gMSwgbmIpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLnNhbWVfc3RyaW5nIChvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykpXG4gICAgZW5kXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cmluZyBsZXhpY29ncmFwaGljYWxseSBsb3dlciB0aGFuIGBvdGhlcic/XG4gICAgbG9jYWxcbiAgICAgIG90aGVyX2NvdW50OiBJTlRFR0VSXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICBvdGhlcl9jb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgICBjdXJyZW50X2NvdW50IDo9IGNvdW50XG4gICAgICAgIGlmIG90aGVyX2NvdW50ID0gY3VycmVudF9jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IHN0cl9zdHJpY3RfY21wIChvdGhlci5hcmVhLCBhcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBvdGhlcl9jb3VudCkgPiAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBjdXJyZW50X2NvdW50IDwgb3RoZXJfY291bnQgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IHN0cl9zdHJpY3RfY21wIChvdGhlci5hcmVhLCBhcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBjdXJyZW50X2NvdW50KSA+PSAwXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgUmVzdWx0IDo9IHN0cl9zdHJpY3RfY21wIChvdGhlci5hcmVhLCBhcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBvdGhlcl9jb3VudCkgPiAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX3N0cmluZ184OiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuICBpc19zdHJpbmdfMzI6IEJPT0xFQU4gPSBGYWxzZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuICBpc192YWxpZF9hc19zdHJpbmdfODogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG5cbiAgaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBpLCBuOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMVxuICAgICAgICBuIDo9IGFyZWFfbG93ZXIgKyBlbmRfaW5kZXggLSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbiBvciBub3QgbF9hcmVhLml0ZW0gKGkpLmlzX3NwYWNlXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IGkgPiBuXG4gICAgZW5kXG5cbiAgaGFzIChjOiBDSEFSQUNURVJfOCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIChsX2FyZWEuaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDwgbmIpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGZhbHNlX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2ZpcnN0OiBjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjIGltcGxpZXMgUmVzdWx0XG4gICAgICByZWN1cnNlOiAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgKFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLmhhcyAoYykpXG4gICAgZW5kXG5cbiAgc3RhcnRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICBsX3NfYXJlYSA6PSBzLmFyZWFcbiAgICAgICAgICAgIGogOj0gYXJlYV9sb3dlciArIGlcbiAgICAgICAgICAgIGkgOj0gcy5hcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgbmIgOj0gcy5hcmVhX2xvd2VyXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgICBpZiBsX2FyZWEuaXRlbSAoaikgLz0gbF9zX2FyZWEuaXRlbSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSBuYiAtLSBKdW1wIG91dCBvZiBsb29wXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHMuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoMSwgcy5jb3VudCkpXG4gICAgZW5kXG5cbiAgZW5kc193aXRoIChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGZpbmlzaCB3aXRoIGBzJz9cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfc19hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA9IHMgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBpIDo9IHMuY291bnRcbiAgICAgICAgaiA6PSBjb3VudFxuICAgICAgICBpZiBpIDw9IGogdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICBsX3NfYXJlYSA6PSBzLmFyZWFcbiAgICAgICAgICAgIGogOj0gYXJlYV91cHBlciArIDFcbiAgICAgICAgICAgIGkgOj0gcy5hcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgbmIgOj0gcy5hcmVhX2xvd2VyXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgICBpZiBsX2FyZWEuaXRlbSAoaikgLz0gbF9zX2FyZWEuaXRlbSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSBuYiAtLSBKdW1wIG91dCBvZiBsb29wXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHMuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoY291bnQgLSBzLmNvdW50ICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHZhbGlkX2NvZGUgKHY6IE5BVFVSQUxfMzIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdicgYSB2YWxpZCBjb2RlIGZvciBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHYgPD0ge0NIQVJBQ1RFUl84fS5tYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGlzX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIEJPT0xFQU4/XG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPSA0IHRoZW5cbiAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIGlzIGB0cnVlX2NvbnN0YW50J1xuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgUmVzdWx0IDo9IGxfYXJlYS5pdGVtIChpKS5sb3dlciA9ICd0JyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMSkubG93ZXIgPSAncicgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDIpLmxvd2VyID0gJ3UnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAzKS5sb3dlciA9ICdlJ1xuICAgICAgZWxzZWlmIG5iID0gNSB0aGVuXG4gICAgICAgICAgLS0gQ2hlY2sgaWYgdGhpcyBpcyBgZmFsc2VfY29uc3RhbnQnXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpLmxvd2VyID0gJ2YnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAxKS5sb3dlciA9ICdhJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMikubG93ZXIgPSAnbCcgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDMpLmxvd2VyID0gJ3MnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyA0KS5sb3dlciA9ICdlJ1xuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1JFQURBQkxFX1NUUklOR184fSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBSZWluaXRpYWxpemUgYnkgY29weWluZyB0aGUgY2hhcmFjdGVycyBvZiBgb3RoZXInLlxuICAgICAgLS0gKFRoaXMgaXMgYWxzbyB1c2VkIGJ5IGB0d2luJy4pXG4gICAgbG9jYWxcbiAgICAgIG9sZF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIG9sZF9hcmVhIDo9IGFyZWFcbiAgICAgICAgc3RhbmRhcmRfY29weSAob3RoZXIpXG4gICAgICAgICAgLS0gTm90ZTogPD0gaXMgbmVlZGVkIGFzIGFsbCBFaWZmZWwgc3RyaW5nIHNob3VsZCBoYXZlIGFuXG4gICAgICAgICAgLS0gZXh0cmEgY2hhcmFjdGVyIHRvIGluc2VydCBudWxsIGNoYXJhY3RlciBhdCB0aGUgZW5kLlxuICAgICAgICBpZiBvbGRfYXJlYSA9IFZvaWQgb3IgZWxzZSBvbGRfYXJlYSA9IG90aGVyLmFyZWEgb3IgZWxzZSBvbGRfYXJlYS5jb3VudCA8PSBjb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBQcmV2ZW50IGNvcHlpbmcgb2YgbGFyZ2UgYGFyZWEnIGlmIG9ubHkgYSBmZXcgY2hhcmFjdGVycyBhcmUgYWN0dWFsbHkgdXNlZC5cbiAgICAgICAgICBhcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhIChjb3VudCArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvbGRfYXJlYS5jb3B5X2RhdGEgKGFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgICAgIGFyZWEgOj0gb2xkX2FyZWFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X3Jlc3VsdF9jb3VudDogY291bnQgPSBvdGhlci5jb3VudFxuICAgICAgLS0gc2FtZV9jaGFyYWN0ZXJzOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IGBvdGhlcicuYGl0ZW0nIChgaScpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgZmlsbF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgY2hhcmFjdGVycyBhbGwgZXF1YWwgdG8gYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NhcDogbGlrZSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBsX2NhcCA6PSBjYXBhY2l0eVxuICAgICAgaWYgbF9jYXAgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NhcCAtIDEpXG4gICAgICAgIGNvdW50IDo9IGxfY2FwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogY291bnQgPSBjYXBhY2l0eVxuICAgICAgc2FtZV9zaXplOiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgLS0gYWxsX2NoYXI6IEZvciBldmVyeSBgaScgaW4gMS4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYGMnXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgUmVzdWx0Jy5gaXRlbScgKGBpJykgPSBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoQ3VycmVudClcbiAgICBlbnN1cmUgdGhlblxuICAgICAgb3V0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9pdGVtczogc2FtZV90eXBlIChcIlwiKSBpbXBsaWVzIFJlc3VsdC5zYW1lX3N0cmluZyAoQ3VycmVudClcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBzdHJpbmdfc2VhcmNoZXI6IFNUUklOR184X1NFQVJDSEVSXG4gICAgICAtLSBTdHJpbmcgc2VhcmNoZXIgc3BlY2lhbGl6ZWQgZm9yIFJFQURBQkxFX1NUUklOR184IGluc3RhbmNlc1xuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG4gIHN0cl9zdHJpY3RfY21wICh0aGlzLCBvdGhlcjogbGlrZSBhcmVhOyB0aGlzX2luZGV4LCBvdGhlcl9pbmRleCwgbjogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENvbXBhcmUgYG4nIGNoYXJhY3RlcnMgZnJvbSBgdGhpcycgc3RhcnRpbmcgYXQgYHRoaXNfaW5kZXgnIHdpdGhcbiAgICAgIC0tIGBuJyBjaGFyYWN0ZXJzIGZyb20gYW5kIGBvdGhlcicgc3RhcnRpbmcgYXQgYG90aGVyX2luZGV4Jy5cbiAgICAgIC0tIDAgaWYgZXF1YWwsIDwgMCBpZiBgdGhpcycgPCBgb3RoZXInLFxuICAgICAgLS0gPiAwIGlmIGB0aGlzJyA+IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICB0aGlzX25vdF92b2lkOiB0aGlzIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX3ZhbGlkOiBuIDw9ICh0aGlzLnVwcGVyIC0gdGhpc19pbmRleCArIDEpIGFuZCBuIDw9IChvdGhlci51cHBlciAtIG90aGVyX2luZGV4ICsgMSlcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmIsIGxfY3VycmVudF9jb2RlLCBsX290aGVyX2NvZGU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHRoaXNfaW5kZXhcbiAgICAgICAgbmIgOj0gaSArIG5cbiAgICAgICAgaiA6PSBvdGhlcl9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY3VycmVudF9jb2RlIDo9IHRoaXMuaXRlbSAoaSkuY29kZVxuICAgICAgICBsX290aGVyX2NvZGUgOj0gb3RoZXIuaXRlbSAoaikuY29kZVxuICAgICAgICBpZiBsX2N1cnJlbnRfY29kZSAvPSBsX290aGVyX2NvZGUgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBsX2N1cnJlbnRfY29kZSAtIGxfb3RoZXJfY29kZVxuICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgICAgLS0gd2l0aCB0aGVpciBsb3dlciB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gZW5kX2luZGV4XG4gICAgICBsb29wXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGkpLmxvd2VyLCBpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b191cHBlcl9hcmVhIChhOiBsaWtlIGFyZWE7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgICAtLSB3aXRoIHRoZWlyIHVwcGVyIHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgYV9ub3Rfdm9pZDogYSAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGEuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYS5wdXQgKGEuaXRlbSAoaSkudXBwZXIsIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvcl9hcmVhIChhOiBsaWtlIGFyZWE7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBNaXJyb3IgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgYV9ub3Rfdm9pZDogYSAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGEuY291bnRcbiAgICBsb2NhbFxuICAgICAgYzogQ0hBUkFDVEVSXzhcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA8PSBqXG4gICAgICBsb29wXG4gICAgICAgIGMgOj0gYS5pdGVtIChpKVxuICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgYS5wdXQgKGMsIGopXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmVcbiAge1JFQURBQkxFX1NUUklOR184LCBSRUFEQUJMRV9TVFJJTkdfMzIsXG4gIFNUUklOR184X1NFQVJDSEVSLCBTVFJJTkdfMzJfU0VBUkNIRVIsXG4gIEhFWEFERUNJTUFMX1NUUklOR19UT19JTlRFR0VSX0NPTlZFUlRFUixcbiAgU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVE9SLFxuICBTVFJJTkdfVE9fUkVBTF9DT05WRVJUT1J9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzhdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzXG5cbiAgYXJlYV9sb3dlcjogSU5URUdFUlxuICAgICAgLS0gTWluaW11bSBpbmRleFxuICAgIGRvXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX2xvd2VyX25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICAgIGFyZWFfbG93ZXJfdmFsaWQ6IFJlc3VsdCA8PSBhcmVhLnVwcGVyXG4gICAgZW5kXG5cbiAgYXJlYV91cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV9sb3dlciArIGNvdW50IC0gMVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV91cHBlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICAgIGFyZWFfdXBwZXJfaW5fYm91bmQ6IGFyZWFfbG93ZXIgPD0gUmVzdWx0ICsgMVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgYXJlYV9ub3Rfdm9pZDogYXJlYSAvPSBWb2lkXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb21tb24gYW5jZXN0b3JzIHRvIGFsbCBTVFJJTkcgY2xhc3Nlcy4gUmVhZC1vbmx5IGludGVyZmFjZS5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMTkgMDY6Mjc6MDEgLTA3MDAgKFdlZCwgMTkgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NjMwICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuXG5pbmhlcml0XG4gIENPTVBBUkFCTEVcbiAgICBleHBvcnRcbiAgICAgIHtSRUFEQUJMRV9TVFJJTkdfR0VORVJBTH0gY29weSwgc3RhbmRhcmRfY29weSwgZGVlcF9jb3B5XG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICBleHBvcnRcbiAgICAgIHtSRUFEQUJMRV9TVFJJTkdfR0VORVJBTH0gY29weSwgc3RhbmRhcmRfY29weSwgZGVlcF9jb3B5XG4gICAgdW5kZWZpbmVcbiAgICAgIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgU1RSSU5HX0hBTkRMRVJcbiAgICBleHBvcnRcbiAgICAgIHtSRUFEQUJMRV9TVFJJTkdfR0VORVJBTH0gY29weSwgc3RhbmRhcmRfY29weSwgZGVlcF9jb3B5XG4gICAgdW5kZWZpbmVcbiAgICAgIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5X3N0cmluZzogY291bnQgPSAwXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgIGVuZFxuXG4gIG1ha2VfZW1wdHlcbiAgICAgIC0tIENyZWF0ZSBlbXB0eSBzdHJpbmcuXG4gICAgZG9cbiAgICAgIG1ha2UgKDApXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eTogY291bnQgPSAwXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGNvZGUgKGk6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb2RlIGF0IHBvc2l0aW9uIGBpJ1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiIChpOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGluZGV4X29mIChjOiBsaWtlIGl0ZW07IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycgYXQgb3IgYWZ0ZXIgYHN0YXJ0X2luZGV4JztcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnRfaW5kZXggPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBzdGFydF9pbmRleCA8PSBuYiB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIGVsc2UgaXRlbSAoaSkgPSBjXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBpIDw9IG5iIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gaVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIChzdGFydF9pbmRleCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBjb3VudClcbiAgICAgIHplcm9faWZfYWJzZW50OiAoUmVzdWx0ID0gMCkgPSBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXMgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYmVmb3JlOiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBSZXN1bHQgLSAxKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZiAoYzogbGlrZSBpdGVtOyBzdGFydF9pbmRleF9mcm9tX2VuZDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGxhc3Qgb2NjdXJyZW5jZSBvZiBgYycuXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleF9mcm9tX2VuZCA8PSBjb3VudFxuICAgICAgc3RhcnRfaW5kZXhfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleF9mcm9tX2VuZCA+PSAxXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgUmVzdWx0IDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB1bnRpbFxuICAgICAgICBSZXN1bHQgPD0gMCBvciBlbHNlIGl0ZW0gKFJlc3VsdCkgPSBjXG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogMCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBzdGFydF9pbmRleF9mcm9tX2VuZFxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgICBmb3VuZF9pZl9wcmVzZW50OiBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpIGltcGxpZXMgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYWZ0ZXI6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChSZXN1bHQgKyAxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKVxuICAgIGVuZFxuXG4gIGluZGV4X29mX2NvZGUgKGM6IGxpa2UgY29kZTsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X2xhcmdlX2Vub3VnaDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgc3RhcnRfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSBjb2RlIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPD0gbmIgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCA9IDAgb3IgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50KVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzX2NvZGUgKGMpXG4gICAgICBmb3VuZF9pZl9wcmVzZW50OiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzX2NvZGUgKGMpIGltcGxpZXMgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYmVmb3JlOiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzX2NvZGUgKGMpIGltcGxpZXNcbiAgICAgICAgbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIFJlc3VsdCAtIDEpLmhhc19jb2RlIChjKVxuICAgIGVuZFxuXG4gIGxhc3RfaW5kZXhfb2ZfY29kZSAoYzogbGlrZSBjb2RlOyBzdGFydF9pbmRleF9mcm9tX2VuZDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGxhc3Qgb2NjdXJyZW5jZSBvZiBgYycuXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleF9mcm9tX2VuZCA8PSBjb3VudFxuICAgICAgc3RhcnRfaW5kZXhfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleF9mcm9tX2VuZCA+PSAxXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgUmVzdWx0IDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB1bnRpbFxuICAgICAgICBSZXN1bHQgPD0gMCBvciBlbHNlIGNvZGUgKFJlc3VsdCkgPSBjXG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogMCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBzdGFydF9pbmRleF9mcm9tX2VuZFxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXNfY29kZSAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKSBpbXBsaWVzIGNvZGUgKFJlc3VsdCkgPSBjXG4gICAgICBub25lX2FmdGVyOiBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXNfY29kZSAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChSZXN1bHQgKyAxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzX2NvZGUgKGMpXG4gICAgZW5kXG5cbiAgZmFsc2VfY29uc3RhbnQ6IFNUUklOR184ID0gXCJmYWxzZVwiXG4gICAgICAtLSBDb25zdGFudCBzdHJpbmcgXCJmYWxzZVwiXG5cbiAgdHJ1ZV9jb25zdGFudDogU1RSSU5HXzggPSBcInRydWVcIlxuICAgICAgLS0gQ29uc3RhbnQgc3RyaW5nIFwidHJ1ZVwiXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgaWYgUmVzdWx0ID0gMCB0aGVuXG4gICAgICAgICAgLS0gVGhlIG1hZ2ljIG51bWJlciBgODM4ODU5MycgYmVsb3cgaXMgdGhlIGdyZWF0ZXN0IHByaW1lIGxvd2VyIHRoYW5cbiAgICAgICAgICAtLSAyXjIzIHNvIHRoYXQgdGhpcyBtYWdpYyBudW1iZXIgc2hpZnRlZCB0byB0aGUgbGVmdCBkb2VzIG5vdCBleGNlZWQgMl4zMS5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBSZXN1bHQgOj0gKChSZXN1bHQgXFxcXCA4Mzg4NTkzKSB8PDwgOCkgKyBpdGVtIChpKS5jb2RlXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IFJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZSBvZiB0aGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIGBDdXJyZW50Jy5cbiAgICBsb2NhbFxuICAgICAgbF9wcm9wczogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGludGVybmFsX2Nhc2VfaW5zZW5zaXRpdmVfaGFzaF9jb2RlXG4gICAgICBpZiBSZXN1bHQgPSAwIHRoZW5cbiAgICAgICAgICAtLSBUaGUgbWFnaWMgbnVtYmVyIGA4Mzg4NTkzJyBiZWxvdyBpcyB0aGUgZ3JlYXRlc3QgcHJpbWUgbG93ZXIgdGhhblxuICAgICAgICAgIC0tIDJeMjMgc28gdGhhdCB0aGlzIG1hZ2ljIG51bWJlciBzaGlmdGVkIHRvIHRoZSBsZWZ0IGRvZXMgbm90IGV4Y2VlZCAyXjMxLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgICBsX3Byb3BzIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBSZXN1bHQgOj0gKChSZXN1bHQgXFxcXCA4Mzg4NTkzKSB8PDwgOCkgKyBsX3Byb3BzLnRvX2xvd2VyIChpdGVtIChpKSkuY29kZVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2Nhc2VfaW5zZW5zaXRpdmVfaGFzaF9jb2RlIDo9IFJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjb25zaXN0ZW50OiBSZXN1bHQgPSBhc19sb3dlci5oYXNoX2NvZGVcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaW1tdXRhYmxlOiBCT09MRUFOXG4gICAgICAtLSBDYW4gdGhlIGNoYXJhY3RlciBzZXF1ZW5jZSBvZiBgQ3VycmVudCcgYmUgbm90IGNoYW5nZWQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgIGVuZFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBzdHJpbmc/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoaSA+IDApIGFuZCAoaSA8PSBjb3VudClcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9ICgxIDw9IGkgYW5kIGkgPD0gY291bnQpXG4gICAgZW5kXG5cbiAgdmFsaWRfY29kZSAodjogbGlrZSBjb2RlKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHYnIGEgdmFsaWQgY29kZSBmb3IgQ3VycmVudD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX3N0cmluZ184OiBCT09MRUFOXG4gICAgICAtLSBJcyBgQ3VycmVudCcgYSBzZXF1ZW5jZSBvZiBDSEFSQUNURVJfOD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTlxuICAgICAgLS0gSXMgYEN1cnJlbnQnIGEgc2VxdWVuY2Ugb2YgQ0hBUkFDVEVSXzMyP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfYXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBjb252ZXJ0aWJsZSB0byBhIHNlcXVlbmNlIG9mIENIQVJBQ1RFUl84IHdpdGhvdXQgaW5mb3JtYXRpb24gbG9zcz9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX2VtcHR5OiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZW1wdHk/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc193aGl0ZXNwYWNlOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3N1YnN0cmluZ193aGl0ZXNwYWNlICgxLCBjb3VudClcbiAgICBlbmRcblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN1YnN0cmluZyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnIGNvbnRhaW5pbmcgb25seSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnM/XG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfYmlnX2Vub3VnaDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgZW5kX2luZGV4X3NtYWxsX2Vub3VnaDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBjb25zaXN0ZW50X2luZGV4ZXM6IHN0YXJ0X2luZGV4IC0gMSA8PSBlbmRfaW5kZXhcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGhhcyAoYzogbGlrZSBpdGVtKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgaW5jbHVkZSBgYyc/XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIGVsc2UgKGl0ZW0gKGkpID0gYylcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIFJlc3VsdCA6PSAoaSA8PSBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBmYWxzZV9pZl9lbXB0eTogY291bnQgPSAwIGltcGxpZXMgbm90IFJlc3VsdFxuICAgICAgdHJ1ZV9pZl9maXJzdDogY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpID0gYyBpbXBsaWVzIFJlc3VsdFxuICAgICAgcmVjdXJzZTogKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSAvPSBjKSBpbXBsaWVzXG4gICAgICAgIChSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5oYXMgKGMpKVxuICAgIGVuZFxuXG4gIGhhc19jb2RlIChjOiBsaWtlIGNvZGUpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBpbmNsdWRlIGBjJz9cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSAoY29kZSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDw9IG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGZhbHNlX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2ZpcnN0OiBjb3VudCA+IDAgYW5kIHRoZW4gY29kZSAoMSkgPSBjIGltcGxpZXMgUmVzdWx0XG4gICAgICByZWN1cnNlOiAoY291bnQgPiAwIGFuZCB0aGVuIGNvZGUgKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgKFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLmhhc19jb2RlIChjKSlcbiAgICBlbmRcblxuICBpc19udW1iZXJfc2VxdWVuY2U6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIG51bWJlciBzZXF1ZW5jZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tIFJlc3VsdCBpcyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBmb2xsb3dpbmcgdHdvXG4gICAgICAgIC0tIGNvbmRpdGlvbnMgYXJlIHNhdGlzZmllZDpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gSW4gdGhlIGZvbGxvd2luZyBCTkYgZ3JhbW1hciwgdGhlIHZhbHVlIG9mXG4gICAgICAgIC0tICBDdXJyZW50IGNhbiBiZSBwcm9kdWNlZCBieSBcIkludGVnZXJfbGl0ZXJhbFwiOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbnRlZ2VyX2xpdGVyYWwgPSBbU3BhY2VdIFtTaWduXSBJbnRlZ2VyIFtTcGFjZV1cbiAgICAgICAgLS0gU3BhY2UgID0gXCIgXCIgfCBcIiBcIiBTcGFjZVxuICAgICAgICAtLSBTaWduICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgID0gRGlnaXQgfCBEaWdpdCBJbnRlZ2VyXG4gICAgICAgIC0tIERpZ2l0ICA9IFwiMFwifFwiMVwifFwiMlwifFwiM1wifFwiNFwifFwiNVwifFwiNlwifFwiN1wifFwiOFwifFwiOVwiXG4gICAgZW5kXG5cbiAgaXNfcmVhbF9zZXF1ZW5jZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgcmVhbCBzZXF1ZW5jZT9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IuaXNfaW50ZWdyYWxfZG91YmxlXG4gICAgZW5zdXJlXG4gICAgICBzeW50YXhfYW5kX3JhbmdlOlxuICAgICAgICAtLSAnUmVzdWx0JyBpcyBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uIGlzIHNhdGlzZmllZDpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gSW4gdGhlIGZvbGxvd2luZyBCTkYgZ3JhbW1hciwgdGhlIHZhbHVlIG9mXG4gICAgICAgIC0tICAnQ3VycmVudCcgY2FuIGJlIHByb2R1Y2VkIGJ5IFwiUmVhbF9saXRlcmFsXCI6XG4gICAgICAgIC0tXG4gICAgICAgIC0tIFJlYWxfbGl0ZXJhbCA9IE1hbnRpc3NhIFtFeHBvbmVudF9wYXJ0XVxuICAgICAgICAtLSBFeHBvbmVudF9wYXJ0ID0gXCJFXCIgRXhwb25lbnRcbiAgICAgICAgLS0gICAgICAgICB8IFwiZVwiIEV4cG9uZW50XG4gICAgICAgIC0tIEV4cG9uZW50ICAgPSBJbnRlZ2VyX2xpdGVyYWxcbiAgICAgICAgLS0gTWFudGlzc2EgICA9IERlY2ltYWxfbGl0ZXJhbFxuICAgICAgICAtLSBEZWNpbWFsX2xpdGVyYWwgPSBJbnRlZ2VyX2xpdGVyYWwgW1wiLlwiIFtJbnRlZ2VyXV0gfCBcIi5cIiBJbnRlZ2VyXG4gICAgICAgIC0tIEludGVnZXJfbGl0ZXJhbCA9IFtTaWduXSBJbnRlZ2VyXG4gICAgICAgIC0tIFNpZ24gICAgID0gXCIrXCIgfCBcIi1cIlxuICAgICAgICAtLSBJbnRlZ2VyICAgID0gRGlnaXQgfCBEaWdpdCBJbnRlZ2VyXG4gICAgICAgIC0tIERpZ2l0ICAgID0gXCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJcbiAgICAgICAgLS1cbiAgICBlbmRcblxuICBpc19yZWFsLCBpc19yZWFsXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBSRUFMXzMyP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9yX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9yX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfcmVhbClcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9yZWFsXG4gICAgZW5zdXJlXG4gICAgICBzeW50YXhfYW5kX3JhbmdlOlxuICAgICAgICAtLSAnUmVzdWx0JyBpcyBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBmb2xsb3dpbmcgdHdvXG4gICAgICAgIC0tIGNvbmRpdGlvbnMgYXJlIHNhdGlzZmllZDpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gMS4gSW4gdGhlIGZvbGxvd2luZyBCTkYgZ3JhbW1hciwgdGhlIHZhbHVlIG9mXG4gICAgICAgIC0tICAnQ3VycmVudCcgY2FuIGJlIHByb2R1Y2VkIGJ5IFwiUmVhbF9saXRlcmFsXCI6XG4gICAgICAgIC0tXG4gICAgICAgIC0tIFJlYWxfbGl0ZXJhbCA9IE1hbnRpc3NhIFtFeHBvbmVudF9wYXJ0XVxuICAgICAgICAtLSBFeHBvbmVudF9wYXJ0ID0gXCJFXCIgRXhwb25lbnRcbiAgICAgICAgLS0gICAgICAgICB8IFwiZVwiIEV4cG9uZW50XG4gICAgICAgIC0tIEV4cG9uZW50ICAgPSBJbnRlZ2VyX2xpdGVyYWxcbiAgICAgICAgLS0gTWFudGlzc2EgICA9IERlY2ltYWxfbGl0ZXJhbFxuICAgICAgICAtLSBEZWNpbWFsX2xpdGVyYWwgPSBJbnRlZ2VyX2xpdGVyYWwgW1wiLlwiIFtJbnRlZ2VyXV0gfCBcIi5cIiBJbnRlZ2VyXG4gICAgICAgIC0tIEludGVnZXJfbGl0ZXJhbCA9IFtTaWduXSBJbnRlZ2VyXG4gICAgICAgIC0tIFNpZ24gICAgID0gXCIrXCIgfCBcIi1cIlxuICAgICAgICAtLSBJbnRlZ2VyICAgID0gRGlnaXQgfCBEaWdpdCBJbnRlZ2VyXG4gICAgICAgIC0tIERpZ2l0ICAgID0gXCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJcbiAgICAgICAgLS1cbiAgICAgICAgLS0gMi4gVGhlIG51bWVyaWNhbCB2YWx1ZSByZXByZXNlbnRlZCBieSAnQ3VycmVudCdcbiAgICAgICAgLS0gIGlzIHdpdGhpbiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICAgICAgLS0gIGJ5IGFuIGluc3RhbmNlIG9mIHR5cGUgUkVBTC5cbiAgICBlbmRcblxuICBpc19kb3VibGUsIGlzX3JlYWxfNjQ6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIFJFQUxfNjQ/XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b3JfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b3JfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9kb3VibGUpXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IuaXNfaW50ZWdyYWxfZG91YmxlXG4gICAgZW5zdXJlXG4gICAgICBzeW50YXhfYW5kX3JhbmdlOlxuICAgICAgICAtLSAnUmVzdWx0JyBpcyBUcnVlIGlmIGFuZCBvbmx5IGlmIHRoZSBmb2xsb3dpbmcgdHdvXG4gICAgICAgIC0tIGNvbmRpdGlvbnMgYXJlIHNhdGlzZmllZDpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gMS4gSW4gdGhlIGZvbGxvd2luZyBCTkYgZ3JhbW1hciwgdGhlIHZhbHVlIG9mXG4gICAgICAgIC0tICAnQ3VycmVudCcgY2FuIGJlIHByb2R1Y2VkIGJ5IFwiUmVhbF9saXRlcmFsXCI6XG4gICAgICAgIC0tXG4gICAgICAgIC0tIFJlYWxfbGl0ZXJhbCA9IE1hbnRpc3NhIFtFeHBvbmVudF9wYXJ0XVxuICAgICAgICAtLSBFeHBvbmVudF9wYXJ0ID0gXCJFXCIgRXhwb25lbnRcbiAgICAgICAgLS0gICAgICAgICB8IFwiZVwiIEV4cG9uZW50XG4gICAgICAgIC0tIEV4cG9uZW50ICAgPSBJbnRlZ2VyX2xpdGVyYWxcbiAgICAgICAgLS0gTWFudGlzc2EgICA9IERlY2ltYWxfbGl0ZXJhbFxuICAgICAgICAtLSBEZWNpbWFsX2xpdGVyYWwgPSBJbnRlZ2VyX2xpdGVyYWwgW1wiLlwiIFtJbnRlZ2VyXV0gfCBcIi5cIiBJbnRlZ2VyXG4gICAgICAgIC0tIEludGVnZXJfbGl0ZXJhbCA9IFtTaWduXSBJbnRlZ2VyXG4gICAgICAgIC0tIFNpZ24gICAgID0gXCIrXCIgfCBcIi1cIlxuICAgICAgICAtLSBJbnRlZ2VyICAgID0gRGlnaXQgfCBEaWdpdCBJbnRlZ2VyXG4gICAgICAgIC0tIERpZ2l0ICAgID0gXCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJcbiAgICAgICAgLS1cbiAgICAgICAgLS0gMi4gVGhlIG51bWVyaWNhbCB2YWx1ZSByZXByZXNlbnRlZCBieSAnQ3VycmVudCdcbiAgICAgICAgLS0gIGlzIHdpdGhpbiB0aGUgcmFuZ2UgdGhhdCBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICAgICAgLS0gIGJ5IGFuIGluc3RhbmNlIG9mIHR5cGUgRE9VQkxFLlxuICAgIGVuZFxuXG4gIGlzX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIEJPT0xFQU4/XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGlzX2Jvb2xlYW46IFJlc3VsdCA9ICh0cnVlX2NvbnN0YW50LnNhbWVfc3RyaW5nX2dlbmVyYWwgKGFzX2xvd2VyKSBvclxuICAgICAgICBmYWxzZV9jb25zdGFudC5zYW1lX3N0cmluZ19nZW5lcmFsIChhc19sb3dlcikpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl84OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9pbnRlZ2VyXzgpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl8xNjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGFuIElOVEVHRVJfMTY/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2ludGVnZXJfMTYpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlciwgaXNfaW50ZWdlcl8zMjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGFuIElOVEVHRVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2ludGVnZXJfMzIpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl82NDogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGFuIElOVEVHRVJfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2ludGVnZXJfNjQpXG4gICAgZW5kXG5cbiAgaXNfbmF0dXJhbF84OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBOQVRVUkFMXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfOClcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzE2OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBOQVRVUkFMXzE2P1xuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfMTYpXG4gICAgZW5kXG5cbiAgaXNfbmF0dXJhbCwgaXNfbmF0dXJhbF8zMjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgTkFUVVJBTF8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF8zMilcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzY0OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBOQVRVUkFMXzY0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9uYXR1cmFsXzY0KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBjaGFyYWN0ZXJzIGluIEN1cnJlbnRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgY2hhcmFjdGVycyBhbGxvY2F0ZWQgaW4gQ3VycmVudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjYXBhY2l0eV9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgb2NjdXJyZW5jZXMgKGM6IENIQVJBQ1RFUl8zMik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSA9IGMgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHplcm9faWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIFJlc3VsdCA9IDBcbiAgICAgIHJlY3Vyc2VfaWZfbm90X2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICAgIHJlY3Vyc2VfaWZfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gMSArIHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInIHJlZ2FyZGxlc3Mgb2YgY2FzaW5nXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBuYiA9IDAgb3IgZWxzZSBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyLCAxLCBuYiwgMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAoQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnQ6IGF0dGFjaGVkIHtsaWtlIEN1cnJlbnR9IG90aGVyIGFzIGxfb3RoZXIgaW1wbGllcyAoc3RhbmRhcmRfaXNfZXF1YWwgKGxfb3RoZXIpIGltcGxpZXMgUmVzdWx0KVxuICAgICAgdmFsaWRfcmVzdWx0OiBhc19sb3dlciB+IG90aGVyLmFzX2xvd2VyIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGNhc2VsZXNzIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIGMxLGMyOiBsaWtlIGl0ZW1cbiAgICBkb1xuICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGlmIG5iIDw9IGNvdW50IC0gaW5kZXhfcG9zICsgMSB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIGkgOj0gaW5kZXhfcG9zXG4gICAgICAgICAgaiA6PSBzdGFydF9wb3NcbiAgICAgICAgICBuYiA6PSBuYiArIGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMxIDo9IGl0ZW0gKGkpXG4gICAgICAgICAgYzIgOj0gb3RoZXIuaXRlbSAoailcbiAgICAgICAgICBpZiBjMSAvPSBjMiBhbmQgdGhlbiBsX3Byb3AudG9fbG93ZXIgKGMxKSAvPSBsX3Byb3AudG9fbG93ZXIgKGMyKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGluY3JlYXNpbmdfaW5kZXg6IG5iIC0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLmlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBoYXNfc3Vic3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyBjb250YWluIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VpZiBvdGhlci5jb3VudCA8PSBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBzdWJzdHJpbmdfaW5kZXggKG90aGVyLCAxKSA+IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmFsc2VfaWZfdG9vX3NtYWxsOiBjb3VudCA8IG90aGVyLmNvdW50IGltcGxpZXMgbm90IFJlc3VsdFxuICAgICAgdHJ1ZV9pZl9pbml0aWFsOiAoY291bnQgPj0gb3RoZXIuY291bnQgYW5kIHRoZW5cbiAgICAgICAgb3RoZXIuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoMSwgb3RoZXIuY291bnQpKSkgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+PSBvdGhlci5jb3VudCBhbmQgdGhlblxuICAgICAgICBub3Qgb3RoZXIuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoMSwgb3RoZXIuY291bnQpKSkgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzX3N1YnN0cmluZyAob3RoZXIpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBvdGhlcicgcmVwcmVzZW50IHRoZSBzYW1lIHN0cmluZyBhcyBgQ3VycmVudCc/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNhbWVfY2hhcmFjdGVycyAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBpbmRleF9wb3NcbiAgICAgICAgICBqIDo9IHN0YXJ0X3Bvc1xuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgaWYgaXRlbSAoaSkgLz0gb3RoZXIuaXRlbSAoaikgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBpIDo9IG5iIC0gMSAtLSBKdW1wIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpbmNyZWFzaW5nX2luZGV4OiBuYiAtIGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NoYXJhY3RlcnM6IFJlc3VsdCA9IHN1YnN0cmluZyAoaW5kZXhfcG9zLCBpbmRleF9wb3MgKyBlbmRfcG9zIC0gc3RhcnRfcG9zKS5zYW1lX3N0cmluZyAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHN0YXJ0c193aXRoIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGJlZ2luIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBpZiBpIDw9IGNvdW50IHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGlmIGNvZGUgKGkpIC89IHMuY29kZSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSAxIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBzLmNvdW50KSlcbiAgICBlbmRcblxuICBlbmRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgZmluaXNoIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBqIDo9IGNvdW50XG4gICAgICAgIGlmIGkgPD0gaiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgaSA9IDBcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpZiBjb2RlKGopIC89IHMuY29kZSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSAxIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgICAgaiA6PSBqIC0gMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChjb3VudCAtIHMuY291bnQgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4X2luX2JvdW5kcyAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBvdGhlcicgYXQgb3IgYWZ0ZXIgYHN0YXJ0X3BvcydcbiAgICAgIC0tIGFuZCB0byBvciBiZWZvcmUgYGVuZF9wb3MnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vbnZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIG90aGVyX25vdGVtcHR5OiBub3Qgb3RoZXIuaXNfZW1wdHlcbiAgICAgIHN0YXJ0X3Bvc19sYXJnZV9lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBzdGFydF9wb3Nfc21hbGxfZW5vdWdoOiBzdGFydF9wb3MgPD0gY291bnRcbiAgICAgIGVuZF9wb3NfbGFyZ2VfZW5vdWdoOiBlbmRfcG9zID49IHN0YXJ0X3Bvc1xuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gY291bnRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY29ycmVjdF9wbGFjZTogUmVzdWx0ID4gMCBpbXBsaWVzIG90aGVyLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKFJlc3VsdCwgUmVzdWx0ICsgb3RoZXIuY291bnQgLSAxKSlcbiAgICAgIC0tIGZvcmFsbCB4IDogc3RhcnRfcG9zLi5SZXN1bHRcbiAgICAgIC0tICBub3Qgc3Vic3RyaW5nICh4LCB4K290aGVyLmNvdW50IC0xKS5pc19lcXVhbCAob3RoZXIpXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gSW5kZXggb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBvdGhlciBhdCBvciBhZnRlciBzdGFydF9pbmRleDtcbiAgICAgIC0tIDAgaWYgbm9uZVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogc3RhcnRfaW5kZXggPj0gMSBhbmQgc3RhcnRfaW5kZXggPD0gY291bnQgKyAxXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0ID0gMCBvciBlbHNlXG4gICAgICAgIChzdGFydF9pbmRleCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBjb3VudCAtIG90aGVyLmNvdW50ICsgMSlcbiAgICAgIHplcm9faWZfYWJzZW50OiAoUmVzdWx0ID0gMCkgPVxuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhc19zdWJzdHJpbmcgKG90aGVyKVxuICAgICAgYXRfdGhpc19pbmRleDogUmVzdWx0ID49IHN0YXJ0X2luZGV4IGltcGxpZXNcbiAgICAgICAgb3RoZXIuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoUmVzdWx0LCBSZXN1bHQgKyBvdGhlci5jb3VudCAtIDEpKVxuICAgICAgbm9uZV9iZWZvcmU6IFJlc3VsdCA+IHN0YXJ0X2luZGV4IGltcGxpZXNcbiAgICAgICAgbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIFJlc3VsdCArIG90aGVyLmNvdW50IC0gMikuaGFzX3N1YnN0cmluZyAob3RoZXIpXG4gICAgZW5kXG5cbiAgZnV6enlfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnQ6IElOVEVHRVI7IGZ1eno6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBvdGhlcicgYXQgb3IgYWZ0ZXIgYHN0YXJ0J1xuICAgICAgLS0gd2l0aCAwLi5gZnV6eicgbWlzbWF0Y2hlcyBiZXR3ZWVuIHRoZSBzdHJpbmcgYW5kIGBvdGhlcicuXG4gICAgICAtLSAwIGlmIHRoZXJlIGFyZSBubyBmdXp6eSBtYXRjaGVzXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBvdGhlcl9ub3RfZW1wdHk6IG5vdCBvdGhlci5pc19lbXB0eVxuICAgICAgc3RhcnRfbGFyZ2VfZW5vdWdoOiBzdGFydCA+PSAxXG4gICAgICBzdGFydF9zbWFsbF9lbm91Z2g6IHN0YXJ0IDw9IGNvdW50XG4gICAgICBhY2NlcHRhYmxlX2Z1enp5OiBmdXp6IDw9IG90aGVyLmNvdW50XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgZnJvemVuIHRvX2NpbDogU1lTVEVNX1NUUklOR1xuICAgICAgLS0gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFNZU1RFTV9TVFJJTkcgdXNpbmcgY2hhcmFjdGVyc1xuICAgICAgLS0gb2YgQ3VycmVudCBiZXR3ZWVuIGluZGljZXMgYDEnIGFuZCBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGRvdG5ldF9jb252ZXJ0b3IuZnJvbV9zdHJpbmdfdG9fc3lzdGVtX3N0cmluZyAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIHRvX2NpbF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICB0b19zdHJpbmdfODogU1RSSU5HXzhcbiAgICAgIC0tIENvbnZlcnQgYEN1cnJlbnQnIGFzIGEgU1RSSU5HXzguXG4gICAgcmVxdWlyZVxuICAgICAgaXNfdmFsaWRfYXNfc3RyaW5nXzg6IGlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfOFxuICAgIGVuc3VyZVxuICAgICAgYXNfc3RyaW5nXzhfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpZGVudGl0eTogKGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0ID0gQ3VycmVudCkgb3IgKG5vdCBjb25mb3Jtc190byAoXCJcIikgYW5kIFJlc3VsdCAvPSBDdXJyZW50KVxuICAgIGVuZFxuXG4gIGFzX3N0cmluZ184X2NvbnZlcnNpb246IFNUUklOR184XG4gICAgICAtLSBFcXVpdmFsZW50IHRvIGBhc19zdHJpbmdfOCcgd2l0aCBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgLS0gVG8gYmUgdXNlZCBmb3IgbWlncmF0aW5nIGV4aXN0aW5nIGNvZGUgdG8gVW5pY29kZVxuICAgICAgLS0gd2hlbiB5b3UgZ2V0IGEgY29tcGlsZXIgZXJyb3IgYnV0IGNhbm5vdCBvciBkbyBub3QgaGF2ZVxuICAgICAgLS0gdGhlIHRpbWUgeWV0IHRvIGFkZHJlc3MgdGhlIHRhcmdldCByZWNpcGllbnQgb2YgdGhlIHN0cmluZyB0byBiZVxuICAgICAgLS0gYSBSRUFEQUJMRV9TVFJJTkdfMzIgb3IgZGVzY2VuZGFudHMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXBkYXRlIHJlY2lwaWVudCBvZiBjYWxsIHRvIHVzZSBSRUFEQUJMRV9TVFJJTkdfMzIgYW5kIGRlc2NlbmRhbnRzIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX3N0cmluZ184XG4gICAgZW5kXG5cbiAgYXNfcmVhZGFibGVfc3RyaW5nXzg6IFJFQURBQkxFX1NUUklOR184XG4gICAgICAtLVxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBleHBsaWNpdCBjb252ZXJzaW9uIGB0b19zdHJpbmdfOCcgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfc3RyaW5nXzhcbiAgICBlbmRcblxuICBhc19zdHJpbmdfODogU1RSSU5HXzhcbiAgICAgIC0tIENvbnZlcnQgYEN1cnJlbnQnIGFzIGEgU1RSSU5HXzguIElmIGEgY29kZSBvZiBgQ3VycmVudCcgaXNcbiAgICAgIC0tIG5vdCBhIHZhbGlkIGNvZGUgZm9yIGEgU1RSSU5HXzggaXQgaXMgcmVwbGFjZWQgd2l0aCB0aGUgbnVsbFxuICAgICAgLS0gY2hhcmFjdGVyLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9jb2RlOiBsaWtlIGNvZGVcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1NUUklOR184fSBDdXJyZW50IGFzIGxfcmVzdWx0IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfcmVzdWx0XG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobmIpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKG5iKVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX2NvZGUgOj0gY29kZSAoaSlcbiAgICAgICAgICBpZiBSZXN1bHQudmFsaWRfY29kZSAobF9jb2RlKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQucHV0X2NvZGUgKGxfY29kZSwgaSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBSZXN1bHQucHV0X2NvZGUgKDAsIGkpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYXNfc3RyaW5nXzhfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpZGVudGl0eTogKGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0ID0gQ3VycmVudCkgb3IgKG5vdCBjb25mb3Jtc190byAoXCJcIikgYW5kIFJlc3VsdCAvPSBDdXJyZW50KVxuICAgIGVuZFxuXG4gIGFzX3N0cmluZ18zMl9jb252ZXJzaW9uOiBTVFJJTkdfMzJcbiAgICAgIC0tIEVxdWl2YWxlbnQgdG8gYGFzX3N0cmluZ18zMicgd2l0aCBhIGRpZmZlcmVudCBuYW1lLlxuICAgICAgLS0gVG8gYmUgdXNlZCBmb3IgbWlncmF0aW5nIGV4aXN0aW5nIGNvZGUgdG8gVW5pY29kZVxuICAgICAgLS0gd2hlbiB5b3UgZ2V0IGEgY29tcGlsZXIgZXJyb3IgYnV0IGNhbm5vdCBvciBkbyBub3QgaGF2ZVxuICAgICAgLS0gdGhlIHRpbWUgeWV0IHRvIGFkZHJlc3MgdGhlIHNvdXJjZSBvZiB0aGUgc3RyaW5nIHRvIGJlXG4gICAgICAtLSBhIFJFQURBQkxFX1NUUklOR18zMiBvciBkZXNjZW5kYW50cy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVcGRhdGUgdGFyZ2V0IG9mIGNhbGwgdG8gdXNlIFJFQURBQkxFX1NUUklOR18zMiBhbmQgZGVzY2VuZGFudHMgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfc3RyaW5nXzMyXG4gICAgZW5kXG5cbiAgYXNfcmVhZGFibGVfc3RyaW5nXzMyOiBSRUFEQUJMRV9TVFJJTkdfMzJcbiAgICAgIC0tXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGV4cGxpY2l0IGNvbnZlcnNpb24gYHRvX3N0cmluZ18zMicgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfc3RyaW5nXzMyXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzMyLCB0b19zdHJpbmdfMzI6IFNUUklOR18zMlxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfMzIuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtTVFJJTkdfMzJ9IEN1cnJlbnQgYXMgbF9yZXN1bHQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9yZXN1bHRcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuYilcbiAgICAgICAgUmVzdWx0LnNldF9jb3VudCAobmIpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAoY29kZSAoaSksIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYXNfc3RyaW5nXzMyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgaWRlbnRpdHk6IChjb25mb3Jtc190byAoY3JlYXRlIHtTVFJJTkdfMzJ9Lm1ha2VfZW1wdHkpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIFJlc3VsdCAvPSBDdXJyZW50KVxuICAgIGVuZFxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBhc19sb3dlcl9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGxlbmd0aDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIGFuY2hvcjogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSkuYXNfbG93ZXJcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLmFzX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgYXNfdXBwZXJfYXR0YWNoZWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBsZW5ndGg6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICBhbmNob3I6IGNvdW50ID4gMCBpbXBsaWVzIFJlc3VsdC5pdGVtICgxKSA9IGl0ZW0gKDEpLmFzX3VwcGVyXG4gICAgICByZWN1cnNlOiBjb3VudCA+IDEgaW1wbGllcyBSZXN1bHQuc3Vic3RyaW5nICgyLCBjb3VudCkgfiBzdWJzdHJpbmcgKDIsIGNvdW50KS5hc191cHBlclxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSA4LWJpdCBpbnRlZ2VyIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfaW50ZWdlcl84OiBpc19pbnRlZ2VyXzhcbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3RvaV9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3RvaV9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIDE2LWJpdCBpbnRlZ2VyIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfaW50ZWdlcl8xNjogaXNfaW50ZWdlcl8xNlxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXIsIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIDMyLWJpdCBpbnRlZ2VyIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfaW50ZWdlcjogaXNfaW50ZWdlcl8zMlxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfaW50ZWdlclxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIDY0LWJpdCBpbnRlZ2VyIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfaW50ZWdlcl82NDogaXNfaW50ZWdlcl82NFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSA4LWJpdCBuYXR1cmFsIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfbmF0dXJhbF84OiBpc19uYXR1cmFsXzhcbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3RvaV9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3RvaV9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIDE2LWJpdCBuYXR1cmFsIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfbmF0dXJhbF8xNjogaXNfbmF0dXJhbF8xNlxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIHRvX25hdHVyYWwsIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIDMyLWJpdCBuYXR1cmFsIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfbmF0dXJhbDogaXNfbmF0dXJhbF8zMlxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIDY0LWJpdCBuYXR1cmFsIHZhbHVlXG4gICAgcmVxdWlyZVxuICAgICAgaXNfbmF0dXJhbF82NDogaXNfbmF0dXJhbF82NFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIHRvX3JlYWwsIHRvX3JlYWxfMzI6IFJFQUxcbiAgICAgIC0tIFJlYWwgdmFsdWU7XG4gICAgICAtLSBmb3IgZXhhbXBsZSwgd2hlbiBhcHBsaWVkIHRvIFwiMTIzLjBcIiwgd2lsbCB5aWVsZCAxMjMuMFxuICAgIHJlcXVpcmVcbiAgICAgIHJlcHJlc2VudHNfYV9yZWFsOiBpc19yZWFsXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0b19kb3VibGUudHJ1bmNhdGVkX3RvX3JlYWxcbiAgICBlbmRcblxuICB0b19kb3VibGUsIHRvX3JlYWxfNjQ6IERPVUJMRVxuICAgICAgLS0gXCJEb3VibGVcIiB2YWx1ZTtcbiAgICAgIC0tIGZvciBleGFtcGxlLCB3aGVuIGFwcGxpZWQgdG8gXCIxMjMuMFwiLCB3aWxsIHlpZWxkIDEyMy4wIChkb3VibGUpXG4gICAgcmVxdWlyZVxuICAgICAgcmVwcmVzZW50c19hX2RvdWJsZTogaXNfZG91YmxlXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b3JfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b3JfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9kb3VibGVcbiAgICBlbmRcblxuICB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHZhbHVlO1xuICAgICAgLS0gXCJUcnVlXCIgeWllbGRzIGBUcnVlJywgXCJGYWxzZVwiIHlpZWxkcyBgRmFsc2UnXG4gICAgICAtLSAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICByZXF1aXJlXG4gICAgICBpc19ib29sZWFuOiBpc19ib29sZWFuXG4gICAgZG9cbiAgICAgIGNoZWNrIHRydWVfY29uc3RhbnQuY291bnQgPSA0IGVuZFxuICAgICAgaWYgY291bnQgPSA0IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdG9fYm9vbGVhbjogKFJlc3VsdCA9IGFzX2xvd2VyLnNhbWVfc3RyaW5nICh0cnVlX2NvbnN0YW50KSkgb3JcbiAgICAgICAgKG5vdCBSZXN1bHQgPSBhc19sb3dlci5zYW1lX3N0cmluZyAoZmFsc2VfY29uc3RhbnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBzcGxpdCAoYV9zZXBhcmF0b3I6IENIQVJBQ1RFUl8zMik6IExJU1QgW2xpa2UgQ3VycmVudF1cbiAgICAgIC0tIFNwbGl0IG9uIGBhX3NlcGFyYXRvcicuXG4gICAgbG9jYWxcbiAgICAgIGxfbGlzdDogQVJSQVlFRF9MSVNUIFtsaWtlIEN1cnJlbnRdXG4gICAgICBwYXJ0OiBsaWtlIEN1cnJlbnRcbiAgICAgIGksIGosIGM6IElOVEVHRVJcbiAgICBkb1xuICAgICAgYyA6PSBjb3VudFxuICAgICAgICAtLSBXb3JzZSBjYXNlIGFsbG9jYXRpb246IGV2ZXJ5IGNoYXJhY3RlciBpcyBhIHNlcGFyYXRvclxuICAgICAgY3JlYXRlIGxfbGlzdC5tYWtlIChjICsgMSlcbiAgICAgIGlmIGMgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBjXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBqIDo9IGluZGV4X29mIChhX3NlcGFyYXRvciwgaSlcbiAgICAgICAgICBpZiBqID0gMCB0aGVuXG4gICAgICAgICAgICAgIC0tIE5vIHNlcGFyYXRvciB3YXMgZm91bmQsIHdlIHdpbGxcbiAgICAgICAgICAgICAgLS0gc2ltcGx5IGNyZWF0ZSBhIGxpc3Qgd2l0aCBhIGNvcHkgb2ZcbiAgICAgICAgICAgICAgLS0gQ3VycmVudCBpbiBpdC5cbiAgICAgICAgICAgIGogOj0gYyArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBwYXJ0IDo9IHN1YnN0cmluZyAoaSwgaiAtIDEpXG4gICAgICAgICAgbF9saXN0LmV4dGVuZCAocGFydClcbiAgICAgICAgICBpIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBqID0gYyB0aGVuXG4gICAgICAgICAgY2hlY2tcbiAgICAgICAgICAgIGxhc3RfY2hhcmFjdGVyX2lzX2Ffc2VwYXJhdG9yOiBpdGVtIChqKSA9IGFfc2VwYXJhdG9yXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBBIHNlcGFyYXRvciB3YXMgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgbF9saXN0LmV4dGVuZCAobmV3X3N0cmluZyAoMCkpXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dGVuZCBlbXB0eSBzdHJpbmcsIHNpbmNlIEN1cnJlbnQgaXMgZW1wdHkuXG4gICAgICAgIGxfbGlzdC5leHRlbmQgKG5ld19zdHJpbmcgKDApKVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gbF9saXN0XG4gICAgICBjaGVja1xuICAgICAgICBsX2xpc3QuY291bnQgPSBvY2N1cnJlbmNlcyAoYV9zZXBhcmF0b3IpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBwbHVzX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudCArIHMuY291bnRcbiAgICAgIGluaXRpYWw6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBSZXN1bHQuc3Vic3RyaW5nICgxLCBjb3VudCkgfiBDdXJyZW50XG4gICAgICBmaW5hbDogZWxrc19jaGVja2luZyBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKGNvdW50ICsgMSwgY291bnQgKyBzLmNvdW50KS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHN1YnN0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHN1YnN0cmluZ19jb3VudDogUmVzdWx0LmNvdW50ID0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxIG9yIFJlc3VsdC5jb3VudCA9IDBcbiAgICAgIGZpcnN0X2NvZGU6IFJlc3VsdC5jb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtIChzdGFydF9pbmRleClcbiAgICAgIHJlY3Vyc2U6IFJlc3VsdC5jb3VudCA+IDAgaW1wbGllc1xuICAgICAgICBSZXN1bHQuc3Vic3RyaW5nICgyLCBSZXN1bHQuY291bnQpIH4gc3Vic3RyaW5nIChzdGFydF9pbmRleCArIDEsIGVuZF9pbmRleClcbiAgICBlbmRcblxuICBoZWFkIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcmVmaXgsIHJldGFpbmluZyBmaXJzdCBgbicgY2hhcmFjdGVycyAob3IgYXMgbWFueSBhcyBhdmFpbGFibGUpLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdWJzdHJpbmcgKDEsIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudClcbiAgICAgIG5ld19jb3VudDogUmVzdWx0LmNvdW50ID0gbi5taW4gKGNvdW50KVxuICAgIGVuZFxuXG4gIHRhaWwgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1ZmZpeCwgcmV0YWluaW5nIGxhc3QgYG4nIGNoYXJhY3RlcnMgKG9yIGFzIG1hbnkgYXMgYXZhaWxhYmxlKS5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gc3Vic3RyaW5nIChjb3VudCAtIG4gKyAxLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgKGNvdW50KVxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAoY291bnQpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEFzc2VydGlvbiBoZWxwZXJcblxuICBlbGtzX2NoZWNraW5nOiBCT09MRUFOID0gRmFsc2VcbiAgICAgIC0tIEFyZSBFTEtTIGNoZWNraW5ncyB2ZXJpZmllZD8gTXVzdCBiZSBUcnVlIHdoZW4gY2hhbmdpbmcgaW1wbGVtZW50YXRpb24gb2YgU1RSSU5HX0dFTkVSQUwgb3IgZGVzY2VuZGFudC5cblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19zdHJpbmdfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfc3RyaW5nX2VtcHR5OiBSZXN1bHQuaXNfZW1wdHlcbiAgICAgIG5ld19zdHJpbmdfYXJlYV9iaWdfZW5vdWdoOiBSZXN1bHQuY2FwYWNpdHkgPj0gblxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAodHlwZTogSU5URUdFUikgOiBCT09MRUFOXG4gICAgICAtLSBJcyBgQ3VycmVudCcgYSB2YWxpZCBudW1iZXIgYWNjb3JkaW5nIHRvIGdpdmVuIGB0eXBlJz9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3RvaV9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3RvaV9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnJlc2V0ICh0eXBlKVxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwgdHlwZSlcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9pbnRlZ2VyXG4gICAgZW5kXG5cbiAgc3RyaW5nX3NlYXJjaGVyOiBTVFJJTkdfU0VBUkNIRVJcbiAgICAgIC0tIEZhY2lsaXRpZXMgdG8gc2VhcmNoIHN0cmluZyBpbiBhbm90aGVyIHN0cmluZy5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX3NlYXJjaGVyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGNfc3RyaW5nX3Byb3ZpZGVyOiBDX1NUUklOR1xuICAgICAgLS0gVG8gY3JlYXRlIEVpZmZlbCBzdHJpbmdzIGZyb20gQyBzdHJpbmcuXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5ICgwKVxuICAgIGVuc3VyZVxuICAgICAgY19zdHJpbmdfcHJvdmlkZXJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY3RvaV9jb252ZXJ0b3I6IFNUUklOR19UT19JTlRFR0VSX0NPTlZFUlRPUlxuICAgICAgLS0gQ29udmVydG9yIHVzZWQgdG8gY29udmVydCBzdHJpbmcgdG8gaW50ZWdlciBvciBuYXR1cmFsXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlXG4gICAgICBSZXN1bHQuc2V0X2xlYWRpbmdfc2VwYXJhdG9ycyAoXCIgXCIpXG4gICAgICBSZXN1bHQuc2V0X3RyYWlsaW5nX3NlcGFyYXRvcnMgKFwiIFwiKVxuICAgICAgUmVzdWx0LnNldF9sZWFkaW5nX3NlcGFyYXRvcnNfYWNjZXB0YWJsZSAoVHJ1ZSlcbiAgICAgIFJlc3VsdC5zZXRfdHJhaWxpbmdfc2VwYXJhdG9yc19hY2NlcHRhYmxlIChUcnVlKVxuICAgIGVuc3VyZVxuICAgICAgY3RvaV9jb252ZXJ0b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY3Rvcl9jb252ZXJ0b3I6IFNUUklOR19UT19SRUFMX0NPTlZFUlRPUlxuICAgICAgLS0gQ29udmVydG9yIHVzZWQgdG8gY29udmVydCBzdHJpbmcgdG8gcmVhbCBvciBkb3VibGVcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfdHJhaWxpbmdfc2VwYXJhdG9ycyAoXCIgXCIpXG4gICAgICBSZXN1bHQuc2V0X2xlYWRpbmdfc2VwYXJhdG9yc19hY2NlcHRhYmxlIChUcnVlKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgZW5zdXJlXG4gICAgICBjdG9yX2NvbnZlcnRvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBkb3RuZXRfY29udmVydG9yOiBTWVNURU1fU1RSSU5HX0ZBQ1RPUllcbiAgICAgIC0tIENvbnZlcnRvciB1c2VkIHRvIGNvbnZlcnQgZnJvbSBhbmQgdG8gU1lTVEVNX1NUUklORy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5zdXJlXG4gICAgICBkb3RuZXRfY29udmVydG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzOiBDSEFSQUNURVJfUFJPUEVSVFlcbiAgICAgIC0tIEFjY2VzcyB0byBVbmljb2RlIGNoYXJhY3RlciBwcm9wZXJ0aWVzXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlXG4gICAgZW5kXG5cbmZlYXR1cmUge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGludGVybmFsX2hhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gQ2FjaGUgZm9yIGBoYXNoX2NvZGUnLlxuXG4gIGludGVybmFsX2Nhc2VfaW5zZW5zaXRpdmVfaGFzaF9jb2RlOiBJTlRFR0VSO1xuICAgICAgLS0gQ2FzaCBmb3IgYGNhc2VfaW5zZW5zaXRpdmVfaGFzaF9jb2RlJy5cblxuXG5mZWF0dXJlIC0tIEFjY2VzczogQ3Vyc29yXG5cbiAgbmV3X2NoYXJhY3Rlcl8zMl9jdXJzb3I6IFNUUklOR19JVEVSQVRJT05fQ1VSU09SXG4gICAgICAtLSBGcmVzaCBjdXJzb3IgZm9yIHRoaXMgc3RyaW5nIHRoYXQgaXRlcmF0ZXMgb3ZlciBjb2RlIHBvaW50cyAoc2VlIGBjb2RlJylcbiAgICAgIC0tIGV4cG9zZWQgYXMge0NIQVJBQ1RFUl8zMn0uXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoQ3VycmVudClcbiAgICAgIFJlc3VsdC5zdGFydFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiRmluaXRlIHN0cnVjdHVyZXMgd2hvc2UgaXRlbSBjb3VudCBpcyBzdWJqZWN0IHRvIGNoYW5nZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHN0b3JhZ2U7XG4gIHNpemU6IHJlc2l6YWJsZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIFJFU0laQUJMRSBbR10gaW5oZXJpdFxuXG4gIEJPVU5ERUQgW0ddXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBHcm93dGhfcGVyY2VudGFnZTogSU5URUdFUiA9IDUwXG4gICAgICAtLSBQZXJjZW50YWdlIGJ5IHdoaWNoIHN0cnVjdHVyZSB3aWxsIGdyb3cgYXV0b21hdGljYWxseVxuXG4gIE1pbmltYWxfaW5jcmVhc2U6IElOVEVHRVIgPSA1XG4gICAgICAtLSBNaW5pbWFsIG51bWJlciBvZiBhZGRpdGlvbmFsIGl0ZW1zXG5cbiAgYWRkaXRpb25hbF9zcGFjZTogSU5URUdFUlxuICAgICAgLS0gUHJvcG9zZWQgbnVtYmVyIG9mIGFkZGl0aW9uYWwgaXRlbXNcbiAgICAgIC0tfCBSZXN1bHQgaXMgYSByZWFzb25hYmxlIHZhbHVlLCByZXN1bHRpbmcgZnJvbSBhIHNwYWNlLXRpbWUgdHJhZGVvZmYuXG4gICAgZG9cbiAgICAgICAgLS0gVG8gcHJldmVudCBvdmVyZmxvdyB3ZSBkbyBub3QgdXNlIGBncm93dGhfcGVyY2VudGFnZScgYnV0IGl0cyBrbm93biB2YWx1ZS5cbiAgICAgIFJlc3VsdCA6PSAoY2FwYWNpdHkgLy8gMikubWF4IChNaW5pbWFsX2luY3JlYXNlKVxuICAgIGVuc3VyZVxuICAgICAgQXRfbGVhc3Rfb25lOiBSZXN1bHQgPj0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZXNpemFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgY2FwYWNpdHknIGJlIGNoYW5nZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBhdXRvbWF0aWNfZ3Jvd1xuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhY2NvbW1vZGF0ZSBhdCBsZWFzdFxuICAgICAgLS0gYEdyb3d0aF9wZXJjZW50YWdlJyBtb3JlIGl0ZW1zLlxuICAgICAgLS18IFRyYWRlcyBzcGFjZSBmb3IgdGltZTpcbiAgICAgIC0tfCBhbGxvY2F0ZXMgZmFpcmx5IGxhcmdlIGNodW5rcyBvZiBtZW1vcnkgYnV0IG5vdCB2ZXJ5IG9mdGVuLlxuICAgIHJlcXVpcmVcbiAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlXG4gICAgZG9cbiAgICAgIGdyb3cgKGNhcGFjaXR5ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICBlbnN1cmVcbiAgICAgIGluY3JlYXNlZF9jYXBhY2l0eTogY2FwYWNpdHkgPj0gb2xkIGNhcGFjaXR5ICsgb2xkIGFkZGl0aW9uYWxfc3BhY2VcbiAgICBlbmRcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgY2FwYWNpdHkgaXMgYXQgbGVhc3QgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jYXBhY2l0eTogY2FwYWNpdHkgPj0gaVxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIERlY3JlYXNlIGBjYXBhY2l0eScgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICAtLSBBcHBseSB0byByZWR1Y2UgYWxsb2NhdGVkIHN0b3JhZ2UuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBtaW5pbWFsX2NhcGFjaXR5OiBjYXBhY2l0eSA9IGNvdW50XG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGluY3JlYXNlX2J5X2F0X2xlYXN0X29uZTogTWluaW1hbF9pbmNyZWFzZSA+PSAxXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDMtMDQgMTU6MDE6MjUgLTA4MDAgKE1vbiwgMDQgTWFyIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTc4ICRcIlxuXG5mcm96ZW4gY2xhc3NcbiAgU1BFQ0lBTCBbVF1cblxuaW5oZXJpdFxuICBBQlNUUkFDVF9TUEVDSUFMXG4gICAgcmVkZWZpbmVcbiAgICAgIGRlYnVnX291dHB1dFxuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbVF1cblxuY3JlYXRlXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fbmF0aXZlX2FycmF5XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9lbXB0eSAobjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBhIHNwZWNpYWwgb2JqZWN0IGZvciBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X3NldDogY2FwYWNpdHkgPSBuXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gMFxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkICh2OiBUOyBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlIGEgc3BlY2lhbCBvYmplY3QgZm9yIGBuJyBlbnRyaWVzIGluaXRpYWxpemVkIHdpdGggYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2VfZW1wdHkgKG4pXG4gICAgICBmaWxsX3dpdGggKHYsIDAsIG4gLSAxKVxuICAgIGVuc3VyZVxuICAgICAgY2FwYWNpdHlfc2V0OiBjYXBhY2l0eSA9IG5cbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBmaWxsZWQ6IGZpbGxlZF93aXRoICh2LCAwLCBuIC0gMSlcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fbmF0aXZlX2FycmF5IChhbl9hcnJheTogbGlrZSBuYXRpdmVfYXJyYXkpXG4gICAgICAtLSBDcmVhdGUgYSBzcGVjaWFsIG9iamVjdCBmcm9tIGBhbl9hcnJheScuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgICAgYW5fYXJyYXlfbm90X3ZvaWQ6IGFuX2FycmF5IC89IFZvaWRcbiAgICBkb1xuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiIChpOiBJTlRFR0VSKTogVCBhc3NpZ24gcHV0XG4gICAgICAtLSBJdGVtIGF0IGBpJy10aCBwb3NpdGlvblxuICAgICAgLS0gKGluZGljZXMgYmVnaW4gYXQgMClcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBUXG4gICAgICAtLSBJdGVtIGF0IGBpJy10aCBwb3NpdGlvblxuICAgICAgLS0gKGluZGljZXMgYmVnaW4gYXQgMClcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIChpKVxuICAgIGVuZFxuXG4gIGluZGV4X29mICh2OiBUOyBzdGFydF9wb3NpdGlvbjogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIEluZGV4IG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgaXRlbSBpZGVudGljYWwgdG8gYHYnLlxuICAgICAgLS0gLTEgaWYgbm9uZS5cbiAgICAgIC0tIChVc2Ugb2JqZWN0IGVxdWFsaXR5IGZvciBjb21wYXJpc29uLilcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9wb3NpdGlvbjogc3RhcnRfcG9zaXRpb24gPj0gMFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIFJlc3VsdCA6PSBzdGFydF9wb3NpdGlvblxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgUmVzdWx0ID49IG5iIG9yIGVsc2UgaXRlbSAoUmVzdWx0KSB+IHZcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgUmVzdWx0ID49IG5iIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGZvdW5kX29yX25vdF9mb3VuZDogUmVzdWx0ID0gLTEgb3IgZWxzZSAoUmVzdWx0ID49IDAgYW5kIHRoZW4gUmVzdWx0IDwgY291bnQpXG4gICAgZW5kXG5cbiAgaXRlbV9hZGRyZXNzIChpOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQWRkcmVzcyBvZiBlbGVtZW50IGF0IHBvc2l0aW9uIGBpJy5cbiAgICAgIC0tIFVzZSBvbmx5IHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBDIGV4dGVybmFscyB3aGVuIEN1cnJlbnQgaXMgZ3VhcmFudGVlZCB0byBub3QgbW92ZSBpbiBtZW1vcnkuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDwgY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGJhc2VfYWRkcmVzcyArIGkgKiBlbGVtZW50X3NpemVcbiAgICBlbnN1cmVcbiAgICAgIGVsZW1lbnRfYWRkcmVzc19ub3RfbnVsbDogUmVzdWx0IC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuZFxuXG4gIGJhc2VfYWRkcmVzczogUE9JTlRFUlxuICAgICAgLS0gQWRkcmVzcyBvZiBlbGVtZW50IGF0IHBvc2l0aW9uIGAwJy5cbiAgICAgIC0tIFVzZSBvbmx5IHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBDIGV4dGVybmFscyB3aGVuIEN1cnJlbnQgaXMgZ3VhcmFudGVlZCB0byBub3QgbW92ZSBpbiBtZW1vcnkuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgYmFzZV9hZGRyZXNzX25vdF9udWxsOiBSZXN1bHQgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZW5kXG5cbiAgbmF0aXZlX2FycmF5OiBOQVRJVkVfQVJSQVkgW1RdXG4gICAgICAtLSBPbmx5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggLk5FVFxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgIGVuZFxuXG4gIHRvX2FycmF5OiBBUlJBWSBbVF1cbiAgICAgIC0tIEJ1aWxkIGFuIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIEN1cnJlbnQgZnJvbSBgMScgdG8gYGNvdW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3BlY2lhbCAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIHRvX2FycmF5X2F0dGFjaGVkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgdG9fYXJyYXlfbG93ZXJfc2V0OiBSZXN1bHQubG93ZXIgPSAxXG4gICAgICB0b19hcnJheV91cHBlcl9zZXQ6IFJlc3VsdC51cHBlciA9IGNvdW50XG4gICAgZW5kXG5cbiAgaW5kZXhfc2V0OiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGxvd2VyLCB1cHBlcilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGxvd2VyOiBJTlRFR0VSID0gMFxuICAgICAgLS0gTWluaW11bSBpbmRleCBvZiBDdXJyZW50XG5cbiAgdXBwZXI6IElOVEVHRVJcbiAgICAgIC0tIE1heGltdW0gaW5kZXggb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY291bnQgLSAxXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBsb3dlciA8PSBSZXN1bHQgKyAxXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIENvdW50IG9mIHNwZWNpYWwgYXJlYVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gQ2FwYWNpdHkgb2Ygc3BlY2lhbCBhcmVhXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBmaWxsZWRfd2l0aCAodjogVDsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgYmV0d2VlbiBpbmRleCBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgICAgLS0gc2V0IHRvIGB2Jz9cbiAgICAgIC0tIChVc2UgcmVmZXJlbmNlIGVxdWFsaXR5IGZvciBjb21wYXJpc29uLilcbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gZW5kX2luZGV4IG9yIGVsc2Ugbm90IFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAoaSkgPSB2XG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNhbWVfaXRlbXMgKG90aGVyOiBsaWtlIEN1cnJlbnQ7IHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgdGhlIGBuJyBlbGVtZW50cyBvZiBgb3RoZXInIGZyb20gYHNvdXJjZV9pbmRleCcgcG9zaXRpb24gdGhlIHNhbWUgYXNcbiAgICAgIC0tIHRoZSBgbicgZWxlbWVudHMgb2YgYEN1cnJlbnQnIGZyb20gYGRlc3RpbmF0aW9uX2luZGV4Jz9cbiAgICAgIC0tIChVc2UgcmVmZXJlbmNlIGVxdWFsaXR5IGZvciBjb21wYXJpc29uLilcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBvdGhlci5jb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBqIDo9IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgICAgbmIgOj0gc291cmNlX2luZGV4ICsgblxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgaWYgb3RoZXIuaXRlbSAoaSkgLz0gaXRlbSAoaikgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9vbl9lbXB0eV9hcmVhOiAobiA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgQ3VycmVudD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9ICgwIDw9IGkpIGFuZCAoaSA8IGNvdW50KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBUOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggaXRlbSBieSBgdicuXG4gICAgICAtLSAoSW5kaWNlcyBiZWdpbiBhdCAwLilcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDwgY291bnRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuICBmb3JjZSAodjogVDsgaTogSU5URUdFUilcbiAgICAgIC0tIElmIGBpJyBpcyBlcXVhbCB0byBgY291bnQnIGluY3JlYXNlIGBjb3VudCcgYnkgb25lIGFuZCBpbnNlcnQgYHYnIGF0IGluZGV4IGBjb3VudCcsXG4gICAgICAtLSBvdGhlcndpc2UgcmVwbGFjZSBgaSctdGggaXRlbSBieSBgdicuXG4gICAgICAtLSAoSW5kaWNlcyBiZWdpbiBhdCAwLilcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50XG4gICAgICBub3RfZnVsbDogaSA9IGNvdW50IGltcGxpZXMgY291bnQgPCBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBpZiBpIDwgY291bnQgdGhlblxuICAgICAgICBwdXQgKHYsIGkpXG4gICAgICBlbHNlXG4gICAgICAgIGV4dGVuZCAodilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAoaSArIDEpLm1heCAob2xkIGNvdW50KVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IHZcbiAgICBlbmRcblxuICBleHRlbmQgKHY6IFQpXG4gICAgICAtLSBBZGQgYHYnIGF0IGluZGV4IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgY291bnRfc21hbGxfZW5vdWdoOiBjb3VudCA8IGNhcGFjaXR5XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgY291bnRfaW5jcmVhc2VkOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBpbnNlcnRlZDogaXRlbSAoY291bnQgLSAxKSA9IHZcbiAgICBlbmRcblxuICBleHRlbmRfZmlsbGVkICh2OiBUKVxuICAgICAgLS0gU2V0IGl0ZW1zIGJldHdlZW4gYGNvdW50JyBhbmQgYGNhcGFjaXR5IC0gMScgd2l0aCBgdicuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAodiwgY291bnQsIGNhcGFjaXR5IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBjb3VudF9pbmNyZWFzZWQ6IGNvdW50ID0gY2FwYWNpdHlcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYsIG9sZCBjb3VudCwgY2FwYWNpdHkgLSAxKVxuICAgIGVuZFxuXG4gIGZpbGxfd2l0aCAodjogVDsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFNldCBpdGVtcyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnIHdpdGggYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfaW5fYm91bmQ6IHN0YXJ0X2luZGV4IDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBjYXBhY2l0eVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9jb3VudDogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbF9jb3VudCA6PSBjb3VudC5taW4gKGVuZF9pbmRleCArIDEpXG4gICAgICAgIG5iIDo9IGxfY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBwdXQgKHYsIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGxfY291bnRcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4ICsgMVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGV4dGVuZCAodilcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfZGVmaW5pdGlvbjogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGVuZF9pbmRleCArIDEpXG4gICAgICBmaWxsZWQ6IGZpbGxlZF93aXRoICh2LCBzdGFydF9pbmRleCwgZW5kX2luZGV4KVxuICAgIGVuZFxuXG4gIGZpbGxfd2l0aF9kZWZhdWx0IChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQ2xlYXIgaXRlbXMgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICBpc19zZWxmX2luaXRpYWxpemluZzogKHtUfSkuaGFzX2RlZmF1bHRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgY291bnRcbiAgICBkb1xuICAgICAgZmlsbF93aXRoICgoe1R9KS5kZWZhdWx0LCBzdGFydF9pbmRleCwgZW5kX2luZGV4KVxuICAgIGVuc3VyZVxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAoKHtUfSkuZGVmYXVsdCwgc3RhcnRfaW5kZXgsIGVuZF9pbmRleClcbiAgICBlbmRcblxuICBpbnNlcnRfZGF0YSAob3RoZXI6IFNQRUNJQUwgW1RdOyBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBuJyBlbGVtZW50cyBvZiBgb3RoZXInIGZyb20gYHNvdXJjZV9pbmRleCcgcG9zaXRpb24gdG8gQ3VycmVudCBhdFxuICAgICAgLS0gYGRlc3RpbmF0aW9uX2luZGV4JyBhbmQgc2hpZnQgZWxlbWVudHMgYmV0d2VlbiBgZGVzdGluYXRpb25faW5kZXgnIGFuZCBgY291bnQnXG4gICAgICAtLSB0byB0aGUgcmlnaHQuIE90aGVyIGVsZW1lbnRzIG9mIEN1cnJlbnQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IG90aGVyLmNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGNvdW50ICsgbiA8PSBjYXBhY2l0eVxuICAgICAgc2FtZV90eXBlOiBvdGhlci5jb25mb3Jtc190byAoQ3VycmVudClcbiAgICBsb2NhbFxuICAgICAgbF9yZW1haW5pbmdfaXRlbXMsIGxfb2Zmc2V0LCBsX25iX2l0ZW1zX2xlZnQ6IElOVEVHRVJcbiAgICAgIGxfc291cmNlX2luZGV4LCBsX2VuZF9pbmRleCwgbF9kZXN0aW5hdGlvbl9pbmRleDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3JlbWFpbmluZ19pdGVtcyA6PSBjb3VudCAtIGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICBpZiBsX3JlbWFpbmluZ19pdGVtcyA9IDAgdGhlblxuICAgICAgICAgIC0tIEl0IGlzIGJlaW5nIGFkZGVkIGF0IHRoZSBlbmQgb2YgQ3VycmVudCwgdGhlcmVmb3JlIHdlIGNhbiBzaW1wbHkgZXh0ZW5kLlxuICAgICAgICBjb3B5X2RhdGEgKG90aGVyLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgZWxzZWlmIG4gPD0gbF9yZW1haW5pbmdfaXRlbXMgdGhlblxuICAgICAgICAgIC0tIFNpbXBsZSBjYXNlIHdoZXJlIHdlIGNhbiBwZXJmb3JtIGEgbW92ZSBvZiB0aGUgZXhpc3RpbmcgaXRlbXMgdG8gdGhlIGVuZFxuICAgICAgICAgIC0tIGFuZCB0aGVuIGNvcHkgdGhlIGVsZW1lbnRzIG9mIGBvdGhlcicuXG4gICAgICAgIG1vdmVfZGF0YSAoZGVzdGluYXRpb25faW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4ICsgbiwgbF9yZW1haW5pbmdfaXRlbXMpXG4gICAgICAgIGNvcHlfZGF0YSAob3RoZXIsIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gQmVjYXVzZSB3ZSBjYW5ub3QgaGF2ZSB1bmluaXRpYWxpemVkIGl0ZW1zLCB3ZSBjYW5ub3QgbW92ZSBhbGwgdGhlIHJlbWFpbmluZyBpdGVtcyBiZXlvbmQgY291bnRcbiAgICAgICAgICAtLSBpbnN0ZWFkIHdlIGNvcHkgYnkgY2h1bmtzIG9mIGBsX3JlbWFpbmluZ19pdGVtcycuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3NvdXJjZV9pbmRleCA6PSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBsX2Rlc3RpbmF0aW9uX2luZGV4IDo9IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgICAgbF9lbmRfaW5kZXggOj0gc291cmNlX2luZGV4ICsgblxuICAgICAgICAgIGxfbmJfaXRlbXNfbGVmdCA6PSBuXG4gICAgICAgICAgbF9vZmZzZXQgOj0gbF9yZW1haW5pbmdfaXRlbXNcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3NvdXJjZV9pbmRleCA+PSBsX2VuZF9pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbW92ZV9kYXRhIChsX2Rlc3RpbmF0aW9uX2luZGV4LCBsX2Rlc3RpbmF0aW9uX2luZGV4ICsgbF9vZmZzZXQsIGxfcmVtYWluaW5nX2l0ZW1zKVxuICAgICAgICAgIGNvcHlfZGF0YSAob3RoZXIsIGxfc291cmNlX2luZGV4LCBsX2Rlc3RpbmF0aW9uX2luZGV4LCBsX29mZnNldClcbiAgICAgICAgICBsX2Rlc3RpbmF0aW9uX2luZGV4IDo9IGxfZGVzdGluYXRpb25faW5kZXggKyBsX29mZnNldFxuICAgICAgICAgIGxfc291cmNlX2luZGV4IDo9IGxfc291cmNlX2luZGV4ICsgbF9vZmZzZXRcbiAgICAgICAgICAgIC0tIENvbXB1dGUgaG93IG1hbnkgbW9yZSBpdGVtcyB3ZSBoYXZlIHRvIGNvcHkuXG4gICAgICAgICAgbF9uYl9pdGVtc19sZWZ0IDo9IGxfbmJfaXRlbXNfbGVmdCAtIGxfcmVtYWluaW5nX2l0ZW1zXG4gICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQubWluIChsX25iX2l0ZW1zX2xlZnQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjb3BpZWQ6IHNhbWVfaXRlbXMgKG90aGVyLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBvbGQgY291bnQgKyBuXG4gICAgZW5kXG5cbiAgY29weV9kYXRhIChvdGhlcjogU1BFQ0lBTCBbVF07IHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGBuJyBlbGVtZW50cyBvZiBgb3RoZXInIGZyb20gYHNvdXJjZV9pbmRleCcgcG9zaXRpb24gdG8gQ3VycmVudCBhdFxuICAgICAgLS0gYGRlc3RpbmF0aW9uX2luZGV4Jy4gT3RoZXIgZWxlbWVudHMgb2YgQ3VycmVudCByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBzb3VyY2VfaW5kZXhfbm9uX25lZ2F0aXZlOiBzb3VyY2VfaW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfbm9uX25lZ2F0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9pbl9ib3VuZDogZGVzdGluYXRpb25faW5kZXggPD0gY291bnRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gb3RoZXIuY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNhcGFjaXR5XG4gICAgICBzYW1lX3R5cGU6IG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBtb3ZlX2RhdGEgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHNvdXJjZV9pbmRleFxuICAgICAgICAgIGogOj0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggKyBuXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBmb3JjZSAob3RoZXIuaXRlbSAoaSksIGopXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvcGllZDogc2FtZV9pdGVtcyAob3RoZXIsIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZGVzdGluYXRpb25faW5kZXggKyBuKVxuICAgIGVuZFxuXG4gIG1vdmVfZGF0YSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIE1vdmUgYG4nIGVsZW1lbnRzIG9mIEN1cnJlbnQgZnJvbSBgc291cmNlX3N0YXJ0JyBwb3NpdGlvbiB0byBgZGVzdGluYXRpb25faW5kZXgnLlxuICAgICAgLS0gT3RoZXIgZWxlbWVudHMgcmVtYWluIHVuY2hhbmdlZC5cbiAgICByZXF1aXJlXG4gICAgICBzb3VyY2VfaW5kZXhfbm9uX25lZ2F0aXZlOiBzb3VyY2VfaW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfbm9uX25lZ2F0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9pbl9ib3VuZDogZGVzdGluYXRpb25faW5kZXggPD0gY291bnRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNhcGFjaXR5XG4gICAgZG9cbiAgICAgIGlmIHNvdXJjZV9pbmRleCA9IGRlc3RpbmF0aW9uX2luZGV4IHRoZW5cbiAgICAgIGVsc2VpZiBzb3VyY2VfaW5kZXggPiBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICAgIGlmIGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8IHNvdXJjZV9pbmRleCB0aGVuXG4gICAgICAgICAgbm9uX292ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgaWYgc291cmNlX2luZGV4ICsgbiA8IGRlc3RpbmF0aW9uX2luZGV4IHRoZW5cbiAgICAgICAgICBub25fb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG92ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBtb3ZlZDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZGVzdGluYXRpb25faW5kZXggKyBuKVxuICAgIGVuZFxuXG4gIG92ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGBuJyBlbGVtZW50cyBvZiBDdXJyZW50IGZyb20gYHNvdXJjZV9zdGFydCcgcG9zaXRpb24gdG8gYGRlc3RpbmF0aW9uX2luZGV4Jy5cbiAgICAgIC0tIE90aGVyIGVsZW1lbnRzIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBkaWZmZXJlbnRfc291cmNlX2FuZF90YXJnZXQ6IHNvdXJjZV9pbmRleCAvPSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBjb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPD0gY2FwYWNpdHlcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIHNvdXJjZV9pbmRleCA8IGRlc3RpbmF0aW9uX2luZGV4IHRoZW5cbiAgICAgICAgICAtLSBXZSBzaGlmdCBmcm9tIGxlZnQgdG8gcmlnaHQgc3RhcnRpbmcgZnJvbSB0aGUgZW5kXG4gICAgICAgICAgLS0gZHVlIHRvIHBvc3NpYmxlIG92ZXJsYXBwaW5nLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzb3VyY2VfaW5kZXggKyBuIC0gMVxuICAgICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCAtIDFcbiAgICAgICAgICBsX29mZnNldCA6PSBkZXN0aW5hdGlvbl9pbmRleCAtIHNvdXJjZV9pbmRleFxuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbl9pbmRleCArIG4gPj0gY291bnQpIHRoZW5cbiAgICAgICAgICAgICAgLS0gSW5pdGlhbGl6ZSBlbGVtZW50cyBhYm92ZSBgY291bnQnIHRvIGEgZHVtbXkgaXRlbS5cbiAgICAgICAgICAgIGZpbGxfd2l0aCAoaXRlbSAoc291cmNlX2luZGV4KSwgY291bnQsIGRlc3RpbmF0aW9uX2luZGV4ICsgbiAtIDEpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgY2hlY2tcbiAgICAgICAgICAgIGxfb2Zmc2V0X3Bvc2l0aXZlOiBsX29mZnNldCA+IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIHB1dCAoaXRlbSAoaSksIGkgKyBsX29mZnNldClcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIFdlIHNoaWZ0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc291cmNlX2luZGV4XG4gICAgICAgICAgbmIgOj0gc291cmNlX2luZGV4ICsgblxuICAgICAgICAgIGxfb2Zmc2V0IDo9IHNvdXJjZV9pbmRleCAtIGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgICAgY2hlY2tcbiAgICAgICAgICAgIGxfb2Zmc2V0X3Bvc2l0aXZlOiBsX29mZnNldCA+IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGZvcmNlIChpdGVtIChpKSwgaSAtIGxfb2Zmc2V0KVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG1vdmVkOiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gKG9sZCBjb3VudCkubWF4IChkZXN0aW5hdGlvbl9pbmRleCArIG4pXG4gICAgZW5kXG5cbiAgbm9uX292ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGBuJyBlbGVtZW50cyBvZiBDdXJyZW50IGZyb20gYHNvdXJjZV9zdGFydCcgcG9zaXRpb24gdG8gYGRlc3RpbmF0aW9uX2luZGV4Jy5cbiAgICAgIC0tIE90aGVyIGVsZW1lbnRzIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBkaWZmZXJlbnRfc291cmNlX2FuZF90YXJnZXQ6IHNvdXJjZV9pbmRleCAvPSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgbm9uX292ZXJsYXBwaW5nOlxuICAgICAgICAoc291cmNlX2luZGV4IDwgZGVzdGluYXRpb25faW5kZXggaW1wbGllcyBzb3VyY2VfaW5kZXggKyBuIDwgZGVzdGluYXRpb25faW5kZXgpIG9yXG4gICAgICAgIChzb3VyY2VfaW5kZXggPiBkZXN0aW5hdGlvbl9pbmRleCBpbXBsaWVzIGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8IHNvdXJjZV9pbmRleClcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNhcGFjaXR5XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX29mZnNldDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc291cmNlX2luZGV4XG4gICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgbF9vZmZzZXQgOj0gZGVzdGluYXRpb25faW5kZXggLSBzb3VyY2VfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBmb3JjZSAoaXRlbSAoaSksIGkgKyBsX29mZnNldClcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBtb3ZlZDogc2FtZV9pdGVtcyAoQ3VycmVudCwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gKG9sZCBjb3VudCkubWF4IChkZXN0aW5hdGlvbl9pbmRleCArIG4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBLZWVwIHRoZSBmaXJzdCBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgICAgbGVzc190aGFuX2NvdW50OiBuIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHNldF9jb3VudCAobilcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gblxuICAgICAga2VwdDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIDAsIDAsIG4pXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gS2VlcCB0aGUgbGFzdCBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgICAgbGVzc190aGFuX2NvdW50OiBuIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIG92ZXJsYXBwaW5nX21vdmUgKGNvdW50IC0gbiwgMCwgbilcbiAgICAgIHNldF9jb3VudCAobilcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gblxuICAgICAga2VwdDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIG4sIDAsIG4pXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgdGhlIGZpcnN0IGBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgICBsZXNzX3RoYW5fY291bnQ6IG4gPD0gY291bnRcbiAgICBkb1xuICAgICAga2VlcF90YWlsIChjb3VudCAtIG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG9sZCBjb3VudCAtIG5cbiAgICAgIGtlcHQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCBuLCAwLCBjb3VudClcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIEtlZXAgdGhlIGZpcnN0ICBgY291bnQgLSBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgICBsZXNzX3RoYW5fY291bnQ6IG4gPD0gY291bnRcbiAgICBkb1xuICAgICAga2VlcF9oZWFkIChjb3VudCAtIG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG9sZCBjb3VudCAtIG5cbiAgICAgIGtlcHQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCAwLCAwLCBjb3VudClcbiAgICBlbmRcblxuICByZXNpemVkX2FyZWEgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENyZWF0ZSBhIGNvcHkgb2YgQ3VycmVudCB3aXRoIGEgY291bnQgb2YgYG4nXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKG4pXG4gICAgICBSZXN1bHQuY29weV9kYXRhIChDdXJyZW50LCAwLCAwLCBuLm1pbiAoY291bnQpKVxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgUmVzdWx0X2RpZmZlcmVudF9mcm9tX2N1cnJlbnQ6IFJlc3VsdCAvPSBDdXJyZW50XG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBuZXdfY2FwYWNpdHk6IFJlc3VsdC5jYXBhY2l0eSA9IG5cbiAgICAgIHByZXNlcnZlZDogUmVzdWx0LnNhbWVfaXRlbXMgKEN1cnJlbnQsIDAsIDAsIG4ubWluIChvbGQgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogVDsgbjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ3JlYXRlIGEgY29weSBvZiBDdXJyZW50IHdpdGggYSBjb3VudCBvZiBgbicgd2hlcmUgbm90IHlldCBpbml0aWFsaXplZFxuICAgICAgLS0gZW50cmllcyBhcmUgc2V0IHRvIGBhX2RlZmF1bHRfdmFsdWUnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5IChuKVxuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0LmNvcHlfZGF0YSAoQ3VycmVudCwgMCwgMCwgY291bnQpXG4gICAgICAgIFJlc3VsdC5maWxsX3dpdGggKGFfZGVmYXVsdF92YWx1ZSwgY291bnQsIG4gLSAxKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQuY29weV9kYXRhIChDdXJyZW50LCAwLCAwLCBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfZGlmZmVyZW50X2Zyb21fY3VycmVudDogUmVzdWx0IC89IEN1cnJlbnRcbiAgICAgIG5ld19jb3VudDogUmVzdWx0LmNvdW50ID0gblxuICAgICAgbmV3X2NhcGFjaXR5OiBSZXN1bHQuY2FwYWNpdHkgPSBuXG4gICAgICBwcmVzZXJ2ZWQ6IFJlc3VsdC5zYW1lX2l0ZW1zIChDdXJyZW50LCAwLCAwLCBuLm1pbiAob2xkIGNvdW50KSlcbiAgICBlbmRcblxuICBhbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVHJ5IHRvIHJlc2l6ZSBgQ3VycmVudCcgd2l0aCBhIGNvdW50IG9mIGBuJywgaWYgbm90XG4gICAgICAtLSBwb3NzaWJsZSBhIG5ldyBjb3B5XG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIG5ld19jb3VudDogUmVzdWx0LmNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIG5ld19jYXBhY2l0eTogUmVzdWx0LmNhcGFjaXR5ID0gblxuICAgICAgcHJlc2VydmVkOiBSZXN1bHQuc2FtZV9pdGVtcyAob2xkIHR3aW4sIDAsIDAsIG4ubWluIChvbGQgY291bnQpKVxuICAgIGVuZFxuXG4gIGFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoYV9kZWZhdWx0X3ZhbHVlOiBUOyBuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBUcnkgdG8gcmVzaXplIGBDdXJyZW50JyB3aXRoIGEgY291bnQgb2YgYG4nLCBpZiBub3RcbiAgICAgIC0tIHBvc3NpYmxlIGEgbmV3IGNvcHkuIE5vbiB5ZXQgaW5pdGlhbGl6ZWQgZW50cmllcyBhcmUgc2V0IHRvIGBhX2RlZmF1bHRfdmFsdWUnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgUmVzdWx0LmZpbGxfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlLCBSZXN1bHQuY291bnQsIG4gLSAxKVxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuXG4gICAgICBuZXdfY2FwYWNpdHk6IFJlc3VsdC5jYXBhY2l0eSA9IG5cbiAgICAgIHByZXNlcnZlZDogUmVzdWx0LnNhbWVfaXRlbXMgKG9sZCB0d2luLCAwLCAwLCBuLm1pbiAob2xkIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVwbGFjZV9hbGwgKHY6IFQpXG4gICAgICAtLSBSZXBsYWNlIGFsbCBpdGVtcyB3aXRoIGB2Jy5cbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpIDwgMFxuICAgICAgbG9vcFxuICAgICAgICBwdXQgKHYsIGkpXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY2xlYXJlZDogZmlsbGVkX3dpdGggKHYsIDAsIHVwcGVyKVxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZXNldCBjb3VudCB0byB6ZXJvLlxuICAgIGRvXG4gICAgICBzZXRfY291bnQgKDApXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfcmVzZXQ6IGNvdW50ID0gMFxuICAgIGVuZFxuXG4gIGNsZWFyX2FsbFxuICAgICAgLS0gUmVzZXQgYWxsIGl0ZW1zIHRvIGRlZmF1bHQgdmFsdWVzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkJlY2F1c2Ugb2YgdGhlIG5ldyBwcmVjb25kaXRpb24sIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7VH0pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aF9kZWZhdWx0ICgwLCB1cHBlcilcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBjb3VudF9yZXNldDogY291bnQgPSBvbGQgY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBJdGVyYXRpb25cblxuICBkb19hbGxfaW5fYm91bmRzIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbVF1dOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhY3Rpb24uY2FsbCAoW2l0ZW0gKGkpXSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZG9faWZfaW5fYm91bmRzIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbVF1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbVF0sIEJPT0xFQU5dOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBvciBgdGVzdCcgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaWYgdGVzdC5pdGVtIChbaXRlbSAoaSldKSB0aGVuXG4gICAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtIChpKV0pXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHNfaW5fYm91bmRzICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbVF0sIEJPT0xFQU5dOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGF0IGxlYXN0IG9uZSBpdGVtP1xuICAgIHJlcXVpcmVcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmIgb3IgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSB0ZXN0Lml0ZW0gKFtpdGVtIChpKV0pXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZvcl9hbGxfaW5fYm91bmRzICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbVF0sIEJPT0xFQU5dOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGFsbCBpdGVtcz9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iIG9yIG5vdCBSZXN1bHRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IHRlc3QuaXRlbSAoW2l0ZW0gKGkpXSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZG9fYWxsX3dpdGhfaW5kZXhfaW5fYm91bmRzIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbVCwgSU5URUdFUl1dOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gYGFjdGlvbicgcmVjZWl2ZXMgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbSAoaSksIGpdKVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2lmX3dpdGhfaW5kZXhfaW5fYm91bmRzIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbVCwgSU5URUdFUl1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbVCwgSU5URUdFUl0sIEJPT0xFQU5dOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIGFuZCBgdGVzdCcgcmVjZWl2ZSB0aGUgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2l0ZW0gKGkpLCBqXSkgdGhlblxuICAgICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbSAoaSksIGpdKVxuICAgICAgICBlbmRcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBkZWJ1Z19vdXRwdXQ6IFNUUklOR1xuICAgICAgLS0gU3RyaW5nIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBkZWJ1Z2dlciB0byByZXByZXNlbnQgYEN1cnJlbnQnLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gUHJlY3Vyc29yXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZyAoXCIsIGNhcGFjaXR5PVwiKVxuICAgICAgUmVzdWx0LmFwcGVuZF9pbnRlZ2VyIChjYXBhY2l0eSlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBlbGVtZW50X3NpemU6IElOVEVHRVJcbiAgICAgIC0tIFNpemUgb2YgZWxlbWVudHNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBlbGVtZW50X3NpemVfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG4gIHNldF9jb3VudCAobjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHdpdGggYG4nLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIHZhbGlkX25ld19jb3VudDogbiA8PSBjb3VudFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBjYXBhY2l0eV9wcmVzZXJ2ZWQ6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbmludmFyaWFudFxuICBjb3VudF9sZXNzX3RoYW5fY2FwYWNpdHk6IGNvdW50IDw9IGNhcGFjaXR5XG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEzLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwiY2xhc3NcbiAgU1RSSU5HXG5cbmluaGVyaXRcbiAgUkVBREFCTEVfU1RSSU5HXzMyXG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBleHBvcnRcbiAgICAgIHtBTll9IG1ha2UsIG1ha2VfZW1wdHksIG1ha2VfZmlsbGVkLCBtYWtlX2Zyb21fYywgbWFrZV9mcm9tX3N0cmluZywgZmlsbF9jaGFyYWN0ZXJcbiAgICBlbmRcblxuICBTVFJJTkdfR0VORVJBTFxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBoYXMsIGluZGV4X29mLCBsYXN0X2luZGV4X29mLCBvY2N1cnJlbmNlc1xuICAgIHJlZGVmaW5lXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsXG4gICAgcmVuYW1lXG4gICAgICBhcHBlbmQgYXMgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgYXBwZW5kX3N1YnN0cmluZyBhcyBhcHBlbmRfc3Vic3RyaW5nX2dlbmVyYWwsXG4gICAgICBwcmVwZW5kIGFzIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBwcmVwZW5kX3N1YnN0cmluZyBhcyBwcmVwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9zdHJpbmcgYXMgc2FtZV9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfY2hhcmFjdGVycyBhcyBzYW1lX2NoYXJhY3RlcnNfZ2VuZXJhbCxcbiAgICAgIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyBhcyBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnNfZ2VuZXJhbCxcbiAgICAgIHN0YXJ0c193aXRoIGFzIHN0YXJ0c193aXRoX2dlbmVyYWwsXG4gICAgICBlbmRzX3dpdGggYXMgZW5kc193aXRoX2dlbmVyYWwsXG4gICAgICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIGFzIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbQ0hBUkFDVEVSXzMyLCBJTlRFR0VSXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIHBydW5lX2FsbCxcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBSRVNJWkFCTEUgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgVE9fU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBpdGVtLCBhdCwgcHV0LCB2YWxpZF9pbmRleFxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9zdHJpbmcsXG4gIG1ha2VfZnJvbV9zdHJpbmdfZ2VuZXJhbCxcbiAgbWFrZV9mcm9tX2MsXG4gIG1ha2VfZnJvbV9jX3BvaW50ZXIsXG4gIG1ha2VfZnJvbV9jaWxcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgbWFrZV9mcm9tX2NpbCAoe1NZU1RFTV9TVFJJTkd9KSxcbiAgYXNfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOCwgU1RSSU5HXzh9XG5cbmZlYXR1cmUgLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBzMzIgdGhlblxuICAgICAgICBtYWtlX2Zyb21fc3RyaW5nIChzMzIpXG4gICAgICBlbHNlXG4gICAgICAgIG1ha2UgKHMuY291bnQpXG4gICAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jaWwgKGFfc3lzdGVtX3N0cmluZzogZGV0YWNoYWJsZSBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IHdpdGggYGFfc3lzdGVtX3N0cmluZycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGFfc3lzdGVtX3N0cmluZy5sZW5ndGggKyBkb3RuZXRfY29udmVydG9yLmVzY2FwZV9jb3VudCAoYV9zeXN0ZW1fc3RyaW5nKVxuICAgICAgZW5kXG4gICAgICBtYWtlIChsX2NvdW50KVxuICAgICAgaWYgbF9jb3VudCA+IDAgYW5kIHRoZW4gYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBzZXRfY291bnQgKGxfY291bnQpXG4gICAgICAgIGRvdG5ldF9jb252ZXJ0b3IucmVhZF9zeXN0ZW1fc3RyaW5nX2ludG8gKGFfc3lzdGVtX3N0cmluZywgQ3VycmVudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBjb250ZW50cyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdHJpbmdfaW50byAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIG5vX3plcm9fYnl0ZTogbm90IGhhcyAoJyUvMC8nKVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgICAgLS0gY29ycmVjdF9jb3VudDogdGhlIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgY291bnRcbiAgICAgIC0tICAgICAgIGlzIE5VTExcbiAgICBlbmRcblxuICBmcm9tX2Nfc3Vic3RyaW5nIChjX3N0cmluZzogUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gc3Vic3RyaW5nIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGNfc3RyaW5nICsgKHN0YXJ0X3BvcyAtIDEpLCBsX2NvdW50KVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG8gKEN1cnJlbnQsIDEsIGxfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgIGVuZFxuXG4gIGFkYXB0IChzOiBTVFJJTkdfMzIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9iamVjdCBvZiBhIHR5cGUgY29uZm9ybWluZyB0byB0aGUgdHlwZSBvZiBgcycsXG4gICAgICAtLSBpbml0aWFsaXplZCB3aXRoIGF0dHJpYnV0ZXMgZnJvbSBgcydcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBSZXN1bHQuc2hhcmUgKHMpXG4gICAgZW5zdXJlXG4gICAgICBhZGFwdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNoYXJlZF9pbXBsZW1lbnRhdGlvbjogUmVzdWx0LnNoYXJlZF93aXRoIChzKVxuICAgIGVuZFxuXG4gIHJlbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG1ha2UnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkb1xuICAgICAgbWFrZSAobilcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5X3N0cmluZzogY291bnQgPSAwXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMiBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKVxuICAgIGVuZFxuXG4gIGNvZGUgKGk6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLm5hdHVyYWxfMzJfY29kZS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gU3RvcmFnZSBmb3IgY2hhcmFjdGVyc1xuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gTWF5IG5ldyBpdGVtcyBiZSBhZGRlZD8gKEFuc3dlcjogeWVzLilcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvbjogQk9PTEVBTiA9IEZhbHNlXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXQgKHQ6IFJFQURBQkxFX1NUUklOR18zMjsgbjEsIG4yOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGN1cnJlbnQgc3RyaW5nIHRvIHN1YnN0cmluZyBvZiBgdCcgZnJvbSBpbmRpY2VzIGBuMSdcbiAgICAgIC0tIHRvIGBuMicsIG9yIHRvIGVtcHR5IHN0cmluZyBpZiBubyBzdWNoIHN1YnN0cmluZy5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIHM6IFJFQURBQkxFX1NUUklOR18zMlxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyB0byBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgICAgZW5vdWdoX3NwYWNlOiAoY291bnQgLSBpbmRleF9wb3MpID49IChlbmRfcG9zIC0gc3RhcnRfcG9zKVxuICAgIGxvY2FsXG4gICAgICBsX290aGVyX2FyZWEsIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGVuZF9wb3MgPj0gc3RhcnRfcG9zIHRoZW5cbiAgICAgICAgbF9vdGhlcl9hcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaWYgbF9hcmVhIC89IGxfb3RoZXJfYXJlYSB0aGVuXG4gICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9vdGhlcl9hcmVhLCBzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGNvcGllZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGluZGV4X3BvcyAtIDEpICtcbiAgICAgICAgb2xkIG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSArXG4gICAgICAgIG9sZCBzdWJzdHJpbmcgKGluZGV4X3BvcyArIChlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCcgdG8gYGVuZF9pbmRleCcgd2l0aCBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bGxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGRpZmY6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBzX2NvdW50OiBJTlRFR0VSXG4gICAgICBvbGRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBvbGRfY291bnQgOj0gY291bnRcbiAgICAgIGRpZmYgOj0gc19jb3VudCAtIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBuZXdfc2l6ZSA6PSBkaWZmICsgb2xkX2NvdW50XG4gICAgICBpZiBkaWZmID4gMCB0aGVuXG4gICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgdGhlIHN0cmluZy5cbiAgICAgICAgZ3JvdyAobmV3X3NpemUpXG4gICAgICBlbmRcblxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgLS18IFdlIG1vdmUgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGZvcndhcmQgKGlmIGRpZmYgaXMgPiAwKSwgYmFja3dhcmQgKGlmIGRpZmYgPCAwKSxcbiAgICAgICAgLS18IGFuZCBub3RoaW5nIG90aGVyd2lzZS5cbiAgICAgIGlmIGRpZmYgLz0gMCB0aGVuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChlbmRfaW5kZXgsIGVuZF9pbmRleCArIGRpZmYsIG9sZF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgIGVuZFxuICAgICAgICAtLXwgU2V0IG5ldyBjb3VudFxuICAgICAgc2V0X2NvdW50IChuZXdfc2l6ZSlcbiAgICAgICAgLS18IFdlIGNvcHkgdGhlIHN1YnN0cmluZy5cbiAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBzdGFydF9pbmRleCAtIDEsIHNfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnQgLSBlbmRfaW5kZXggKyBzdGFydF9pbmRleCAtIDFcbiAgICAgIHJlcGxhY2VkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIChzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgK1xuICAgICAgICAgIHMgKyBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nX2FsbCAob3JpZ2luYWwsIG5ldzogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGV4dGVyblxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9ibGFua1xuICAgICAgLS0gUmVwbGFjZSBhbGwgY3VycmVudCBjaGFyYWN0ZXJzIHdpdGggYmxhbmtzLlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgYWxsX2JsYW5rOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKCcgJykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGZpbGxfYmxhbmtcbiAgICAgIC0tIEZpbGwgd2l0aCBgY2FwYWNpdHknIGJsYW5rIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGZpbGxfY2hhcmFjdGVyICgnICcpXG4gICAgZW5zdXJlXG4gICAgICBmaWxsZWQ6IGZ1bGxcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gY2FwYWNpdHkpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICAtLSBhbGxfYmxhbms6IEZvciBldmVyeSBgaScgaW4gYGNvdW50Jy4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYEJsYW5rJ1xuICAgIGVuZFxuXG4gIGZpbGxfd2l0aCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBjaGFyYWN0ZXIgd2l0aCBgYycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbF9jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgYXJlYS5maWxsX3dpdGggKGMsIDAsIGxfY291bnQgLSAxKVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBmaWxsZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIHJlcGxhY2VfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkJ1wiXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoYylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgbG9jYWxcbiAgICAgIG5iOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGVmdF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIG5iLCBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbmJfc3BhY2UgPiBuYiBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChuYl9zcGFjZSkpXG4gICAgICBsb29wXG4gICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudCB2YWx1ZS5cbiAgICAgICAgbmIgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmJfc3BhY2UsIDAsIG5iKVxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGkgOj0gbmJcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwXG4gICAgICBsb29wXG4gICAgICAgIGMgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGMpIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGFyZSBkb25lLlxuICAgICAgICAgIGkgOj0gLTFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50LlxuICAgICAgICBjb3VudCA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2hhcmUgKG90aGVyOiBTVFJJTkdfMzIpXG4gICAgICAtLSBNYWtlIGN1cnJlbnQgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcicuXG4gICAgICAtLSBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmdcbiAgICAgIC0tIHdpbGwgYWxzbyBhZmZlY3QgYG90aGVyJywgYW5kIGNvbnZlcnNlbHkuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICBjb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZF9jb3VudDogb3RoZXIuY291bnQgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IG90aGVyLmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbiAgcHV0IChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgYGMnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAoYywgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHB1dF9jb2RlICh2OiBOQVRVUkFMXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknIGJ5IGNoYXJhY3RlciBvZiBjb2RlIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYudG9fY2hhcmFjdGVyXzMyLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgcHJlcGVuZCAobF9zMzIpXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7U1RSSU5HX0dFTkVSQUx9IChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJlY2VkZSwgcHJlcGVuZF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFkZCBgYycgYXQgZnJvbnQuXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCAxLCBjb3VudClcbiAgICAgIGxfYXJlYS5wdXQgKGMsIDApXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCAxKVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgY291bnRcbiAgICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgb2YgY3VycmVudC5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIGxfc19jb3VudCwgY291bnQpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgYmVnaW5uaW5nLlxuICAgICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgMCwgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBiJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYi5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgZCcgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGQub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGkub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgcHJlcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgYXBwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnRcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCBsX2NvdW50LCBsX3NfY291bnQpXG4gICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKEN1cnJlbnQgKyBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkpKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoY291bnQgKyBzLmNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoQ3VycmVudClcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhcHBlbmRlZDogcyAvPSBWb2lkIGltcGxpZXNcbiAgICAgICAgKGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCB0d2luICsgb2xkIHMudHdpbikpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzggKGk6IElOVEVHRVJfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzE2IChpOiBJTlRFR0VSXzE2KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl8xNlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzE2fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl82NH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfOCAoaTogTkFUVVJBTF84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMTYgKGk6IE5BVFVSQUxfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMzIgKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzMyXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfNjQgKGk6IE5BVFVSQUxfNjQpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzY0XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHIub3V0KVxuICAgIGVuZFxuXG4gIGFwcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2NoYXJhY3RlciwgZXh0ZW5kIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBBcHBlbmQgYGMnIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgY3VycmVudF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjdXJyZW50X2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBjdXJyZW50X2NvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGN1cnJlbnRfY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBhcmVhLnB1dCAoYywgY3VycmVudF9jb3VudClcbiAgICAgIGNvdW50IDo9IGN1cnJlbnRfY291bnQgKyAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpdGVtX2luc2VydGVkOiBpdGVtIChjb3VudCkgPSBjXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgc3RhYmxlX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgY291bnQgLSAxKSB+IChvbGQgdHdpbilcbiAgICBlbmRcblxuICBhcHBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBiJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYi5vdXQpXG4gICAgZW5kXG5cbiAgaW5zZXJ0IChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBBZGQgYHMnIHRvIGxlZnQgb2YgcG9zaXRpb24gYGknIGluIGN1cnJlbnQgc3RyaW5nLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBpbnNlcnRfc3RyaW5nJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudCArIDFcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYHMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHBvcyA6PSBpIC0gMVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIGxfc19jb3VudCwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBwb3MsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBjJyBhdCBpbmRleCBgaScsIHNoaWZ0aW5nIGNoYXJhY3RlcnMgYmV0d2VlbiByYW5rc1xuICAgICAgLS0gYGknIGFuZCBgY291bnQnIHJpZ2h0d2FyZHMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgbmV3X3NpemUgOj0gMSArIGNvdW50XG4gICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcblxuICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICBwb3MgOj0gaSAtIDFcbiAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAocG9zLCBwb3MgKyAxLCBjb3VudCAtIHBvcylcblxuICAgICAgICAtLSBJbnNlcnQgbmV3IGNoYXJhY3RlclxuICAgICAgbF9hcmVhLnB1dCAoYywgcG9zKVxuXG4gICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG9uZV9tb3JlX2NoYXJhY3RlcjogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSBjXG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlbW92ZSAoaTogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBgaSctdGggY2hhcmFjdGVyLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdC5cbiAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAoaSwgaSAtIDEsIGxfY291bnQgLSBpKVxuICAgICAgICAtLSBVcGRhdGUgY29udGVudC5cbiAgICAgIGNvdW50IDo9IGxfY291bnQgLSAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IDBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF90YWlsIChjb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKG4ubWluIChjb3VudCkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3N1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCdcbiAgICAgIC0tIHRvIGBlbmRfaW5kZXgnIGluY2x1c2l2ZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbmJfcmVtb3ZlZDogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYl9yZW1vdmVkIDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbmJfcmVtb3ZlZCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfaW5kZXggKyBuYl9yZW1vdmVkIC0gMSwgc3RhcnRfaW5kZXggLSAxLCBsX2NvdW50IC0gZW5kX2luZGV4KVxuICAgICAgICBjb3VudCA6PSBsX2NvdW50IC0gbmJfcmVtb3ZlZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICsgb2xkIHN1YnN0cmluZyAoZW5kX2luZGV4ICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBuID4gbF9jb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IDBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF9oZWFkIChsX2NvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgY291bnQgLSBuLm1pbiAoY291bnQpKSlcbiAgICBlbmRcblxuICBwcnVuZSAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnLCBpZiBhbnkuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBjb3VudGVyIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGNvdW50ZXIgPiBjb3VudCBvciBlbHNlIChpdGVtIChjb3VudGVyKSA9IGMpXG4gICAgICBsb29wXG4gICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgY291bnRlciA8PSBjb3VudCB0aGVuXG4gICAgICAgIHJlbW92ZSAoY291bnRlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9jaGFyOiBDSEFSQUNURVJfMzJcbiAgICBkb1xuICAgICAgICAtLSBUcmF2ZXJzZSBzdHJpbmcgYW5kIHNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnRcbiAgICAgICAgLS0gZWFjaCB0aW1lIHdlIGZpbmQgYW4gb2NjdXJyZW5jZSBvZiBgYycuXG4gICAgICBmcm9tXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgbF9jaGFyIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICBpZiBsX2NoYXIgLz0gYyB0aGVuXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9jaGFyLCBqKVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0galxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgY2hhbmdlZF9jb3VudDogY291bnQgPSAob2xkIGNvdW50KSAtIChvbGQgb2NjdXJyZW5jZXMgKGMpKVxuICAgICAgLS0gcmVtb3ZlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgLz0gYGMnXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsX2xlYWRpbmcgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgbGVhZGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoMSkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfdHJhaWxpbmcgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgdHJhaWxpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKGNvdW50KSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoY291bnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG4gIGNsZWFyX2FsbFxuICAgICAgLS0gUmVzZXQgYWxsIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB3aXBlX291dCcgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgaXNfZW1wdHk6IGNvdW50ID0gMFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGFkYXB0X3NpemVcbiAgICAgIC0tIEFkYXB0IHRoZSBzaXplIHRvIGFjY29tbW9kYXRlIGBjb3VudCcgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgcmVzaXplIChjb3VudClcbiAgICBlbmRcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgY2hhcmFjdGVyLlxuICAgIGRvXG4gICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgnJS8wMDAvJywgbmV3c2l6ZSArIDEpXG4gICAgZW5kXG5cbiAgZ3JvdyAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIEVuc3VyZSB0aGF0IHRoZSBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgbmV3c2l6ZScuXG4gICAgZG9cbiAgICAgIGlmIG5ld3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3c2l6ZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfc3RyaW5nOiBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b191cHBlclxuICAgIGVuZFxuXG4gIGxlZnRfanVzdGlmeVxuICAgICAgLS0gTGVmdCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aXRkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlIHNwYWNlcy5cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBsZWZ0X2FkanVzdFxuXG4gICAgICAgIC0tIEdldCBuZXcgY291bnRcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgLS0gYGxlZnRfYWRqdXN0JyBkaWQgcmVtb3ZlIHNvbWUgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAtLSBzb21lIHdoaXRlIHNwYWNlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjZW50ZXJfanVzdGlmeVxuICAgICAgLS0gQ2VudGVyIGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYiwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxlZnRfbmJfc3BhY2UsIHJpZ2h0X25iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgPSBuYiBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChsZWZ0X25iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA6PSBsZWZ0X25iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAtMSBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgIGxvb3BcbiAgICAgICAgcmlnaHRfbmJfc3BhY2UgOj0gcmlnaHRfbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFdlIGVuY291cmFnZSB0aGF0IG1vcmUgc3BhY2VzIHdpbGwgYmUgcHV0IHRvIHRoZSBsZWZ0LCB3aGVuXG4gICAgICAgIC0tIG51bWJlciBvZiBzcGFjZXMgaXMgbm90IGV2ZW4uXG4gICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlICsgcmlnaHRfbmJfc3BhY2VcbiAgICAgIGlmIGxfb2Zmc2V0IFxcXFwgMiA9IDAgdGhlblxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMlxuICAgICAgZWxzZVxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMiAtIDFcbiAgICAgIGVuZFxuICAgICAgaWYgbF9vZmZzZXQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgbGVmdCAoZGVwZW5kaW5nIG9uIHNpZ24gb2ZcbiAgICAgICAgICAtLSBgbF9vZmZzZXQnIGJ5IGBsX29mZnNldCcgcG9zaXRpb24uXG4gICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCxcbiAgICAgICAgICBuYiAtIGxlZnRfbmJfc3BhY2UgLSByaWdodF9uYl9zcGFjZSlcblxuICAgICAgICBpZiBsX29mZnNldCA8IDAgdGhlblxuICAgICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaWxsIHJpZ2h0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBuYiAtIHJpZ2h0X25iX3NwYWNlIC0gbF9vZmZzZXQsIG5iIC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9qdXN0aWZ5XG4gICAgICAtLSBSaWdodCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBuYl9zcGFjZSA6PSBuYiAtIGlcbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGkpLCBpICsgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpICsgMVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbmJfc3BhY2UgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgbmJfc3BhY2UgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9qdXN0aWZ5IChwaXZvdDogQ0hBUkFDVEVSXzMyOyBwb3NpdGlvbjogSU5URUdFUilcbiAgICAgIC0tIEp1c3RpZnkgYSBzdHJpbmcgYmFzZWQgb24gYSBgcGl2b3QnXG4gICAgICAtLSBhbmQgdGhlIGBwb3NpdGlvbicgaXQgbmVlZHMgdG8gYmUgaW5cbiAgICAgIC0tIHRoZSBmaW5hbCBzdHJpbmcuXG4gICAgICAtLSBUaGlzIHdpbGwgZ3JvdyB0aGUgc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgLS0gdG8gZ2V0IHRoZSBwaXZvdCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9wb3NpdGlvbjogcG9zaXRpb24gPD0gY2FwYWNpdHlcbiAgICAgIHBvc2l0aXZlX3Bvc2l0aW9uOiBwb3NpdGlvbiA+PSAxXG4gICAgICBwaXZvdF9ub3Rfc3BhY2U6IHBpdm90IC89ICcgJ1xuICAgICAgbm90X2VtcHR5OiBub3QgaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgbF9pbmRleF9vZl9waXZvdCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9pbmRleF9vZl9waXZvdCA6PSBpbmRleF9vZiAocGl2b3QsIDEpXG4gICAgICBpZiBsX2luZGV4X29mX3Bpdm90IC89IDAgdGhlblxuICAgICAgICBpZiBsX2luZGV4X29mX3Bpdm90IDwgcG9zaXRpb24gdGhlblxuICAgICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgQ3VycmVudCBzbyB0aGF0IHdlIGNhbiBzaGlmdCBDdXJyZW50IGJ5XG4gICAgICAgICAgICAtLSBgbF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uJy5cbiAgICAgICAgICBsX25ld19zaXplIDo9IGNvdW50ICsgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90XG4gICAgICAgICAgZ3JvdyAobF9uZXdfc2l6ZSlcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCwgY291bnQpXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCAwLCBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3QgLSAxKVxuICAgICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHNoaWZ0IGNvbnRlbnQgdG8gdGhlIGxlZnQgYW5kIHJlc2V0IHRyYWlsaW5nIHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uLCAwLCBjb3VudCAtIGxfaW5kZXhfb2ZfcGl2b3QgKyBwb3NpdGlvbilcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uLCBjb3VudCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fbG93ZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX2xvd2VyKVxuICAgIGVuZFxuXG4gIHRvX3VwcGVyXG4gICAgICAtLSBDb252ZXJ0IHRvIHVwcGVyIGNhc2UuXG4gICAgZG9cbiAgICAgIHRvX3VwcGVyX2FyZWEgKGFyZWEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBsZW5ndGhfYW5kX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBhc191cHBlcilcbiAgICBlbmRcblxuICBsaW5lYXJfcmVwcmVzZW50YXRpb246IExJTkVBUiBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2M6IEFOWVxuICAgICAgLS0gQSByZWZlcmVuY2UgdG8gYSBDIGZvcm0gb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICAtLSBVc2VmdWwgb25seSBmb3IgaW50ZXJmYWNpbmcgd2l0aCBDIHNvZnR3YXJlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLnB1dCAoJyVVJywgY291bnQpXG4gICAgICBSZXN1bHQgOj0gbF9hcmVhXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5taXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvclxuICAgICAgLS0gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgIC0tIFwiSGVsbG8gd29ybGRcIiAtPiBcImRscm93IG9sbGVIXCIuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzMyXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGNvdW50IC0gMVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPD0galxuICAgICAgICBsb29wXG4gICAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgICAgYS5wdXQgKGEuaXRlbSAoaiksIGkpXG4gICAgICAgICAgYS5wdXQgKGMsIGopXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgPSBvbGQgYGl0ZW0nIChgY291bnQnKzEtYGknKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkb1xuICAgICAgaWYgKDEgPD0gc3RhcnRfaW5kZXgpIGFuZCAoc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4KSBhbmQgKGVuZF9pbmRleCA8PSBjb3VudCkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuYXJlYS5jb3B5X2RhdGEgKGFyZWEsIHN0YXJ0X2luZGV4IC0gMSwgMCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbXVsdGlwbHkgKG46IElOVEVHRVIpXG4gICAgICAtLSBEdXBsaWNhdGUgYSBzdHJpbmcgd2l0aGluIGl0c2VsZlxuICAgICAgLS0gKFwiaGVsbG9cIikubXVsdGlwbHkoMykgPT4gXCJoZWxsb2hlbGxvaGVsbG9cIlxuICAgIHJlcXVpcmVcbiAgICAgIG1lYW5pbmdmdWxfbXVsdGlwbGllcjogbiA+PSAxXG4gICAgbG9jYWxcbiAgICAgIHM6IGxpa2UgQ3VycmVudFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBzIDo9IHR3aW5cbiAgICAgIGdyb3cgKG4gKiBjb3VudClcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMVxuICAgICAgbG9vcFxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmcm96ZW4gc2V0X2NvdW50IChudW1iZXI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB0byBgbnVtYmVyJyBvZiBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSBudW1iZXJcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgbmV3X3N0cmluZyAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IGluc3RhbmNlIG9mIGN1cnJlbnQgd2l0aCBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBUcmFuc2Zvcm1hdGlvblxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggZHVyaW5nIHJldHJpZXZlIHVzaW5nIGBtaXNtYXRjaF9pbmZvcm1hdGlvbicuXG4gICAgZG9cbiAgICAgICAgLS0gTm90aGluZyB0byBiZSBkb25lIGJlY2F1c2Ugd2Ugb25seSBhZGRlZCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB0aGF0IHdpbGxcbiAgICAgICAgLS0gYmUgcmVjb21wdXRlZCBuZXh0IHRpbWUgd2UgcXVlcnkgYGhhc2hfY29kZScuXG5cbiAgICAgICAgLS0gSW4gLk5FVCwgd2UgaGF2ZSBhIG1pc21hdGNoIHRoYXQgaXMgdHJpZ2dlcmVkIGR1ZSB0byB0aGUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgICAgLS0gU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXSBhcyBhIC5ORVQgYXJyYXkgb2YgVUludDE2LlxuICAgICAgaWYgYXJlYSA9IFZvaWQgYW5kIHRoZW4gYXR0YWNoZWQge2xpa2UgYXJlYX0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJhcmVhXCIpIGFzIGxfYXJlYSB0aGVuXG4gICAgICAgIGFyZWEgOj0gbF9hcmVhXG4gICAgICBlbmRcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgY29tcGFyZV9jaGFyYWN0ZXI6IG5vdCBvYmplY3RfY29tcGFyaXNvblxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAzLTI2IDE0OjQ5OjQwIC0wNzAwIChXZWQsIDI2IE1hciAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDcyMSAkXCJcblxuY2xhc3NcbiAgU1RSSU5HXzhcblxuaW5oZXJpdFxuICBSRUFEQUJMRV9TVFJJTkdfOFxuICAgIGV4cG9ydFxuICAgICAge0FOWX0gbWFrZSwgbWFrZV9lbXB0eSwgbWFrZV9maWxsZWQsIG1ha2VfZnJvbV9jLCBtYWtlX2Zyb21fc3RyaW5nLCBmaWxsX2NoYXJhY3RlclxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgU1RSSU5HX0dFTkVSQUxcbiAgICByZW5hbWVcbiAgICAgIGFwcGVuZCBhcyBhcHBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBhcHBlbmRfc3Vic3RyaW5nIGFzIGFwcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmQgYXMgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3Vic3RyaW5nIGFzIHByZXBlbmRfc3Vic3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsLFxuICAgICAgaXRlbSBhcyBjaGFyYWN0ZXJfMzJfaXRlbSxcbiAgICAgIGhhcyBhcyBjaGFyYWN0ZXJfMzJfaGFzLFxuICAgICAgaW5kZXhfb2YgYXMgY2hhcmFjdGVyXzMyX2luZGV4X29mLFxuICAgICAgbGFzdF9pbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfbGFzdF9pbmRleF9vZixcbiAgICAgIG9jY3VycmVuY2VzIGFzIGNoYXJhY3Rlcl8zMl9vY2N1cnJlbmNlc1xuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWxcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0NIQVJBQ1RFUl84LCBJTlRFR0VSXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIHBydW5lX2FsbCxcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBSRVNJWkFCTEUgW0NIQVJBQ1RFUl84XVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaXRlbSwgYXQsIHB1dCwgdmFsaWRfaW5kZXhcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fc3RyaW5nLFxuICBtYWtlX2Zyb21fYyxcbiAgbWFrZV9mcm9tX2NfcG9pbnRlcixcbiAgbWFrZV9mcm9tX2NpbFxuXG5jb252ZXJ0XG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9LFxuICBtYWtlX2Zyb21fY2lsICh7U1lTVEVNX1NUUklOR30pLFxuICBhc19zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzIsIFNUUklOR18zMn1cblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9jaWwgKGFfc3lzdGVtX3N0cmluZzogZGV0YWNoYWJsZSBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IHdpdGggYGFfc3lzdGVtX3N0cmluZycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGFfc3lzdGVtX3N0cmluZy5sZW5ndGggKyBkb3RuZXRfY29udmVydG9yLmVzY2FwZV9jb3VudCAoYV9zeXN0ZW1fc3RyaW5nKVxuICAgICAgZW5kXG4gICAgICBtYWtlIChsX2NvdW50KVxuICAgICAgaWYgbF9jb3VudCA+IDAgYW5kIHRoZW4gYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBzZXRfY291bnQgKGxfY291bnQpXG4gICAgICAgIGRvdG5ldF9jb252ZXJ0b3IucmVhZF9zeXN0ZW1fc3RyaW5nX2ludG8gKGFfc3lzdGVtX3N0cmluZywgQ3VycmVudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBjb250ZW50cyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdHJpbmdfaW50byAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIG5vX3plcm9fYnl0ZTogbm90IGhhcyAoJyUvMC8nKVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgICAgLS0gY29ycmVjdF9jb3VudDogdGhlIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgY291bnRcbiAgICAgIC0tICAgICAgIGlzIE5VTExcbiAgICBlbmRcblxuICBmcm9tX2Nfc3Vic3RyaW5nIChjX3N0cmluZzogUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gc3Vic3RyaW5nIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGNfc3RyaW5nICsgKHN0YXJ0X3BvcyAtIDEpLCBsX2NvdW50KVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG8gKEN1cnJlbnQsIDEsIGxfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgIGVuZFxuXG4gIGFkYXB0IChzOiBTVFJJTkdfOCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT2JqZWN0IG9mIGEgdHlwZSBjb25mb3JtaW5nIHRvIHRoZSB0eXBlIG9mIGBzJyxcbiAgICAgIC0tIGluaXRpYWxpemVkIHdpdGggYXR0cmlidXRlcyBmcm9tIGBzJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoMClcbiAgICAgIFJlc3VsdC5zaGFyZSAocylcbiAgICBlbnN1cmVcbiAgICAgIGFkYXB0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBSZXN1bHQuc2hhcmVkX3dpdGggKHMpXG4gICAgZW5kXG5cbiAgcmVtYWtlIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZScgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX3NpemU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nOiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzggYXNzaWduIHB1dFxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzMyX2l0ZW0gKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgICAgLS0gV2Ugc2hvdWxkIGJlIHVzaW5nIGBhcmVhLml0ZW0gKGkgLSAxKS50b19jaGFyYWN0ZXJfMzInXG4gICAgICAgIC0tIGJ1dCBzb21lIGRlc2NlbmRhbnRzIG9mIFNUUklORyB0aGF0IGhhdmUgdGhlaXIgY29udGVudCBlbmNvZGVkXG4gICAgICAgIC0tIGluIFVURi04IGZvciBleGFtcGxlIHJlbGllcyBvbiBgY29kZScgdG8gZ2V0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgIC0tIENIQVJBQ1RFUl8zMiBieSByZWFkaW5nIG1vcmUgdGhhbiBvbmUgYnl0ZS4gT25jZSB0aGV5IGhhdmVcbiAgICAgICAgLS0gYmVlbiB1cGRhdGVkIHRvIHVzZSBgY2hhcmFjdGVyXzMyX2l0ZW0nIHdlIGNhbiByZXZlcnQgdGhlIGNvZGVcbiAgICAgICAgLS0gYmFjayB0byB1c2luZyBgYXJlYScgZGlyZWN0bHkuXG4gICAgICBSZXN1bHQgOj0gY29kZSAoaSkudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSkuY29kZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgICAtLSBVc2UgYGNvZGUnIGluc3RlYWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggVW5pY29kZSBoYW5kbGluZy5cbiAgICAgIC0tfCBOb3Qgb2Jzb2xldGUgYmVjYXVzZSBvbGQgY29kZSB1c2luZyBqdXN0IEFTQ0lJIGlzIHNhZmUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlXG4gICAgZW5kXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzhdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzLlxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gTWF5IG5ldyBpdGVtcyBiZSBhZGRlZD8gKEFuc3dlcjogeWVzLilcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvbjogQk9PTEVBTiA9IEZhbHNlXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXQgKHQ6IFJFQURBQkxFX1NUUklOR184OyBuMSwgbjI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgY3VycmVudCBzdHJpbmcgdG8gc3Vic3RyaW5nIG9mIGB0JyBmcm9tIGluZGljZXMgYG4xJ1xuICAgICAgLS0gdG8gYG4yJywgb3IgdG8gZW1wdHkgc3RyaW5nIGlmIG5vIHN1Y2ggc3Vic3RyaW5nLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiB0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgczogUkVBREFCTEVfU1RSSU5HXzhcbiAgICBkb1xuICAgICAgcyA6PSB0LnN1YnN0cmluZyAobjEsIG4yKVxuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19zdWJzdHJpbmc6IHNhbWVfc3RyaW5nICh0LnN1YnN0cmluZyAobjEsIG4yKSlcbiAgICBlbmRcblxuICBzdWJjb3B5IChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyB0byBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgICAgZW5vdWdoX3NwYWNlOiAoY291bnQgLSBpbmRleF9wb3MpID49IChlbmRfcG9zIC0gc3RhcnRfcG9zKVxuICAgIGxvY2FsXG4gICAgICBsX290aGVyX2FyZWEsIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGVuZF9wb3MgPj0gc3RhcnRfcG9zIHRoZW5cbiAgICAgICAgbF9vdGhlcl9hcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaWYgbF9hcmVhIC89IGxfb3RoZXJfYXJlYSB0aGVuXG4gICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9vdGhlcl9hcmVhLCBzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGNvcGllZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGluZGV4X3BvcyAtIDEpICtcbiAgICAgICAgb2xkIG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSArXG4gICAgICAgIG9sZCBzdWJzdHJpbmcgKGluZGV4X3BvcyArIChlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR184OyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4JyB0byBgZW5kX2luZGV4JyB3aXRoIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsbF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgZGlmZjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIHNfY291bnQ6IElOVEVHRVJcbiAgICAgIG9sZF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBzX2NvdW50IDo9IHMuY291bnRcbiAgICAgIG9sZF9jb3VudCA6PSBjb3VudFxuICAgICAgZGlmZiA6PSBzX2NvdW50IC0gKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIG5ld19zaXplIDo9IGRpZmYgKyBvbGRfY291bnRcbiAgICAgIGlmIGRpZmYgPiAwIHRoZW5cbiAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSB0aGUgc3RyaW5nLlxuICAgICAgICBncm93IChuZXdfc2l6ZSlcbiAgICAgIGVuZFxuXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAtLXwgV2UgbW92ZSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgZm9yd2FyZCAoaWYgZGlmZiBpcyA+IDApLCBiYWNrd2FyZCAoaWYgZGlmZiA8IDApLFxuICAgICAgICAtLXwgYW5kIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICAgICAgaWYgZGlmZiAvPSAwIHRoZW5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKGVuZF9pbmRleCwgZW5kX2luZGV4ICsgZGlmZiwgb2xkX2NvdW50IC0gZW5kX2luZGV4KVxuICAgICAgZW5kXG4gICAgICAgIC0tfCBTZXQgbmV3IGNvdW50XG4gICAgICBzZXRfY291bnQgKG5ld19zaXplKVxuICAgICAgICAtLXwgV2UgY29weSB0aGUgc3Vic3RyaW5nLlxuICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHN0YXJ0X2luZGV4IC0gMSwgc19jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudCAtIGVuZF9pbmRleCArIHN0YXJ0X2luZGV4IC0gMVxuICAgICAgcmVwbGFjZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgKHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArXG4gICAgICAgICAgcyArIHN1YnN0cmluZyAoZW5kX2luZGV4ICsgMSwgY291bnQpKSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmdfYWxsIChvcmlnaW5hbCwgbmV3OiBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgb2NjdXJyZW5jZSBvZiBgb3JpZ2luYWwnIHdpdGggYG5ldycuXG4gICAgcmVxdWlyZVxuICAgICAgb3JpZ2luYWxfZXhpc3RzOiBvcmlnaW5hbCAvPSBWb2lkXG4gICAgICBuZXdfZXhpc3RzOiBuZXcgLz0gVm9pZFxuICAgICAgb3JpZ2luYWxfbm90X2VtcHR5OiBub3Qgb3JpZ2luYWwuaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgbF9maXJzdF9wb3MsIGxfbmV4dF9wb3M6IElOVEVHRVJcbiAgICAgIGxfb3JpZ19jb3VudCwgbF9uZXdfY291bnQsIGxfbmV3X2xvd2VyLCBsX2NvdW50LCBpLCBsX2luZGV4X2NvdW50OiBJTlRFR0VSXG4gICAgICBsX3NyY19pbmRleCwgbF9kZXN0X2luZGV4LCBsX3ByZXZfaW5kZXgsIGxfY29weV9kZWx0YTogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX25ld19hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgICBsX3N0cmluZ19zZWFyY2hlcjogbGlrZSBzdHJpbmdfc2VhcmNoZXJcbiAgICAgIGxfaW5kZXhfbGlzdDogU1BFQ0lBTCBbSU5URUdFUl1cbiAgICBkb1xuICAgICAgaWYgbm90IGlzX2VtcHR5IHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX3N0cmluZ19zZWFyY2hlciA6PSBzdHJpbmdfc2VhcmNoZXJcbiAgICAgICAgbF9zdHJpbmdfc2VhcmNoZXIuaW5pdGlhbGl6ZV9kZWx0YXMgKG9yaWdpbmFsKVxuICAgICAgICBsX29yaWdfY291bnQgOj0gb3JpZ2luYWwuY291bnRcbiAgICAgICAgbF9uZXdfY291bnQgOj0gbmV3LmNvdW50XG4gICAgICAgIGlmIGxfb3JpZ19jb3VudCA+PSBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgMSwgbF9jb3VudClcbiAgICAgICAgICBpZiBsX2ZpcnN0X3BvcyA+IDAgdGhlblxuICAgICAgICAgICAgaWYgbF9vcmlnX2NvdW50ID0gbF9uZXdfY291bnQgdGhlblxuICAgICAgICAgICAgICAgIC0tIFN0cmluZyB3aWxsIG5vdCBiZSByZXNpemVkLCBzaW1wbHkgcGVyZm9ybSBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2FyZWEgOj0gbmV3LmFyZWFcbiAgICAgICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zID0gMFxuICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9uZXdfYXJlYSwgbF9uZXdfbG93ZXIsIGxfZmlyc3RfcG9zIC0gMSwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgaWYgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCA8PSBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQsIGxfY291bnQpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gMFxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VpZiBsX29yaWdfY291bnQgPiBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gTmV3IHN0cmluZyBpcyBzbWFsbGVyIHRoYW4gcHJldmlvdXMgc3RyaW5nLCB3ZSBjYW4gb3B0aW1pemVcbiAgICAgICAgICAgICAgICAtLSBzdWJzdGl0dXRpb24gYnkgb25seSBtb3ZpbmcgYmxvY2sgYmV0d2VlbiB0d28gb2NjdXJyZW5jZXMgb2YgYG9yZ2luYWwnLlxuICAgICAgICAgICAgICBmcm9tXG4gICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCBsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2FyZWEgOj0gbmV3LmFyZWFcbiAgICAgICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgICAgIGxfbmV4dF9wb3MgPSAwXG4gICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICAgIC0tIENvcHkgbmV3IHN0cmluZyBpbnRvIEN1cnJlbnRcbiAgICAgICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxIC0gbF9vZmZzZXQsIGxfbmV3X2NvdW50KVxuICAgICAgICAgICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyBiZXR3ZWVuIGBsX2ZpcnN0X3BvcycgYW5kIGBsX25leHRfcG9zJ1xuICAgICAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IC0gMSAtIGxfb2Zmc2V0LCBsX25leHRfcG9zIC0gbF9maXJzdF9wb3MgLSBsX29yaWdfY291bnQpXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9uZXh0X3Bvc1xuICAgICAgICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfb2Zmc2V0ICsgKGxfb3JpZ19jb3VudCAtIGxfbmV3X2NvdW50KVxuICAgICAgICAgICAgICAgIGlmIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgPD0gbF9jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgICBsX25leHRfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50LCBsX2NvdW50KVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIGxfbmV4dF9wb3MgOj0gMFxuICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgICAtLSBQZXJmb3JtIGZpbmFsIHN1YnN0aXR1dGlvbjpcbiAgICAgICAgICAgICAgICAtLSBDb3B5IG5ldyBzdHJpbmcgaW50byBDdXJyZW50XG4gICAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2ZpcnN0X3BvcyAtIDEgLSBsX29mZnNldCwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyBiZXR3ZWVuIGBsX2ZpcnN0X3BvcycgYW5kIHRoZSBlbmQgb2YgdGhlIHN0cmluZ1xuICAgICAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQgLSAxLFxuICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgLSAxIC0gbF9vZmZzZXQsIGxfY291bnQgKyAxIC0gbF9maXJzdF9wb3MgLSBsX29yaWdfY291bnQpXG4gICAgICAgICAgICAgICAgICAtLSBQZXJmb3JtIGxhc3Qgc3Vic3RpdHV0aW9uXG4gICAgICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfb2Zmc2V0ICsgKGxfb3JpZ19jb3VudCAtIGxfbmV3X2NvdW50KVxuXG4gICAgICAgICAgICAgICAgLS0gVXBkYXRlIGBjb3VudCdcbiAgICAgICAgICAgICAgc2V0X2NvdW50IChsX2NvdW50IC0gbF9vZmZzZXQpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgLS0gU3RyaW5nIHdhcyBtb2RpZmllZCB3ZSBuZWVkIHRvIHJlY29tcHV0ZSB0aGUgYGhhc2hfY29kZScuXG4gICAgICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgYXR0YWNoZWQgbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X2xpc3Rfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCAxLCBsX2NvdW50KSBhcyBsX2xpc3QgdGhlblxuICAgICAgICAgICAgLS0gR2V0IHRoZSBudW1iZXIgb2Ygc3Vic3RpdHV0aW9uIHRvIGJlIHBlcmZvcm1lZCBieSBnZXR0aW5nIGEgbGlzdFxuICAgICAgICAgICAgLS0gb2YgbG9jYXRpb24gd2hlcmUgYG9yaWdpbmFsJyBhcHBlYXJzLlxuICAgICAgICAgIGxfaW5kZXhfbGlzdCA6PSBsX2xpc3QuYXJlYVxuICAgICAgICAgIGxfaW5kZXhfY291bnQgOj0gbF9pbmRleF9saXN0LmNvdW50XG4gICAgICAgICAgICAtLSBTdG9yZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIHVwIHRvIHdoaWNoIHdlIG5lZWQgdG8gbW92ZVxuICAgICAgICAgICAgLS0gY2hhcmFjdGVycyBpbiB0aGUgcmVhbGxvY2F0ZWQgc3RyaW5nLlxuICAgICAgICAgIGxfcHJldl9pbmRleCA6PSBsX2NvdW50XG4gICAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgICAgICAgIGxfY29weV9kZWx0YSA6PSBsX25ld19jb3VudCAtIGxfb3JpZ19jb3VudFxuICAgICAgICAgIGxfY291bnQgOj0gbF9jb3VudCArIChsX2luZGV4X2NvdW50ICogbF9jb3B5X2RlbHRhKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhLnJlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKCclVScsIGxfY291bnQgKyAxKVxuICAgICAgICAgIGFyZWEgOj0gbF9hcmVhXG4gICAgICAgICAgICAtLSBQZXJmb3JtIHRoZSBzdWJzdGl0dXRpb24gc3RhcnRpbmcgZnJvbSB0aGUgZW5kLlxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIGkgOj0gbF9pbmRleF9jb3VudFxuICAgICAgICAgICAgbF9uZXdfbG93ZXIgOj0gbmV3LmFyZWFfbG93ZXJcbiAgICAgICAgICAgIGxfbmV3X2FyZWEgOj0gbmV3LmFyZWFcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgaSA9IDBcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBsX3NyY19pbmRleCA6PSBsX2luZGV4X2xpc3QuaXRlbSAoaSlcbiAgICAgICAgICAgIGxfZGVzdF9pbmRleCA6PSBsX3NyY19pbmRleCArIGkgKiBsX2NvcHlfZGVsdGFcbiAgICAgICAgICAgICAgLS0gU2hpZnQgbm9uLW1hdGNoaW5nIGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBuZXdseSByZXBsYWNlZCBzdHJpbmcuXG4gICAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobF9zcmNfaW5kZXggKyBsX29yaWdfY291bnQgLSAxLCBsX2Rlc3RfaW5kZXggKyBsX25ld19jb3VudCAtIDEsIGxfcHJldl9pbmRleCAtIGxfc3JjX2luZGV4IC0gbF9vcmlnX2NvdW50ICsgMSlcbiAgICAgICAgICAgICAgLS0gU3RvcmUgbmV3IGVuZCBvZiBzdHJpbmcgd2hlcmUgY2hhcmFjdGVycyB3aWxsIGJlIG1vdmVkLlxuICAgICAgICAgICAgbF9wcmV2X2luZGV4IDo9IGxfc3JjX2luZGV4IC0gMVxuXG4gICAgICAgICAgICAgIC0tIENvcHkgYG5ldycgdG8gaXRzIGFwcHJvcHJpYXRlIHBvc2l0aW9uXG4gICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9kZXN0X2luZGV4IC0gMSwgbF9uZXdfY291bnQpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBVcGRhdGUgdGhlIG5ldyBgY291bnQnIHdoaWNoIGFsc28gcmVzZXRzIHRoZSBgaGFzaF9jb2RlJy5cbiAgICAgICAgICBzZXRfY291bnQgKGxfY291bnQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9ibGFua1xuICAgICAgLS0gUmVwbGFjZSBhbGwgY3VycmVudCBjaGFyYWN0ZXJzIHdpdGggYmxhbmtzLlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgYWxsX2JsYW5rOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKCcgJykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGZpbGxfYmxhbmtcbiAgICAgIC0tIEZpbGwgd2l0aCBgY2FwYWNpdHknIGJsYW5rIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGZpbGxfY2hhcmFjdGVyICgnICcpXG4gICAgZW5zdXJlXG4gICAgICBmaWxsZWQ6IGZ1bGxcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gY2FwYWNpdHkpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICAtLSBhbGxfYmxhbms6IEZvciBldmVyeSBgaScgaW4gYGNvdW50Jy4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYEJsYW5rJ1xuICAgIGVuZFxuXG4gIGZpbGxfd2l0aCAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBsX2NvdW50IC89IDAgdGhlblxuICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYywgMCwgbF9jb3VudCAtIDEpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgcmVwbGFjZV9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBjaGFyYWN0ZXIgd2l0aCBgYycuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGZpbGxfd2l0aCcgaW5zdGVhZCdcIlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKGMpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBmaWxsZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIGRvXG4gICAgICBpZiBuIDwgY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBrZWVwX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgbGFzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIGxvY2FsXG4gICAgICBuYjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbiA8IG5iIHRoZW5cbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYiAtIG4sIDAsIG4pXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGxlZnRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBuYiwgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIG5iX3NwYWNlID4gbmIgb3IgZWxzZSBub3QgbF9hcmVhLml0ZW0gKG5iX3NwYWNlKS5pc19zcGFjZVxuICAgICAgbG9vcFxuICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQgdmFsdWUuXG4gICAgICAgIG5iIDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdC5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iX3NwYWNlLCAwLCBuYilcbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50LlxuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmlnaHRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgcmlnaHQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBpIDo9IG5iXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpIDwgMCBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzaGFyZSAob3RoZXI6IFNUUklOR184KVxuICAgICAgLS0gTWFrZSBjdXJyZW50IHN0cmluZyBzaGFyZSB0aGUgdGV4dCBvZiBgb3RoZXInLlxuICAgICAgLS0gU3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nXG4gICAgICAtLSB3aWxsIGFsc28gYWZmZWN0IGBvdGhlcicsIGFuZCBjb252ZXJzZWx5LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBzaGFyZWRfY291bnQ6IG90aGVyLmNvdW50ID0gY291bnRcbiAgICAgIHNoYXJlZF9hcmVhOiBvdGhlci5hcmVhID0gYXJlYVxuICAgIGVuZFxuXG4gIHB1dCAoYzogQ0hBUkFDVEVSXzg7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgYGMnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAoYywgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHB1dF9jb2RlICh2OiBOQVRVUkFMXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknIGJ5IGNoYXJhY3RlciBvZiBjb2RlIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYudG9fY2hhcmFjdGVyXzgsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICBwcmVjZWRlLCBwcmVwZW5kX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBBZGQgYGMnIGF0IGZyb250LlxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBjb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgMSwgY291bnQpXG4gICAgICBsX2FyZWEucHV0IChjLCAwKVxuICAgICAgY291bnQgOj0gY291bnQgKyAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfOH0gcyBhcyBsX3M4IHRoZW5cbiAgICAgICAgcHJlcGVuZCAobF9zOClcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcmVwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCAxKVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR184OyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBvZiBjdXJyZW50LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgbF9zX2NvdW50LCBjb3VudClcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBiZWdpbm5pbmcuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCAwLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChiLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZCAoaS5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZCAoci5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzgpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIHMgLz0gVm9pZCB0aGVuXG4gICAgICAgIHByZXBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR184fSBzIGFzIGxfczggdGhlblxuICAgICAgICBhcHBlbmQgKGxfczgpXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7U1RSSU5HX0dFTkVSQUx9IChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnRcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR184OyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSkpXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChjb3VudCArIHMuY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gQXBwZW5kIGEgY29weSBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIHMgLz0gVm9pZCB0aGVuXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYXBwZW5kZWQ6IHMgLz0gVm9pZCBpbXBsaWVzXG4gICAgICAgIChlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgdHdpbiArIG9sZCBzLnR3aW4pKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfOCAoaTogSU5URUdFUl84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl84fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzE2IChpOiBJTlRFR0VSXzE2KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl8xNlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfNjQgKGk6IElOVEVHRVJfNjQpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzY0XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl82NH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMTYgKGk6IE5BVFVSQUxfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzMyIChpOiBOQVRVUkFMXzMyKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF8zMlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF82NCAoaTogTkFUVVJBTF82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmQgKHIub3V0KVxuICAgIGVuZFxuXG4gIGFwcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2NoYXJhY3RlciwgZXh0ZW5kIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWEucHV0IChjLCBjdXJyZW50X2NvdW50KVxuICAgICAgY291bnQgOj0gY3VycmVudF9jb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kIChiLm91dClcbiAgICBlbmRcblxuICBpbnNlcnQgKHM6IFJFQURBQkxFX1NUUklOR184OyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQWRkIGBzJyB0byBsZWZ0IG9mIHBvc2l0aW9uIGBpJyBpbiBjdXJyZW50IHN0cmluZy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgaW5zZXJ0X3N0cmluZycgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnQgKyAxXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPiAwXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIGkpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X3N0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYHMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHBvcyA6PSBpIC0gMVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIGxfc19jb3VudCwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBwb3MsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzg7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICBuZXdfc2l6ZSA6PSAxICsgY291bnRcbiAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgIHBvcyA6PSBpIC0gMVxuICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIDEsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgIC0tIEluc2VydCBuZXcgY2hhcmFjdGVyXG4gICAgICBsX2FyZWEucHV0IChjLCBwb3MpXG5cbiAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgb25lX21vcmVfY2hhcmFjdGVyOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IGNcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChpLCBpIC0gMSwgbF9jb3VudCAtIGkpXG4gICAgICAgIC0tIFVwZGF0ZSBjb250ZW50LlxuICAgICAgY291bnQgOj0gbF9jb3VudCAtIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAobi5taW4gKGNvdW50KSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4J1xuICAgICAgLS0gdG8gYGVuZF9pbmRleCcgaW5jbHVzaXZlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBuYl9yZW1vdmVkOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iX3JlbW92ZWQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBuYl9yZW1vdmVkID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9pbmRleCArIG5iX3JlbW92ZWQgLSAxLCBzdGFydF9pbmRleCAtIDEsIGxfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICAgIGNvdW50IDo9IGxfY291bnQgLSBuYl9yZW1vdmVkXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgKyBvbGQgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgbGFzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIG4gPiBsX2NvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX2hlYWQgKGxfY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBjb3VudCAtIG4ubWluIChjb3VudCkpKVxuICAgIGVuZFxuXG4gIHBydW5lIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJywgaWYgYW55LlxuICAgIHJlcXVpcmUgZWxzZVxuICAgICAgVHJ1ZVxuICAgIGxvY2FsXG4gICAgICBjb3VudGVyOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgY291bnRlciA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBjb3VudGVyID4gY291bnQgb3IgZWxzZSAoaXRlbSAoY291bnRlcikgPSBjKVxuICAgICAgbG9vcFxuICAgICAgICBjb3VudGVyIDo9IGNvdW50ZXIgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIGNvdW50ZXIgPD0gY291bnQgdGhlblxuICAgICAgICByZW1vdmUgKGNvdW50ZXIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9jaGFyOiBDSEFSQUNURVJfOFxuICAgIGRvXG4gICAgICAgIC0tIFRyYXZlcnNlIHN0cmluZyBhbmQgc2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdFxuICAgICAgICAtLSBlYWNoIHRpbWUgd2UgZmluZCBhbiBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBsX2NoYXIgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIGxfY2hhciAvPSBjIHRoZW5cbiAgICAgICAgICBsX2FyZWEucHV0IChsX2NoYXIsIGopXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBqXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjaGFuZ2VkX2NvdW50OiBjb3VudCA9IChvbGQgY291bnQpIC0gKG9sZCBvY2N1cnJlbmNlcyAoYykpXG4gICAgICAtLSByZW1vdmVkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSAvPSBgYydcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfbGVhZGluZyAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZW1vdmUgYWxsIGxlYWRpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKDEpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlICgxKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsX3RyYWlsaW5nIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlbW92ZSBhbGwgdHJhaWxpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKGNvdW50KSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoY291bnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG4gIGNsZWFyX2FsbFxuICAgICAgLS0gUmVzZXQgYWxsIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB3aXBlX291dCcgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgaXNfZW1wdHk6IGNvdW50ID0gMFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGFkYXB0X3NpemVcbiAgICAgIC0tIEFkYXB0IHRoZSBzaXplIHRvIGFjY29tbW9kYXRlIGBjb3VudCcgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgcmVzaXplIChjb3VudClcbiAgICBlbmRcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyUvMDAwLycsIG5ld3NpemUgKyAxKVxuICAgIGVuZFxuXG4gIGdyb3cgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBFbnN1cmUgdGhhdCB0aGUgY2FwYWNpdHkgaXMgYXQgbGVhc3QgYG5ld3NpemUnLlxuICAgIGRvXG4gICAgICBpZiBuZXdzaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld3NpemUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0cmltXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBuOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG4gOj0gY291bnRcbiAgICAgIGlmIG4gPCBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYW1lX3N0cmluZzogc2FtZV9zdHJpbmcgKG9sZCB0d2luKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19sb3dlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b19sb3dlclxuICAgIGVuZFxuXG4gIGFzX3VwcGVyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiB1cHBlciBjYXNlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fdXBwZXJcbiAgICBlbmRcblxuICBsZWZ0X2p1c3RpZnlcbiAgICAgIC0tIExlZnQganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2l0ZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZSBzcGFjZXMuXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgbGVmdF9hZGp1c3RcblxuICAgICAgICAtLSBHZXQgbmV3IGNvdW50XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgIC0tIGBsZWZ0X2FkanVzdCcgZGlkIHJlbW92ZSBzb21lIGNoYXJhY3RlcnMsIHNvIHdlIG5lZWQgdG8gYWRkXG4gICAgICAgICAgLS0gc29tZSB3aGl0ZSBzcGFjZXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY2VudGVyX2p1c3RpZnlcbiAgICAgIC0tIENlbnRlciBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmIsIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgICBsZWZ0X25iX3NwYWNlLCByaWdodF9uYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBsZWZ0X25iX3NwYWNlID0gbmIgb3IgZWxzZSBub3QgbF9hcmVhLml0ZW0gKGxlZnRfbmJfc3BhY2UpLmlzX3NwYWNlXG4gICAgICBsb29wXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgOj0gbGVmdF9uYl9zcGFjZSArIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgcmlnaHQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbmIgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gLTEgb3IgZWxzZSBub3QgbF9hcmVhLml0ZW0gKGkpLmlzX3NwYWNlXG4gICAgICBsb29wXG4gICAgICAgIHJpZ2h0X25iX3NwYWNlIDo9IHJpZ2h0X25iX3NwYWNlICsgMVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBXZSBlbmNvdXJhZ2UgdGhhdCBtb3JlIHNwYWNlcyB3aWxsIGJlIHB1dCB0byB0aGUgbGVmdCwgd2hlblxuICAgICAgICAtLSBudW1iZXIgb2Ygc3BhY2VzIGlzIG5vdCBldmVuLlxuICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSArIHJpZ2h0X25iX3NwYWNlXG4gICAgICBpZiBsX29mZnNldCBcXFxcIDIgPSAwIHRoZW5cbiAgICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC8vIDJcbiAgICAgIGVsc2VcbiAgICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC8vIDIgLSAxXG4gICAgICBlbmRcbiAgICAgIGlmIGxfb2Zmc2V0IC89IDAgdGhlblxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0IG9yIGxlZnQgKGRlcGVuZGluZyBvbiBzaWduIG9mXG4gICAgICAgICAgLS0gYGxfb2Zmc2V0JyBieSBgbF9vZmZzZXQnIHBvc2l0aW9uLlxuICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQsXG4gICAgICAgICAgbmIgLSBsZWZ0X25iX3NwYWNlIC0gcmlnaHRfbmJfc3BhY2UpXG5cbiAgICAgICAgaWYgbF9vZmZzZXQgPCAwIHRoZW5cbiAgICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgbGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gRmlsbCByaWdodCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgbmIgLSByaWdodF9uYl9zcGFjZSAtIGxfb2Zmc2V0LCBuYiAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmlnaHRfanVzdGlmeVxuICAgICAgLS0gUmlnaHQganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIHJpZ2h0X2FkanVzdFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgbmJfc3BhY2UgOj0gbmIgLSBpXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChpKSwgaSArIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaSArIDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIG5iX3NwYWNlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIG5iX3NwYWNlICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfanVzdGlmeSAocGl2b3Q6IENIQVJBQ1RFUl84OyBwb3NpdGlvbjogSU5URUdFUilcbiAgICAgIC0tIEp1c3RpZnkgYSBzdHJpbmcgYmFzZWQgb24gYSBgcGl2b3QnXG4gICAgICAtLSBhbmQgdGhlIGBwb3NpdGlvbicgaXQgbmVlZHMgdG8gYmUgaW5cbiAgICAgIC0tIHRoZSBmaW5hbCBzdHJpbmcuXG4gICAgICAtLSBUaGlzIHdpbGwgZ3JvdyB0aGUgc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgLS0gdG8gZ2V0IHRoZSBwaXZvdCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9wb3NpdGlvbjogcG9zaXRpb24gPD0gY2FwYWNpdHlcbiAgICAgIHBvc2l0aXZlX3Bvc2l0aW9uOiBwb3NpdGlvbiA+PSAxXG4gICAgICBwaXZvdF9ub3Rfc3BhY2U6IHBpdm90IC89ICcgJ1xuICAgICAgbm90X2VtcHR5OiBub3QgaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgbF9pbmRleF9vZl9waXZvdCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9pbmRleF9vZl9waXZvdCA6PSBpbmRleF9vZiAocGl2b3QsIDEpXG4gICAgICBpZiBsX2luZGV4X29mX3Bpdm90IC89IDAgdGhlblxuICAgICAgICBpZiBsX2luZGV4X29mX3Bpdm90IDwgcG9zaXRpb24gdGhlblxuICAgICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgQ3VycmVudCBzbyB0aGF0IHdlIGNhbiBzaGlmdCBDdXJyZW50IGJ5XG4gICAgICAgICAgICAtLSBgbF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uJy5cbiAgICAgICAgICBsX25ld19zaXplIDo9IGNvdW50ICsgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90XG4gICAgICAgICAgZ3JvdyAobF9uZXdfc2l6ZSlcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCwgY291bnQpXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCAwLCBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3QgLSAxKVxuICAgICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHNoaWZ0IGNvbnRlbnQgdG8gdGhlIGxlZnQgYW5kIHJlc2V0IHRyYWlsaW5nIHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uLCAwLCBjb3VudCAtIGxfaW5kZXhfb2ZfcGl2b3QgKyBwb3NpdGlvbilcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uLCBjb3VudCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fbG93ZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX2xvd2VyKVxuICAgIGVuZFxuXG4gIHRvX3VwcGVyXG4gICAgICAtLSBDb252ZXJ0IHRvIHVwcGVyIGNhc2UuXG4gICAgZG9cbiAgICAgIHRvX3VwcGVyX2FyZWEgKGFyZWEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBsZW5ndGhfYW5kX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBhc191cHBlcilcbiAgICBlbmRcblxuICBsaW5lYXJfcmVwcmVzZW50YXRpb246IExJTkVBUiBbQ0hBUkFDVEVSXzhdXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgdGVtcDogQVJSQVlFRF9MSVNUIFtDSEFSQUNURVJfOF1cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNvdW50XG4gICAgICBsb29wXG4gICAgICAgIHRlbXAuZXh0ZW5kIChpdGVtIChpKSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gdGVtcFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19jOiBBTllcbiAgICAgIC0tIEEgcmVmZXJlbmNlIHRvIGEgQyBmb3JtIG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgLS0gVXNlZnVsIG9ubHkgZm9yIGludGVyZmFjaW5nIHdpdGggQyBzb2Z0d2FyZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5wdXQgKCclVScsIGNvdW50KVxuICAgICAgUmVzdWx0IDo9IGxfYXJlYVxuICAgIGVuZFxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBSZXN1bHQubWlycm9yXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtaXJyb3JcbiAgICAgIC0tIFJldmVyc2UgdGhlIG9yZGVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAtLSBcIkhlbGxvIHdvcmxkXCIgLT4gXCJkbHJvdyBvbGxlSFwiLlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl84XG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGNvdW50IC0gMVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPD0galxuICAgICAgICBsb29wXG4gICAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgICAgYS5wdXQgKGEuaXRlbSAoaiksIGkpXG4gICAgICAgICAgYS5wdXQgKGMsIGopXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgPSBvbGQgYGl0ZW0nIChgY291bnQnKzEtYGknKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkb1xuICAgICAgaWYgKDEgPD0gc3RhcnRfaW5kZXgpIGFuZCAoc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4KSBhbmQgKGVuZF9pbmRleCA8PSBjb3VudCkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuYXJlYS5jb3B5X2RhdGEgKGFyZWEsIHN0YXJ0X2luZGV4IC0gMSwgMCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbXVsdGlwbHkgKG46IElOVEVHRVIpXG4gICAgICAtLSBEdXBsaWNhdGUgYSBzdHJpbmcgd2l0aGluIGl0c2VsZlxuICAgICAgLS0gKFwiaGVsbG9cIikubXVsdGlwbHkoMykgPT4gXCJoZWxsb2hlbGxvaGVsbG9cIlxuICAgIHJlcXVpcmVcbiAgICAgIG1lYW5pbmdmdWxfbXVsdGlwbGllcjogbiA+PSAxXG4gICAgbG9jYWxcbiAgICAgIHM6IGxpa2UgQ3VycmVudFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBzIDo9IHR3aW5cbiAgICAgIGdyb3cgKG4gKiBjb3VudClcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMVxuICAgICAgbG9vcFxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmcm96ZW4gc2V0X2NvdW50IChudW1iZXI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB0byBgbnVtYmVyJyBvZiBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSBudW1iZXJcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgbmV3X3N0cmluZyAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IGluc3RhbmNlIG9mIGN1cnJlbnQgd2l0aCBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBUcmFuc2Zvcm1hdGlvblxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggZHVyaW5nIHJldHJpZXZlIHVzaW5nIGBtaXNtYXRjaF9pbmZvcm1hdGlvbicuXG4gICAgZG9cbiAgICAgIC0tIE5vdGhpbmcgdG8gYmUgZG9uZSBiZWNhdXNlIHdlIG9ubHkgYWRkZWQgYGludGVybmFsX2hhc2hfY29kZScgdGhhdCB3aWxsXG4gICAgICAtLSBiZSByZWNvbXB1dGVkIG5leHQgdGltZSB3ZSBxdWVyeSBgaGFzaF9jb2RlJy5cbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBlbXB0eV9hcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIEVtcHR5IGBhcmVhJyB0byBhdm9pZCB1c2VsZXNzIGNyZWF0aW9uIG9mIGVtcHR5IGFyZWFzIHdoZW4gd2lwaW5nIG91dCBhIFNUUklORy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJTaW1wbHkgY3JlYXRlIGBhcmVhJyBkaXJlY3RseS5cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDEpXG4gICAgICBSZXN1bHQuZXh0ZW5kICgnJVUnKVxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfYXJlYV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgY29tcGFyZV9jaGFyYWN0ZXI6IG5vdCBvYmplY3RfY29tcGFyaXNvblxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ29tbW9uIGFuY2VzdG9ycyB0byBhbGwgU1RSSU5HIGNsYXNzZXMuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAzLTE5IDA3OjM2OjEwIC0wNzAwIChXZWQsIDE5IE1hciAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDYzMyAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgU1RSSU5HX0dFTkVSQUxcblxuaW5oZXJpdFxuICBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgIGV4cG9ydFxuICAgICAge0FOWX0gY29weSwgc3RhbmRhcmRfY29weSwgZGVlcF9jb3B5XG4gICAgZW5kXG5cbmNvbnZlcnRcbiAgYXNfc3RyaW5nXzMyOiB7UkVBREFCTEVfU1RSSU5HXzMyLCBTVFJJTkdfMzJ9LFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfVxuXG5mZWF0dXJlIC0tIFNldHRpbmdzXG5cbiAgcHV0X2NvZGUgKHY6IGxpa2UgY29kZTsgaTogSU5URUdFUilcbiAgICAgIC0tIFB1dCBjb2RlIGB2JyBhdCBwb3NpdGlvbiBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY29kZTogdmFsaWRfY29kZSAodilcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGNvZGUgKGkpID0gdlxuICAgICAgc3RhYmxlX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSB7U1RSSU5HX0hBTkRMRVJ9IC0tIFNldHRpbmdzXG5cbiAgc2V0X2NvdW50IChudW1iZXI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB0byBgbnVtYmVyJyBvZiBjaGFyYWN0ZXJzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NvdW50OiAwIDw9IG51bWJlciBhbmQgbnVtYmVyIDw9IGNhcGFjaXR5XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBudW1iZXJcbiAgICBlbmRcblxuICBzZXRfaW50ZXJuYWxfaGFzaF9jb2RlICh2OiBsaWtlIGludGVybmFsX2hhc2hfY29kZSlcbiAgICAgIC0tIFNldCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB3aXRoIGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vbm5lZ2F0aXZlOiB2ID49IDBcbiAgICBkb1xuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IHZcbiAgICBlbnN1cmVcbiAgICAgIGludGVybmFsX2hhc2hfY29kZV9zZXQ6IGludGVybmFsX2hhc2hfY29kZSA9IHZcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIGFwcGVuZF9jb2RlIChjOiBsaWtlIGNvZGUpXG4gICAgICAtLSBBcHBlbmQgYGMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb2RlOiB2YWxpZF9jb2RlIChjKVxuICAgIGxvY2FsXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnQgKyAxXG4gICAgICBpZiBjdXJyZW50X2NvdW50ID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGN1cnJlbnRfY291bnQpXG4gICAgICBlbmRcbiAgICAgIHNldF9jb3VudCAoY3VycmVudF9jb3VudClcbiAgICAgIHB1dF9jb2RlIChjLCBjdXJyZW50X2NvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpdGVtX2luc2VydGVkOiBjb2RlIChjb3VudCkgPSBjXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgc3RhYmxlX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgY291bnQgLSAxKSB+IChvbGQgdHdpbilcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbF9zX2NvdW50XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY29kZSAocy5jb2RlIChpKSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBzZXRfY291bnQgKGxfbmV3X3NpemUpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkICh0b19zdHJpbmdfMzIgKyBzKSlcbiAgICBlbmRcblxuICBhcHBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gZW5kX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY29kZSAocy5jb2RlIChpKSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBzZXRfY291bnQgKGxfbmV3X3NpemUpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAodG9fc3RyaW5nXzMyICsgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpKSlcbiAgICBlbmRcblxuICBwcmVwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgY29tcGF0aWJsZV9zdHJpbmdzOiBpc19zdHJpbmdfOCBpbXBsaWVzIHMuaXNfdmFsaWRfYXNfc3RyaW5nXzhcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUpXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIENvcHkgYEN1cnJlbnQnIGF0IHRoZSBlbmQgc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHNpbmNlIGl0IHdpbGwgcHJvYmFibHkgb3ZlcmxhcC5cbiAgICAgICAgc2V0X2NvdW50IChsX25ld19zaXplKVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBsX2NvdW50XG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIHB1dF9jb2RlIChjb2RlIChpKSwgaSArIGxfc19jb3VudClcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIENvcHkgYHMnIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ3VycmVudC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBsX3NfY291bnRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIHB1dF9jb2RlIChzLmNvZGUgKGkpLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy50b19zdHJpbmdfMzIgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgY29tcGF0aWJsZV9zdHJpbmdzOiBpc19zdHJpbmdfOCBpbXBsaWVzIHMuaXNfdmFsaWRfYXNfc3RyaW5nXzhcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSlcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgQ3VycmVudCcgYXQgdGhlIGVuZCBzdGFydGluZyBmcm9tIHRoZSBlbmQgc2luY2UgaXQgd2lsbCBwcm9iYWJseSBvdmVybGFwLlxuICAgICAgICBzZXRfY291bnQgKGxfbmV3X3NpemUpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxfY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKGNvZGUgKGkpLCBpICsgbF9zX2NvdW50KVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgcycgYXQgdGhlIGJlZ2lubmluZyBvZiBDdXJyZW50LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICAgIGogOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIHB1dF9jb2RlIChzLmNvZGUgKGkpLCBqKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KS50b19zdHJpbmdfMzIgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgZmlyc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIG4ubWluIChjb3VudCkpKVxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBrZXB0OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nIChjb3VudCAtIG4ubWluKGNvdW50KSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICBsZWZ0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY291bnQ6IGNvdW50IDw9IG9sZCBjb3VudFxuICAgICAgbmV3X2NvdW50OiBub3QgaXNfZW1wdHkgaW1wbGllcyBub3QgaXRlbSAoMSkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKChvbGQgdHdpbikuc3Vic3RyaW5nIChvbGQgY291bnQgLSBjb3VudCArIDEsIG9sZCBjb3VudCkpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIChvbGQgdHdpbikuaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIChvbGQgdHdpbikuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCAxKSAtIDEpXG4gICAgZW5kXG5cbiAgcmlnaHRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY291bnQ6IGNvdW50IDw9IG9sZCBjb3VudFxuICAgICAgbmV3X2NvdW50OiBub3QgaXNfZW1wdHkgaW1wbGllcyBub3QgaXRlbSAoY291bnQpLmlzX3NwYWNlXG4gICAgICBrZXB0OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+ICgob2xkIHR3aW4pLnN1YnN0cmluZyAoMSwgY291bnQpKVxuICAgICAgb25seV9zcGFjZXNfcmVtb3ZlZF9hZnRlcjogZWxrc19jaGVja2luZyBpbXBsaWVzIChvbGQgdHdpbikuaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKChvbGQgdHdpbikuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCAxKSArIGNvdW50LCBvbGQgY291bnQpXG4gICAgZW5kXG5cbiAgYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICBkb1xuICAgICAgbGVmdF9hZGp1c3RcbiAgICAgIHJpZ2h0X2FkanVzdFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY291bnQ6IGNvdW50IDw9IG9sZCBjb3VudFxuICAgICAgbmV3X2NvdW50X2xlZnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtICgxKS5pc19zcGFjZVxuICAgICAgbmV3X2NvdW50X3JpZ2h0OiBub3QgaXNfZW1wdHkgaW1wbGllcyBub3QgaXRlbSAoY291bnQpLmlzX3NwYWNlXG4gICAgICBrZXB0OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5oYXNfc3Vic3RyaW5nIChDdXJyZW50KVxuICAgICAgb25seV9zcGFjZXNfcmVtb3ZlZF9iZWZvcmU6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyAob2xkIHR3aW4pLmlzX3N1YnN0cmluZ193aGl0ZXNwYWNlICgxLCAob2xkIHR3aW4pLnN1YnN0cmluZ19pbmRleCAoQ3VycmVudCwgMSkgLSAxKVxuICAgICAgb25seV9zcGFjZXNfcmVtb3ZlZF9hZnRlcjogZWxrc19jaGVja2luZyBpbXBsaWVzIChvbGQgdHdpbikuaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKChvbGQgdHdpbikuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCAxKSArIGNvdW50LCBvbGQgY291bnQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlbW92ZSAoaTogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBgaSctdGggY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCAtIDFcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICB0b19zdHJpbmdfMzIgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpLnRvX3N0cmluZ18zMiArIG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkudG9fc3RyaW5nXzMyKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgcmVzaXplIChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIHN0cmluZyBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gYXQgbGVhc3QgYG5ld3NpemUnIGNoYXJhY3RlcnMuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBuZXdfc2l6ZV9sYXJnZV9lbm91Z2g6IG5ld3NpemUgPj0gY291bnRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGNhcGFjaXR5X2xhcmdlX2Vub3VnaDogY2FwYWNpdHkgPj0gbmV3c2l6ZVxuICAgICAgc2FtZV9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCB0d2luKVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgbXV0YWJsZTogbm90IGlzX2ltbXV0YWJsZVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiT2JqZWN0cyB0aGF0IGNhbiBhY2Nlc3MgYHNldF9jb3VudCcgZnJvbSBTVFJJTkdcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzc1xuICBTVFJJTkdfSEFORExFUlxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ29udGFpbmVycyB3aG9zZSBpdGVtcyBhcmUgYWNjZXNzaWJsZSB0aHJvdWdoIGtleXNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiB0YWJsZSwgYWNjZXNzO1xuICBhY2Nlc3M6IGtleSwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBUQUJMRSBbRywgSF0gaW5oZXJpdFxuXG4gIEJBRyBbR11cbiAgICByZW5hbWVcbiAgICAgIHB1dCBhcyBiYWdfcHV0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChrOiBIKTogRyBhc3NpZ24gZm9yY2VcbiAgICAgIC0tIEVudHJ5IG9mIGtleSBgaycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9rZXkgKGspXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgdmFsaWRfa2V5IChrOiBIKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGsnIGEgdmFsaWQga2V5P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQgKHY6IEc7IGs6IEgpXG4gICAgICAtLSBBc3NvY2lhdGUgdmFsdWUgYHYnIHdpdGgga2V5IGBrJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2tleSAoaylcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGZvcmNlICh2OiBHOyBrOiBIKVxuICAgICAgLS0gQXNzb2NpYXRlIHZhbHVlIGB2JyB3aXRoIGtleSBgaycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9rZXkgKGspXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpdGVtIChrKSA9IHZcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5hcHBsaWNhYmxlXG5cbiAgYmFnX3B1dCAodjogRylcbiAgICBkb1xuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBzcGVjaWFsIG9iamVjdHMsIGZvciBkaXJlY3QgYWNjZXNzIHRvIGFycmF5cyBhbmQgc3RyaW5nc1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzIFRPX1NQRUNJQUwgW1RdXG5cbmNyZWF0ZVxuICBtYWtlX2VtcHR5X2FyZWEsXG4gIG1ha2VfZmlsbGVkX2FyZWFcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBhcmVhOiBTUEVDSUFMIFtUXVxuICAgICAgLS0gU3BlY2lhbCBkYXRhIHpvbmVcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2VtcHR5X2FyZWEgKG46IElOVEVHRVIpXG4gICAgICAtLSBDcmVhdGVzIGEgc3BlY2lhbCBvYmplY3QgZm9yIGBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZW1wdHkgKG4pXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX2FsbG9jYXRlZDogYXJlYSAvPSBWb2lkXG4gICAgICBjYXBhY2l0eV9zZXQ6IGFyZWEuY2FwYWNpdHkgPSBuXG4gICAgICBjb3VudF9zZXQ6IGFyZWEuY291bnQgPSAwXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWRfYXJlYSAoYV9kZWZhdWx0X3ZhbHVlOiBUOyBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlcyBhIHNwZWNpYWwgb2JqZWN0IGZvciBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoYV9kZWZhdWx0X3ZhbHVlLCBuKVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGFyZWEgLz0gVm9pZFxuICAgICAgY2FwYWNpdHlfc2V0OiBhcmVhLmNhcGFjaXR5ID0gblxuICAgICAgY291bnRfc2V0OiBhcmVhLmNvdW50ID0gblxuICAgICAgYXJlYV9maWxsZWQ6IGFyZWEuZmlsbGVkX3dpdGggKGFfZGVmYXVsdF92YWx1ZSwgMCwgbiAtIDEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogVCBhc3NpZ24gcHV0XG4gICAgICAtLSBFbnRyeSBhdCBpbmRleCBgaScsIGlmIGluIGluZGV4IGludGVydmFsXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiBDdXJyZW50P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS52YWxpZF9pbmRleCAoaSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAodjogVDsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYGknLXRoIGVudHJ5LCBpZiBpbiBpbmRleCBpbnRlcnZhbCwgYnkgYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2FyZWEgKG90aGVyOiBsaWtlIGFyZWEpXG4gICAgICAtLSBNYWtlIGBvdGhlcicgdGhlIG5ldyBgYXJlYSdcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlclxuICAgIGVuc3VyZVxuICAgICAgYXJlYV9zZXQ6IGFyZWEgPSBvdGhlclxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==