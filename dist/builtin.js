var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"C_STRING.e","content":"note\n  description: \"A low-level string class to solve some garbage %\n    %collector problems (mainly objects moving around) when %\n    %interfacing with C APIs.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-20 16:35:07 -0800 (Sun, 20 Jan 2013) $\"\n  revision: \"$Revision: 92128 $\"\n\nclass\n  C_STRING\n\ninherit\n  STRING_HANDLER\n\ncreate\n  make,\n  make_empty,\n  make_by_pointer,\n  make_by_pointer_and_count,\n  make_shared_from_pointer,\n  make_shared_from_pointer_and_count,\n  own_from_pointer,\n  own_from_pointer_and_count\n\nfeature {NONE} -- Initialization\n\n  make (a_string: READABLE_STRING_GENERAL)\n      -- Make a C string from `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      a_string_is_valid_as_string_8: a_string.is_valid_as_string_8\n    do\n      make_empty (a_string.count)\n      set_string (a_string)\n    end\n\n  make_empty (a_length: INTEGER)\n      -- Make an empty C string of `a_length' characters.\n      -- C memory area is not initialized.\n    require\n      a_length_positive: a_length >= 0\n    do\n      create managed_data.make (a_length + 1)\n      count := 0\n    end\n\n  make_by_pointer (a_ptr: POINTER)\n      -- Make a copy of string pointed by `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      make_by_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  make_by_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- Make a copy of first `a_length' byte of string pointed by `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      create managed_data.make ((a_length + 1))\n      managed_data.item.memory_copy (a_ptr, a_length)\n    end\n\n  make_shared_from_pointer (a_ptr: POINTER)\n      -- New instance sharing `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      make_shared_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  make_shared_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- New instance sharing `a_ptr' of `a_length' byte.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      create managed_data.share_from_pointer (a_ptr, a_length + 1)\n    end\n\n  own_from_pointer (a_ptr: POINTER)\n      -- New instance using `a_ptr' as memory. Current will free pointed memory\n      -- by `a_ptr' when collected.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      own_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  own_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- New instance using `a_ptr' as memory. Current will free pointed memory\n      -- by `a_ptr' when collected.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      create managed_data.own_from_pointer (a_ptr, a_length)\n    end\n\nfeature -- Initialization\n\n  set_shared_from_pointer (a_ptr: POINTER)\n      -- Share `a_ptr'.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      set_shared_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  set_shared_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- Share `a_ptr' of `a_length' byte.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      count := a_length\n      if not managed_data.is_shared then\n        create managed_data.share_from_pointer (a_ptr, a_length + 1)\n      else\n        managed_data.set_from_pointer (a_ptr, a_length + 1)\n      end\n    end\n\n  share_from_pointer (a_ptr: POINTER)\n      -- New instance sharing `a_ptr'.\n    obsolete\n      \"Use `make_shared_from_pointer' to create object and `set_shared_from_pointer' to modify it.\"\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n    do\n      set_shared_from_pointer_and_count (a_ptr, c_strlen (a_ptr))\n    end\n\n  share_from_pointer_and_count (a_ptr: POINTER; a_length: INTEGER)\n      -- New instance sharing `a_ptr' of `a_length' byte.\n    obsolete\n      \"Use `make_shared_from_pointer_and_count' to create object and `set_shared_from_pointer_and_count' to modify it.\"\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      a_length_non_negative: a_length >= 0\n    do\n      set_shared_from_pointer_and_count (a_ptr, a_length)\n    end\n\nfeature -- Access\n\n  substring (start_pos, end_pos: INTEGER): STRING\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos'.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      create Result.make (l_count)\n      Result.set_count (l_count)\n      read_substring_into (Result, start_pos, end_pos)\n    ensure\n      susbstring_not_void: Result /= Void\n    end\n\n  string: STRING\n      -- Eiffel string, ignoring `count'. Reads until a null character is being read.\n    do\n      Result := substring (1, c_strlen (item))\n    ensure\n      string_not_void: Result /= Void\n    end\n\n  copy_to_string (a_string: STRING_GENERAL; source_index, destination_index, n: INTEGER)\n      -- Copy `n' characters of `Current' from `source_index' position to `a_string' at\n      -- `destination_index'. Other characters of `a_string' remain unchanged.\n    require\n      a_string_not_void: a_string /= Void\n      source_index_positive: source_index >= 1\n      destination_index_positive: destination_index >= 1\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + (n - 1) <= capacity\n      n_is_small_enough_for_destination: destination_index + (n - 1) <= a_string.count\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := source_index - 1\n        j := destination_index\n        nb := source_index + (n - 1)\n        l_data := managed_data\n      until\n        i = nb\n      loop\n        a_string.put_code (l_data.read_natural_8 (i), j)\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  read_substring_into (a_string: STRING_GENERAL; start_pos, end_pos: INTEGER)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n      a_string_large_enough: a_string.count >= end_pos - start_pos + 1\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_pos - 1\n        nb := end_pos - start_pos\n        l_data := managed_data\n        j := 1\n      until\n        i > nb\n      loop\n        a_string.put_code (l_data.read_natural_8 (i), j)\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  read_string_into (a_string: STRING_GENERAL)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_string' replacing any\n      -- existing characters.\n    require\n      a_string_not_void: a_string /= Void\n      a_string_large_enough: a_string.count >= count\n    do\n      read_substring_into (a_string, 1, count)\n    end\n\n  read_substring_into_character_8_area (a_area: SPECIAL [CHARACTER_8]; start_pos, end_pos: INTEGER)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_area'.\n    require\n      a_area_not_void: a_area /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n      a_area_large_enough: a_area.count >= end_pos - start_pos + 1\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_pos - 1\n        nb := end_pos - start_pos\n        l_data := managed_data\n      until\n        i > nb\n      loop\n        a_area.put (l_data.read_natural_8 (i).to_character_8, j)\n        i := i + 1\n        j := j + 1\n      end\n    ensure\n      copied: -- for i in 0..end_pos - start_pos, a_area [i] = Current [i + start_pos]\n    end\n\n  read_substring_into_character_32_area (a_area: SPECIAL [CHARACTER_32]; start_pos, end_pos: INTEGER)\n      -- Copy of substring containing all characters at indices\n      -- between `start_pos' and `end_pos' into `a_area'.\n    require\n      a_area_not_void: a_area /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_position_not_too_big: end_pos <= capacity\n      a_area_large_enough: a_area.count >= end_pos - start_pos + 1\n    local\n      l_data: like managed_data\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_pos - 1\n        nb := end_pos - start_pos\n        l_data := managed_data\n      until\n        i > nb\n      loop\n        a_area.put (l_data.read_natural_8 (i).to_character_32, j)\n        i := i + 1\n        j := j + 1\n      end\n    ensure\n      copied: -- for i in 0..end_pos - start_pos, a_area [i] = Current [i + start_pos]\n    end\n\n  item: POINTER\n      -- Get pointer to allocated area.\n    do\n      Result := managed_data.item\n    ensure\n      item_not_null: Result /= default_pointer\n    end\n\n  managed_data: MANAGED_POINTER\n      -- Hold data of Current.\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Number of characters in Current.\n    do\n      Result := managed_data.count\n    end\n\n  bytes_count: INTEGER\n      -- Number of bytes represented by the string.\n    do\n      Result := count\n    end\n\n  count: INTEGER\n      -- Number of characters in Current.\n\n  character_size: INTEGER = 1\n      -- Size of a character\n\nfeature -- Element change\n\n  set_string (a_string: READABLE_STRING_GENERAL)\n      -- Set `string' with `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      a_string_is_string_8: a_string.is_valid_as_string_8\n    do\n      set_substring (a_string, 1, a_string.count)\n    end\n\n  set_substring (a_string: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER)\n      -- Set `string' with `a_string'.\n    require\n      a_string_not_void: a_string /= Void\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= a_string.count\n    local\n      i, nb: INTEGER\n      new_size: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      count := nb\n\n      new_size := nb + 1\n\n      if managed_data.count < new_size  then\n        managed_data.resize (new_size)\n      end\n\n      from\n        i := 0\n      until\n        i = nb\n      loop\n        managed_data.put_natural_8 (a_string.code (i + start_pos).to_natural_8, i)\n        i := i +  1\n      end\n      managed_data.put_natural_8 (0, nb)\n    end\n\n  set_count (a_count: INTEGER)\n      -- Set `count' with `a_count'.\n      -- Note: Current content from index `1' to\n      -- `count.min (a_count)' is unchanged.\n    require\n      a_count_non_negative: a_count >= 0\n    local\n      new_size: INTEGER\n    do\n      new_size := a_count + 1\n      if managed_data.count < new_size then\n        managed_data.resize (new_size)\n      end\n      count := a_count\n    ensure\n      count_set: count = a_count\n    end\n\n  fill_blank\n      -- Fill Current with zeros.\n    do\n      fill_value (0)\n    ensure\n      -- all_values: For every `i' in 1..`count', `item' (`i') = `0'\n    end\n\n  fill_value (a_value: INTEGER_8)\n      -- Fill Current with `a_value'.\n    do\n      managed_data.item.memory_set (a_value, managed_data.count)\n    ensure\n      -- all_values: For every `i' in 1..`count', `item' (`i') = `a_value'\n    end\n\nfeature {NONE} -- Implementation\n\n  c_strlen (ptr: POINTER): INTEGER\n    external\n      \"C signature (char *): EIF_INTEGER use <string.h>\"\n    alias\n      \"strlen\"\n    end\n\ninvariant\n  managed_data_not_void: managed_data /= Void\n  count_not_negative: count >= 0\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"abstract_special.e","content":"note\n  description: \"Ancestor of SPECIAL to perform queries on SPECIAL without knowing its actual generic type.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-04-12 16:54:50 -0700 (Fri, 12 Apr 2013) $\"\n  revision: \"$Revision: 92440 $\"\n\ndeferred class\n  ABSTRACT_SPECIAL\n\ninherit\n  DEBUG_OUTPUT\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Count of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    deferred\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      create Result.make (12)\n      Result.append_string (\"count=\")\n      Result.append_integer (count)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"active.e","content":"note\n  description: \"[\n    ``Active'' data structures, which at every stage have\n    a possibly undefined ``current item''.\n    Basic access and modification operations apply to the current item.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: active, access\n  access: membership\n  contents: generic\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class ACTIVE [G] inherit\n\n  BAG [G]\n\nfeature -- Access\n\n  item: G\n      -- Current item\n    require\n      readable: readable\n    deferred\n    end\n\nfeature -- Status report\n\n  readable: BOOLEAN\n      -- Is there a current item that may be read?\n    deferred\n    end\n\n  writable: BOOLEAN\n      -- Is there a current item that may be modified?\n    deferred\n    end\n\n  replaceable: BOOLEAN\n      -- Can current item be replaced?\n    do\n      Result := True\n    end\n\nfeature -- Element change\n\n  replace (v: G)\n      -- Replace current item by `v'.\n    require\n      writable: writable\n      replaceable: replaceable\n    deferred\n    ensure\n      item_replaced: item = v\n    end\n\nfeature -- Removal\n\n  remove\n      -- Remove current item.\n    require\n      prunable: prunable\n      writable: writable\n    deferred\n    end\n\ninvariant\n\n  writable_constraint: writable implies readable\n  empty_constraint: is_empty implies (not readable) and (not writable)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"any.e","content":"class\n  ANY\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    external\n      \"built_in\"\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n  frozen do_nothing\n      -- Execute a null action.\n    do\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\n\nend\n"});
__eiffel_builtin.push({"filename":"array.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 14:18:20 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92138 $\"\n\nclass ARRAY [G] inherit\n\n  RESIZABLE [G]\n    redefine\n      full, copy, is_equal, resizable\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as item alias \"[]\"\n    redefine\n      copy, is_equal\n    end\n\n  TO_SPECIAL [G]\n    export\n      {ARRAY} set_area\n    redefine\n      copy, is_equal, item, put, at, valid_index\n    end\n\ncreate\n  make_empty,\n  make,\n  make_filled,\n  make_from_array,\n  make_from_special,\n  make_from_cil\n\nconvert\n  to_cil: {NATIVE_ARRAY [G]},\n  to_special: {SPECIAL [G]},\n  make_from_cil ({NATIVE_ARRAY [G]})\n\nfeature -- Initialization\n\n  make_empty\n      -- Allocate empty array starting at `1'.\n    do\n      lower := 1\n      upper := 0\n      make_empty_area (0)\n    ensure\n      lower_set: lower = 1\n      upper_set: upper = 0\n      items_set: all_default\n    end\n\n  make_filled (a_default_value: G; min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    require\n      valid_bounds: min_index <= max_index + 1\n    local\n      n: INTEGER\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        n := max_index - min_index + 1\n      end\n      make_filled_area (a_default_value, n)\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: filled_with (a_default_value)\n    end\n\n  make (min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    obsolete\n      \" `make' is not void-safe statically. Use `make_empty' or `make_filled' instead. [07-2010]\"\n    require\n      valid_bounds: min_index <= max_index + 1\n      has_default: min_index <= max_index implies ({G}).has_default\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        make_filled_area (({G}).default, max_index - min_index + 1)\n      else\n        make_empty_area (0)\n      end\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: all_default\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Initialize from the items of `a'.\n      -- (Useful in proper descendants of class `ARRAY',\n      -- to initialize an array-like object from a manifest array.)\n    require\n      array_exists: a /= Void\n    do\n      set_area (a.area)\n      lower := a.lower\n      upper := a.upper\n    ensure\n      shared: area = a.area\n      lower_set: lower = a.lower\n      upper_set: upper = a.upper\n    end\n\n  make_from_special (a: SPECIAL [G])\n      -- Initialize Current from items of `a'.\n    require\n      special_attached: a /= Void\n    do\n      set_area (a)\n      lower := 1\n      upper := a.count\n    ensure\n      shared: area = a\n      lower_set: lower = 1\n      upper_set: upper = a.count\n    end\n\n  make_from_cil (na: NATIVE_ARRAY [like item])\n      -- Initialize array from `na'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      na_not_void: na /= Void\n    do\n      create area.make_from_native_array (na)\n      lower := 1\n      upper := area.count\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): G assign put\n      -- Entry at index `i', if in index interval\n    do\n      Result := area.item (i - lower)\n    end\n\n  entry (i: INTEGER): G\n      -- Entry at index `i', if in index interval\n    require\n      valid_key: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  has (v: G): BOOLEAN\n      -- Does `v' appear in array?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      l_area := area\n      nb := upper - lower\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) ~ v\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) = v\n          i := i + 1\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER\n      -- Minimum index\n\n  upper: INTEGER\n      -- Maximum index\n\n  count, capacity: INTEGER\n      -- Number of available indices\n    do\n      Result := upper - lower + 1\n    ensure then\n      consistent_with_bounds: Result = upper - lower + 1\n    end\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n    local\n      i: INTEGER\n    do\n      if object_comparison then\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) ~ v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      else\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) = v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    ensure then\n      same_count: Result.count = count\n      same_bounds:\n        ((Result.lower = lower) and (Result.upper = upper))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif lower = other.lower and then upper = other.upper and then\n        object_comparison = other.object_comparison\n      then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := item (i) ~ other.item (i)\n            i := i + 1\n          end\n        else\n          Result := area.same_items (other.area, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    do\n      if count > 0 then\n        Result := ({G}).has_default and then area.filled_with (({G}).default, 0, upper - lower)\n      else\n        Result := True\n      end\n    ensure\n      definition: Result = (count = 0 or else\n        ((not attached item (upper) as i or else i = ({G}).default) and\n        subarray (lower, upper - 1).all_default))\n    end\n\n  filled_with (v: G): BOOLEAN\n      -- Are all items set to `v'?\n    do\n      Result := area.filled_with (v, 0, upper - lower)\n    ensure\n      definition: Result = (count = 0 or else\n        (item (upper) = v and subarray (lower, upper - 1).filled_with (v)))\n    end\n\n  full: BOOLEAN\n      -- Is structure filled to capacity? (Answer: yes)\n    do\n      Result := True\n    end\n\n  same_items (other: like Current): BOOLEAN\n      -- Do `other' and Current have same items?\n    require\n      other_not_void: other /= Void\n    do\n      if count = other.count then\n        Result := area.same_items (other.area, 0, 0, count)\n      end\n    ensure\n      definition: Result = ((count = other.count) and then\n        (count = 0 or else (item (upper) = other.item (other.upper)\n        and subarray (lower, upper - 1).same_items\n        (other.subarray (other.lower, other.upper - 1)))))\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the array?\n    do\n      Result := (lower <= i) and then (i <= upper)\n    end\n\n  extendible: BOOLEAN\n      -- May items be added?\n      -- (Answer: no, although array may be resized.)\n    do\n      Result := False\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: no.)\n    do\n      Result := False\n    end\n\n  resizable: BOOLEAN\n      -- Can array be resized automatically?\n    do\n      Result := ({G}).has_default\n    end\n\n  valid_index_set: BOOLEAN\n    do\n      Result := index_set.count = count\n    end\n\nfeature -- Element change\n\n  put (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area.put (v, i - lower)\n    end\n\n  enter (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_key: valid_index (i)\n    do\n      area.put (v, i - lower)\n    end\n\n  force (v: like item; i: INTEGER)\n      -- Assign item `v' to `i'-th entry.\n      -- Resize the array if `i' falls out of currently defined bounds; preserve existing items.\n      -- In void-safe mode, if ({G}).has_default does not hold, then you can only insert between\n      -- `lower - 1' or `upper + 1' position in the ARRAY.\n    require\n      has_default_if_too_low:\n        (i < lower - 1 and lower /= {like lower}.min_value) implies ({G}).has_default\n      has_default_if_too_high:\n        (i > upper + 1 and upper /= {like upper}.max_value) implies ({G}).has_default\n    local\n      old_size, new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      l_count, l_offset: INTEGER\n      l_increased_by_one: BOOLEAN\n    do\n      new_lower := lower.min (i)\n      new_upper := upper.max (i)\n      new_size := new_upper - new_lower + 1\n      l_increased_by_one := (i = upper + 1) or (i = lower - 1)\n      if empty_area then\n          -- List is empty. First we create an empty SPECIAL of the right capacity.\n        make_empty_area (new_size.max (additional_space))\n        if not l_increased_by_one then\n            -- We need to fill the SPECIAL for `0' to `new_size - 2' with the default value.\n          area.fill_with (({G}).default, 0, new_size - 2)\n        end\n        area.extend (v)\n      else\n        old_size := area.capacity\n        if new_size > old_size then\n          set_area (area.aliased_resized_area (new_size.max (old_size + additional_space)))\n        end\n        if new_lower < lower then\n            -- We have inserted below the previous `lower'. We need to shift entries to the right\n            -- before we can insert `v'.\n          l_offset := lower - new_lower\n          l_count := capacity\n          if not l_increased_by_one and l_offset > l_count then\n              -- With the `new_lower' given, the data has to move\n              -- beyond the `area''s count which requires us to fill\n              -- the gap between the old data's location and the new one\n              -- with the default value.\n            area.fill_with (({G}).default, l_count, l_offset - 1)\n          end\n          area.move_data (0, l_offset, l_count)\n          if not l_increased_by_one then\n              -- We start at `1' and not `0' because next instruction\n              -- will update the item at position `0'.\n            area.fill_with (({G}).default, 1, l_offset - 1)\n          end\n            -- Insert `v' at the new lower position.\n          area.put (v, 0)\n        else\n          if new_size > area.count then\n              -- We are adding to the new `upper' position. First we fill the non-initialized\n              -- elements if any up to `new_size - 2' (i.e. up the the item prior to `upper').\n            if not l_increased_by_one then\n              area.fill_with (({G}).default, area.count, new_size - 2)\n            end\n              -- Add `v' at upper position.\n            area.extend (v)\n          else\n              -- Here `lower' hasn't changed\n            area.put (v, i - lower)\n          end\n        end\n      end\n      lower := new_lower\n      upper := new_upper\n    ensure\n      inserted: item (i) = v\n      higher_count: count >= old count\n      lower_set: lower = (old lower).min (i)\n      upper_set: upper = (old upper).max (i)\n    end\n\n  fill_with (v: G)\n      -- Set items between `lower' and `upper' with `v'.\n    do\n      area.fill_with (v, 0, upper - lower)\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = old count\n      filled: filled_with (v)\n    end\n\n  subcopy (other: ARRAY [like item]; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy items of `other' within bounds `start_pos' and `end_pos'\n      -- to current array starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: start_pos >= other.lower\n      valid_end_pos: end_pos <= other.upper\n      valid_bounds: start_pos <= end_pos + 1\n      valid_index_pos: index_pos >= lower\n      enough_space: (upper - index_pos) >= (end_pos - start_pos)\n    do\n      area.copy_data (other.area, start_pos - other.lower, index_pos - lower, end_pos - start_pos + 1)\n    ensure\n      -- copied: forall `i' in 0 .. (`end_pos'-`start_pos'),\n      --     item (index_pos + i) = other.item (start_pos + i)\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    do\n      area.do_all_in_bounds (action, 0, count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    do\n      area.do_if_in_bounds (action, test, 0, count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.there_exists_in_bounds (test, 0, count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.for_all_in_bounds (test, 0, count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Removal\n\n  wipe_out\n      -- Make array empty.\n    obsolete\n      \"Not applicable since not `prunable'. Use `discard_items' instead.\"\n    do\n      discard_items\n    end\n\n  discard_items\n      -- Reset all items to default values with reallocation.\n    require\n      has_default: ({G}).has_default\n    do\n      create area.make_filled (({G}).default, capacity)\n    ensure\n      default_items: all_default\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    require\n      has_default: ({G}).has_default\n    do\n      area.fill_with (({G}).default, 0, area.count - 1)\n    ensure\n      stable_lower: lower = old lower\n      stable_upper: upper = old upper\n      default_items: all_default\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all items except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    do\n      if n < count then\n        upper := lower + n - 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_lower: lower = old lower\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all items except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        lower := upper - n + 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_upper: upper = old upper\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_upper: upper = old upper\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_head (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_lower: lower = old lower\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > capacity then\n        conservative_resize_with_default (({G}).default, lower, upper + i - capacity)\n      end\n    end\n\n  conservative_resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \" `conservative_resize' is not void-safe statically. Use `conservative_resize_with_default' instead. [07-2010]\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  conservative_resize_with_default (a_default_value: G; min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    require\n      good_indices: min_index <= max_index\n    local\n      new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      offset: INTEGER\n    do\n      if empty_area then\n        set_area (area.aliased_resized_area_with_default (a_default_value, max_index - min_index + 1))\n        lower := min_index\n        upper := max_index\n      else\n        new_lower := min_index.min (lower)\n        new_upper := max_index.max (upper)\n        new_size := new_upper - new_lower + 1\n        if new_size > area.count then\n          set_area (area.aliased_resized_area_with_default (a_default_value, new_size))\n        end\n        if new_lower < lower then\n          offset := lower - new_lower\n          area.move_data (0, offset, upper - lower + 1)\n          area.fill_with (a_default_value, 0, offset - 1)\n        end\n        lower := new_lower\n        upper := new_upper\n      end\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \"Use `conservative_resize_with_default' instead as future versions will implement `resize' as specified in ELKS.\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area.capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: same_items (old twin)\n    end\n\n  rebase (a_lower: like lower)\n      -- Without changing the actual content of `Current' we set `lower' to `a_lower'\n      -- and `upper' accordingly to `a_lower + count - 1'.\n    local\n      l_old_lower: like lower\n    do\n      l_old_lower := lower\n      lower := a_lower\n      upper := a_lower + (upper - l_old_lower)\n    ensure\n      lower_set: lower = a_lower\n      upper_set: upper = a_lower + old count - 1\n    end\n\nfeature -- Conversion\n\n  to_c: ANY\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    do\n      Result := area\n    end\n\n  to_cil: NATIVE_ARRAY [G]\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := area.native_array\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_special: SPECIAL [G]\n      -- 'area'.\n    do\n      Result := area\n    ensure\n      to_special_not_void: Result /= Void\n    end\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [G]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := lower\n      until\n        i > upper\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area.twin)\n      end\n    ensure then\n      equal_areas: area ~ other.area\n    end\n\n  subarray (start_pos, end_pos: INTEGER): ARRAY [G]\n      -- Array made of items of current array within\n      -- bounds `start_pos' and `end_pos'.\n    require\n      valid_start_pos: valid_index (start_pos)\n      valid_end_pos: end_pos <= upper\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n    do\n      if start_pos <= end_pos then\n        create Result.make_filled (item (start_pos), start_pos, end_pos)\n          -- Only copy elements if needed.\n        Result.subcopy (Current, start_pos, end_pos, start_pos)\n      else\n          -- make empty\n        create Result.make_empty\n        Result.rebase (start_pos)\n      end\n    ensure\n      lower: Result.lower = start_pos\n      upper: Result.upper = end_pos\n      -- copied: forall `i' in `start_pos' .. `end_pos',\n      --     Result.item (i) = item (i)\n    end\n\nfeature {NONE} -- Inapplicable\n\n  prune (v: G)\n      -- Remove first occurrence of `v' if any.\n      -- (Precondition is False.)\n    do\n    end\n\n  extend (v: G)\n      -- Add `v' to structure.\n      -- (Precondition is False.)\n    do\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: BOOLEAN\n      -- Is `area' empty?\n    do\n      Result := area = Void or else area.capacity = 0\n    end\n\ninvariant\n\n  area_exists: area /= Void\n  consistent_size: capacity = upper - lower + 1\n  non_negative_count: count >= 0\n  index_set_has_same_count: valid_index_set\n-- Internal discussion haven't reached an agreement on this invariant\n--  index_set_has_same_bounds: ((index_set.lower = lower) and\n--        (index_set.upper = lower + count - 1))\n\nend\n"});
__eiffel_builtin.push({"filename":"arrayed_list.e","content":"note\n  description: \"Lists implemented by resizable arrays\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: sequence;\n  representation: array;\n  access: index, cursor, membership;\n  size: fixed;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass ARRAYED_LIST [G] inherit\n\n  TO_SPECIAL [G]\n    rename\n      put as array_put,\n      at as array_at,\n      item as array_item,\n      valid_index as array_valid_index,\n      area as area_v2\n    redefine\n      is_equal, copy\n    end\n\n  RESIZABLE [G]\n    redefine\n      is_equal, copy\n    end\n\n  DYNAMIC_LIST [G]\n    undefine\n      put_i_th,\n      force, is_inserted, copy\n    redefine\n      first, last, swap, wipe_out, i_th, at,\n      go_i_th, move, prunable, start, finish,\n      count, prune, remove,\n      put_left, merge_left,\n      merge_right, duplicate, prune_all, has, search,\n      append, valid_index, is_equal, copy,\n      for_all, there_exists, do_all, do_if\n    end\n\n  MISMATCH_CORRECTOR\n    redefine\n      is_equal, copy, correct_mismatch\n    end\n\ncreate\n  make, make_filled, make_from_array\n\nfeature -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate list with `n' items.\n      -- (`n' may be zero for empty list.)\n    require\n      valid_number_of_items: n >= 0\n    do\n      index := 0\n      create area_v2.make_empty (n)\n    ensure\n      correct_position: before\n      is_empty: is_empty\n    end\n\n  make_filled (n: INTEGER)\n      -- Allocate list with `n' items.\n      -- (`n' may be zero for empty list.)\n      -- This list will be full.\n    require\n      valid_number_of_items: n >= 0\n      has_default: ({G}).has_default\n    do\n      index := 0\n      make_filled_area (({G}).default, n)\n    ensure\n      correct_position: before\n      filled: full\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Create list from array `a'.\n    require\n      array_exists: a /= Void\n    do\n      index := 0\n      area_v2 := a.area\n    ensure\n      shared: area = a.area\n      correct_position: before\n      filled: count = a.count\n    end\n\nfeature -- Access\n\n  area: SPECIAL [G]\n      -- Access to internal storage of ARRAYED_LIST\n    do\n        -- Internal storage is called `area_v2' so that it triggers\n        -- a mismatch during retrieval.\n      Result := area_v2\n    end\n\n  item: G\n      -- Current item\n    require else\n      index_is_valid: valid_index (index)\n    do\n      Result := area_v2.item (index - 1)\n    end\n\n  i_th alias \"[]\", at alias \"@\" (i: INTEGER): like item assign put_i_th\n      -- Item at `i'-th position\n    do\n      Result := area_v2.item (i - 1)\n    end\n\n  first: like item\n      -- Item at first position\n    do\n      Result := area_v2.item (0)\n    end\n\n  last: like first\n      -- Item at last position\n    do\n      Result := area_v2.item (count - 1)\n    end\n\n  index: INTEGER\n      -- Index of `item', if valid.\n\n  cursor: ARRAYED_LIST_CURSOR\n      -- Current cursor position\n    do\n      create Result.make (index)\n    end\n\n  has (v: like item): BOOLEAN\n      -- Does current include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      l_area: like area_v2\n      i, nb: INTEGER\n    do\n      l_area := area_v2\n      nb := count - 1\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := v ~ l_area.item (i)\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := v = l_area.item (i)\n          i := i + 1\n        end\n      end\n    end\n\n  to_array: ARRAY [G]\n      -- Share content to be used as an ARRAY.\n      -- Note that although the content is shared, it might\n      -- not be shared when a resizing occur in either ARRAY or Current.\n    do\n      create Result.make_from_special (area_v2)\n    ensure\n      to_array_attached: Result /= Void\n      array_lower_set: Result.lower = 1\n      array_upper_set: Result.upper = count\n      shared_area: Result.area = area\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    do\n      area_v2.do_all_in_bounds (action, 0, area_v2.count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    do\n      area_v2.do_if_in_bounds (action, test, 0, area_v2.count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    do\n      Result := area_v2.there_exists_in_bounds (test, 0, area_v2.count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    do\n      Result := area_v2.for_all_in_bounds (test, 0, area_v2.count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, j, nb: INTEGER\n      l_area: like area_v2\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area_v2\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, j, nb: INTEGER\n      l_area: like area_v2\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area_v2\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER = 1\n      -- Lower bound for accessing list items via indexes\n\n  upper: INTEGER\n      -- Upper bound for accessing list items via indexes\n    do\n      Result := area_v2.count\n    end\n\n  count: INTEGER\n      -- Number of items\n    do\n      Result := area_v2.count\n    end\n\n  capacity: INTEGER\n    do\n      Result := area_v2.capacity\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif count = other.count and then object_comparison = other.object_comparison then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := i_th (i) ~ other.i_th (i)\n            i := i + 1\n          end\n        else\n          Result := area_v2.same_items (other.area_v2, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  valid_cursor (p: CURSOR): BOOLEAN\n      -- Can the cursor be moved to position `p'?\n    do\n      if attached {ARRAYED_LIST_CURSOR} p as al_c then\n        Result := valid_cursor_index (al_c.index)\n      end\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' a valid index?\n    do\n      Result := (1 <= i) and (i <= count)\n    end\n\n  is_inserted (v: G): BOOLEAN\n      -- Has `v' been inserted at the end by the most recent `put' or\n      -- `extend'?\n    do\n      if not is_empty then\n        Result := (v = last) or else (not off and then (v = item))\n      end\n    end\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    require\n      has_default: ({G}).has_default\n    do\n      Result := area_v2.filled_with (({G}).default, 0, area_v2.upper)\n    end\n\nfeature -- Cursor movement\n\n  move (i: INTEGER)\n      -- Move cursor `i' positions.\n    do\n      index := index + i\n      if (index > count + 1) then\n        index := count + 1\n      elseif (index < 0) then\n        index := 0\n      end\n    end\n\n  start\n      -- Move cursor to first position if any.\n    do\n      index := 1\n    ensure then\n      after_when_empty: is_empty implies after\n    end\n\n  finish\n      -- Move cursor to last position if any.\n    do\n      index := count\n    ensure then\n      before_when_empty: is_empty implies before\n    end\n\n  forth\n      -- Move cursor one position forward.\n    do\n      index := index + 1\n    end\n\n  back\n      -- Move cursor one position backward.\n    do\n      index := index - 1\n    end\n\n  go_i_th (i: INTEGER)\n      -- Move cursor to `i'-th position.\n    do\n      index := i\n    end\n\n  go_to (p: CURSOR)\n      -- Move cursor to position `p'.\n    do\n      if attached {ARRAYED_LIST_CURSOR} p as al_c then\n        index := al_c.index\n      else\n        check\n          correct_cursor_type: False\n        end\n      end\n    end\n\n  search (v: like item)\n      -- Move to first position (at or after current\n      -- position) where `item' and `v' are equal.\n      -- If structure does not include `v' ensure that\n      -- `exhausted' will be true.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      l_area: like area_v2\n      i, nb: INTEGER\n      l_found: BOOLEAN\n    do\n      l_area := area_v2\n      nb := count - 1\n        -- If we are before we need to be sure\n        -- that i is positive.\n      i := (index - 1).max (0)\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or l_found\n        loop\n          l_found := v ~ l_area.item (i)\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or l_found\n        loop\n          l_found := v = l_area.item (i)\n          i := i + 1\n        end\n      end\n        -- Set position of `index' to `i', location of item when\n        -- found, otherwise to `i + 1' which corresponds to `after'.\n      if l_found then\n        index := i\n      else\n        index := i + 1\n      end\n    end\n\nfeature -- Element change\n\n  put_front (v: like item)\n      -- Add `v' to the beginning.\n      -- Do not move cursor.\n    do\n      if is_empty then\n        extend (v)\n      else\n        insert (v, 1)\n      end\n      index := index + 1\n    end\n\n  put_i_th (v: like i_th; i: INTEGER_32)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area_v2.put (v, i - 1)\n    end\n\n  force, extend (v: like item)\n      -- Add `v' to end.\n      -- Do not move cursor.\n    local\n      i: INTEGER\n      l_area: like area_v2\n    do\n      i := count + 1\n      l_area := area_v2\n      if i > l_area.capacity then\n        l_area := l_area.aliased_resized_area (i + additional_space)\n        area_v2 := l_area\n      end\n      l_area.extend (v)\n    end\n\n  put_left (v: like item)\n      -- Add `v' to the left of current position.\n      -- Do not move cursor.\n    do\n      if after or is_empty then\n        extend (v)\n      else\n        insert (v, index)\n      end\n      index := index + 1\n    end\n\n  put_right (v: like item)\n      -- Add `v' to the right of current position.\n      -- Do not move cursor.\n    do\n      if index = count then\n        extend (v)\n      else\n        insert (v, index + 1)\n      end\n    end\n\n  replace (v: like first)\n      -- Replace current item by `v'.\n    do\n      put_i_th (v, index)\n    end\n\n  merge_left (other: ARRAYED_LIST [G])\n      -- Merge `other' into current structure before cursor.\n    local\n      old_index: INTEGER\n      old_other_count: INTEGER\n    do\n      old_index := index\n      old_other_count := other.count\n      index := index - 1\n      merge_right (other)\n      index := old_index + old_other_count\n    end\n\n  merge_right (other: ARRAYED_LIST [G])\n      -- Merge `other' into current structure after cursor.\n    local\n      l_new_count, l_old_count: INTEGER\n    do\n      if not other.is_empty then\n        l_old_count := count\n        l_new_count := l_old_count + other.count\n        if l_new_count > area_v2.capacity then\n          area_v2 := area_v2.aliased_resized_area (l_new_count)\n        end\n        area_v2.insert_data (other.area_v2, 0, index, other.count)\n        other.wipe_out\n      end\n    end\n\n  append (s: SEQUENCE [G])\n      -- Append a copy of `s'.\n    local\n      c, old_count, new_count: INTEGER\n    do\n      if attached {ARRAYED_LIST [G]} s as al then -- Optimization for arrayed lists\n        c := al.count\n          -- If `s' is empty nothing to be done.\n        if c > 0 then\n          old_count := count\n          new_count := old_count + al.count\n          if new_count > area_v2.capacity then\n            area_v2 := area_v2.aliased_resized_area (new_count)\n          end\n          area_v2.copy_data (al.area_v2, 0, old_count, c)\n        end\n      else\n        Precursor {DYNAMIC_LIST} (s)\n      end\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > area_v2.capacity then\n        area_v2 := area_v2.aliased_resized_area (i)\n      end\n    end\n\n  resize (new_capacity: INTEGER)\n      -- Resize list so that it can contain\n      -- at least `n' items. Do not lose any item.\n    require\n      resizable: resizable\n      new_capacity_large_enough: new_capacity >= capacity\n    do\n      grow (new_capacity)\n    ensure\n      capacity_set: capacity >= new_capacity\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area_v2.capacity then\n        area_v2 := area_v2.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: to_array.same_items (old to_array)\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area_v2.twin)\n      end\n    ensure then\n      equal_areas: area_v2 ~ other.area_v2\n    end\n\nfeature -- Removal\n\n  prune (v: like item)\n      -- Remove first occurrence of `v', if any,\n      -- after cursor position.\n      -- Move cursor to right neighbor.\n      -- (or `after' if no right neighbor or `v' does not occur)\n    do\n      if before then\n        index := 1\n      end\n      if object_comparison then\n        from\n        until\n          after or else item ~ v\n        loop\n          forth\n        end\n      else\n        from\n        until\n          after or else item = v\n        loop\n          forth\n        end\n      end\n      if not after then\n        remove\n      end\n    end\n\n  remove\n      -- Remove current item.\n      -- Move cursor to right neighbor\n      -- (or `after' if no right neighbor)\n    do\n      if index < count then\n        area_v2.move_data (index, index - 1, count - index)\n      end\n      area_v2.remove_tail (1)\n    ensure then\n      index: index = old index\n    end\n\n  prune_all (v: like item)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      offset: INTEGER\n      res: BOOLEAN\n      obj_cmp: BOOLEAN\n      l_area: like area_v2\n    do\n      obj_cmp := object_comparison\n      from\n        l_area := area_v2\n        i := 0\n        nb := count\n      until\n        i = count\n      loop\n        if i < nb - offset then\n          if offset > 0 then\n            l_area.put (l_area.item (i + offset), i)\n          end\n          if obj_cmp then\n            res := v ~ l_area.item (i)\n          else\n            res := v = l_area.item (i)\n          end\n          if res then\n            offset := offset + 1\n          else\n            i := i + 1\n          end\n        else\n          i := i + 1\n        end\n      end\n      l_area.remove_tail (offset)\n      index := count + 1\n    ensure then\n      is_after: after\n    end\n\n  remove_left\n      -- Remove item to the left of cursor position.\n      -- Do not move cursor.\n    do\n      index := index - 1\n      remove\n    end\n\n  remove_right\n      -- Remove item to the right of cursor position\n      -- Do not move cursor\n    do\n      index := index + 1\n      remove\n      index := index - 1\n    end\n\n  wipe_out\n      -- Remove all items.\n    do\n      area_v2.wipe_out\n      index := 0\n    end\n\nfeature -- Transformation\n\n  swap (i: INTEGER)\n      -- Exchange item at `i'-th position with item\n      -- at cursor position.\n    local\n      old_item: like item\n    do\n      old_item := item\n      replace (area_v2.item (i - 1))\n      area_v2.put (old_item, i - 1)\n    end\n\nfeature -- Retrieval\n\n  correct_mismatch\n    local\n      i: INTEGER\n    do\n      if\n        not mismatch_information.has (\"area_v2\") and then\n        attached {SPECIAL [G]} mismatch_information.item (\"area\") as l_area and then\n        attached {INTEGER} mismatch_information.item (\"count\") as l_count and then\n        attached {BOOLEAN} mismatch_information.item (\"object_comparison\") as l_comp and then\n        attached {INTEGER} mismatch_information.item (\"index\") as l_index\n      then\n        create area_v2.make_empty (l_count)\n        from\n          i := 0\n        until\n          i = l_count\n        loop\n          area_v2.extend (l_area.item (i))\n          i := i + 1\n        end\n        object_comparison := l_comp\n        index := l_index\n      else\n        Precursor\n      end\n    end\n\nfeature -- Duplication\n\n  duplicate (n: INTEGER): like Current\n      -- Copy of sub-list beginning at current position\n      -- and having min (`n', `count' - `index' + 1) items.\n    local\n      end_pos: INTEGER\n    do\n      if after then\n        Result := new_filled_list (0)\n      else\n        end_pos := count.min (index + n - 1)\n        Result := new_filled_list (end_pos - index + 1)\n        Result.area_v2.copy_data (area_v2, index - 1, 0, end_pos - index + 1)\n      end\n    end\n\nfeature {NONE} -- Inapplicable\n\n  new_chain: like Current\n      -- Unused\n    do\n      Result := Current\n    end\n\nfeature {NONE} -- Implementation\n\n  force_i_th (v: like i_th; pos: INTEGER)\n    do\n      if count + 1 > capacity then\n        grow (count + additional_space)\n      end\n      area_v2.force (v, pos)\n    end\n\n  insert (v: like item; pos: INTEGER)\n      -- Add `v' at `pos', moving subsequent items\n      -- to the right.\n    require\n      index_small_enough: pos <= count\n      index_large_enough: pos >= 1\n    do\n      if count + 1 > capacity then\n        grow (count + additional_space)\n      end\n      area_v2.move_data (pos - 1, pos, count - pos + 1)\n      put_i_th (v, pos)\n    ensure\n      new_count: count = old count + 1\n      index_unchanged: index = old index\n      insertion_done: i_th (pos) = v\n    end\n\n  new_filled_list (n: INTEGER): like Current\n      -- New list with `n' elements.\n    require\n      n_non_negative: n >=0\n    do\n      create Result.make (n)\n    ensure\n      new_filled_list_not_void: Result /= Void\n      new_filled_list_count_set: Result.count = 0\n      new_filled_list_before: Result.before\n    end\n\ninvariant\n  prunable: prunable\n  starts_from_one: lower = 1\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"bag.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bag, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BAG [G] inherit\n\n  COLLECTION [G]\n    redefine\n      extend\n    end\n\nfeature -- Measurement\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      non_negative_occurrences: Result >= 0\n    end\n\nfeature -- Element change\n\n  extend (v: G)\n      -- Add a new occurrence of `v'.\n    deferred\n    ensure then\n        -- Commented due to the expensive nature of the check when inserting a new item\n        -- in a containers with many items.\n      -- one_more_occurrence: occurrences (v) = old (occurrences (v)) + 1\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"bilinear.e","content":"note\n  description: \"Structures that may be traversed forward and backward\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bidirectional, traversing;\n  access: cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BILINEAR [G] inherit\n\n  LINEAR [G]\n    rename\n      search as sequential_search\n    export\n      {NONE}\n        sequential_search\n    redefine\n      off\n    end\n\n  LINEAR [G]\n    redefine\n      search, off\n    select\n      search\n    end\n\nfeature -- Access\n\n  off: BOOLEAN\n      -- Is there no current item?\n    do\n      Result := before or after\n    end\n\nfeature -- Cursor movement\n\n  before: BOOLEAN\n      -- Is there no valid position to the left of current one?\n    deferred\n    end\n\n  back\n      -- Move to previous position.\n    require\n      not_before: not before\n    deferred\n    ensure then\n      -- moved_forth_after_start: (not before) implies index = old index - 1\n    end\n\n  search (v: like item)\n      -- Move to first position (at or after current\n      -- position) where `item' and `v' are equal.\n      -- If structure does not include `v' ensure that\n      -- `exhausted' will be true.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    do\n      if before and not is_empty then\n        forth\n      end\n      sequential_search (v)\n    end\n\ninvariant\n\n  not_both: not (after and before)\n  before_constraint: before implies off\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"boolean.e","content":"note\n  description: \"Truth values, with the boolean operations\"\n  external_name: \"System.Boolean\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class BOOLEAN\n\ninherit\n  BOOLEAN_REF\n    redefine\n      conjuncted,\n      conjuncted_semistrict,\n      disjuncted,\n      disjuncted_semistrict,\n      disjuncted_exclusive,\n      implication,\n      negated\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({BOOLEAN_REF})\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: BOOLEAN): BOOLEAN\n      -- Boolean conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  implication alias \"implies\" (other: BOOLEAN): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    external\n      \"built_in\"\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    external\n      \"built_in\"\n    end\n\n  disjuncted alias \"or\" (other: BOOLEAN): BOOLEAN\n      -- Boolean disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: BOOLEAN): BOOLEAN\n      -- Boolean exclusive or with `other'\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"boolean_ref.e","content":"note\n  description: \"References to objects containing a boolean value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass BOOLEAN_REF inherit\n\n  HASHABLE\n    redefine\n      out\n    end\n\nfeature -- Access\n\n  item: BOOLEAN\n      -- Boolean value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      if item then\n        Result := 1\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: BOOLEAN_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: BOOLEAN_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n      same_item: Result.item = item\n    end\n\n  to_integer: INTEGER\n      -- 1 if `True'\n      -- 0 if `False'\n    do\n      if item then\n        Result := 1\n      end\n    ensure\n      not_item_implies_zero: not item implies Result = 0\n      item_implies_one: item implies Result = 1\n    end\n\nfeature -- Element change\n\n  set_item (b: BOOLEAN)\n      -- Make `b' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: like Current): BOOLEAN\n      -- Boolean conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and other.item\n    ensure\n      de_morgan: Result = not (not Current or not other)\n      commutative: Result = (other and Current)\n      consistent_with_semi_strict: Result implies (Current and then other)\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and then other.item\n    ensure\n      de_morgan: Result = not (not Current or else not other)\n    end\n\n  implication alias \"implies\" (other: like Current): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    require\n      other_exists: other /= Void\n    do\n      Result := item implies other.item\n    ensure\n      definition: Result = (not Current or else other)\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    do\n      Result := not item\n    end\n\n  disjuncted alias \"or\" (other: like Current): BOOLEAN\n      -- Boolean disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or other.item\n    ensure\n      de_morgan: Result = not (not Current and not other)\n      commutative: Result = (other or Current)\n      consistent_with_semi_strict: Result implies (Current or else other)\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or else other.item\n    ensure\n      de_morgan: Result = not (not Current and then not other)\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: like Current): BOOLEAN\n      -- Boolean exclusive or with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item xor other.item\n    ensure\n      definition: Result = ((Current or other) and not (Current and other))\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of boolean\n    do\n      Result := \"False\"\n      if item then\n        Result := \"True\"\n      end\n    end\n\ninvariant\n  involutive_negation: (not (not Current)).item = item\n  non_contradiction: not ((not Current) and Current)\n  completeness: (not Current) or Current\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"bounded.e","content":"note\n  description: \"Bounded data structures, with a notion of capacity.\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bounded, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOUNDED [G] inherit\n\n  FINITE [G]\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Number of items that may be stored\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure full?\n    do\n      Result := (count = capacity)\n    end\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed?\n    deferred\n    end\n\ninvariant\n\n  valid_count: count <= capacity\n  full_definition: full = (count = capacity)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"box.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOX [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure filled to capacity?\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"cell.e","content":"note\n  description: \"Cells containing an item\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: cell;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\nclass CELL [G]\n\ncreate\n  put\n\nfeature -- Access\n\n  item: G\n      -- Content of cell.\n\nfeature -- Element change\n\n  put, replace (v: like item)\n      -- Make `v' the cell's `item'.\n    do\n      item := v\n    ensure\n      item_inserted: item = v\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"chain.e","content":"note\n  description: \"[\n    Possibly circular sequences of items,\n    without commitment to a particular representation\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: chain, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2013-01-15 13:41:22 -0800 (Tue, 15 Jan 2013) $\"\n  revision: \"$Revision: 92122 $\"\n\ndeferred class CHAIN [G] inherit\n\n  CURSOR_STRUCTURE [G]\n    rename\n      put as sequence_put\n    undefine\n      prune_all\n    redefine\n      fill\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as i_th alias \"[]\",\n      put as put_i_th,\n      bag_put as sequence_put\n    undefine\n      prune_all, sequence_put\n    redefine\n      fill\n    end\n\n  SEQUENCE [G]\n    rename\n      put as sequence_put\n    export\n      {NONE} sequence_put\n    redefine\n      index_of, has, off, occurrences, fill, append\n    select\n      index_of, has, occurrences\n    end\n\n  SEQUENCE [G]\n    rename\n      put as sequence_put,\n      index_of as sequential_index_of,\n      has as sequential_has,\n      occurrences as sequential_occurrences\n    export\n      {NONE}\n        sequential_index_of, sequential_has,\n        sequence_put, sequential_occurrences\n    redefine\n      off, fill, append\n    end\n\nfeature -- Access\n\n  first: like item\n      -- Item at first position\n    require\n      not_empty: not is_empty\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      start\n      Result := item\n      go_to (pos)\n    end\n\n  last: like item\n      -- Item at last position\n    require\n      not_empty: not is_empty\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      finish\n      Result := item\n      go_to (pos)\n    end\n\n  has (v: like item): BOOLEAN\n      -- Does chain include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      Result := sequential_has (v)\n      go_to (pos)\n    end\n\n  index_of (v: like item; i: INTEGER): INTEGER\n      -- Index of `i'-th occurrence of item identical to `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      -- 0 if none.\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      Result := sequential_index_of (v, i)\n      go_to (pos)\n    end\n\n  i_th alias \"[]\", at alias \"@\" (i: INTEGER): like item assign put_i_th\n      -- Item at `i'-th position\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      go_i_th (i)\n      Result := item\n      go_to (pos)\n    end\n\nfeature -- Measurement\n\n  occurrences (v: like item): INTEGER\n      -- Number of times `v' appears.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      Result := sequential_occurrences (v)\n      go_to (pos)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      count_definition: Result.count = count\n    end\n\nfeature -- Cursor movement\n\n  start\n      -- Move cursor to first position.\n      -- (No effect if empty)\n    do\n      if not is_empty then\n        go_i_th (1)\n      end\n    ensure then\n      at_first: not is_empty implies isfirst\n    end\n\n  finish\n      -- Move cursor to last position.\n      -- (No effect if empty)\n    do\n      if not is_empty then\n        go_i_th (count)\n      end\n    ensure then\n      at_last: not is_empty implies islast\n    end\n\n  move (i: INTEGER)\n      -- Move cursor `i' positions. The cursor\n      -- may end up `off' if the absolute value of `i'\n      -- is too big.\n    local\n      counter, pos, final: INTEGER\n    do\n      if i > 0 then\n        from\n        until\n          (counter = i) or else after\n        loop\n          forth\n          counter := counter + 1\n        end\n      elseif i < 0 then\n        final := index + i\n        if final <= 0 then\n          start\n          back\n        else\n          from\n            start\n            pos := 1\n          until\n            pos = final\n          loop\n            forth\n            pos := pos + 1\n          end\n        end\n      end\n    ensure\n      too_far_right: (old index + i > count) implies exhausted\n      too_far_left: (old index + i < 1) implies exhausted\n      expected_index: (not exhausted) implies (index = old index + i)\n    end\n\n  go_i_th (i: INTEGER)\n      -- Move cursor to `i'-th position.\n    require\n      valid_cursor_index: valid_cursor_index (i)\n    do\n      move (i - index)\n    ensure\n      position_expected: index = i\n    end\n\n feature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within allowable bounds?\n    do\n      Result := (i >= 1) and (i <= count)\n    ensure then\n      valid_index_definition: Result = ((i >= 1) and (i <= count))\n    end\n\n\n  isfirst: BOOLEAN\n      -- Is cursor at first position?\n    do\n      Result := not is_empty and (index = 1)\n    ensure\n      valid_position: Result implies not is_empty\n    end\n\n  islast: BOOLEAN\n      -- Is cursor at last position?\n    do\n      Result := not is_empty and (index = count)\n    ensure\n      valid_position: Result implies not is_empty\n    end\n\n  off: BOOLEAN\n      -- Is there no current item?\n    do\n      Result := (index = 0) or (index = count + 1)\n    end\n\n\n  valid_cursor_index (i: INTEGER): BOOLEAN\n      -- Is `i' correctly bounded for cursor movement?\n    do\n      Result := (i >= 0) and (i <= count + 1)\n    ensure\n      valid_cursor_index_definition: Result = ((i >= 0) and (i <= count + 1))\n    end\n\nfeature -- Element change\n\n  put (v: like item)\n      -- Replace current item by `v'.\n      -- (Synonym for `replace')\n    require\n      writeable: writable\n      replaceable: replaceable\n    do\n      replace (v)\n    ensure\n      same_count: count = old count\n      is_inserted: is_inserted (v)\n    end\n\n  put_i_th (v: like item; i: INTEGER)\n      -- Put `v' at `i'-th position.\n    local\n      pos: CURSOR\n    do\n      pos := cursor\n      go_i_th (i)\n      replace (v)\n      go_to (pos)\n    end\n\n  append (s: SEQUENCE [G])\n      -- Append a copy of `s'.\n    local\n      l: SEQUENCE [G]\n      l_cursor: CURSOR\n    do\n      l := s\n      if s = Current then\n        l := twin\n      end\n      from\n        l_cursor := cursor\n        l.start\n      until\n        l.exhausted\n      loop\n        extend (l.item)\n        finish\n        l.forth\n      end\n      go_to (l_cursor)\n    end\n\n  fill (other: CONTAINER [G])\n      -- Fill with as many items of `other' as possible.\n      -- The representations of `other' and current structure\n      -- need not be the same.\n    local\n      lin_rep: LINEAR [G]\n      l_cursor: CURSOR\n    do\n      lin_rep := other.linear_representation\n      from\n        l_cursor := cursor\n        lin_rep.start\n      until\n        not extendible or else lin_rep.off\n      loop\n        extend (lin_rep.item)\n        finish\n        lin_rep.forth\n      end\n      go_to (l_cursor)\n    end\nfeature -- Transformation\n\n  swap (i: INTEGER)\n      -- Exchange item at `i'-th position with item\n      -- at cursor position.\n    require\n      not_off: not off\n      valid_index: valid_index (i)\n    local\n      old_item, new_item: like item\n      pos: CURSOR\n    do\n      pos := cursor\n      old_item := item\n      go_i_th (i)\n      new_item := item\n      replace (old_item)\n      go_to (pos)\n      replace (new_item)\n    ensure\n      swapped_to_item: item = old i_th (i)\n      swapped_from_item: i_th (i) = old item\n    end\n\nfeature -- Duplication\n\n  duplicate (n: INTEGER): like Current\n      -- Copy of sub-chain beginning at current position\n      -- and having min (`n', `from_here') items,\n      -- where `from_here' is the number of items\n      -- at or to the right of current position.\n    require\n      not_off_unless_after: off implies after\n      valid_subchain: n >= 0\n    deferred\n    end\n\nfeature {NONE} -- Inapplicable\n\n  remove\n      -- Remove current item.\n    do\n    end\n\ninvariant\n\n  non_negative_index: index >= 0\n  index_small_enough: index <= count + 1\n  off_definition: off = ((index = 0) or (index = count + 1))\n  isfirst_definition: isfirst = ((not is_empty) and (index = 1))\n  islast_definition: islast = ((not is_empty) and (index = count))\n  item_corresponds_to_index: (not off) implies (item = i_th (index))\n  index_set_has_same_count: index_set.count = count\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_32.e","content":"note\n  description: \"Unicode characters, with comparison operations\"\n  assembly: \"mscorlib\"\n  external_name: \"System.UInt32\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_32\n\ninherit\n  CHARACTER_32_REF\n    redefine\n      code,\n      natural_32_code,\n      to_character_8\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_32_REF})\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"character_32_ref.e","content":"note\n  description: \"References to objects containing a unicode character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  CHARACTER_32_REF\n\ninherit\n  COMPARABLE\n    redefine\n      is_equal, out\n    end\n\n  HASHABLE\n    redefine\n      is_equal, out\n    end\n\nfeature -- Access\n\n  item: CHARACTER_32\n      -- Unicode character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := natural_32_code.as_integer_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.natural_32_code\n    ensure\n      natural_32_code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  min_value: NATURAL_32 = 0\n  max_value: NATURAL_32 = 4294967295\n      -- Bounds for integer representation of CHARACTER_32\n\n  max_unicode_value: NATURAL_32 = 0x10FFFD\n      -- Maximum Unicode characters.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: NATURAL_32): CHARACTER_32\n      -- Add `incr' to the code of `item'.\n    require\n      valid_increment: (item.natural_32_code.to_natural_64 + incr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code + incr).to_character_32\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: NATURAL_32): CHARACTER_32\n      -- Subtract `decr' from the code of `item'.\n    require\n      valid_decrement: (item.natural_32_code.to_integer_64 - decr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code - decr).to_character_32\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_32): INTEGER_64\n      -- Difference between the codes of `item' and `other'.\n    do\n      Result := item.natural_32_code.to_integer_64 - other.natural_32_code.to_integer_64\n    ensure\n      valid_non_negative_result: Result >= 0 implies ((other + Result.to_natural_32) = item)\n      valid_negative_result: Result < 0 implies (other = (item + Result.to_natural_32))\n    end\n\n  next: CHARACTER_32\n      -- Next character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 + 1).is_valid_character_32_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_32\n      -- Previous character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 - 1).is_valid_character_32_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_32)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of wide character.\n    do\n      create Result.make (6)\n      Result.append_character ('U')\n      Result.append_character ('+')\n      Result.append_string (natural_32_code.to_hex_string)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_32_REF\n      -- Associated reference of Current.\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8.\n    require\n      is_character_8_compatible: is_character_8\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Convert current to CHARACTER_32.\n    do\n      Result := item\n    end\n\n  as_upper, upper: CHARACTER_32\n      -- Uppercase value of `item'.\n      -- Returns `item' if not `is_lower'.\n    do\n      Result := properties.to_upper (item)\n    end\n\n  as_lower, lower: CHARACTER_32\n      -- Lowercase value of `item'.\n      -- Returns `item' if not `is_upper'.\n    do\n      Result := properties.to_lower (item)\n    end\n\nfeature -- Status report\n\n  is_character_8: BOOLEAN\n      -- Can current be represented on a CHARACTER_8?\n    do\n      Result := natural_32_code <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'.\n    do\n      Result := properties.is_alpha (item)\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := properties.is_upper (item)\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := properties.is_lower (item)\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789.\n    do\n      Result := '0' <= item and item <= '9'\n    end\n\n  is_unicode_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for Unicode characters?\n    do\n      Result := properties.is_digit (item)\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' a hexadecimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789ABCDEFabcedf.\n    do\n      Result := properties.is_hexa_digit (item)\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := properties.is_space (item)\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := properties.is_punctuation (item)\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := properties.is_alpha (item) or properties.is_digit (item)\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := properties.is_control (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  properties: CHARACTER_PROPERTY\n      -- Property for Unicode characters.\n    once\n      create Result.make\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8.e","content":"note\n  description: \"Characters, with comparison operations and an ASCII code\"\n  external_name: \"System.Char\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_8\n\ninherit\n  CHARACTER_8_REF\n    redefine\n      code,\n      to_character_32\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_8_REF}),\n  to_character_32: {CHARACTER_32}\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8_ref.e","content":"note\n  description: \"References to objects containing a character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass CHARACTER_8_REF inherit\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      out, is_equal\n    end\n\nfeature -- Access\n\n  item: CHARACTER_8\n      -- Character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := item.code\n    ensure\n      code_non_negatif: Result >= 0\n      code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.code.to_natural_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  min_value: INTEGER = 0\n  max_value: INTEGER = 255\n  max_ascii_value: INTEGER = 127\n      -- Bounds for integer representation of characters (ASCII)\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: INTEGER): CHARACTER_8\n      -- Add `incr' to the code of `item'\n    require\n      valid_increment: (item.code + incr).is_valid_character_8_code\n    do\n      Result := (item.code + incr).to_character_8\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: INTEGER): CHARACTER_8\n      -- Subtract `decr' from the code of `item'\n    require\n      valid_decrement: (item.code - decr).is_valid_character_8_code\n    do\n      Result := (item.code - decr).to_character_8\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_8): INTEGER\n      -- Difference between the codes of `item' and `other'\n    do\n      Result := item.code - other.code\n    ensure\n      valid_result: other + Result = item\n    end\n\n  next: CHARACTER_8\n      -- Next character\n    require\n      valid_character: (item.code + 1).is_valid_character_8_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_8\n      -- Previous character\n    require\n      valid_character: (item.code - 1).is_valid_character_8_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_8)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of character\n    do\n      create Result.make (1)\n      Result.append_character (item)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version\n    do\n      Result := item\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    do\n      Result := item.to_character_32\n    end\n\n  as_upper, upper: CHARACTER_8\n      -- Uppercase value of `item'\n      -- Returns `item' if not `is_lower'\n    do\n      if is_lower then\n        Result := (item.code - ('a').code + ('A').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\n  as_lower, lower: CHARACTER_8\n      -- Lowercase value of `item'\n      -- Returns `item' if not `is_upper'\n    do\n      if is_upper then\n        Result := (item.code - ('A').code + ('a').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\nfeature -- Status report\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag)) > 0\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := (character_types (item.code) & is_upper_flag) > 0\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := (character_types (item.code) & is_lower_flag) > 0\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a digit?\n      -- A digit is one of 0123456789\n    do\n      Result := (character_types (item.code) & is_digit_flag) > 0\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' an hexadecimal digit?\n      -- A digit is one of 0123456789ABCDEFabcedf\n    do\n      Result := (character_types (item.code) & (is_hexa_digit_flag | is_digit_flag)) > 0\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := (character_types (item.code) & is_white_space_flag) > 0\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := (character_types (item.code) & is_punctuation_flag) > 0\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag | is_digit_flag)) > 0\n    end\n\n  is_printable: BOOLEAN\n      -- Is `item' a printable character including space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag | is_space_flag)) > 0\n    end\n\n  is_graph: BOOLEAN\n      -- Is `item' a printable character except space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag)) > 0\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := (character_types (item.code) & is_control_flag) > 0\n    end\n\nfeature {NONE} -- Implementation\n\n  character_types (a_code: INTEGER): NATURAL_8\n      -- Associated type for character of code `a_code'\n    do\n        -- For character whose code is above 256, it is as if\n        -- we had no information about it.\n      if a_code < 256 then\n        Result := internal_character_types.item (a_code)\n      end\n    end\n\n  internal_character_types: SPECIAL [NATURAL_8]\n      -- Array which stores the various type for the ASCII characters\n    once\n      create Result.make_empty (256)\n      Result.extend (is_control_flag)             -- 0  null\n      Result.extend (is_control_flag)                         -- 1  start of heading\n      Result.extend (is_control_flag)                         -- 2  start of text\n      Result.extend (is_control_flag)                         -- 3  end of text\n      Result.extend (is_control_flag)                         -- 4  end of transmission\n      Result.extend (is_control_flag)                         -- 5  enquiry\n      Result.extend (is_control_flag)                         -- 6  acknowledge\n      Result.extend (is_control_flag)                         -- 7  bell\n      Result.extend (is_control_flag)                         -- 8  backspace\n      Result.extend (is_control_flag | is_white_space_flag)   -- 9  horizontal tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 10 NL line feed, new line\n      Result.extend (is_control_flag | is_white_space_flag)   -- 11 vertical tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 12 NP form feed, new page\n      Result.extend (is_control_flag | is_white_space_flag)   -- 13 carriage return=CR\n      Result.extend (is_control_flag)                         -- 14 shift out\n      Result.extend (is_control_flag)                         -- 15 shift in\n      Result.extend (is_control_flag)                         -- 16\n      Result.extend (is_control_flag)                         -- 17\n      Result.extend (is_control_flag)                         -- 18\n      Result.extend (is_control_flag)                         -- 19\n      Result.extend (is_control_flag)                         -- 20\n      Result.extend (is_control_flag)                         -- 21\n      Result.extend (is_control_flag)                         -- 22\n      Result.extend (is_control_flag)                         -- 23\n      Result.extend (is_control_flag)                         -- 24\n      Result.extend (is_control_flag)                         -- 25\n      Result.extend (is_control_flag)                         -- 26\n      Result.extend (is_control_flag)                         -- 27 Escape\n      Result.extend (is_control_flag)                         -- 28 file separator\n      Result.extend (is_control_flag)                         -- 29 group separator\n      Result.extend (is_control_flag)                         -- 30 record separator\n      Result.extend (is_control_flag)                         -- 31 unit separator\n      Result.extend (is_white_space_flag | is_space_flag)     -- 32 Space\n      Result.extend (is_punctuation_flag)                     -- 33 !\n      Result.extend (is_punctuation_flag)                     -- 34 \"\n      Result.extend (is_punctuation_flag)                     -- 35 #\n      Result.extend (is_punctuation_flag)                     -- 36 $\n      Result.extend (is_punctuation_flag)                     -- 37 %\n      Result.extend (is_punctuation_flag)                     -- 38 &\n      Result.extend (is_punctuation_flag)                     -- 39 '\n      Result.extend (is_punctuation_flag)                     -- 40 (\n      Result.extend (is_punctuation_flag)                     -- 41 )\n      Result.extend (is_punctuation_flag)                     -- 42 *\n      Result.extend (is_punctuation_flag)                     -- 43 +\n      Result.extend (is_punctuation_flag)                     -- 44 ,\n      Result.extend (is_punctuation_flag)                     -- 45 -\n      Result.extend (is_punctuation_flag)                     -- 46 .\n      Result.extend (is_punctuation_flag)                     -- 47 /\n      Result.extend (is_digit_flag)                           -- 48 0\n      Result.extend (is_digit_flag)                           -- 49 1\n      Result.extend (is_digit_flag)                           -- 50 2\n      Result.extend (is_digit_flag)                           -- 51 3\n      Result.extend (is_digit_flag)                           -- 52 4\n      Result.extend (is_digit_flag)                           -- 53 5\n      Result.extend (is_digit_flag)                           -- 54 6\n      Result.extend (is_digit_flag)                           -- 55 7\n      Result.extend (is_digit_flag)                           -- 56 8\n      Result.extend (is_digit_flag)                           -- 57 9\n      Result.extend (is_punctuation_flag)                     -- 58 :\n      Result.extend (is_punctuation_flag)                     -- 59 ;\n      Result.extend (is_punctuation_flag)                     -- 60 <\n      Result.extend (is_punctuation_flag)                     -- 61 =\n      Result.extend (is_punctuation_flag)                     -- 62 >\n      Result.extend (is_punctuation_flag)                     -- 63 ?\n      Result.extend (is_punctuation_flag)                     -- 64 @\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 65 A\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 66 B\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 67 C\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 68 D\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 69 E\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 70 F\n      Result.extend (is_upper_flag)                           -- 71 G\n      Result.extend (is_upper_flag)                           -- 72 H\n      Result.extend (is_upper_flag)                           -- 73 I\n      Result.extend (is_upper_flag)                           -- 74 J\n      Result.extend (is_upper_flag)                           -- 75 K\n      Result.extend (is_upper_flag)                           -- 76 L\n      Result.extend (is_upper_flag)                           -- 77 M\n      Result.extend (is_upper_flag)                           -- 78 N\n      Result.extend (is_upper_flag)                           -- 79 O\n      Result.extend (is_upper_flag)                           -- 80 P\n      Result.extend (is_upper_flag)                           -- 81 Q\n      Result.extend (is_upper_flag)                           -- 82 R\n      Result.extend (is_upper_flag)                           -- 83 S\n      Result.extend (is_upper_flag)                           -- 84 T\n      Result.extend (is_upper_flag)                           -- 85 U\n      Result.extend (is_upper_flag)                           -- 86 V\n      Result.extend (is_upper_flag)                           -- 87 W\n      Result.extend (is_upper_flag)                           -- 88 X\n      Result.extend (is_upper_flag)                           -- 89 Y\n      Result.extend (is_upper_flag)                           -- 90 Z\n      Result.extend (is_punctuation_flag)                     -- 91 [\n      Result.extend (is_punctuation_flag)                     -- 92 \\\n      Result.extend (is_punctuation_flag)                     -- 93 ]\n      Result.extend (is_punctuation_flag)                     -- 94 ^\n      Result.extend (is_punctuation_flag)                     -- 95 _\n      Result.extend (is_punctuation_flag)                     -- 96 `\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 97 a\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 98 b\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 99 c\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 100  d\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 101  e\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 102  f\n      Result.extend (is_lower_flag)                           -- 103  g\n      Result.extend (is_lower_flag)                           -- 104  h\n      Result.extend (is_lower_flag)                           -- 105  i\n      Result.extend (is_lower_flag)                           -- 106  j\n      Result.extend (is_lower_flag)                           -- 107  k\n      Result.extend (is_lower_flag)                           -- 108  l\n      Result.extend (is_lower_flag)                           -- 109  m\n      Result.extend (is_lower_flag)                           -- 110  n\n      Result.extend (is_lower_flag)                           -- 111  o\n      Result.extend (is_lower_flag)                           -- 112  p\n      Result.extend (is_lower_flag)                           -- 113  q\n      Result.extend (is_lower_flag)                           -- 114  r\n      Result.extend (is_lower_flag)                           -- 115  s\n      Result.extend (is_lower_flag)                           -- 116  t\n      Result.extend (is_lower_flag)                           -- 117  u\n      Result.extend (is_lower_flag)                           -- 118  v\n      Result.extend (is_lower_flag)                           -- 119  w\n      Result.extend (is_lower_flag)                           -- 120  x\n      Result.extend (is_lower_flag)                           -- 121  y\n      Result.extend (is_lower_flag)                           -- 122  z\n      Result.extend (is_punctuation_flag)                     -- 123  {\n      Result.extend (is_punctuation_flag)                     -- 124  |\n      Result.extend (is_punctuation_flag)                     -- 125  }\n      Result.extend (is_punctuation_flag)                     -- 126  ~\n      Result.extend (is_control_flag)                         -- 127  DEL\n      Result.fill_with (0, 128, 255)              -- extended ASCII\n    ensure\n      internal_character_types_not_void: Result /= Void\n    end\n\n  is_upper_flag: NATURAL_8 = 0x01\n\n  is_lower_flag: NATURAL_8 = 0x02\n\n  is_digit_flag: NATURAL_8 = 0x04\n\n  is_white_space_flag: NATURAL_8 = 0x08\n\n  is_punctuation_flag: NATURAL_8 = 0x10\n\n  is_control_flag: NATURAL_8 = 0x20\n\n  is_hexa_digit_flag: NATURAL_8 = 0x40\n\n  is_space_flag: NATURAL_8 = 0x80;\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"collection.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: collection, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class COLLECTION [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  extendible: BOOLEAN\n      -- May new items be added?\n    deferred\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed?\n    deferred\n    end\n\n  is_inserted (v: G): BOOLEAN\n      -- Has `v' been inserted by the most recent insertion?\n      -- (By default, the value returned is equivalent to calling\n      -- `has (v)'. However, descendants might be able to provide more\n      -- efficient implementations.)\n    do\n      Result := has (v)\n    end\n\nfeature -- Element change\n\n  put, extend (v: G)\n      -- Ensure that structure includes `v'.\n    require\n      extendible: extendible\n    deferred\n    ensure\n      item_inserted: is_inserted (v)\n    end\n\n  fill (other: CONTAINER [G])\n      -- Fill with as many items of `other' as possible.\n      -- The representations of `other' and current structure\n      -- need not be the same.\n    require\n      other_not_void: other /= Void\n      extendible: extendible\n    local\n      lin_rep: LINEAR [G]\n    do\n      lin_rep := other.linear_representation\n      from\n        lin_rep.start\n      until\n        not extendible or else lin_rep.off\n      loop\n        extend (lin_rep.item)\n        lin_rep.forth\n      end\n    end\n\nfeature -- Removal\n\n  prune (v: G)\n      -- Remove one occurrence of `v' if any.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    require\n      prunable: prunable\n    deferred\n    end\n\n  prune_all (v: G)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      --|Default implementation, usually inefficient.\n    require\n      prunable: prunable\n    do\n      from\n      until not has (v) loop\n        prune (v)\n      end\n    ensure\n      no_more_occurrences: not has (v)\n    end\n\n  wipe_out\n      -- Remove all items.\n    require\n      prunable: prunable\n    deferred\n    ensure\n      wiped_out: is_empty\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"comparable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class COMPARABLE inherit\n\n  PART_COMPARABLE\n    redefine\n      is_less, is_less_equal,\n      is_greater, is_greater_equal,\n      is_equal\n    end\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    deferred\n    ensure then\n      asymmetric: Result implies not (other < Current)\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    do\n      Result := not (other < Current)\n    ensure then\n      definition: Result = ((Current < other) or (Current ~ other))\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    do\n      Result := other < Current\n    ensure then\n      definition: Result = (other < Current)\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    do\n      Result := not (Current < other)\n    ensure then\n      definition: Result = (other <= Current)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := (not (Current < other) and not (other < Current))\n    ensure then\n      trichotomy: Result = (not (Current < other) and not (other < Current))\n    end\n\n  three_way_comparison (other: like Current): INTEGER\n      -- If current object equal to `other', 0;\n      -- if smaller, -1; if greater, 1\n    require\n      other_exists: other /= Void\n    do\n      if Current < other then\n        Result := -1\n      elseif other < Current then\n        Result := 1\n      end\n    ensure\n      equal_zero: (Result = 0) = (Current ~ other)\n      smaller_negative: (Result = -1) = (Current < other)\n      greater_positive: (Result = 1) = (Current > other)\n    end\n\n  max (other: like Current): like Current\n      -- The greater of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current >= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_smaller: Current >= other implies Result = Current\n      other_if_smaller: Current < other implies Result = other\n    end\n\n  min (other: like Current): like Current\n      -- The smaller of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current <= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_greater: Current <= other implies Result = Current\n      other_if_greater: Current > other implies Result = other\n    end\n\ninvariant\n\n  irreflexive_comparison: not (Current < Current)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"container.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class\n  CONTAINER [G]\n\nfeature -- Access\n\n  has (v: G): BOOLEAN\n      -- Does structure include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      not_found_in_empty: Result implies not is_empty\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is there no element?\n    deferred\n    end\n\n  empty: BOOLEAN\n      -- Is there no element?\n    obsolete\n      \"ELKS 2000: Use `is_empty' instead\"\n    do\n      Result := is_empty\n    end\n\n  object_comparison: BOOLEAN\n      -- Must search operations use `equal' rather than `='\n      -- for comparing references? (Default: no, use `='.)\n\n  changeable_comparison_criterion: BOOLEAN\n      -- May `object_comparison' be changed?\n      -- (Answer: yes by default.)\n    do\n      Result := True\n    end\n\nfeature -- Status setting\n\n  compare_objects\n      -- Ensure that future search operations will use `equal'\n      -- rather than `=' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := True\n    ensure\n      object_comparison\n    end\n\n  compare_references\n      -- Ensure that future search operations will use `='\n      -- rather than `equal' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := False\n    ensure\n      reference_comparison: not object_comparison\n    end\n\nfeature -- Conversion\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"cursor.e","content":"note\n  description: \"Cursors for remembering positions in arbitrary data structures\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: cursor;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\nclass\n  CURSOR\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"cursor_structure.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: cursor_structure, access;\n  access: cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class CURSOR_STRUCTURE [G] inherit\n\n  ACTIVE [G]\n\nfeature -- Access\n\n  cursor: CURSOR\n      -- Current cursor position\n    deferred\n    ensure\n      cursor_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  valid_cursor (p: CURSOR): BOOLEAN\n      -- Can the cursor be moved to position `p'?\n    deferred\n    end\n\nfeature -- Cursor movement\n\n  go_to (p: CURSOR)\n      -- Move cursor to position `p'.\n    require\n      cursor_position_valid: valid_cursor (p)\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"debug_output.e","content":"note\n  description: \"Objects that provide an output in debugger\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-17 11:46:15 -0800 (Thu, 17 Jan 2013) $\"\n  revision: \"$Revision: 92124 $\"\n\ndeferred class\n  DEBUG_OUTPUT\n\nfeature -- Status report\n\n  debug_output: READABLE_STRING_GENERAL\n      -- String that should be displayed in debugger to represent `Current'.\n    deferred\n    ensure\n      result_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"developer_exception.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-12-26 18:57:50 -0800 (Wed, 26 Dec 2012) $\"\n  revision: \"$Revision: 92096 $\"\n\nclass\n  DEVELOPER_EXCEPTION\n\ninherit\n  EXCEPTION\n    redefine\n      code,\n      tag\n    end\n\nfeature -- Access\n\n  frozen code: INTEGER\n      -- Exception code\n    do\n      Result := {EXCEP_CONST}.developer_exception\n    end\n\n  tag: IMMUTABLE_STRING_32\n    once\n      create Result.make_from_string_8 (\"Developer exception.\")\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"disposable.e","content":"note\n  description: \"Perform cleanup operations before current instance is reclaimed by garbage collection.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  DISPOSABLE\n\nfeature -- Removal\n\n  dispose\n      -- Action to be executed just before garbage collection\n      -- reclaims an object.\n      -- Effect it in descendants to perform specific dispose\n      -- actions. Those actions should only take care of freeing\n      -- external resources; they should not perform remote calls\n      -- on other objects since these may also be dead and reclaimed.\n    deferred\n    end\n\nfeature {NONE} -- Status report\n\n  is_in_final_collect: BOOLEAN\n      -- Is GC currently performing final collection\n      -- after execution of current program?\n      -- Safe to use in `dispose'.\n    external\n      \"C inline use %\"eif_memory.h%\"\"\n    alias\n      \"return eif_is_in_final_collect;\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"dynamic_chain.e","content":"note\n  description: \"Dynamically modifiable chains\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: dynamic_chain, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class DYNAMIC_CHAIN [G] inherit\n\n  CHAIN [G]\n    export\n      {ANY} remove, prune_all, prune\n    undefine\n      remove, prune_all, prune\n    end\n\n  UNBOUNDED [G]\n\nfeature -- Status report\n\n  extendible: BOOLEAN\n      -- May new items be added? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\nfeature -- Element change\n\n  put_front (v: like item)\n      -- Add `v' at beginning.\n      -- Do not move cursor.\n    require\n      extendible: extendible\n    deferred\n    ensure\n      new_count: count = old count + 1\n      item_inserted: first = v\n    end\n\n  put_left (v: like item)\n      -- Add `v' to the left of cursor position.\n      -- Do not move cursor.\n    require\n      extendible: extendible\n      not_before: not before\n    deferred\n    ensure\n      new_count: count = old count + 1\n      new_index: index = old index + 1\n    end\n\n  put_right (v: like item)\n      -- Add `v' to the right of cursor position.\n      -- Do not move cursor.\n    require\n      extendible: extendible\n      not_after: not after\n    deferred\n    ensure\n      new_count: count = old count + 1\n      same_index: index = old index\n    end\n\n  merge_left (other: like Current)\n      -- Merge `other' into current structure before cursor\n      -- position. Do not move cursor. Empty `other'.\n    require\n      extendible: extendible\n      not_before: not before\n      other_exists: other /= Void\n      not_current: other /= Current\n    deferred\n    ensure\n      new_count: count = old count + old other.count\n      new_index: index = old index + old other.count\n      other_is_empty: other.is_empty\n    end\n\n  merge_right (other: like Current)\n      -- Merge `other' into current structure after cursor\n      -- position. Do not move cursor. Empty `other'.\n    require\n      extendible: extendible\n      not_after: not after\n      other_exists: other /= Void\n      not_current: other /= Current\n    deferred\n    ensure\n      new_count: count = old count + old other.count\n      same_index: index = old index\n      other_is_empty: other.is_empty\n    end\n\nfeature -- Removal\n\n  prune (v: like item)\n      -- Remove first occurrence of `v', if any,\n      -- after cursor position.\n      -- If found, move cursor to right neighbor;\n      -- if not, make structure `exhausted'.\n    do\n      search (v)\n      if not exhausted then\n        remove\n      end\n    end\n\n  remove_left\n      -- Remove item to the left of cursor position.\n      -- Do not move cursor.\n    require\n      left_exists: index > 1\n    deferred\n    ensure\n      new_count: count = old count - 1\n      new_index: index = old index - 1\n    end\n\n  remove_right\n      -- Remove item to the right of cursor position.\n      -- Do not move cursor.\n    require\n      right_exists: index < count\n    deferred\n    ensure\n      new_count: count = old count - 1\n      same_index: index = old index\n    end\n\n  prune_all (v: like item)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      -- Leave structure `exhausted'.\n    do\n      from\n        start\n        search (v)\n      until\n        exhausted\n      loop\n        remove\n        search (v)\n      end\n    ensure then\n      is_exhausted: exhausted\n    end\n\n  wipe_out\n      -- Remove all items.\n    do\n      from\n        start\n      until\n        is_empty\n      loop\n        remove\n      end\n    end\n\nfeature -- Duplication\n\n  duplicate (n: INTEGER): like Current\n      -- Copy of sub-chain beginning at current position\n      -- and having min (`n', `from_here') items,\n      -- where `from_here' is the number of items\n      -- at or to the right of current position.\n    local\n      pos: CURSOR\n      counter: INTEGER\n    do\n      from\n        Result := new_chain\n        if object_comparison then\n          Result.compare_objects\n        end\n        pos := cursor\n      until\n        (counter = n) or else exhausted\n      loop\n        Result.extend (item)\n        forth\n        counter := counter + 1\n      end\n      go_to (pos)\n    end\n\nfeature {DYNAMIC_CHAIN} -- Implementation\n\n  new_chain: like Current\n      -- A newly created instance of the same type.\n      -- This feature may be redefined in descendants so as to\n      -- produce an adequately allocated and initialized object.\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"dynamic_list.e","content":"note\n  description: \"[\n    Sequential, dynamically modifiable lists,\n    without commitment to a particular representation\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: dynamic_list, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class DYNAMIC_LIST [G] inherit\n\n  LIST [G]\n    undefine\n      prune,\n      sequential_index_of, sequential_has,\n      remove, prune_all\n    end\n\n  DYNAMIC_CHAIN [G]\n    rename\n      wipe_out as chain_wipe_out\n    export\n      {NONE} chain_wipe_out\n    undefine\n      is_equal\n    redefine\n      put_left, put_right,\n      remove_left, remove_right\n    end\n\n  DYNAMIC_CHAIN [G]\n    undefine\n      is_equal\n    redefine\n      put_left, put_right,\n      remove_left, remove_right, wipe_out\n    select\n      wipe_out\n    end\n\nfeature -- Element change\n\n  put_left (v: like item)\n      -- Add `v' to the left of cursor position.\n      -- Do not move cursor.\n    local\n      temp: like item\n    do\n      if is_empty then\n        put_front (v)\n      elseif after then\n        back\n        put_right (v)\n        move (2)\n      else\n        temp := item\n        replace (v)\n        put_right (temp)\n        forth\n      end\n    end\n\n  put_right (v: like item)\n      -- Add `v' to the right of cursor position.\n      -- Do not move cursor.\n    deferred\n    end\n\n  merge_left (other: like Current)\n      -- Merge `other' into current structure before cursor\n      -- position. Do not move cursor. Empty `other'.\n    do\n      from\n        other.start\n      until\n        other.is_empty\n      loop\n        put_left (other.item)\n        other.remove\n      end\n    end\n\n  merge_right (other: like Current)\n      -- Merge `other' into current structure after cursor\n      -- position. Do not move cursor. Empty `other'.\n    do\n      from\n        other.finish\n      until\n        other.is_empty\n      loop\n        put_right (other.item)\n        other.back\n        other.remove_right\n      end\n    end\n\nfeature -- Removal\n\n  remove\n      -- Remove current item.\n      -- Move cursor to right neighbor\n      -- (or `after' if no right neighbor).\n    deferred\n    ensure then\n      after_when_empty: is_empty implies after\n    end\n\n  remove_left\n      -- Remove item to the left of cursor position.\n      -- Do not move cursor.\n    deferred\n    end\n\n  remove_right\n      -- Remove item to the right of cursor position.\n      -- Do not move cursor.\n    deferred\n    end\n\n  wipe_out\n      -- Remove all items.\n    do\n      chain_wipe_out\n      back\n    ensure then\n      is_before: before\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"excep_const.e","content":"note\n  description: \"[\n    Constants used for exception handling.\n    This class may be used as ancestor by classes needing its facilities.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  EXCEP_CONST\n\nfeature -- Access\n\n  Void_call_target: INTEGER = 1\n      -- Exception code for feature applied to void reference\n\n  No_more_memory: INTEGER = 2\n      -- Exception code for failed memory allocation\n\n  Precondition: INTEGER = 3\n      -- Exception code for violated precondition\n\n  Postcondition: INTEGER = 4\n      -- Exception code for violated postcondition\n\n  Floating_point_exception: INTEGER = 5\n      -- Exception code for floating point exception\n\n  Class_invariant: INTEGER = 6\n      -- Exception code for violated class invariant\n\n  Check_instruction: INTEGER = 7\n      -- Exception code for violated check\n\n  Routine_failure: INTEGER = 8\n      -- Exception code for failed routine\n\n  Incorrect_inspect_value: INTEGER =  9\n      -- Exception code for inspect value which is not one\n      -- of the inspect constants, if there is no Else_part\n\n  Loop_variant: INTEGER = 10\n      -- Exception code for non-decreased loop variant\n\n  Loop_invariant: INTEGER = 11\n      -- Exception code for violated loop invariant\n\n  Signal_exception: INTEGER = 12\n      -- Exception code for operating system signal\n\n  Eiffel_runtime_panic: INTEGER = 13\n      -- Eiffel run-time panic\n\n  Rescue_exception: INTEGER = 14\n      -- Exception code for exception in rescue clause\n\n  Out_of_memory: INTEGER = 15\n      -- Out of memory (cannot be ignored)\n\n  Resumption_failed: INTEGER = 16\n      -- Resumption failed (retry did not succeed)\n\n  Create_on_deferred: INTEGER = 17\n      -- Create on deferred\n\n  External_exception: INTEGER = 18\n      -- Exception code for operating system error\n      -- which does not set the `errno' variable\n      -- (Unix-specific)\n\n  Void_assigned_to_expanded: INTEGER = 19\n      -- Exception code for assignment of void value\n      -- to expanded entity\n\n  Exception_in_signal_handler: INTEGER = 20\n      -- Exception in signal handler\n\n  Io_exception: INTEGER = 21\n      -- Exception code for I/O error\n\n  Operating_system_exception: INTEGER = 22\n      -- Exception code for operating system error\n      -- which sets the `errno' variable\n      -- (Unix-specific)\n\n  Retrieve_exception: INTEGER = 23\n      -- Exception code for retrieval error\n      -- may be raised by `retrieved' in `IO_MEDIUM'.\n\n  Developer_exception: INTEGER = 24\n      -- Exception code for developer exception\n\n  Eiffel_runtime_fatal_error: INTEGER = 25\n      -- Eiffel run-time fatal error\n\n  Dollar_applied_to_melted_feature: INTEGER = 26\n      -- $ applied to melted feature\n\n  Runtime_io_exception: INTEGER = 27\n      -- Exception code for I/O error raised by runtime functions\n      -- such as store/retrieve, file access...\n\n  Com_exception: INTEGER = 28\n      -- Exception code for a COM error.\n\n  Runtime_check_exception: INTEGER = 29\n      -- Exception code for runtime check being violated.\n\n  old_exception: INTEGER = 30\n      -- Old exception code.\n\n  serialization_exception: INTEGER = 31\n      -- Serialization exception code.\n\n  number_of_codes: INTEGER = 31\n      -- How many codes are there to represent exceptions?\n\n  valid_code (c: INTEGER): BOOLEAN\n      -- Is `c' a valid code to represent some kind of exceptions?\n    do\n      Result := c >= 1 and c <= number_of_codes\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exception.e","content":"note\n  description: \"[\n    Ancestor of all exception classes.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-12-28 06:07:03 -0800 (Fri, 28 Dec 2012) $\"\n  revision: \"$Revision: 92098 $\"\n\nclass\n  EXCEPTION\n\ninherit\n  EXCEPTION_MANAGER_FACTORY\n    undefine\n      out\n    end\n\ncreate\n  default_create,\n  make_with_tag_and_trace\n\nfeature {NONE} -- Initialization\n\n  make_with_tag_and_trace (a_tag, a_trace_string: STRING)\n      -- Make `Current' with `description' set to `a_tag'.\n    obsolete\n      \"Use `default_create' and `set_description' instead.\"\n    require\n      tag_not_void: a_tag /= Void\n      trace_string_not_void: a_trace_string /= Void\n    do\n      set_description (a_tag)\n    ensure\n      description_set: attached description as l_des and then a_tag.same_string_general (l_des)\n    end\n\nfeature -- Raise\n\n  raise\n      -- Raise current exception\n    require\n      is_raisable: is_raisable\n    do\n      exception_manager.raise (Current)\n    end\n\nfeature -- Access\n\n  meaning: STRING\n      -- A short message describing what current exception is\n    obsolete\n      \"Use `tag' instead.\"\n    do\n      Result := tag.as_string_8\n    end\n\n  tag: IMMUTABLE_STRING_32\n      -- A short message describing what current exception is\n    once\n      create Result.make_from_string_8 (\"General exception\")\n    end\n\n  message: detachable STRING\n      -- Message of current exception\n    obsolete\n      \"Use `description' instead.\"\n    do\n      if attached c_description as l_m then\n        Result := l_m.substring (1, l_m.count)\n      end\n    end\n\n  description: detachable READABLE_STRING_GENERAL\n      -- Detailed description of current exception\n    local\n      u: UTF_CONVERTER\n      l_res: STRING_32\n    do\n      if attached c_description as l_m then\n          -- Description is encoded in UTF-8 by the runtime.\n        create l_res.make (l_m.count)\n        u.utf_8_0_subpointer_into_escaped_string_32 (l_m.managed_data, 0, l_m.count - 1, False, l_res)\n        Result := l_res\n      end\n    end\n\n  exception_trace: detachable STRING\n      -- String representation of current exception trace\n    obsolete\n      \"Use `trace' instead.\"\n    do\n      Result := internal_trace\n    end\n\n  trace: detachable STRING_32\n      -- String representation of current exception trace\n    local\n      u: UTF_CONVERTER\n    do\n      if attached internal_trace as l_trace then\n        Result := u.utf_8_string_8_to_string_32 (l_trace)\n      end\n    end\n\n  code: INTEGER\n      -- Code of the exception.\n    do\n    end\n\n  frozen original: EXCEPTION\n      -- The original exception directly triggered current exception\n    local\n      t: like throwing_exception\n    do\n      t := throwing_exception\n      if t = Current or else t = Void then\n        Result := Current\n      elseif (attached {ROUTINE_FAILURE} Current) or else (attached {OLD_VIOLATION} Current) then\n        Result := t.original\n      else\n        Result := Current\n      end\n    ensure\n      original_not_void: Result /= Void\n    end\n\n  frozen cause: EXCEPTION\n      -- The cause of current exception raised during rescue processing\n    do\n      if attached original.throwing_exception as e then\n        Result := e\n      else\n        Result := Current\n      end\n    ensure\n      cause_not_void: Result /= Void\n    end\n\n  frozen recipient_name: detachable STRING\n      -- Name of the routine whose execution was\n      -- interrupted by current exception\n\n  frozen type_name: detachable STRING\n      -- Name of the class that includes the recipient\n      -- of original form of current exception\n\n  frozen line_number: INTEGER\n      -- Line number\n\nfeature -- Access obselete\n\n  trace_as_string: detachable STRING\n      -- Exception trace represented as a string\n    obsolete\n      \"Use `trace' instead.\"\n    do\n      Result := exception_trace\n    end\n\nfeature -- Status settings\n\n  set_message (a_message: like message)\n      -- Set `message' with `a_message'.\n    obsolete\n      \"Use `set_description' instead.\"\n    do\n      set_description (a_message)\n    ensure\n      message_set: message ~ a_message\n    end\n\n  set_description (a_description: detachable READABLE_STRING_GENERAL)\n      -- Set `description' with `a_description'.\n    local\n      u: UTF_CONVERTER\n      l_upper: CELL [INTEGER]\n      l_c: like c_description\n    do\n      if a_description /= Void then\n        create l_c.make_empty (a_description.count)\n        create l_upper.put (0)\n        u.utf_32_string_into_utf_8_0_pointer (a_description, l_c.managed_data, 0, l_upper)\n        l_c.set_count (l_upper.item)\n        c_description := l_c\n      else\n        c_description := Void\n      end\n    ensure\n      description_set: (attached a_description as a_des and then attached description as l_des and then l_des.same_string (l_des)) or else\n              (a_description = Void and then description = Void)\n    end\n\nfeature -- Status report\n\n  frozen is_ignorable: BOOLEAN\n      -- Is current exception ignorable?\n    do\n      Result := exception_manager.is_ignorable (generating_type)\n    end\n\n  frozen is_raisable: BOOLEAN\n      -- Is current exception raisable by `raise'?\n    do\n      Result := exception_manager.is_raisable (generating_type)\n    end\n\n  frozen is_ignored: BOOLEAN\n      -- If set, current exception is not raised.\n    do\n      Result := exception_manager.is_ignored (generating_type)\n    ensure\n      is_ignored_implies_is_ignorable: Result implies is_ignorable\n      not_is_caught: Result = not is_caught\n    end\n\n  frozen is_caught: BOOLEAN\n      -- If set, current exception is raised.\n    do\n      Result := not is_ignored\n    ensure\n      not_is_caught_implies_is_ignorable: not Result implies is_ignorable\n      not_is_ignored: Result = not is_ignored\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    local\n      t: detachable STRING_32\n    do\n      Result := generating_type\n      t := trace\n      if t /= Void then\n        Result.append_character ('%N')\n        Result.append_string (t.as_string_8)\n      end\n    end\n\nfeature {EXCEPTION} -- Access\n\n  frozen throwing_exception: detachable EXCEPTION\n      -- The exception throwing current exception\n\nfeature {EXCEPTION_MANAGER} -- Implementation\n\n  frozen set_throwing_exception (a_exception: detachable EXCEPTION)\n      -- Set `throwing_exception' with `a_exception'.\n    do\n      throwing_exception := a_exception\n    ensure\n      throwing_exception_set: throwing_exception = a_exception\n    end\n\n  frozen set_recipient_name (a_name: like recipient_name)\n      -- Set `recipient_name' with `a_name'\n    do\n      recipient_name := a_name\n    end\n\n  frozen set_line_number (a_number: like line_number)\n      -- Set `line_number' with `a_number'.\n    do\n      line_number := a_number\n    end\n\n  frozen set_c_description (a_des: detachable STRING_8)\n      -- Set `c_description' with `a_des'. `a_des' is in UTF-8.\n    do\n      if a_des /= Void then\n        create c_description.make (a_des)\n      else\n        c_description := Void\n      end\n    end\n\n  c_description: detachable C_STRING\n      -- Message, stored as C string to keep it alive and usable by the runtime trace printing.\n\n  frozen set_type_name (a_type: like type_name)\n      -- Set `type_name' with `a_type'\n    do\n      type_name := a_type\n    end\n\n  frozen internal_is_ignorable: BOOLEAN\n      -- Internal `is_ignorable'\n\n  frozen set_exception_trace (a_trace: like exception_trace)\n      -- Set `exception_trace' with `a_trace'.\n    do\n      internal_trace := a_trace\n    end\n\n  internal_trace: detachable STRING;\n      -- String representation of the exception trace\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exception_manager.e","content":"note\n  description: \"[\n    Common exception operations and management.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  EXCEPTION_MANAGER\n\nfeature -- Access\n\n  last_exception: detachable EXCEPTION\n      -- Last exception\n    external\n      \"built_in\"\n    end\n\nfeature -- Raise\n\n  raise (a_exception: EXCEPTION)\n      -- Raise `a_exception'.\n    require\n      a_exception_not_void: a_exception /= Void\n      a_exception_is_raisable: a_exception.is_raisable\n    external\n      \"built_in\"\n    end\n\nfeature -- Status setting\n\n  ignore (a_exception: TYPE [detachable EXCEPTION])\n      -- Ignore type of `a_exception'.\n    require\n      a_exception_not_void: a_exception /= Void\n      is_ignorable: is_ignorable (a_exception)\n    external\n      \"built_in\"\n    ensure\n      is_caught: is_ignored (a_exception)\n    end\n\n  catch (a_exception: TYPE [detachable EXCEPTION])\n      -- Set type of `a_exception' `is_caught'.\n    require\n      a_exception_not_void: a_exception /= Void\n    external\n      \"built_in\"\n    ensure\n      is_ignored: not is_ignored (a_exception)\n    end\n\n  set_is_ignored (a_exception: TYPE [detachable EXCEPTION]; a_ignored: BOOLEAN)\n      -- Set type of `a_exception' to be `a_ignored'.\n    require\n      a_exception_not_void: a_exception /= Void\n      a_ignored_implies_is_ignorable: a_ignored implies is_ignorable (a_exception)\n    external\n      \"built_in\"\n    ensure\n      is_ignored_set: is_ignored (a_exception) = a_ignored\n    end\n\nfeature -- Status report\n\n  is_ignorable (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is ignorable.\n    external\n      \"built_in\"\n    end\n\n  is_raisable (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is raisable.\n    external\n      \"built_in\"\n    end\n\n  is_ignored (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is not raised.\n    external\n      \"built_in\"\n    ensure\n      not_is_caught: Result = not is_caught (a_exception)\n    end\n\n  is_caught (a_exception: TYPE [detachable EXCEPTION]): BOOLEAN\n      -- If set, type of `a_exception' is raised.\n    external\n      \"built_in\"\n    ensure\n      not_is_ignored: Result = not is_ignored (a_exception)\n    end\n\nfeature {EXCEPTIONS} -- Backward compatibility support\n\n  type_of_code (a_code: INTEGER): detachable TYPE [EXCEPTION]\n      -- Exception type of `a_code'\n    external\n      \"built_in\"\n    end\n\n  exception_from_code (a_code: INTEGER): detachable EXCEPTION\n      -- Create exception object from `a_code'\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exception_manager_factory.e","content":"note\n  description: \"[\n    Exception manager factory.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  EXCEPTION_MANAGER_FACTORY\n\nfeature -- Access\n\n  exception_manager: EXCEPTION_MANAGER\n      -- Exception manager\n    external\n      \"built_in\"\n    ensure\n      exception_manager_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"exceptions.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-18 11:50:31 -0800 (Fri, 18 Jan 2013) $\"\n  revision: \"$Revision: 92126 $\"\n\nclass EXCEPTIONS\n\ninherit\n  EXCEP_CONST\n\n  EXCEPTION_MANAGER_FACTORY\n\nfeature -- Status report\n\n  meaning (except: INTEGER): detachable STRING\n      -- A message in English describing what `except' is\n    do\n      if attached exception_manager.exception_from_code (except) as l_exception then\n        Result := l_exception.tag.as_string_8\n      end\n    end\n\n  assertion_violation: BOOLEAN\n      -- Is last exception originally due to a violated\n      -- assertion or non-decreasing variant?\n    do\n      Result := attached exception_manager.last_exception as l_exception and then\n            attached {ASSERTION_VIOLATION} l_exception.original\n    end\n\n  is_developer_exception: BOOLEAN\n      -- Is the last exception originally due to\n      -- a developer exception?\n    do\n      Result := attached exception_manager.last_exception as l_exception and then\n            attached {DEVELOPER_EXCEPTION} l_exception.original\n    end\n\n  is_developer_exception_of_name (name: detachable STRING): BOOLEAN\n      -- Is the last exception originally due to a developer\n      -- exception of name `name'?\n    do\n      if is_developer_exception then\n        Result := developer_exception_name ~ name\n      end\n    end\n\n  developer_exception_name: detachable STRING\n      -- Name of last developer-raised exception\n    require\n      applicable: is_developer_exception\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.original.description as l_des then\n        Result := l_des.as_string_8\n      end\n    end\n\n  is_signal: BOOLEAN\n      -- Is last exception originally due to an external\n      -- event (operating system signal)?\n    do\n      Result := attached exception_manager.last_exception as l_exception and then\n            attached {OPERATING_SYSTEM_SIGNAL_FAILURE} l_exception.original\n    end\n\n  is_system_exception: BOOLEAN\n      -- Is last exception originally due to an\n      -- external event (operating system error)?\n    do\n      if\n        attached exception_manager.last_exception as l_exception and\n        attached exception_manager.exception_from_code (external_exception) as l_external\n      then\n        Result := l_exception.original.conforms_to (l_external) or else\n            attached {OPERATING_SYSTEM_FAILURE} l_exception.original\n      end\n    end\n\n  tag_name: detachable STRING\n      -- Tag of last violated assertion clause\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.description as l_des then\n        Result := l_des.as_string_8\n      end\n    end\n\n  recipient_name: detachable STRING\n      -- Name of the routine whose execution was\n      -- interrupted by last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.recipient_name\n      end\n    end\n\n  class_name: detachable STRING\n      -- Name of the class that includes the recipient\n      -- of original form of last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.type_name\n      end\n    end\n\n  exception: INTEGER\n      -- Code of last exception that occurred\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.code\n      end\n    end\n\n  exception_trace: detachable STRING\n      -- String representation of the exception trace\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.original.trace as l_trace then\n        Result := l_trace.as_string_8\n      end\n    end\n\n  original_tag_name: detachable STRING\n      -- Assertion tag for original form of last\n      -- assertion violation.\n    do\n      if attached exception_manager.last_exception as l_exception and then attached l_exception.cause.original.description as l_des then\n        Result := l_des.as_string_8\n      end\n    end\n\n  original_exception: INTEGER\n      -- Original code of last exception that triggered\n      -- current exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.cause.original.code\n      end\n    end\n\n  original_recipient_name: detachable STRING\n      -- Name of the routine whose execution was\n      -- interrupted by original form of last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.cause.original.recipient_name\n      end\n    end\n\n  original_class_name: detachable STRING\n      -- Name of the class that includes the recipient\n      -- of original form of last exception\n    do\n      if attached exception_manager.last_exception as l_exception then\n        Result := l_exception.cause.original.type_name\n      end\n    end\n\nfeature -- Status setting\n\n  catch (code: INTEGER)\n      -- Make sure that any exception of code `code' will be\n      -- caught. This is the default.\n    do\n      if attached exception_manager.type_of_code (code) as l_type then\n        exception_manager.catch (l_type)\n      end\n    end\n\n  ignore (code: INTEGER)\n      -- Make sure that any exception of code `code' will be\n      -- ignored. This is not the default.\n    do\n      if attached exception_manager.type_of_code (code) as l_type then\n        exception_manager.ignore (l_type)\n      end\n    end\n\n  raise (name: detachable STRING)\n      -- Raise a developer exception of name `name'.\n    local\n      l_exception: DEVELOPER_EXCEPTION\n    do\n      create l_exception\n      l_exception.set_description (name)\n      l_exception.raise\n    end\n\n  raise_retrieval_exception (name: detachable STRING)\n      -- Raise a retrieval exception of name `name'.\n    do\n      if attached exception_manager.exception_from_code (serialization_exception) as l_exception then\n        l_exception.set_description (name)\n        l_exception.raise\n      end\n    end\n\n  die (code: INTEGER)\n      -- Terminate execution with exit status `code',\n      -- without triggering an exception.\n    external\n      \"C use %\"eif_except.h%\"\"\n    alias\n      \"esdie\"\n    ensure\n      False\n    end\n\n  new_die (code: INTEGER) obsolete \"Use ``die''\"\n      -- Terminate execution with exit status `code',\n      -- without triggering an exception.\n    external\n      \"C use %\"eif_except.h%\"\"\n    alias\n      \"esdie\"\n    ensure\n      False\n    end\n\n  message_on_failure\n      -- Print an exception history table\n      -- in case of failure.\n      -- This is the default.\n    do\n      c_trace_exception (True)\n    end\n\n  no_message_on_failure\n      -- Do not print an exception history table\n      -- in case of failure.\n    do\n      c_trace_exception (False)\n    end\n\nfeature {NONE} -- Implementation\n\n  c_trace_exception (b: BOOLEAN)\n    external\n      \"C use %\"eif_except.h%\"\"\n    alias\n      \"eetrace\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"finite.e","content":"note\n  description: \"Structures with a finite item count\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: finite, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class FINITE [G] inherit\n\n  BOX [G]\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of items\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    do\n      Result := (count = 0)\n    end\n\ninvariant\n  empty_definition: is_empty = (count = 0)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"function.e","content":"note\n  description: \"[\n    Objects representing delayed calls to a function,\n    with some arguments possibly still open.\n\n    Note: Features are the same as those of ROUTINE,\n      with `apply' made effective, and the addition\n      of `last_result' and `item'.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-28 14:35:23 -0800 (Tue, 28 Jan 2014) $\"\n  revision: \"$Revision: 94109 $\"\n\nclass\n  FUNCTION [BASE_TYPE -> detachable ANY, OPEN_ARGS -> detachable TUPLE create default_create end, RESULT_TYPE]\n\ninherit\n  ROUTINE [BASE_TYPE, OPEN_ARGS]\n    redefine\n      is_equal, copy\n    end\n\ncreate {NONE}\n  set_rout_disp\n\nfeature -- Access\n\n  last_result: detachable RESULT_TYPE\n      -- Result of last call, if any\n\n  call (args: detachable separate OPEN_ARGS)\n      -- <Precursor>\n    do\n      last_result := item (args)\n    end\n\n  item alias \"()\" (args: detachable separate OPEN_ARGS): RESULT_TYPE\n      -- Result of calling function with `args' as operands.\n    require\n      valid_operands: valid_operands (args)\n    local\n      l_closed_count: INTEGER\n      c: like closed_operands\n    do\n      c := closed_operands\n      if c/= Void then\n        l_closed_count :=  c.count\n      end\n      Result := fast_item (encaps_rout_disp, calc_rout_addr, $closed_operands, $args, routine_id,\n        is_basic, written_type_id_inline_agent, l_closed_count, open_count, $open_map)\n    end\n\n  apply\n      -- Call function with `operands' as last set.\n    do\n      last_result := item (operands)\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is associated function the same as the one\n      -- associated with `other'?\n    do\n      Result := Precursor (other) and then (last_result ~ other.last_result)\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Use same function as `other'.\n    do\n      if other /= Current then\n        Precursor (other)\n        last_result := other.last_result\n      end\n    end\n\nfeature -- Obsolete\n\n  eval (args: detachable OPEN_ARGS): RESULT_TYPE\n      -- Result of evaluating function for `args'.\n    obsolete\n      \"Please use `item' instead\"\n    require\n      valid_operands: valid_operands (args)\n    do\n      Result := item (args)\n    end\n\nfeature -- Removal\n\n  clear_last_result\n      -- Reset content of `last_result' to its default value.\n    local\n      l_result: detachable RESULT_TYPE\n    do\n      last_result := l_result\n    end\n\nfeature -- Extended operations\n\n  flexible_item (a: detachable separate TUPLE): RESULT_TYPE\n      -- Result of calling function with `a' as arguments.\n      -- Compared to `item' the type of `a' may be different from `{OPEN_ARGS}'.\n    require\n      valid_operands: valid_operands (a)\n    local\n      default_arguments: detachable OPEN_ARGS\n    do\n      if not attached a then\n        Result := item (default_arguments)\n      else\n        -- TODO: Implement in JavaScript\n        -- check\n        --   from_precondition: attached {OPEN_ARGS} new_tuple_from_tuple (({OPEN_ARGS}).type_id, a) as x\n        -- then\n        --   Result := item (x)\n        -- end\n      end\n    end\n\nfeature {NONE} -- Implementation\n\n  fast_item (a_rout_disp, a_calc_rout_addr: POINTER\n           a_closed_operands: POINTER; a_operands: POINTER\n         a_routine_id: INTEGER; a_is_basic: BOOLEAN; a_class_id_inline_agent: INTEGER;\n         a_closed_count, a_open_count: INTEGER; a_open_map: POINTER): RESULT_TYPE\n    external\n      \"C inline use %\"eif_rout_obj.h%\"\"\n    alias\n      \"[\n      #ifdef WORKBENCH\n        $$_result_type result;\n        if ($a_rout_disp != 0) {\n          return (FUNCTION_CAST(EIF_TYPED_VALUE, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n            $a_calc_rout_addr, $a_closed_operands, $a_operands).$$_result_value;\n        } else {\n          rout_obj_call_function_dynamic (\n            $a_routine_id,\n            $a_is_basic,\n            $a_class_id_inline_agent,\n            $a_closed_operands,\n            $a_closed_count,\n            $a_operands,\n            $a_open_count,\n            $a_open_map,\n            &result);\n          return result;\n        }\n      #else\n        return (FUNCTION_CAST($$_result_type, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n          $a_calc_rout_addr, $a_closed_operands, $a_operands);\n      #endif\n      ]\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"hashable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  HASHABLE\n\nfeature -- Access\n\n  hash_code: INTEGER\n      -- Hash code value\n    deferred\n    ensure\n      good_hash_value: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True by default.)\n    do\n      Result := True\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"immutable_string_8.e","content":"note\n  description: \"[\n    Sequences of immutable 8-bit characters, accessible through integer indices\n    in a contiguous range.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-03 14:26:20 -0800 (Fri, 03 Jan 2014) $\"\n  revision: \"$Revision: 93888 $\"\n\nfrozen class\n  IMMUTABLE_STRING_8\n\ninherit\n  READABLE_STRING_8\n    undefine\n      is_immutable\n    redefine\n      copy, area_lower\n    end\n\n  IMMUTABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    undefine\n      is_equal, out, copy\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_c,\n  make_from_cil,\n  make_from_separate\n\ncreate {IMMUTABLE_STRING_8}\n  make_from_area_and_bounds\n\nconvert\n  make_from_string ({READABLE_STRING_8, STRING_8}),\n  make_from_cil ({SYSTEM_STRING}),\n  to_cil: {SYSTEM_STRING},\n  as_string_32: {STRING_32},\n  as_string_8: {STRING_8}\n\nfeature {NONE} -- Initialization\n\n  make_from_area_and_bounds (a: like area; low, n: like count)\n      -- Initialize current with area `a' with lower bounds `low' and count `n'.\n    require\n      a_not_void: a /= Void\n      a_valid_count: (a.count - low) >= count + 1\n      low_non_negative: low >= 0\n      n_non_negative: n >= 0\n    do\n      area := a\n      area_lower := low\n      count := n\n    ensure\n      area_set: area = a\n      area_lower_set: area_lower = low\n      count_set: count = n\n    end\n\n  make_from_cil (a_system_string: SYSTEM_STRING)\n      -- <Precursor>\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 then\n        dotnet_convertor.read_system_string_into_area_8 (a_system_string, area)\n        count := l_count\n      end\n    end\n\nfeature {IMMUTABLE_STRING_8} -- Duplication\n\n  copy (other: like Current)\n      -- <Precursor>\n    do\n      if other /= Current then\n          -- Because it is immutable we can simply share the `area' from `other'.\n        standard_copy (other)\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8\n      -- Character at position `i'.\n    do\n      Result := area.item (i + area_lower - 1)\n    end\n\n  character_32_item (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    do\n      Result := area.item (i + area_lower - 1).to_character_32\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Numeric code of character at position `i'.\n    do\n      Result := area.item (i + area_lower - 1).natural_32_code\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n      -- Use `code' instead for consistency with Unicode handling.\n      --| Not obsolete because old code using just ASCII is safe.\n    do\n      Result := area.item (i + area_lower - 1).code\n    end\n\nfeature -- Element change\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    local\n      a, a_8: like area\n      i, j, nb: INTEGER\n      l_s32_area: SPECIAL [CHARACTER_32]\n    do\n      create a.make_empty (count + s.count + 1)\n      a.copy_data (area, area_lower, 0, count)\n      if attached {READABLE_STRING_8} s as l_s8 then\n        a.copy_data (l_s8.area, l_s8.area_lower, count, l_s8.count + 1)\n      elseif attached {READABLE_STRING_32} s as l_s32 then\n        create a_8.make_empty (l_s32.count + 1)\n        from\n          i := 0\n          j := l_s32.area_lower\n          l_s32_area := l_s32.area\n          nb := l_s32.count - 1\n        until\n          i > nb\n        loop\n          a_8.extend (l_s32_area [j].to_character_8)\n          i := i + 1\n          j := j + 1\n        end\n        a_8.extend ('%/000/')\n        a.copy_data (a_8, 0, count, nb + 2)\n      end\n      create Result.make_from_area_and_bounds (a, 0, count + s.count)\n    end\n\n  mirrored: like Current\n      -- <Precursor>\n    local\n      a: like area\n    do\n      create a.make_empty (count + 1)\n      a.copy_data (area, area_lower, 0, count + 1)\n      mirror_area (a, 0, count - 1)\n      create Result.make_from_area_and_bounds (a, 0, count)\n    end\n\n  as_lower: like Current\n      -- <Precursor>\n    local\n      a: like area\n    do\n      create a.make_empty (count + 1)\n      a.copy_data (area, area_lower, 0, count + 1)\n      to_lower_area (a, 0, count - 1)\n      create Result.make_from_area_and_bounds (a, 0, count)\n    end\n\n  as_upper: like Current\n      -- <Precursor>\n    local\n      a: like area\n    do\n      create a.make_empty (count + 1)\n      a.copy_data (area, area_lower, 0, count + 1)\n      to_upper_area (a, 0, count - 1)\n      create Result.make_from_area_and_bounds (a, 0, count)\n    end\n\n  substring (start_index, end_index: INTEGER_32): like Current\n      -- <Precursor>\n    local\n      a: like area\n      nb: INTEGER\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        nb := end_index - start_index + 1\n        create a.make_empty (nb + 1)\n        a.copy_data (area, area_lower + start_index - 1, 0, nb)\n        a.extend ('%/000/')\n        create Result.make_from_area_and_bounds (a, 0, nb)\n      else\n        Result := empty_string\n      end\n    end\n\n  shared_substring (start_index, end_index: INTEGER_32): like Current\n      -- <Precursor>\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        create Result.make_from_area_and_bounds (area, area_lower + start_index - 1, end_index - start_index + 1)\n      else\n        Result := empty_string\n      end\n    end\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    do\n      Result := count = 0\n    end\n\n  linear_representation: LINEAR [CHARACTER_8]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_8]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER_32): IMMUTABLE_STRING_8\n      -- <Precursor>\n    do\n      create Result.make (n)\n    end\n\n  empty_string: IMMUTABLE_STRING_8\n      -- Shared empty immutable string\n    once\n      create Result.make (0)\n    ensure\n      empty_string_not_void: Result /= Void\n      empty_string_empty: Result.is_empty\n    end\n\nfeature {READABLE_STRING_8, READABLE_STRING_32} -- Implementation\n\n  area_lower: INTEGER;\n      -- Index where current string starts in `area'\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"immutable_string_general.e","content":"note\n  description: \"Common ancestors to all immutable STRING classes.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  IMMUTABLE_STRING_GENERAL\n\ninherit\n  READABLE_STRING_GENERAL\n    redefine\n      is_immutable\n    end\n\nfeature -- Status report\n\n  is_immutable: BOOLEAN = True\n      -- <Precursor>\n\ninvariant\n  immutable: is_immutable\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class INDEXABLE [G, H -> INTEGER] inherit\n\n  TABLE [G, INTEGER]\n    rename\n      valid_key as valid_index,\n      force as put\n    end\n\n  READABLE_INDEXABLE [G]\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      asa_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\n-- convert\n--   make_from_reference ({INTEGER_32_REF}),\n--   to_real: {REAL_32},\n--   to_double: {REAL_64},\n--   to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_16.e","content":"note\n  description: \"Integer values coded on 16 bits\"\n  external_name: \"System.Int16\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_16 inherit\n\n  INTEGER_16_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_16_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_16): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_16): INTEGER_16\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_16): INTEGER_16\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_16): INTEGER_16\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_16): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_16\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_16\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_16): INTEGER_16\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_16): INTEGER_16\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_16): INTEGER_16\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_16): INTEGER_16\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_16): INTEGER_16\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_16\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_16\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_16\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_16_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 16 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_16_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_16\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item.to_integer.hash_code\n    end\n\n  sign: INTEGER_16\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_16 = -32768\n  Max_value: INTEGER_16 = 32767\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_16)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_16\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: INTEGER_16_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_16_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_16_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_16_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): INTEGER_16\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_16: n <= 16\n      n_greater_or_equal_to_minus_16: n >= -16\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      Result := item & ((1).to_integer_16 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_16\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      if b then\n        Result := item | ((1).to_integer_16 |<< n)\n      else\n        Result := item & ((1).to_integer_16 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_16): INTEGER_16\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (6)\n      Result.append_integer_16 (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := item & 0x7FFFFFFF\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_32 = -2147483648\n  Max_value: INTEGER_32 = 2147483647\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_32\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: INTEGER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_small: item >= {INTEGER_16}.Min_value\n      not_too_big: item <= {INTEGER_16}.Max_value\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER_32): INTEGER\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & (1 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | (1 |<< n)\n      else\n        Result := item & (1 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_32): INTEGER_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (11)\n      Result.append_integer (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_64.e","content":"note\n  description: \"Integer values coded on 64 bits\"\n  external_name: \"System.Int64\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_64\n\ninherit\n  INTEGER_64_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_64_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_64): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_64): INTEGER_64\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_64): INTEGER_64\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_64): INTEGER_64\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_64): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_64\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_64\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_64): INTEGER_64\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_64): INTEGER_64\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_64): INTEGER_64\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_64): INTEGER_64\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_64): INTEGER_64\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_64\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_64\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_64\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_64_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 64 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_64_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_64\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Get the positive value of `item' and then do\n        -- a modulo on the maximum INTEGER_32 value.\n      Result := (item & 0x000000007FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_64 = -9223372036854775808\n  Max_value: INTEGER_64 = 9223372036854775807\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_64)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0 and item.to_natural_64 <= {CHARACTER_32}.Max_value\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_64 >= {CHARACTER_32}.Min_value and\n        item.to_natural_64 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_64\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: INTEGER_64_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_64_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_32}.Max_value\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_small: item >= {INTEGER_16}.Min_value\n      not_too_big: item <= {INTEGER_16}.Max_value\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_small: item >= {INTEGER_32}.Min_value\n      not_too_big: item <= {INTEGER_32}.Max_value\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      val: INTEGER_64\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_64_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0x0F).to_integer\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_64_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): INTEGER_64\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_64: n <= 64\n      n_greater_or_equal_to_minus_64: n >= -64\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      Result := item & ((1).to_integer_64 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_64\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      if b then\n        Result := item | ((1).to_integer_64 |<< n)\n      else\n        Result := item & ((1).to_integer_64 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_64): INTEGER_64\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_integer_64 (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_8.e","content":"note\n  description: \"Integer values coded on 8 bits\"\n  external_name: \"System.SByte\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class INTEGER_8 inherit\n\n  INTEGER_8_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({INTEGER_8_REF}),\n  to_real: {REAL_32},\n  to_double: {REAL_64},\n  to_integer_16: {INTEGER_16},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_8): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_8): INTEGER_8\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_8): INTEGER_8\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_8): INTEGER_8\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_8): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_8\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_8\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_8): INTEGER_8\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_8): INTEGER_8\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_8): INTEGER_8\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_8): INTEGER_8\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_8): INTEGER_8\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_8\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_8\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_8\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_8_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 8 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_8_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_8\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item.to_integer.hash_code\n    end\n\n  sign: INTEGER_8\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_8 = -128\n  Max_value: INTEGER_8 = 127\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_8)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_8\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: INTEGER_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: V /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := 2\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 15)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      result_not_void: Result /= Void\n      result_valid_count: Result.count = 2\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      Result := tmp.to_hex_character\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): INTEGER_8\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_8: n <= 8\n      n_greater_or_equal_to_minus_8: n >= -8\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      Result := item & ((1).to_integer_8 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_8\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      if b then\n        Result := item | ((1).to_integer_8 |<< n)\n      else\n        Result := item & ((1).to_integer_8 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_8): INTEGER_8\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (4)\n      Result.append_integer_8 (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"iterable.e","content":"note\n  description: \"Structure that can be iterated over using `across...loop...end'.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  ITERABLE [G]\n\nfeature -- Access\n\n  new_cursor: ITERATION_CURSOR [G]\n      -- Fresh cursor associated with current structure\n    deferred\n    ensure\n      result_attached: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"linear.e","content":"note\n  description: \"Structures whose items may be accessed sequentially, one-way\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: sequential, traversing;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class LINEAR [G] inherit\n\n  TRAVERSABLE [G]\n    redefine\n      do_all, do_if, there_exists, for_all\n    end\n\nfeature -- Access\n\n  has (v: like item): BOOLEAN\n      -- Does structure include an occurrence of `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    do\n      start\n      if not off then\n        search (v)\n      end\n      Result := not exhausted\n    end\n\n  index_of (v: like item; i: INTEGER): INTEGER\n      -- Index of `i'-th occurrence of `v'.\n      -- 0 if none.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    require\n      positive_occurrences: i > 0\n    local\n      occur, pos: INTEGER\n    do\n      if object_comparison and v /= Void then\n        from\n          start\n          pos := 1\n        until\n          exhausted or (occur = i)\n        loop\n          if item ~ v then\n            occur := occur + 1\n          end\n          forth\n          pos := pos + 1\n        end\n      else\n        from\n          start\n          pos := 1\n        until\n          exhausted or (occur = i)\n        loop\n          if item = v then\n            occur := occur + 1\n          end\n          forth\n          pos := pos + 1\n        end\n      end\n      if occur = i then\n        Result := pos - 1\n      end\n    ensure\n      non_negative_result: Result >= 0\n    end\n\n  search (v: like item)\n      -- Move to first position (at or after current\n      -- position) where `item' and `v' are equal.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      -- If no such position ensure that `exhausted' will be true.\n    do\n      if object_comparison then\n        from\n        until\n          exhausted or else v ~ item\n        loop\n          forth\n        end\n      else\n        from\n        until\n          exhausted or else v = item\n        loop\n          forth\n        end\n      end\n    ensure\n      object_found: (not exhausted and object_comparison)\n         implies v ~ item\n      item_found: (not exhausted and not object_comparison)\n         implies v = item\n    end\n\n  index: INTEGER\n      -- Index of current position\n    deferred\n    end\n\n  occurrences (v: like item): INTEGER\n      -- Number of times `v' appears.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    do\n      from\n        start\n        search (v)\n      until\n        exhausted\n      loop\n        Result := Result + 1\n        forth\n        search (v)\n      end\n    end\n\n  item_for_iteration: G\n      -- Item at current position\n    require\n      not_off: not off\n    do\n      Result := item\n    end\n\nfeature -- Status report\n\n  exhausted: BOOLEAN\n      -- Has structure been completely explored?\n    do\n      Result := off\n    ensure\n      exhausted_when_off: off implies Result\n    end\n\n  after: BOOLEAN\n      -- Is there no valid position to the right of current one?\n    deferred\n    end\n\n  off: BOOLEAN\n      -- Is there no current item?\n    do\n      Result := is_empty or after\n    end\n\nfeature -- Cursor movement\n\n  finish\n      -- Move to last position.\n    deferred\n    end\n\n  forth\n      -- Move to next position; if no next position,\n      -- ensure that `exhausted' will be true.\n    require\n      not_after: not after\n    deferred\n    ensure\n      -- moved_forth_before_end: (not after) implies index = old index + 1\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n      until\n        after\n      loop\n        action.call ([item])\n        forth\n      end\n\n      if cs /= Void and c /= Void then\n        cs.go_to (c)\n      end\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test'.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n      until\n        after\n      loop\n        if test.item ([item]) then\n          action.call ([item])\n        end\n        forth\n      end\n\n      if cs /= Void and c /= Void then\n        cs.go_to (c)\n      end\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n      -- Semantics not guaranteed if `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable  CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n      until\n        after or Result\n      loop\n        Result := test.item ([item])\n        forth\n      end\n\n      if cs /= Void and c /=Void then\n        cs.go_to (c)\n      end\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n      -- Semantics not guaranteed if `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      c: detachable CURSOR\n      cs: detachable  CURSOR_STRUCTURE [G]\n    do\n      if attached {CURSOR_STRUCTURE [G]} Current as acs then\n        cs := acs\n        c := acs.cursor\n      end\n\n      from\n        start\n        Result := True\n      until\n        after or not Result\n      loop\n        Result := test.item ([item])\n        forth\n      end\n\n      if cs /= Void and c /= Void then\n        cs.go_to (c)\n      end\n    ensure then\n      empty: is_empty implies Result\n    end\n\nfeature -- Conversion\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    do\n      Result := Current\n    end\n\ninvariant\n\n  after_constraint: after implies off\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"list.e","content":"note\n  description: \"Sequential lists, without commitment to a particular representation\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: list, sequence;\n  access: index, cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class LIST [G] inherit\n\n  CHAIN [G]\n    export\n      {ANY} remove\n    redefine\n      forth, is_equal\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Does `other' contain the same elements?\n    do\n      if Current = other then\n        Result := True\n      else\n        Result := (is_empty = other.is_empty) and\n            (object_comparison = other.object_comparison) and\n            (count = other.count)\n        if Result and not is_empty then\n          if\n            attached {CURSOR} cursor as c1 and then\n            attached {CURSOR} other.cursor as c2\n          then\n            from\n              start\n              other.start\n            until\n              after or not Result\n            loop\n              if object_comparison then\n                Result := item ~ other.item\n              else\n                Result := item = other.item\n              end\n              forth\n              other.forth\n            end\n            go_to (c1)\n            other.go_to (c2)\n          else\n            check\n              cursors_exist: False\n                -- Because every list contains a cursor object\n            end\n          end\n        elseif is_empty and other.is_empty and\n          object_comparison = other.object_comparison then\n          Result := True\n        end\n      end\n    ensure then\n      indices_unchanged:\n        index = old index and other.index = old other.index\n      true_implies_same_size: Result implies count = other.count\n    end\n\nfeature -- Status report\n\n  after: BOOLEAN\n      -- Is there no valid cursor position to the right of cursor?\n    do\n      Result := (index = count + 1)\n    end\n\n  before: BOOLEAN\n      -- Is there no valid cursor position to the left of cursor?\n    do\n      Result := (index = 0)\n    end\n\nfeature -- Cursor movement\n\n  forth\n      -- Move to next position; if no next position,\n      -- ensure that `exhausted' will be true.\n    deferred\n    ensure then\n      moved_forth: index = old index + 1\n    end\n\ninvariant\n\n  before_definition: before = (index = 0)\n  after_definition: after = (index = count + 1)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"managed_pointer.e","content":"note\n  description: \"[\n    To easily manage allocation and release of allocated C memory, and\n    to perform insertion of basic elements. Byte order is by default\n    platform specific.\n    Although memory allocation routines do not accept a zero sized pointer\n    MANAGED_POINTER does by allocating in fact a 1 byte sized pointer for\n    this particular case.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-29 17:12:00 -0700 (Mon, 29 Oct 2012) $\"\n  revision: \"$Revision: 92015 $\"\n\nclass\n  MANAGED_POINTER\n\ninherit\n  DISPOSABLE\n    redefine\n      is_equal, copy\n    end\n\n  PLATFORM\n    redefine\n      is_equal, copy\n    end\n\ncreate\n  make, make_from_array, make_from_pointer, share_from_pointer, own_from_pointer\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate `item' with `n' bytes.\n    require\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := item.memory_calloc (n.max (1), 1)\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      count := n\n      is_shared := False\n    ensure\n      item_set: item /= default_pointer\n      count_set: count = n\n      is_shared_set: not is_shared\n    end\n\n  make_from_array (data: ARRAY [NATURAL_8])\n      -- Allocate `item' with `data.count' bytes and copy\n      -- content of `data' into `item'.\n    require\n      data_not_void: data /= Void\n    do\n      increment_counter\n      count := data.count\n      item := item.memory_alloc (count.max (1))\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      put_array (data, 0)\n      is_shared := False\n    ensure\n      item_set: item /= default_pointer\n      count_set: count = data.count\n      is_shared_set: not is_shared\n    end\n\n  make_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Copy `a_count' bytes from `a_ptr' into current.\n    require\n      a_ptr_not_null: a_ptr /= default_pointer\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := item.memory_alloc (n.max (1))\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      item.memory_copy (a_ptr, n)\n      count := n\n      is_shared := False\n    ensure\n      item_set: item /= default_pointer\n      count_set: count = n\n      is_shared_set: not is_shared\n    end\n\n  share_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Use directly `a_ptr' with count `n' to hold current data.\n    require\n      a_ptr_valid: a_ptr = default_pointer implies n = 0\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := a_ptr\n      count := n\n      is_shared := True\n    ensure\n      item_set: item = a_ptr\n      count_set: count = n\n      is_shared_set: is_shared\n    end\n\n  own_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Use directly `a_ptr' with count `n' to hold current data and free\n      -- its associated C memory when Current is collected.\n      -- It assumes that `a_ptr' was allocated using the C-`malloc' routine and thus\n      -- will be freed by calling the C-`free' routine.\n    require\n      a_ptr_valid: a_ptr /= default_pointer\n      n_non_negative: n >= 0\n    do\n      increment_counter\n      item := a_ptr\n      count := n\n      is_shared := False\n    ensure\n      item_set: item = a_ptr\n      count_set: count = n\n      is_shared_set: not is_shared\n    end\n\nfeature -- Settings\n\n  set_from_pointer (a_ptr: POINTER; n: INTEGER)\n      -- Use directly `a_ptr' with count `n' to hold current data.\n    require\n      is_shared: is_shared\n      a_ptr_not_null: a_ptr = default_pointer implies n = 0\n      n_non_negative: n >= 0\n    do\n      item := a_ptr\n      count := n\n    ensure\n      item_set: item = a_ptr\n      count_set: count = n\n      is_shared_unchanged: is_shared\n    end\n\nfeature -- Access\n\n  item: POINTER note option: transient attribute end\n      -- Access to allocated memory.\n\n  count: INTEGER\n      -- Number of elements that Current can hold.\n\n  is_shared: BOOLEAN\n      -- Is `item' shared with another memory area?\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered equal to current object?\n    do\n      if count = other.count then\n        Result := (item = other.item) or else item.memory_compare (other.item, count)\n      end\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Update current object using fields of object attached\n      -- to `other', so as to yield equal objects. If `is_shared'\n      -- and current is not large enough to hold `other' create\n      -- a new pointer area and `is_shared' is set to `False'.\n    do\n      if other /= Current then\n        if item = other.item or is_shared then\n            -- Copy was most likely called via `twin' but even\n            -- if it is not, it makes sense to duplicate the memory.\n            -- Or before `item' was shared, so we simply allocate\n            -- a new memory area from `other' and reset\n            -- the `is_shared' flag.\n          make_from_pointer (other.item, other.count)\n        else\n            -- Simply resize Current and copy data.\n          resize (other.count)\n          item.memory_copy (other.item, other.count)\n        end\n      end\n    ensure then\n      sharing_status_not_preserved: (other /= Current) implies (old is_shared implies not is_shared)\n      count_preserved: count = other.count\n    end\n\nfeature -- Access: Platform specific\n\n  read_natural_8 (pos: INTEGER): NATURAL_8\n      -- Read NATURAL_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_8_bytes)\n    end\n\n  read_natural_16 (pos: INTEGER): NATURAL_16\n      -- Read NATURAL_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_16_bytes)\n    end\n\n  read_natural_32 (pos: INTEGER): NATURAL_32\n      -- Read NATURAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_32_bytes)\n    end\n\n  read_natural_64 (pos: INTEGER): NATURAL_64\n      -- Read NATURAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_64_bytes)\n    end\n\n  read_integer_8 (pos: INTEGER): INTEGER_8\n      -- Read INTEGER_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      Result := read_natural_8 (pos).as_integer_8\n    end\n\n  read_integer_16 (pos: INTEGER): INTEGER_16\n      -- Read INTEGER_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      Result := read_natural_16 (pos).as_integer_16\n    end\n\n  read_integer_32 (pos: INTEGER): INTEGER\n      -- Read INTEGER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      Result := read_natural_32 (pos).as_integer_32\n    end\n\n  read_integer_64 (pos: INTEGER): INTEGER_64\n      -- Read INTEGER_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      Result := read_natural_64 (pos).as_integer_64\n    end\n\n  read_pointer (pos: INTEGER): POINTER\n      -- Read POINTER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Pointer_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Pointer_bytes)\n    end\n\n  read_boolean (pos: INTEGER): BOOLEAN\n      -- Read BOOLEAN at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Boolean_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Boolean_bytes)\n    end\n\n  read_character (pos: INTEGER): CHARACTER\n      -- Read CHARACTER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Character_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Character_8_bytes)\n    end\n\n  read_real (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    obsolete \"Use read_real_32 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_32_bytes)\n    end\n\n  read_real_32 (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_32_bytes)\n    end\n\n  read_double (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    obsolete \"Use read_real_64 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_64_bytes)\n    end\n\n  read_real_64 (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, Real_64_bytes)\n    end\n\n  read_array (pos, a_count: INTEGER): ARRAY [NATURAL_8]\n      -- Read `count' bytes at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      count_positive: a_count > 0\n      valid_position: (pos + a_count) <= count\n    local\n      i: INTEGER\n      l_area: SPECIAL [NATURAL_8]\n    do\n      from\n        create l_area.make_empty (a_count)\n      until\n        i >= a_count\n      loop\n        l_area.extend (read_natural_8 (pos + i))\n        i := i + 1\n      end\n      create Result.make_from_special (l_area)\n    ensure\n      read_array_not_void: Result /= Void\n      read_array_valid_count: Result.count = a_count\n    end\n\nfeature -- Element change: Platform specific\n\n  put_natural_8 (i: NATURAL_8; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_8_bytes)\n    ensure\n      inserted: i = read_natural_8 (pos)\n    end\n\n  put_natural_16 (i: NATURAL_16; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_16_bytes)\n    ensure\n      inserted: i = read_natural_16 (pos)\n    end\n\n  put_natural_32 (i: NATURAL_32; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_32_bytes)\n    ensure\n      inserted: i = read_natural_32 (pos)\n    end\n\n  put_natural_64 (i: NATURAL_64; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_64_bytes)\n    ensure\n      inserted: i = read_natural_64 (pos)\n    end\n\n  put_integer_8 (i: INTEGER_8; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      put_natural_8 (i.as_natural_8, pos)\n    ensure\n      inserted: i = read_integer_8 (pos)\n    end\n\n  put_integer_16 (i: INTEGER_16; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      put_natural_16 (i.as_natural_16, pos)\n    ensure\n      inserted: i = read_integer_16 (pos)\n    end\n\n  put_integer_32 (i: INTEGER; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      put_natural_32 (i.as_natural_32, pos)\n    ensure\n      inserted: i = read_integer_32 (pos)\n    end\n\n  put_integer_64 (i: INTEGER_64; pos: INTEGER)\n      -- Insert `i' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      put_natural_64 (i.as_natural_64, pos)\n    ensure\n      inserted: i = read_integer_64 (pos)\n    end\n\n  put_pointer (p: POINTER; pos: INTEGER)\n      -- Insert `p' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Pointer_bytes) <= count\n    do\n      (item + pos).memory_copy ($p, Pointer_bytes)\n    ensure\n      inserted: p = read_pointer (pos)\n    end\n\n  put_boolean (b: BOOLEAN; pos: INTEGER)\n      -- Insert `b' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Boolean_bytes) <= count\n    do\n      (item + pos).memory_copy ($b, Boolean_bytes)\n    ensure\n      inserted: b = read_boolean (pos)\n    end\n\n  put_character (c: CHARACTER; pos: INTEGER)\n      -- Insert `c' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Character_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($c, Character_8_bytes)\n    ensure\n      inserted: c = read_character (pos)\n    end\n\n  put_real (r: REAL; pos: INTEGER)\n      -- Insert `r' at position `pos'.\n    obsolete \"Use put_real_32 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      (item + pos).memory_copy ($r, Real_32_bytes)\n    ensure\n      inserted: r = read_real_32 (pos)\n    end\n\n  put_real_32 (r: REAL; pos: INTEGER)\n      -- Insert `r' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_32_bytes) <= count\n    do\n      (item + pos).memory_copy ($r, Real_32_bytes)\n    ensure\n      inserted: r = read_real_32 (pos)\n    end\n\n  put_double (d: DOUBLE; pos: INTEGER)\n      -- Insert `d' at position `pos'.\n    obsolete \"Use put_real_64 instead.\"\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      (item + pos).memory_copy ($d, Real_64_bytes)\n    ensure\n      inserted: d = read_real_64 (pos)\n    end\n\n  put_real_64 (d: DOUBLE; pos: INTEGER)\n      -- Insert `d' at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + Real_64_bytes) <= count\n    do\n      (item + pos).memory_copy ($d, Real_64_bytes)\n    ensure\n      inserted: d = read_real_64 (pos)\n    end\n\n  put_array (data: ARRAY [NATURAL_8]; pos: INTEGER)\n      -- Copy content of `data' into `item' at position `pos'.\n    require\n      data_not_void: data /= Void\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + data.count) <= count\n    local\n      l_sp: SPECIAL [NATURAL_8]\n    do\n      l_sp := data.area;\n      (item + pos).memory_copy ($l_sp, data.count)\n    ensure\n      inserted: read_array (pos, data.count) ~ data\n    end\n\nfeature -- Access: Little-endian format\n\n  read_natural_8_le (pos: INTEGER): NATURAL_8\n      -- Read NATURAL_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_8_bytes)\n    end\n\n  read_natural_16_le (pos: INTEGER): NATURAL_16\n      -- Read NATURAL_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    local\n      l_high, l_low: NATURAL_16\n    do\n      if is_little_endian then\n        Result := read_natural_16 (pos)\n      else\n        l_low := {NATURAL_16} 0x00FF & read_natural_8 (pos)\n        l_high := read_natural_8 (pos + natural_8_bytes)\n        Result := (l_high.to_natural_16 |<< 8) | l_low\n      end\n    end\n\n  read_natural_32_le (pos: INTEGER): NATURAL_32\n      -- Read NATURAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    local\n      l_high, l_low: NATURAL_32\n    do\n      if is_little_endian then\n        Result := read_natural_32 (pos)\n      else\n        l_low := {NATURAL_32} 0x0000FFFF & read_natural_16_le (pos)\n        l_high := read_natural_16_le (pos + natural_16_bytes)\n        Result := (l_high.to_natural_32 |<< 16) | l_low\n      end\n    end\n\n  read_natural_64_le (pos: INTEGER): NATURAL_64\n      -- Read NATURAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    local\n      l_high, l_low: NATURAL_64\n    do\n      if is_little_endian then\n        Result := read_natural_64 (pos)\n      else\n        l_low := {NATURAL_64} 0x00000000FFFFFFFF & read_natural_32_le (pos)\n        l_high := read_natural_32_le (pos + natural_32_bytes)\n        Result := (l_high.to_natural_64 |<< 32) | l_low\n      end\n    end\n\n  read_integer_8_le (pos: INTEGER): INTEGER_8\n      -- Read INTEGER_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      Result := read_natural_8_le (pos).as_integer_8\n    end\n\n  read_integer_16_le (pos: INTEGER): INTEGER_16\n      -- Read INTEGER_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      Result := read_natural_16_le (pos).as_integer_16\n    end\n\n  read_integer_32_le (pos: INTEGER): INTEGER\n      -- Read INTEGER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      Result := read_natural_32_le (pos).as_integer_32\n    end\n\n  read_integer_64_le (pos: INTEGER): INTEGER_64\n      -- Read INTEGER_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      Result := read_natural_64_le (pos).as_integer_64\n    end\n\n  read_real_32_le (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      l_nat32 := read_natural_32_le (pos)\n      ($Result).memory_copy ($l_nat32, natural_32_bytes)\n    end\n\n  read_real_64_le (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      l_nat64 := read_natural_64_le (pos)\n      ($Result).memory_copy ($l_nat64, natural_64_bytes)\n    end\n\nfeature -- Element change: Little-endian format\n\n  put_natural_8_le (i: NATURAL_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_8_bytes)\n    ensure\n      inserted: i = read_natural_8_le (pos)\n    end\n\n  put_natural_16_le (i: NATURAL_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_16 (i, pos)\n      else\n        put_natural_8 ((i & 0x00FF).to_natural_8, pos)\n        put_natural_8 ((((i & 0xFF00) |>> 8) & 0x00FF).to_natural_8, pos + natural_8_bytes)\n      end\n    ensure\n      inserted: i = read_natural_16_le (pos)\n    end\n\n  put_natural_32_le (i: NATURAL_32; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_32 (i, pos)\n      else\n        put_natural_16_le ((i & 0x0000FFFF).to_natural_16, pos)\n        put_natural_16_le ((((i & 0xFFFF0000) |>> 16) & 0x0000FFFF).to_natural_16, pos + natural_16_bytes)\n      end\n    ensure\n      inserted: i = read_natural_32_le (pos)\n    end\n\n  put_natural_64_le (i: NATURAL_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_64 (i, pos)\n      else\n        put_natural_32_le ((i & 0x00000000FFFFFFFF).to_natural_32, pos)\n        put_natural_32_le (\n          (((i & 0xFFFFFFFF00000000) |>> 32) & 0x00000000FFFFFFFF).to_natural_32,\n          pos+ natural_32_bytes)\n      end\n    ensure\n      inserted: i = read_natural_64_le (pos)\n    end\n\n  put_integer_8_le (i: INTEGER_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      put_natural_8_le (i.as_natural_8, pos)\n    ensure\n      inserted: i = read_integer_8_le (pos)\n    end\n\n  put_integer_16_le (i: INTEGER_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      put_natural_16_le (i.as_natural_16, pos)\n    ensure\n      inserted: i = read_integer_16_le (pos)\n    end\n\n  put_integer_32_le (i: INTEGER; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      put_natural_32_le (i.as_natural_32, pos)\n    ensure\n      inserted: i = read_integer_32_le (pos)\n    end\n\n  put_integer_64_le (i: INTEGER_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      put_natural_64_le (i.as_natural_64, pos)\n    ensure\n      inserted: i = read_integer_64_le (pos)\n    end\n\n  put_real_32_le (v: REAL; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      ($l_nat32).memory_copy ($v, natural_32_bytes)\n      put_natural_32_le (l_nat32, pos)\n    ensure\n      inserted: v = read_real_32_le (pos)\n    end\n\n  put_real_64_le (v: DOUBLE; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in little-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      ($l_nat64).memory_copy ($v, natural_64_bytes)\n      put_natural_64_le (l_nat64, pos)\n    ensure\n      inserted: v = read_real_64_le (pos)\n    end\n\nfeature -- Access: Big-endian format\n\n  read_natural_8_be (pos: INTEGER): NATURAL_8\n      -- Read NATURAL_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      ($Result).memory_copy (item + pos, natural_8_bytes)\n    end\n\n  read_natural_16_be (pos: INTEGER): NATURAL_16\n      -- Read NATURAL_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    local\n      l_high, l_low: NATURAL_16\n    do\n      if is_little_endian then\n        l_high := read_natural_8 (pos)\n        l_low := (0x00FF).to_natural_16 & read_natural_8 (pos + natural_8_bytes)\n        Result := (l_high.to_natural_16 |<< 8) | l_low\n      else\n        Result := read_natural_16 (pos)\n      end\n    end\n\n  read_natural_32_be (pos: INTEGER): NATURAL_32\n      -- Read NATURAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    local\n      l_high, l_low: NATURAL_32\n    do\n      if is_little_endian then\n        l_high := read_natural_16_be (pos)\n        l_low := (0x0000FFFF).to_natural_32 & read_natural_16_be (pos + natural_16_bytes)\n        Result := (l_high.to_natural_32 |<< 16) | l_low\n      else\n        Result := read_natural_32 (pos)\n      end\n    end\n\n  read_natural_64_be (pos: INTEGER): NATURAL_64\n      -- Read NATURAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    local\n      l_high, l_low: NATURAL_64\n    do\n      if is_little_endian then\n        l_high := read_natural_32_be (pos)\n        l_low := {NATURAL_64} 0x00000000FFFFFFFF & read_natural_32_be (pos + natural_32_bytes)\n        Result := (l_high.to_natural_64 |<< 32) | l_low\n      else\n        Result := read_natural_64 (pos)\n      end\n    end\n\n  read_integer_8_be (pos: INTEGER): INTEGER_8\n      -- Read INTEGER_8 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      Result := read_natural_8_be (pos).as_integer_8\n    end\n\n  read_integer_16_be (pos: INTEGER): INTEGER_16\n      -- Read INTEGER_16 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      Result := read_natural_16_be (pos).as_integer_16\n    end\n\n  read_integer_32_be (pos: INTEGER): INTEGER\n      -- Read INTEGER at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      Result := read_natural_32_be (pos).as_integer_32\n    end\n\n  read_integer_64_be (pos: INTEGER): INTEGER_64\n      -- Read INTEGER_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      Result := read_natural_64_be (pos).as_integer_64\n    end\n\n  read_real_32_be (pos: INTEGER): REAL\n      -- Read REAL_32 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      l_nat32 := read_natural_32_be (pos)\n      ($Result).memory_copy ($l_nat32, natural_32_bytes)\n    end\n\n  read_real_64_be (pos: INTEGER): DOUBLE\n      -- Read REAL_64 at position `pos'.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      l_nat64 := read_natural_64_be (pos)\n      ($Result).memory_copy ($l_nat64, natural_64_bytes)\n    end\n\nfeature -- Element change: Big-endian format\n\n  put_natural_8_be (i: NATURAL_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_8_bytes) <= count\n    do\n      (item + pos).memory_copy ($i, natural_8_bytes)\n    ensure\n      inserted: i = read_natural_8_be (pos)\n    end\n\n  put_natural_16_be (i: NATURAL_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_16_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_8 ((((i & 0xFF00) |>> 8) & 0x00FF).to_natural_8, pos)\n        put_natural_8 ((i & 0x00FF).to_natural_8, pos + natural_8_bytes)\n      else\n        put_natural_16 (i, pos)\n      end\n    ensure\n      inserted: i = read_natural_16_be (pos)\n    end\n\n  put_natural_32_be (i: NATURAL_32; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_32_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_16_be ((((i & 0xFFFF0000) |>> 16) & 0x0000FFFF).to_natural_16, pos)\n        put_natural_16_be ((i & 0x0000FFFF).to_natural_16, pos + natural_16_bytes)\n      else\n        put_natural_32 (i, pos)\n      end\n    ensure\n      inserted: i = read_natural_32_be (pos)\n    end\n\n  put_natural_64_be (i: NATURAL_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + natural_64_bytes) <= count\n    do\n      if is_little_endian then\n        put_natural_32_be (\n          (((i & 0xFFFFFFFF00000000) |>> 32) & 0x00000000FFFFFFFF).to_natural_32, pos)\n        put_natural_32_be ((i & 0x00000000FFFFFFFF).to_natural_32,\n          pos + natural_32_bytes)\n      else\n        put_natural_64 (i, pos)\n      end\n    ensure\n      inserted: i = read_natural_64_be (pos)\n    end\n\n  put_integer_8_be (i: INTEGER_8; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_8_bytes) <= count\n    do\n      put_natural_8_be (i.as_natural_8, pos)\n    ensure\n      inserted: i = read_integer_8_be (pos)\n    end\n\n  put_integer_16_be (i: INTEGER_16; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_16_bytes) <= count\n    do\n      put_natural_16_be (i.as_natural_16, pos)\n    ensure\n      inserted: i = read_integer_16_be (pos)\n    end\n\n  put_integer_32_be (i: INTEGER; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_32_bytes) <= count\n    do\n      put_natural_32_be (i.as_natural_32, pos)\n    ensure\n      inserted: i = read_integer_32_be (pos)\n    end\n\n  put_integer_64_be (i: INTEGER_64; pos: INTEGER)\n      -- Insert `i' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + integer_64_bytes) <= count\n    do\n      put_natural_64_be (i.as_natural_64, pos)\n    ensure\n      inserted: i = read_integer_64_be (pos)\n    end\n\n  put_real_32_be (v: REAL; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_32_bytes) <= count\n    local\n      l_nat32: NATURAL_32\n    do\n      check\n        correct_size: real_32_bytes = natural_32_bytes\n      end\n      ($l_nat32).memory_copy ($v, natural_32_bytes)\n      put_natural_32_be (l_nat32, pos)\n    ensure\n      inserted: v = read_real_32_be (pos)\n    end\n\n  put_real_64_be (v: DOUBLE; pos: INTEGER_32)\n      -- Insert `v' at position `pos' in big-endian format.\n    require\n      pos_nonnegative: pos >= 0\n      valid_position: (pos + real_64_bytes) <= count\n    local\n      l_nat64: NATURAL_64\n    do\n      check\n        correct_size: real_64_bytes = natural_64_bytes\n      end\n      ($l_nat64).memory_copy ($v, natural_64_bytes)\n      put_natural_64_be (l_nat64, pos)\n    ensure\n      inserted: v = read_real_64_be (pos)\n    end\n\nfeature -- Concatenation\n\n  append (other: like Current)\n      -- Append `other' at the end of Current.\n    require\n      not_shared: not is_shared\n      other_not_void: other /= Void\n    local\n      new_count: INTEGER\n    do\n      new_count := count + other.count\n      item := item.memory_realloc (new_count.max (1))\n      if item = default_pointer then\n        (create {EXCEPTIONS}).raise (\"No more memory\")\n      end\n      (item + count).memory_copy (other.item, other.count)\n      count := new_count\n    end\n\nfeature -- Resizing\n\n  resize (n: INTEGER)\n      -- Reallocate `item' to hold `n' bytes.\n    require\n      n_non_negative: n >= 0\n      not_shared: not is_shared\n    do\n        -- Reallocate.\n      if n /= count then\n        item := item.memory_realloc (n.max (1))\n        if item = default_pointer then\n          (create {EXCEPTIONS}).raise (\"No more memory\")\n        end\n      end\n\n      if n > count then\n          -- Reset newly allocated memory to `0'.\n        (item + count).memory_set (0, n - count)\n      end\n      count := n\n    end\n\nfeature {NONE} -- Disposal\n\n  dispose\n      -- Release memory pointed by `item'.\n    local\n      null: POINTER\n    do\n      if not is_shared then\n        item.memory_free\n      end\n      item := null\n      is_shared := False\n    ensure then\n      shared_reset: not is_shared\n    end\n\nfeature {NONE} -- Debugging\n\n  allocation_counter: CELL [NATURAL_64]\n      -- Store current number of allocation being made.\n    once\n      create Result.put (0)\n    end\n\n  counter: NATURAL_64 note option: transient attribute end\n      -- Allocation number associated to Current.\n\n  increment_counter\n      -- Set `counter' with a new allocation number.\n    do\n      debug (\"MANAGED_POINTER_allocation\")\n        counter := allocation_counter.item + 1\n        allocation_counter.put (counter)\n      end\n    end\n\n\ninvariant\n  item_not_null: item = default_pointer implies (count = 0 and is_shared)\n  valid_count: count >= 0\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"mismatch_corrector.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  MISMATCH_CORRECTOR\n\nfeature -- Correction\n\n  correct_mismatch\n      -- Attempt to correct object mismatch using `mismatch_information'.\n    local\n      l_msg: STRING\n      l_exc: EXCEPTIONS\n    do\n        -- If it is not redefined then we raise an exception.\n      create l_msg.make_from_string (\"Mismatch: \")\n      create l_exc\n      l_msg.append (generating_type)\n      l_exc.raise_retrieval_exception (l_msg)\n    end\n\n  mismatch_information: MISMATCH_INFORMATION\n      -- Original attribute values of mismatched object\n    once\n      create Result\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"native_array.e","content":"note\n  description: \"Fake abstraction of a .NET NATIVE_ARRAY in a non-.NET system\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-04-23 14:49:02 -0700 (Tue, 23 Apr 2013) $\"\n  revision: \"$Revision: 92470 $\"\n\nfrozen class\n  NATIVE_ARRAY [G]\n\ninvariant\n  is_dotnet: {PLATFORM}.is_dotnet\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_16.e","content":"note\n  description: \"Unsigned integer values coded on 16 bits\"\n  external_name: \"System.UInt16\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class NATURAL_16\n\ninherit\n  NATURAL_16_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_16_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64},\n  to_natural_32: {NATURAL_32},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_16): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_16): NATURAL_16\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_16): NATURAL_16\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_16): NATURAL_16\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_16): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_16\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_16): NATURAL_16\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_16): NATURAL_16\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_16): NATURAL_16\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_16): NATURAL_16\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_16): NATURAL_16\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_16\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_16\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_16\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_16_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 16 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_16_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_16\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_16 = 0\n  Max_value: NATURAL_16 = 65535\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_16)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: NATURAL_16_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_16_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_16\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_16\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_16_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_16_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_16\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_16: n <= 16\n      n_greater_or_equal_to_minus_16: n >= -16\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_16: n <= 16\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      Result := item & ((1).to_natural_16 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_16\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_16: n < 16\n    do\n      if b then\n        Result := item | ((1).to_natural_16 |<< n)\n      else\n        Result := item & ((1).to_natural_16 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_16): NATURAL_16\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (5)\n      Result.append_natural_16 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32.e","content":"note\n  description: \"Unsigned integer values coded on 32 bits.\"\n  external_name: \"System.UInt32\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_32 inherit\n\n  NATURAL_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_32_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_64: {INTEGER_64},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_32): NATURAL_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_32): NATURAL_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_32): NATURAL_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_32): NATURAL_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_32): NATURAL_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_32): NATURAL_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := (item & 0x7FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_32 = 0\n  Max_value: NATURAL_32 = 4294967295\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value.to_natural_32\n    ensure\n      in_bounds: Result = (\n        item >= {CHARACTER_8}.Min_value.to_natural_32 and\n        item <= {CHARACTER_8}.Max_value.to_natural_32)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: NATURAL_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_32\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_32\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_big: item <= {INTEGER_32}.Max_value.to_natural_32\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      a_digit, val: NATURAL_32\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & ((1).to_natural_32 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | ((1).to_natural_32 |<< n)\n      else\n        Result := item & ((1).to_natural_32 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_32): NATURAL_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_natural_32 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_64.e","content":"note\n  description: \"Unsigned integer values coded on 64 bits\"\n  external_name: \"System.UInt64\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class NATURAL_64\n\ninherit\n  NATURAL_64_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_64_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_64): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_64): NATURAL_64\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_64): NATURAL_64\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_64): NATURAL_64\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_64): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_64\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_64): NATURAL_64\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_64): NATURAL_64\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_64): NATURAL_64\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_64): NATURAL_64\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_64): NATURAL_64\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_64\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_64\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_64\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_64_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 64 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_64_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_64\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Get the positive value of `item' and then do\n        -- a modulo on the maximum INTEGER_32 value.\n      Result := (item & 0x000000007FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_64 = 0\n  Max_value: NATURAL_64 = 18446744073709551615\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_64)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value.to_natural_64\n    ensure\n      in_bounds: Result = (\n        item >= {CHARACTER_8}.Min_value.to_natural_64 and\n        item <= {CHARACTER_8}.Max_value.to_natural_64)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item <= {CHARACTER_32}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other + 0\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: NATURAL_64_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_64_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      not_too_big: item <= {NATURAL_32}.Max_value\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_64\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_64\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_big: item <= {INTEGER_32}.Max_value.to_natural_64\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    require\n      not_too_big: item <= {INTEGER_64}.Max_value.to_natural_64\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      val: NATURAL_64\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_64_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0x0F).to_integer_32\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_64_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_64\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_64: n <= 64\n      n_greater_or_equal_to_minus_64: n >= -64\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_64: n <= 64\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      Result := item & ((1).to_natural_64 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_64\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_64: n < 64\n    do\n      if b then\n        Result := item | ((1).to_natural_64 |<< n)\n      else\n        Result := item & ((1).to_natural_64 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_64): NATURAL_64\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_natural_64 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_8.e","content":"note\n  description: \"Integer values coded on 8 bits\"\n  external_name: \"System.Byte\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_8 inherit\n\n  NATURAL_8_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_8_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_16: {INTEGER_16},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64},\n  to_natural_16: {NATURAL_16},\n  to_natural_32: {NATURAL_32},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_8): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_8): NATURAL_8\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_8): NATURAL_8\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_8): NATURAL_8\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_8): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_8\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_8): NATURAL_8\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_8): NATURAL_8\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_8): NATURAL_8\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_8\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"natural_8_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 8 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_8_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_8\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead.\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_8 = 0\n  Max_value: NATURAL_8 = 255\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_8)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: NATURAL_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: V /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_8\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := 2\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 15)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      result_not_void: Result /= Void\n      result_valid_count: Result.count = 2\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      Result := tmp.to_hex_character\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_8: n <= 8\n      n_greater_or_equal_to_minus_8: n >= -8\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      Result := item & ((1).to_natural_8 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_8\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      if b then\n        Result := item | ((1).to_natural_8 |<< n)\n      else\n        Result := item & ((1).to_natural_8 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_8): NATURAL_8\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (3)\n      Result.append_natural_8 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"numeric.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n\n  NUMERIC\n\ninherit\n  DEBUG_OUTPUT\n    rename\n      debug_output as out\n    end\n\nfeature -- Access\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    obsolete\n      \"[2008_04_01] Will be removed since not used.\"\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other' (commutative).\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n      commutative: Result ~ (other + Current)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\ninvariant\n\n--  neutral_addition: equal (Current + zero, Current);\n--  self_subtraction: equal (Current - Current, zero);\n--  neutral_multiplication: equal (Current * one, Current);\n--  self_division: divisible (Current) implies equal (Current / Current, one)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"part_comparable.e","content":"note\n  description: \"Objects that may be compared according to a partial order relation\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  PART_COMPARABLE\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (Current < other) or (Current ~ other)\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := other < Current\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (other < Current) or (Current ~ other)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"platform.e","content":"note\n  description: \"Platform-dependent properties.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-06-15 12:34:32 -0700 (Fri, 15 Jun 2012) $\"\n  revision: \"$Revision: 91984 $\"\n\nclass PLATFORM\n\nfeature -- Platform\n\n  is_thread_capable: BOOLEAN\n      -- Is current platform capable of multi-threading?\n    external\n      \"built_in static\"\n    end\n\n  is_scoop_capable: BOOLEAN\n      -- Is current platform capable of SCOOP?\n    external\n      \"built_in static\"\n    end\n\n  is_dotnet: BOOLEAN\n      -- Are we targetting .NET?\n    external\n      \"built_in static\"\n    end\n\n  is_windows: BOOLEAN\n      -- Are we running on Windows platform?\n    external\n      \"built_in static\"\n    end\n\n  is_unix: BOOLEAN\n      -- Are we running on a Unix like platform?\n    external\n      \"built_in static\"\n    end\n\n  is_vms: BOOLEAN\n      -- Are we running on VMS?\n    external\n      \"built_in static\"\n    end\n\n  is_mac: BOOLEAN\n      -- Are we running on Mac OS?\n    external\n      \"built_in static\"\n    end\n\n  is_vxworks: BOOLEAN\n      -- Are we running on VxWorks?\n    external\n      \"built_in static\"\n    end\n\n  is_little_endian: BOOLEAN\n      -- Is current platform a little endian one?\n    local\n      l_nat16: NATURAL_16\n      l_nat8: NATURAL_8\n      l_first: NATURAL_8\n    once\n      l_nat16 := 0x4321\n      l_nat8 := 0x21\n      ($l_first).memory_copy ($l_nat16, 1)\n      Result := l_first = l_nat8\n    end\n\nfeature -- Access bytes size\n\n  boolean_bytes: INTEGER\n      -- Number of bytes in a value of type `BOOLEAN'\n    external\n      \"built_in static\"\n    end\n\n  character_8_bytes: INTEGER = 1\n      -- Number of bytes in a value of type `CHARACTER_8'\n\n  character_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `CHARACTER_32'\n\n  natural_8_bytes: INTEGER = 1\n      -- Number of bytes in a value of type `NATURAL_8'\n\n  natural_16_bytes: INTEGER = 2\n      -- Number of bytes in a value of type `NATURAL_16'\n\n  natural_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `NATURAL_32'\n\n  natural_64_bytes: INTEGER = 8\n      -- Number of bytes in a value of type `NATURAL_64'\n\n  integer_8_bytes: INTEGER = 1\n      -- Number of bytes in a value of type `INTEGER_8'\n\n  integer_16_bytes: INTEGER = 2\n      -- Number of bytes in a value of type `INTEGER_16'\n\n  integer_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `INTEGER_32'\n\n  integer_64_bytes: INTEGER = 8\n      -- Number of bytes in a value of type `INTEGER_64'\n\n  real_32_bytes: INTEGER = 4\n      -- Number of bytes in a value of type `REAL_32'\n\n  real_64_bytes: INTEGER = 8\n      -- Number of bytes in a value of type `REAL_64'\n\n  pointer_bytes: INTEGER\n      -- Number of bytes in a value of type `POINTER'\n    external\n      \"built_in static\"\n    end\n\nfeature -- Access bits size\n\n  boolean_bits: INTEGER\n      -- Number of bits in a value of type `BOOLEAN'\n    do\n      Result := boolean_bytes * 8\n    end\n\n  character_8_bits: INTEGER = 8\n      -- Number of bits in a value of type `CHARACTER_8'\n\n  character_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `CHARACTER_32'\n\n  natural_8_bits: INTEGER = 8\n      -- Number of bits in a value of type `NATURAL_8'\n\n  natural_16_bits: INTEGER = 16\n      -- Number of bits in a value of type `NATURAL_16'\n\n  natural_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `NATURAL_32'\n\n  natural_64_bits: INTEGER = 64\n      -- Number of bits in a value of type `NATURAL_64'\n\n  integer_8_bits: INTEGER = 8\n      -- Number of bits in a value of type `INTEGER_8'\n\n  integer_16_bits: INTEGER = 16\n      -- Number of bits in a value of type `INTEGER_16'\n\n  integer_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `INTEGER_32'\n\n  integer_64_bits: INTEGER = 64\n      -- Number of bits in a value of type `INTEGER_64'\n\n  real_32_bits: INTEGER = 32\n      -- Number of bits in a value of type `REAL_32'\n\n  real_64_bits: INTEGER = 64\n      -- Number of bits in a value of type `REAL_64'\n\n  pointer_bits: INTEGER\n      -- Number of bits in a value of type `POINTER'\n    do\n      Result := pointer_bytes * 8\n    end\n\nfeature -- Obsoletes\n\n  character_bytes: INTEGER\n      -- Number of bytes in a value of type `CHARACTER_8'\n    obsolete\n      \"Use `character_8_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  wide_character_bytes: INTEGER\n      -- Number of bytes in a value of type `CHARACTER_32'\n    obsolete\n      \"Use `character_32_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  integer_bytes: INTEGER\n      -- Number of bytes in a value of type `INTEGER_32'\n    obsolete\n      \"Use `integer_32_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  real_bytes: INTEGER\n      -- Number of bytes in a value of type `REAL_32'\n    obsolete\n      \"Use `real_32_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  double_bytes: INTEGER\n      -- Number of bytes in a value of type `REAL_64'\n    obsolete\n      \"Use `real_64_bytes' instead.\"\n    external\n      \"built_in static\"\n    end\n\n  character_bits: INTEGER\n      -- Number of bits in a value of type `CHARACTER_8'\n    obsolete\n      \"Use `character_8_bits' instead.\"\n    do\n      Result := 8\n    end\n\n  integer_bits: INTEGER\n      -- Number of bits in a value of type `INTEGER_32'\n    obsolete\n      \"Use `integer_32_bits' instead.\"\n    do\n      Result := 32\n    end\n\n  real_bits: INTEGER\n      -- Number of bits in a value of type `REAL_32'\n    obsolete\n      \"Use `real_32_bits' instead.\"\n    do\n      Result := 32\n    end\n\n  double_bits: INTEGER\n      -- Number of bits in a value of type `REAL_64'\n    obsolete\n      \"Use `real_64_bits' instead.\"\n    do\n      Result := 64\n    end\n\n  maximum_character_code: INTEGER\n      -- Largest supported code for CHARACTER_8 values\n    obsolete\n      \"Use `{CHARACTER}.max_value' instead.\"\n    do\n      Result := {CHARACTER}.max_value\n    ensure\n      meaningful: Result >= 127\n    end\n\n  maximum_integer: INTEGER\n      -- Largest supported value of type INTEGER_32\n    obsolete\n      \"Use `{INTEGER}.max_value' instead.\"\n    do\n      Result := {INTEGER}.max_value\n    ensure\n      meaningful: Result >= 0\n    end\n\n  minimum_character_code: INTEGER\n      -- Smallest supported code for CHARACTER_8 values\n    obsolete\n      \"Use `{CHARACTER}.min_value' instead.\"\n    do\n      Result := {CHARACTER}.min_value\n    ensure\n      meaningful: Result <= 0\n    end\n\n  minimum_integer: INTEGER\n      -- Smallest supported value of type INTEGER_32\n    obsolete\n      \"Use `{INTEGER}.min_value' instead.\"\n    do\n      Result := {INTEGER}.min_value\n    ensure\n      meaningful: Result <= 0\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"pointer.e","content":"note\n  description: \"References to objects meant to be exchanged with non-Eiffel software.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class POINTER inherit\n\n  POINTER_REF\n    redefine\n      hash_code,\n      plus,\n      to_integer_32,\n      is_default_pointer,\n      out\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({POINTER_REF})\n\nfeature -- Access\n\n  hash_code: INTEGER\n      -- Hash code value\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  is_default_pointer: BOOLEAN\n      -- <Precursor>\n    external\n      \"built_in\"\n    end\n\nfeature -- Operations\n\n  plus alias \"+\" (offset: INTEGER): POINTER\n      -- Pointer moved by an offset of `offset' bytes.\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of pointer value\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"pointer_ref.e","content":"note\n  description: \"[\n    References to objects containing reference to object\n    meant to be exchanged with non-Eiffel software.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass POINTER_REF\ninherit\n  HASHABLE\n    redefine\n      out, is_equal, is_hashable\n    end\n\n  REFACTORING_HELPER\n    redefine\n      out, is_equal\n    end\n\nfeature -- Access\n\n  item: POINTER\n      -- Pointer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item.hash_code\n    end\n\nfeature -- Element change\n\n  frozen set_item (p: POINTER)\n      -- Make `p' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Status report\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= default_pointer\n    end\n\n  is_default_pointer: BOOLEAN\n      -- Is current `default_pointer'?\n    do\n      Result := item = default_pointer\n    ensure\n      definition: Result = (item = default_pointer)\n    end\n\nfeature -- Operations\n\n  plus alias \"+\" (offset: INTEGER): POINTER\n      -- Pointer moved by an offset of `offset' bytes.\n    do\n      Result := item + offset\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: POINTER_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: POINTER_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n--      not_too_small: item >= {INTEGER_32}.Min_value\n--      not_too_big: item <= {INTEGER_32}.Max_value\n    do\n      -- TODO: Fix ONCE arguments\n      --fixme (once \"Do not forget to add proper precondition to ensure we can convert pointer %\n      --  %value into an INTEGER_32\")\n      Result := item.to_integer_32\n    end\n\nfeature -- Memory copy\n\n  memory_copy (a_source: POINTER; a_size: INTEGER)\n      -- Copy `a_size' bytes from `a_source' to `Current'.\n      -- `a_source' and `Current' should not overlap.\n    require\n      valid_size: a_size >= 0\n      valid_source: a_source /= default_pointer\n    do\n      c_memcpy (item, a_source, a_size)\n    end\n\n  memory_move (a_source: POINTER; a_size: INTEGER)\n      -- Copy `a_size' bytes from `a_source' to `Current'.\n      -- `a_source' and `Current' can overlap.\n    require\n      valid_size: a_size >= 0\n      valid_source: a_source /= default_pointer\n    do\n      c_memmove (item, a_source, a_size)\n    end\n\n  memory_set (val, n: INTEGER)\n      -- Fill first `n' bytes of the memory pointed by `Current'\n      -- with constant `val'.\n    require\n      valid_val: val >= 0\n      valid_n: n >= 0\n    do\n      c_memset (item, val, n)\n    end\n\nfeature -- Allocation/free\n\n  memory_alloc (a_size: INTEGER): POINTER\n      -- Allocated `size' bytes using `malloc'.\n    require\n      valid_size: a_size > 0\n    do\n      Result := c_malloc (a_size)\n    end\n\n  memory_calloc (a_count, a_element_size: INTEGER): POINTER\n      -- Allocate `a_count' elements of size `a_element_size' bytes using `calloc.\n    require\n      valid_element_count: a_count > 0\n      valid_element_size: a_element_size > 0\n    do\n      Result := c_calloc (a_count, a_element_size)\n    end\n\n  memory_realloc (a_size: INTEGER): POINTER\n      -- Realloc `Current'.\n    require\n      valid_size: a_size >= 0\n    do\n      Result := c_realloc (item, a_size)\n    end\n\n  memory_free\n      -- Free allocated memory with `malloc'.\n    do\n      c_free (item)\n      set_item (default_pointer)\n    end\n\nfeature -- Comparison\n\n  memory_compare (other: POINTER; a_size: INTEGER): BOOLEAN\n      -- True if `Current' and `other' are identical on `a_size' bytes.\n    require\n      valid_size: a_size > 0\n      valid_other: other /= default_pointer\n    do\n      Result := c_memcmp (item, other, a_size) = 0\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of pointer value\n    do\n      Result := item.out\n    end\n\nfeature {NONE} -- Implementation\n\n  c_memcpy (destination, source: POINTER; count: INTEGER)\n      -- C memcpy\n    external\n      \"C signature (void *, const void *, size_t) use <string.h>\"\n    alias\n      \"memcpy\"\n    end\n\n  c_memmove (destination, source: POINTER; count: INTEGER)\n      -- C memmove\n    external\n      \"C signature (void *, const void *, size_t) use <string.h>\"\n    alias\n      \"memmove\"\n    end\n\n  c_memset (source: POINTER; val: INTEGER; count: INTEGER)\n      -- C memset\n    external\n      \"C signature (void *, int, size_t) use <string.h>\"\n    alias\n      \"memset\"\n    end\n\n  c_memcmp (source, other: POINTER; count: INTEGER): INTEGER\n      -- C memcmp\n    external\n      \"C signature (void *, void *, size_t): EIF_INTEGER use <string.h>\"\n    alias\n      \"memcmp\"\n    end\n\n  c_malloc (size: INTEGER): POINTER\n      -- C malloc\n    external\n      \"C signature (size_t): EIF_POINTER use <stdlib.h>\"\n    alias\n      \"malloc\"\n    end\n\n  c_calloc (nmemb, size: INTEGER): POINTER\n      -- C calloc\n    external\n      \"C signature (size_t, size_t): EIF_POINTER use <stdlib.h>\"\n    alias\n      \"calloc\"\n    end\n\n  c_realloc (source: POINTER; size: INTEGER): POINTER\n      -- C realloc\n    external\n      \"C signature (void *, size_t): EIF_POINTER use <stdlib.h>\"\n    alias\n      \"realloc\"\n    end\n\n  c_free (p: POINTER)\n      -- C free\n    external\n      \"C signature (void *) use <stdlib.h>\"\n    alias\n      \"free\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"procedure.e","content":"note\n  description: \"[\n    Objects representing delayed calls to a procedure.\n    with some operands possibly still open.\n\n    Note: Features are the same as those of ROUTINE,\n      with `apply' made effective, and no further\n      redefinition of `is_equal' and `copy'.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-28 14:35:23 -0800 (Tue, 28 Jan 2014) $\"\n  revision: \"$Revision: 94109 $\"\n\nclass\n  PROCEDURE [BASE_TYPE -> detachable ANY, OPEN_ARGS -> detachable TUPLE create default_create end]\n\ninherit\n  ROUTINE [BASE_TYPE, OPEN_ARGS]\n    rename\n      call as call alias \"()\"\n    end\n\ncreate {NONE}\n  set_rout_disp\n\nfeature -- Calls\n\n  apply\n      -- Call procedure with `args' as last set.\n    do\n      call (operands)\n    end\n\n  call alias \"()\" (args: detachable separate OPEN_ARGS)\n    local\n      c: like closed_operands\n      l_closed_count: INTEGER\n    do\n      c := closed_operands\n      if c /= Void then\n        l_closed_count :=  c.count\n      end\n      fast_call (encaps_rout_disp, calc_rout_addr, $closed_operands, $args, routine_id,\n               is_basic, written_type_id_inline_agent, l_closed_count, open_count, $open_map)\n    end\n\nfeature {NONE} -- Implementation\n\n  fast_call (a_rout_disp, a_calc_rout_addr: POINTER;\n           a_closed_operands: POINTER; a_operands: POINTER;\n         a_routine_id: INTEGER; a_is_basic: BOOLEAN; a_class_id_inline_agent: INTEGER;\n         a_closed_count, a_open_count: INTEGER; a_open_map: POINTER)\n    external\n      \"C inline use %\"eif_rout_obj.h%\"\"\n    alias\n      \"[\n      #ifdef WORKBENCH\n        if ($a_rout_disp != 0) {\n          (FUNCTION_CAST(void, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n            $a_calc_rout_addr, $a_closed_operands, $a_operands);\n        } else {\n          rout_obj_call_procedure_dynamic (\n            $a_routine_id,\n            $a_is_basic,\n            $a_class_id_inline_agent,\n            $a_closed_operands,\n            $a_closed_count,\n            $a_operands,\n            $a_open_count,\n            $a_open_map);\n        }\n      #else\n        (FUNCTION_CAST(void, (EIF_POINTER, EIF_REFERENCE, EIF_REFERENCE)) $a_rout_disp)(\n          $a_calc_rout_addr, $a_closed_operands, $a_operands);\n      #endif\n      ]\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class READABLE_INDEXABLE [G]\n\ninherit\n  ITERABLE [G]\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): G\n      -- Entry at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  new_cursor: INDEXABLE_ITERATION_CURSOR [G]\n      -- <Precursor>\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nfeature -- Measurement\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    deferred\n    ensure\n      not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' a valid index?\n    deferred\n    ensure\n      only_if_in_index_set:\n        Result implies ((i >= index_set.lower) and (i <= index_set.upper))\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"readable_string_32.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:21:19 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95060 $\"\n\ndeferred class\n  READABLE_STRING_32\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    redefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    end\n\n  READABLE_INDEXABLE [CHARACTER_32]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_readable_string_8: {READABLE_STRING_8},\n  as_string_8: {STRING_8},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_32; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_32)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    deferred\n    ensure\n      not_shared_implementation: Current /= s\n      initialized: same_string_general (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_32_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c'.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_32): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_32; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    end\n\n  last_index_of (c: CHARACTER_32; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_32\n      -- New STRING_32 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_32\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_32}\n    do\n      if same_type (create {STRING_32}.make_empty) and then attached {STRING_32} Current as l_s32 then\n        Result := l_s32\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_32]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n        nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n      do\n        if other = Current then\n          Result := True\n        else\n          nb := count\n          if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n          end\n        end\n\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_32): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER_32\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_32): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = False\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = True\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN\n      -- <Precursor>\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      from\n        Result := True\n        i := area_lower\n        nb := count + i\n        l_area := area\n      until\n        i = nb or not Result\n      loop\n        Result := l_area.item (i).code <= {CHARACTER_8}.max_value\n        i := i + 1\n      end\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_prop: like character_properties\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n        l_prop := character_properties\n      until\n        i > n or not l_prop.is_space (l_area.item (i))\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_32): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    end\n\n  starts_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := True\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        Result := is_case_insensitive_equal_general (true_constant)\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        Result := is_case_insensitive_equal_general (false_constant)\n      end\n    end\n\nfeature {READABLE_STRING_32} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_32)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (as_string_8)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies same_string_general (Result)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_32_SEARCHER\n      -- String searcher specialized for READABLE_STRING_32 instances\n    once\n      create Result.make\n    end\n\nfeature {NONE} -- Implementation\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_lower (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_upper (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:22:02 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95061 $\"\n\ndeferred class\n  READABLE_STRING_8\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    redefine\n      copy, is_equal, out\n    end\n\n  READABLE_INDEXABLE [CHARACTER_8]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_string_8: {STRING_8},\n  as_readable_string_32: {READABLE_STRING_32},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_8; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_8)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_8_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c' instead.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8\n      -- Character at position `i'.\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n    obsolete\n      \"For consistency with Unicode string handling, use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_8): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_8; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: CHARACTER_8; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_8\n      -- New STRING_8 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_8\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_8}\n    do\n      if same_type (create {STRING_8}.make_empty) and then attached {STRING_8} Current as l_s8 then\n        Result := l_s8\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_8): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_8]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n        end\n      end\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_8): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then c1.as_lower /= c2.as_lower then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: l_area.upper - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_8): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = False\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n      until\n        i > n or not l_area.item (i).is_space\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_8): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    ensure\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  starts_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := v <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n      l_area: like area\n      i: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 't' and then\n          l_area.item (i + 1).lower = 'r' and then\n          l_area.item (i + 2).lower = 'u' and then\n          l_area.item (i + 3).lower = 'e'\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 'f' and then\n          l_area.item (i + 1).lower = 'a' and then\n          l_area.item (i + 2).lower = 'l' and then\n          l_area.item (i + 3).lower = 's' and then\n          l_area.item (i + 4).lower = 'e'\n      end\n    end\n\nfeature {READABLE_STRING_8} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_8)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (Current)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies Result.same_string (Current)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_8_SEARCHER\n      -- String searcher specialized for READABLE_STRING_8 instances\n    once\n      create Result.make\n    end\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).lower, i)\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).upper, i)\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes. Read-only interface.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 06:27:01 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94630 $\"\n\ndeferred class\n  READABLE_STRING_GENERAL\n\ninherit\n  COMPARABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    end\n\n  HASHABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\n  STRING_HANDLER\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n    require\n      non_negative_size: n >= 0\n    deferred\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\n  make_empty\n      -- Create empty string.\n    do\n      make (0)\n    ensure\n      empty: count = 0\n      area_allocated: capacity >= 0\n    end\n\nfeature -- Access\n\n  code (i: INTEGER): NATURAL_32\n      -- Code at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  item alias \"[]\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  index_of (c: like item; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else item (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: like item; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else item (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  index_of_code (c: like code; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else code (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has_code (c)\n      found_if_present: substring (start_index, count).has_code (c) implies code (Result) = c\n      none_before: substring (start_index, count).has_code (c) implies\n        not substring (start_index, Result - 1).has_code (c)\n    end\n\n  last_index_of_code (c: like code; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else code (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has_code (c)\n      found_if_present: substring (1, start_index_from_end).has_code (c) implies code (Result) = c\n      none_after: substring (1, start_index_from_end).has_code (c) implies\n        not substring (Result + 1, start_index_from_end).has_code (c)\n    end\n\n  false_constant: STRING_8 = \"false\"\n      -- Constant string \"false\"\n\n  true_constant: STRING_8 = \"true\"\n      -- Constant string \"true\"\n\n  hash_code: INTEGER\n      -- Hash code value\n    local\n      i, nb: INTEGER\n    do\n      Result := internal_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + item (i).code\n          i := i + 1\n        end\n        internal_hash_code := Result\n      end\n    end\n\n  case_insensitive_hash_code: INTEGER\n      -- Hash code value of the lower case version of `Current'.\n    local\n      l_props: like character_properties\n      i, nb: INTEGER\n    do\n      Result := internal_case_insensitive_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n          l_props := character_properties\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + l_props.to_lower (item (i)).code\n          i := i + 1\n        end\n        internal_case_insensitive_hash_code := Result\n      end\n    ensure\n      consistent: Result = as_lower.hash_code\n    end\n\nfeature -- Status report\n\n  is_immutable: BOOLEAN\n      -- Can the character sequence of `Current' be not changed?\n    do\n      Result := False\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the string?\n    do\n      Result := (i > 0) and (i <= count)\n    ensure\n      definition: Result = (1 <= i and i <= count)\n    end\n\n  valid_code (v: like code): BOOLEAN\n      -- Is `v' a valid code for Current?\n    deferred\n    end\n\n  is_string_8: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_8?\n    deferred\n    end\n\n  is_string_32: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_32?\n    deferred\n    end\n\n  is_valid_as_string_8: BOOLEAN\n      -- Is `Current' convertible to a sequence of CHARACTER_8 without information loss?\n    deferred\n    end\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    deferred\n    end\n\n  is_whitespace: BOOLEAN\n      -- Is structure containing only whitespace characters?\n    do\n      Result := is_substring_whitespace (1, count)\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- Is substring between `start_index' and `end_index' containing only whitespace characters?\n    require\n      start_index_big_enough: 1 <= start_index\n      end_index_small_enough: end_index <= count\n      consistent_indexes: start_index - 1 <= end_index\n    deferred\n    end\n\n  has (c: like item): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  has_code (c: like code): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (code (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then code (1) = c implies Result\n      recurse: (count > 0 and then code (1) /= c) implies\n        (Result = substring (2, count).has_code (c))\n    end\n\n  is_number_sequence: BOOLEAN\n      -- Does `Current' represent a number sequence?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_no_limitation)\n    ensure\n      syntax_and_range:\n        -- Result is true if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  Current can be produced by \"Integer_literal\":\n        --\n        -- Integer_literal = [Space] [Sign] Integer [Space]\n        -- Space  = \" \" | \" \" Space\n        -- Sign   = \"+\" | \"-\"\n        -- Integer  = Digit | Digit Integer\n        -- Digit  = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n    end\n\n  is_real_sequence: BOOLEAN\n      -- Does `Current' represent a real sequence?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following condition is satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n    end\n\n  is_real, is_real_32: BOOLEAN\n      -- Does `Current' represent a REAL_32?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_real)\n      Result := l_convertor.is_integral_real\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type REAL.\n    end\n\n  is_double, is_real_64: BOOLEAN\n      -- Does `Current' represent a REAL_64?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_double)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type DOUBLE.\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    deferred\n    ensure\n      is_boolean: Result = (true_constant.same_string_general (as_lower) or\n        false_constant.same_string_general (as_lower))\n    end\n\n  is_integer_8: BOOLEAN\n      -- Does `Current' represent an INTEGER_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_8)\n    end\n\n  is_integer_16: BOOLEAN\n      -- Does `Current' represent an INTEGER_16?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_16)\n    end\n\n  is_integer, is_integer_32: BOOLEAN\n      -- Does `Current' represent an INTEGER_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_32)\n    end\n\n  is_integer_64: BOOLEAN\n      -- Does `Current' represent an INTEGER_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_64)\n    end\n\n  is_natural_8: BOOLEAN\n      -- Does `Current' represent a NATURAL_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_8)\n    end\n\n  is_natural_16: BOOLEAN\n      -- Does `Current' represent a NATURAL_16?\n\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_16)\n    end\n\n  is_natural, is_natural_32: BOOLEAN\n      -- Does `Current' represent a NATURAL_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_32)\n    end\n\n  is_natural_64: BOOLEAN\n      -- Does `Current' represent a NATURAL_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_64)\n    end\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of characters in Current\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Number of characters allocated in Current\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          if item (i) = c then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\nfeature -- Comparison\n\n  is_case_insensitive_equal (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      c1,c2: like item\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := item (i)\n          c2 := other.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  has_substring (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `Current' contain `other'?\n    require\n      other_not_void: other /= Void\n    do\n      if other = Current then\n        Result := True\n      elseif other.count <= count then\n        Result := substring_index (other, 1) > 0\n      end\n    ensure\n      false_if_too_small: count < other.count implies not Result\n      true_if_initial: (count >= other.count and then\n        other.same_string (substring (1, other.count))) implies Result\n      recurse: (count >= other.count and then\n        not other.same_string (substring (1, other.count))) implies\n        (Result = substring (2, count).has_substring (other))\n    end\n\n  same_string (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `other' represent the same string as `Current'?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    end\n\n  same_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          if item (i) /= other.item (j) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  starts_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code (i) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code(j) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n            j := j - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start_pos'\n      -- and to or before `end_pos';\n      -- 0 if none.\n    require\n      other_nonvoid: other /= Void\n      other_notempty: not other.is_empty\n      start_pos_large_enough: start_pos >= 1\n      start_pos_small_enough: start_pos <= count\n      end_pos_large_enough: end_pos >= start_pos\n      end_pos_small_enough: end_pos <= count\n    deferred\n    ensure\n      correct_place: Result > 0 implies other.same_string (substring (Result, Result + other.count - 1))\n      -- forall x : start_pos..Result\n      --  not substring (x, x+other.count -1).is_equal (other)\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- Index of first occurrence of other at or after start_index;\n      -- 0 if none\n    require\n      other_not_void: other /= Void\n      valid_start_index: start_index >= 1 and start_index <= count + 1\n    deferred\n    ensure\n      valid_result: Result = 0 or else\n        (start_index <= Result and Result <= count - other.count + 1)\n      zero_if_absent: (Result = 0) =\n        not substring (start_index, count).has_substring (other)\n      at_this_index: Result >= start_index implies\n        other.same_string (substring (Result, Result + other.count - 1))\n      none_before: Result > start_index implies\n        not substring (start_index, Result + other.count - 2).has_substring (other)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start'\n      -- with 0..`fuzz' mismatches between the string and `other'.\n      -- 0 if there are no fuzzy matches\n    require\n      other_exists: other /= Void\n      other_not_empty: not other.is_empty\n      start_large_enough: start >= 1\n      start_small_enough: start <= count\n      acceptable_fuzzy: fuzz <= other.count\n    deferred\n    end\n\nfeature -- Conversion\n\n  frozen to_cil: SYSTEM_STRING\n      -- Create an instance of SYSTEM_STRING using characters\n      -- of Current between indices `1' and `count'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := dotnet_convertor.from_string_to_system_string (Current)\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_string_8: STRING_8\n      -- Convert `Current' as a STRING_8.\n    require\n      is_valid_as_string_8: is_valid_as_string_8\n    do\n      Result := as_string_8\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_8_conversion: STRING_8\n      -- Equivalent to `as_string_8' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the target recipient of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update recipient of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_readable_string_8: READABLE_STRING_8\n      --\n    obsolete\n      \"Use explicit conversion `to_string_8' instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_string_8: STRING_8\n      -- Convert `Current' as a STRING_8. If a code of `Current' is\n      -- not a valid code for a STRING_8 it is replaced with the null\n      -- character.\n    local\n      i, nb: INTEGER\n      l_code: like code\n    do\n      if attached {STRING_8} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          l_code := code (i)\n          if Result.valid_code (l_code) then\n            Result.put_code (l_code, i)\n          else\n            Result.put_code (0, i)\n          end\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_32_conversion: STRING_32\n      -- Equivalent to `as_string_32' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the source of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update target of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_readable_string_32: READABLE_STRING_32\n      --\n    obsolete\n      \"Use explicit conversion `to_string_32' instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_string_32, to_string_32: STRING_32\n      -- Convert `Current' as a STRING_32.\n    local\n      i, nb: INTEGER\n    do\n      if attached {STRING_32} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          Result.put_code (code (i), i)\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_32_not_void: Result /= Void\n      identity: (conforms_to (create {STRING_32}.make_empty) and Result = Current) or (not conforms_to (create {STRING_32}.make_empty) and Result /= Current)\n    end\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    deferred\n    ensure\n      as_lower_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_lower\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    deferred\n    ensure\n      as_upper_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_upper\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_upper\n    end\n\n  to_integer_8: INTEGER_8\n      -- 8-bit integer value\n    require\n      is_integer_8: is_integer_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_8\n    end\n\n  to_integer_16: INTEGER_16\n      -- 16-bit integer value\n    require\n      is_integer_16: is_integer_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_16\n    end\n\n  to_integer, to_integer_32: INTEGER_32\n      -- 32-bit integer value\n    require\n      is_integer: is_integer_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer\n    end\n\n  to_integer_64: INTEGER_64\n      -- 64-bit integer value\n    require\n      is_integer_64: is_integer_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_64\n    end\n\n  to_natural_8: NATURAL_8\n      -- 8-bit natural value\n    require\n      is_natural_8: is_natural_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_8\n    end\n\n  to_natural_16: NATURAL_16\n      -- 16-bit natural value\n    require\n      is_natural_16: is_natural_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_16\n    end\n\n  to_natural, to_natural_32: NATURAL_32\n      -- 32-bit natural value\n    require\n      is_natural: is_natural_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_32\n    end\n\n  to_natural_64: NATURAL_64\n      -- 64-bit natural value\n    require\n      is_natural_64: is_natural_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_64\n    end\n\n  to_real, to_real_32: REAL\n      -- Real value;\n      -- for example, when applied to \"123.0\", will yield 123.0\n    require\n      represents_a_real: is_real\n    do\n      Result := to_double.truncated_to_real\n    end\n\n  to_double, to_real_64: DOUBLE\n      -- \"Double\" value;\n      -- for example, when applied to \"123.0\", will yield 123.0 (double)\n    require\n      represents_a_double: is_double\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_double\n    end\n\n  to_boolean: BOOLEAN\n      -- Boolean value;\n      -- \"True\" yields `True', \"False\" yields `False'\n      -- (case-insensitive)\n    require\n      is_boolean: is_boolean\n    do\n      check true_constant.count = 4 end\n      if count = 4 then\n        Result := True\n      end\n    ensure\n      to_boolean: (Result = as_lower.same_string (true_constant)) or\n        (not Result = as_lower.same_string (false_constant))\n    end\n\nfeature -- Conversion\n\n  split (a_separator: CHARACTER_32): LIST [like Current]\n      -- Split on `a_separator'.\n    local\n      l_list: ARRAYED_LIST [like Current]\n      part: like Current\n      i, j, c: INTEGER\n    do\n      c := count\n        -- Worse case allocation: every character is a separator\n      create l_list.make (c + 1)\n      if c > 0 then\n        from\n          i := 1\n        until\n          i > c\n        loop\n          j := index_of (a_separator, i)\n          if j = 0 then\n              -- No separator was found, we will\n              -- simply create a list with a copy of\n              -- Current in it.\n            j := c + 1\n          end\n          part := substring (i, j - 1)\n          l_list.extend (part)\n          i := j + 1\n        end\n        if j = c then\n          check\n            last_character_is_a_separator: item (j) = a_separator\n          end\n            -- A separator was found at the end of the string\n          l_list.extend (new_string (0))\n        end\n      else\n          -- Extend empty string, since Current is empty.\n        l_list.extend (new_string (0))\n      end\n      Result := l_list\n      check\n        l_list.count = occurrences (a_separator) + 1\n      end\n    ensure\n      Result /= Void\n    end\n\nfeature -- Element change\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    deferred\n    ensure\n      plus_not_void: Result /= Void\n      new_count: Result.count = count + s.count\n      initial: elks_checking implies Result.substring (1, count) ~ Current\n      final: elks_checking implies Result.substring (count + 1, count + s.count).same_string (s)\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    ensure\n      substring_not_void: Result /= Void\n      substring_count: Result.count = end_index - start_index + 1 or Result.count = 0\n      first_code: Result.count > 0 implies Result.item (1) = item (start_index)\n      recurse: Result.count > 0 implies\n        Result.substring (2, Result.count) ~ substring (start_index + 1, end_index)\n    end\n\n  head (n: INTEGER): like Current\n      -- Prefix, retaining first `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (1, n)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\n  tail (n: INTEGER): like Current\n      -- Suffix, retaining last `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (count - n + 1, count)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\nfeature {NONE} -- Assertion helper\n\n  elks_checking: BOOLEAN = False\n      -- Are ELKS checkings verified? Must be True when changing implementation of STRING_GENERAL or descendant.\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    require\n      n_non_negative: n >= 0\n    deferred\n    ensure\n      new_string_not_void: Result /= Void\n      new_string_empty: Result.is_empty\n      new_string_area_big_enough: Result.capacity >= n\n    end\n\n  is_valid_integer_or_natural (type: INTEGER) : BOOLEAN\n      -- Is `Current' a valid number according to given `type'?\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.reset (type)\n      l_convertor.parse_string_with_type (Current, type)\n      Result := l_convertor.is_integral_integer\n    end\n\n  string_searcher: STRING_SEARCHER\n      -- Facilities to search string in another string.\n    deferred\n    ensure\n      string_searcher_not_void: Result /= Void\n    end\n\n  c_string_provider: C_STRING\n      -- To create Eiffel strings from C string.\n    once\n      create Result.make_empty (0)\n    ensure\n      c_string_provider_not_void: Result /= Void\n    end\n\n  ctoi_convertor: STRING_TO_INTEGER_CONVERTOR\n      -- Convertor used to convert string to integer or natural\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctoi_convertor_not_void: Result /= Void\n    end\n\n  ctor_convertor: STRING_TO_REAL_CONVERTOR\n      -- Convertor used to convert string to real or double\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctor_convertor_not_void: Result /= Void\n    end\n\n  dotnet_convertor: SYSTEM_STRING_FACTORY\n      -- Convertor used to convert from and to SYSTEM_STRING.\n    once\n      create Result\n    ensure\n      dotnet_convertor_not_void: Result /= Void\n    end\n\n  character_properties: CHARACTER_PROPERTY\n      -- Access to Unicode character properties\n    once\n      create Result.make\n    end\n\nfeature {READABLE_STRING_GENERAL} -- Implementation\n\n  internal_hash_code: INTEGER\n      -- Cache for `hash_code'.\n\n  internal_case_insensitive_hash_code: INTEGER;\n      -- Cash for `case_insensitive_hash_code'.\n\n\nfeature -- Access: Cursor\n\n  new_character_32_cursor: STRING_ITERATION_CURSOR\n      -- Fresh cursor for this string that iterates over code points (see `code')\n      -- exposed as {CHARACTER_32}.\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_32.e","content":"note\n  description: \"Real values, single precision\"\n  external_name: \"System.Single\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class REAL_32 inherit\n\n  REAL_32_REF\n    redefine\n      is_less,\n      is_nan,\n      is_negative_infinity,\n      is_positive_infinity,\n      truncated_to_integer,\n      truncated_to_integer_64,\n      to_double,\n      ceiling_real_32,\n      floor_real_32,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      opposite,\n      identity,\n      out\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({REAL_32_REF}),\n  to_double: {REAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: REAL_32): BOOLEAN\n      -- Is `other' greater than current real?\n    external\n      \"built_in\"\n    end\n\nfeature -- Status Report\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    external\n      \"built_in\"\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    external\n      \"built_in\"\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Current seen as a double\n    external\n      \"built_in\"\n    end\n\n  ceiling_real_32: REAL_32\n      -- Smallest integral value no smaller than current object\n    external\n      \"built_in\"\n    end\n\n  floor_real_32: REAL_32\n      -- Greatest integral value no greater than current object\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: REAL_32): REAL_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: REAL_32): REAL_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: REAL_32): REAL_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: REAL_32): REAL_32\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current real to the power `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": REAL_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": REAL_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of real value\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_32_ref.e","content":"note\n  description: \"References to objects containing a real value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-12-30 16:54:49 -0800 (Mon, 30 Dec 2013) $\"\n  revision: \"$Revision: 93855 $\"\n\nclass REAL_32_REF inherit\n\n  NUMERIC\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: REAL_32\n      -- Numeric real value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := truncated_to_integer.hash_code\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0.0 then\n        Result := 1\n      elseif item < 0.0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item ({REAL_32} 1.0)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item ({REAL_32} 0.0)\n    end\n\n  nan: REAL_32\n      -- Representation of not a number (NaN)\n    external\n      \"built_in static\"\n    end\n\n  negative_infinity: REAL_32\n      -- Representation of negative infinity\n    external\n      \"built_in static\"\n    end\n\n  positive_infinity: REAL_32\n      -- Representation of positive infinity\n    external\n      \"built_in static\"\n    end\n\n  min_value: REAL_32 = -3.4028234663852885981170e+038\n  max_value: REAL_32 = 3.4028234663852885981170e+038\n      -- Minimum and Maximum value hold in `item'.\n\n  machine_epsilon: REAL_32 = 1.1920928955078125000000e-007\n      -- The difference between 1 and the least value greater than\n      -- 1 that is representable in the given floating point type.\n\n  epsilon: REAL_32 = 1.1754943508222875079688e-038\n      -- Minimum normalized positive floating-point number.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current real?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (r: REAL_32)\n      -- Make `r' the value of `item'.\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  divisible (other: REAL_32_REF): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0.0\n    ensure then\n      ref_not_exact_zero: Result implies (other.item /= 0.0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0.0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0.0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0.0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0.0) or\n        (other.conforms_to (0.0) and item > 0.0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0.0\n    end\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    do\n      Result := item.is_nan\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    do\n      Result := item.is_negative_infinity\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    do\n      Result := item.is_positive_infinity\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: REAL_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: REAL_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer_64\n    end\n\n  to_double: REAL_64\n      -- Current seen as a double\n    do\n      Result := item.to_double\n    end\n\n  ceiling: INTEGER_32\n      -- Smallest integral value no smaller than current object\n    do\n      Result := ceiling_real_32.truncated_to_integer\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor: INTEGER_32\n      -- Greatest integral value no greater than current object\n    do\n      Result := floor_real_32.truncated_to_integer\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded: INTEGER_32\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + 0.5).floor)\n    ensure\n      definition: Result = sign * ((abs + 0.5).floor)\n    end\n\n  ceiling_real_32: REAL_32\n      -- Smallest integral value no smaller than current object\n    do\n      Result := item.ceiling_real_32\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor_real_32: REAL_32\n      -- Greatest integral value no greater than current object\n    do\n      Result := item.floor_real_32\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded_real_32: REAL_32\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + {REAL_32} 0.5).floor_real_32)\n    ensure\n      definition: Result = sign * ((abs + {REAL_32} 0.5).floor_real_32)\n    end\n\nfeature -- Basic operations\n\n  abs: REAL_32\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0.0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    do\n      create Result\n      Result.set_item (item / other.item)\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current real to the power `other'\n    do\n      Result := item ^ other\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of real value\n    do\n      Result := item.out\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item = 0.0 then\n          -- Special case when `item' is `-0'.\n        Result := zero\n      elseif item > 0.0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n  sign_times_abs: not item.is_nan implies sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_64.e","content":"note\n  description: \"Real values, double precision\"\n  external_name: \"System.Double\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class REAL_64 inherit\n\n  REAL_64_REF\n    redefine\n      is_less,\n      is_nan,\n      is_negative_infinity,\n      is_positive_infinity,\n      truncated_to_integer,\n      truncated_to_integer_64,\n      truncated_to_real,\n      ceiling_real_64,\n      floor_real_64,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      opposite,\n      identity,\n      out\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({REAL_64_REF})\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: REAL_64): BOOLEAN\n      -- Is `other' greater than current double?\n    external\n      \"built_in\"\n    end\n\nfeature -- Status Report\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    external\n      \"built_in\"\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    external\n      \"built_in\"\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  truncated_to_real: REAL_32\n      -- Real part (Same sign, largest absolute\n      -- value no greater than current object's)\n    external\n      \"built_in\"\n    end\n\n  ceiling_real_64: REAL_64\n      -- Smallest integral value no smaller than current object\n    external\n      \"built_in\"\n    end\n\n  floor_real_64: REAL_64\n      -- Greatest integral value no greater than current object\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: REAL_64): REAL_64\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: REAL_64): REAL_64\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: REAL_64): REAL_64\n      -- Product with `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: REAL_64): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current double to the power `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": REAL_64\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": REAL_64\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of double value\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"real_64_ref.e","content":"note\n  description: \"References to objects containing a double-precision real number\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-12-30 16:49:34 -0800 (Mon, 30 Dec 2013) $\"\n  revision: \"$Revision: 93854 $\"\n\nclass REAL_64_REF inherit\n\n  NUMERIC\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: REAL_64\n      -- Numeric double value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := truncated_to_integer.hash_code\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0.0 then\n        Result := 1\n      elseif item < 0.0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1.0)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0.0)\n    end\n\n  nan: REAL_64\n      -- Representation of not a number (NaN)\n    external\n      \"built_in static\"\n    end\n\n  negative_infinity: REAL_64\n      -- Representation of negative infinity\n    external\n      \"built_in static\"\n    end\n\n  positive_infinity: REAL_64\n      -- Representation of positive infinity\n    external\n      \"built_in static\"\n    end\n\n  min_value: REAL_64 = -1.7976931348623157081452e+308\n  max_value: REAL_64 = 1.7976931348623157081452e+308\n      -- Minimum and Maximum value hold in `item'.\n\n  machine_epsilon: REAL_64 = 2.2204460492503130808473e-016\n      -- The difference between 1 and the least value greater than\n      -- 1 that is representable in the given floating point type.\n\n  epsilon: REAL_64 = 2.2250738585072013830903e-308\n      -- Minimum normalized positive floating-point number.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current double?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (d: REAL_64)\n      -- Make `d' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  divisible (other: REAL_64_REF): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0.0\n    ensure then\n      not_exact_zero: Result implies (other.item /= 0.0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0.0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0.0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0.0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0.0) or\n        (other.conforms_to (0.0) and item > 0.0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0.0\n    end\n\n  is_nan: BOOLEAN\n      -- Is current the representation of `nan'?\n    do\n      Result := item.is_nan\n    end\n\n  is_negative_infinity: BOOLEAN\n      -- Is current the representation of `negative_infinity'?\n    do\n      Result := item.is_negative_infinity\n    end\n\n  is_positive_infinity: BOOLEAN\n      -- Is current the representation of `positive_infinity'?\n    do\n      Result := item.is_positive_infinity\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: REAL_64_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: REAL_64_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  truncated_to_integer: INTEGER_32\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer\n    end\n\n  truncated_to_integer_64: INTEGER_64\n      -- Integer part (Same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_integer_64\n    end\n\n  truncated_to_real: REAL_32\n      -- Real part (Same sign, largest absolute\n      -- value no greater than current object's)\n    do\n      Result := item.truncated_to_real\n    end\n\n  ceiling: INTEGER_32\n      -- Smallest integral value no smaller than current object\n    do\n      Result := ceiling_real_64.truncated_to_integer\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor: INTEGER_32\n      -- Greatest integral value no greater than current object\n    do\n      Result := floor_real_64.truncated_to_integer\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded: INTEGER_32\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + 0.5).floor)\n    ensure\n      definition: Result = sign * ((abs + 0.5).floor)\n    end\n\n  ceiling_real_64: REAL_64\n      -- Smallest integral value no smaller than current object\n    do\n      Result := item.ceiling_real_64\n    ensure\n      result_no_smaller: Result >= item\n      close_enough: Result - item < item.one\n    end\n\n  floor_real_64: REAL_64\n      -- Greatest integral value no greater than current object\n    do\n      Result := item.floor_real_64\n    ensure\n      result_no_greater: Result <= item\n      close_enough: item - Result < Result.one\n    end\n\n  rounded_real_64: REAL_64\n      -- Rounded integral value\n    do\n      Result := sign * ((abs + 0.5).floor_real_64)\n    ensure\n      definition: Result = sign * ((abs + 0.5).floor_real_64)\n    end\n\nfeature -- Basic operations\n\n  abs: REAL_64\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0.0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product with `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    do\n      create Result\n      Result.set_item (item / other.item)\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Current double to the power `other'\n    do\n      Result := item ^ other\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of double value\n    do\n      Result := item.out\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item = 0.0 then\n          -- Special case when `item' is `-0'.\n        Result := zero\n      elseif item > 0.0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n  sign_times_abs: not item.is_nan implies sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"refactoring_helper.e","content":"note\n  description: \"[\n    Collection of features that are used to mark\n    places in code that needs refactoring.\n    ]\"\n\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass REFACTORING_HELPER\n\nfeature -- Markers\n\n  fixme (comment: STRING)\n      -- Mark code that has to be \"fixed\" with `comment'.\n    require\n      comment_not_void: comment /= Void\n    do\n      -- debug (\"refactor_fixme\")\n      --   io.error.put_string (\"FIXME: \")\n      --   io.error.put_string (comment)\n      --   io.error.put_new_line\n      -- end\n    end\n\n  to_implement (comment: STRING)\n      -- Mark code that has to be \"implemented\" with `comment'.\n    require\n      comment_not_void: comment /= Void\n    do\n      -- debug (\"refactor_fixme\")\n      --   io.error.put_string (\"TO_BE_IMPLEMENTED: \")\n      --   io.error.put_string (comment)\n      --   io.error.put_new_line\n      -- end\n    end\n\n  to_implement_assertion (comment: STRING): BOOLEAN\n      -- Mark assertion that has to be \"implemented\" with `comment'.\n    require\n      comment_not_void: comment /= Void\n    do\n      -- TODO implement debug statement\n      -- debug (\"refactor_fixme\")\n      --   io.error.put_string (\"ASSERTION_TO_BE_IMPLEMENTED: \")\n      --   io.error.put_string (comment)\n      --   io.error.put_new_line\n      -- end\n      Result := True\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"reflector.e","content":"note\n  description: \"[\n      Access to internal object properties.\n      This class may be used as ancestor by classes needing its facilities.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-09-06 21:45:47 -0700 (Fri, 06 Sep 2013) $\"\n  revision: \"$Revision: 92917 $\"\n\nclass\n  REFLECTOR\n\ninherit\n  REFLECTOR_HELPER\n\n  REFLECTOR_CONSTANTS\n\nfeature -- Conformance\n\n  type_conforms_to (type1, type2: INTEGER): BOOLEAN\n      -- Does `type1' conform to `type2'?\n    require\n      type1_nonnegative: type1 >= 0\n      type2_nonnegative: type2 >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.type_conforms_to (type1, type2)\n    end\n\n  field_conforms_to (a_source_type, a_field_type: INTEGER): BOOLEAN\n      -- Does `a_source_type' conform to `a_field_type'?\n      --| Different from `type_conforms_to' since possible attachment mark of `a_field_type'\n      --| is discarded.\n    require\n      a_source_type_non_negative: a_source_type >= 0\n      a_field_type_non_negative: a_field_type >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.type_conforms_to (a_source_type, {ISE_RUNTIME}.detachable_type (a_field_type))\n    end\n\nfeature -- Creation\n\n  dynamic_type_from_string (class_type: READABLE_STRING_GENERAL): INTEGER\n      -- Dynamic type corresponding to `class_type'.\n      -- If no dynamic type available, returns -1.\n    require\n      class_type_not_void: class_type /= Void\n      class_type_not_empty: not class_type.is_empty\n      is_valid_type_string: is_valid_type_string (class_type)\n    local\n      l_cstr: C_STRING\n      l_table: like internal_dynamic_type_string_table\n      l_pre_ecma_status: BOOLEAN\n    external\n      \"built_in\"\n      -- l_table := internal_dynamic_type_string_table\n      -- l_table.search (class_type)\n      -- if l_table.found then\n      --   Result := l_table.found_item\n      -- else\n      --   create l_cstr.make (class_type)\n      --     -- Take into consideration possible pre-ECMA mapping.\n      --   l_pre_ecma_status := {ISE_RUNTIME}.pre_ecma_mapping_status\n      --   {ISE_RUNTIME}.set_pre_ecma_mapping (not is_pre_ecma_mapping_disabled)\n      --   Result := {ISE_RUNTIME}.type_id_from_name (l_cstr.item)\n      --   {ISE_RUNTIME}.set_pre_ecma_mapping (l_pre_ecma_status)\n      --   l_table.put (Result, class_type)\n      -- end\n    ensure\n      dynamic_type_from_string_valid: Result = -1 or Result = none_type or Result >= 0\n    end\n\n  new_instance_of (type_id: INTEGER): ANY\n      -- New instance of dynamic `type_id'.\n      -- Note: returned object is not initialized and may\n      -- hence violate its invariant.\n      -- `type_id' cannot represent a SPECIAL type, use\n      -- `new_special_any_instance' instead.\n    require\n      type_id_nonnegative: type_id >= 0\n      not_special_type: not is_special_type (type_id)\n    do\n      Result := c_new_instance_of (type_id)\n    ensure\n      not_special_type: not attached {SPECIAL [detachable ANY]} Result\n      dynamic_type_set: Result.generating_type.type_id = type_id\n    end\n\n  new_special_any_instance (type_id, count: INTEGER): SPECIAL [detachable ANY]\n      -- New instance of dynamic `type_id' that represents\n      -- a SPECIAL with `count' element. To create a SPECIAL of\n      -- basic type, use `SPECIAL'.\n    require\n      count_valid: count >= 0\n      type_id_nonnegative: type_id >= 0\n      special_type: is_special_any_type (type_id)\n    do\n      create Result.make_empty (count)\n      c_set_dynamic_type (Result, type_id)\n    ensure\n      dynamic_type_set: Result.generating_type.type_id = type_id\n      count_set: Result.count = 0\n      capacity_set: Result.capacity = count\n    end\n\n  new_tuple_from_special (type_id: INTEGER; values: SPECIAL [detachable separate ANY]): detachable TUPLE\n      -- New instance of a tuple of type `type_id' filled with `values' if all types of items are suitable.\n      -- `Void' if some items from `values' are inappropriate for a tuple of type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n      is_tuple_type: is_tuple_type (type_id)\n      -- sufficient_values_count: values.count >= tuple_type_count (type_id)\n      -- valid_value_types: across 1 |..| tuple_type_count (type_id) as i all valid_object_for_tuple_index (values [i - 1], i)\n    local\n      i: INTEGER\n      v: detachable separate ANY\n    do\n      Result := c_new_tuple_instance_of (type_id)\n      i := Result.count\n      if i <= values.count then\n        from\n        until\n          i <= 0 or else not attached Result\n        loop\n          v := values [i - 1]\n          if Result.valid_type_for_index (v, i) then\n              -- Value `v' is compatible with tuple item at index `i'.\n            Result [i] := v\n          else\n              -- Value `v' is not compatible with tuple item at index `i'.\n            Result := Void\n          end\n          i := i - 1\n        end\n      else\n          -- Insufficient number of values.\n        Result := Void\n      end\n    ensure\n      dynamic_type_set: attached Result implies Result.generating_type.type_id = type_id\n      values_set: attached Result implies across 1 |..| Result.count as k all Result.item (k.item) = values [k.item - 1] end\n    end\n\n  new_tuple_from_tuple (type_id: INTEGER; source: separate TUPLE): detachable TUPLE\n      -- New instance of a tuple of type `type_id' filled with values fom `source' if all value types are suitable.\n      -- `Void' if some values from `source' are inappropriate for a tuple of type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n      is_tuple_type: is_tuple_type (type_id)\n      -- sufficient_values_count: source.count >= tuple_type_count (type_id)\n      -- valid_value_types: across 1 |..| tuple_type_count (type_id) as i all valid_object_for_tuple_index (values [i - 1], i)\n    local\n      i: INTEGER\n      v: detachable separate ANY\n    do\n      Result := c_new_tuple_instance_of (type_id)\n      i := Result.count\n      if i <= source.count then\n        if source.object_comparison then\n          Result.compare_objects\n        end\n        from\n        until\n          i <= 0 or else not attached Result\n        loop\n          v := source [i]\n          if Result.valid_type_for_index (v, i) then\n              -- Value `v' is compatible with tuple item at index `i'.\n            Result [i] := v\n          else\n              -- Value `v' is not compatible with tuple item at index `i'.\n            Result := Void\n          end\n          i := i - 1\n        end\n      else\n          -- Insufficient number of values.\n        Result := Void\n      end\n    ensure\n      dynamic_type_set: attached Result implies Result.generating_type.type_id = type_id\n      object_comparison_set: attached Result implies Result.object_comparison = source.object_comparison\n      values_set: attached Result implies across 1 |..| Result.count as k all Result.item (k.item) = source [k.item] end\n    end\n\n  type_of_type (type_id: INTEGER): TYPE [detachable ANY]\n      -- Associated TYPE instance for an object of type id `type_id'\n    require\n      type_id_nonnegative: type_id >= 0\n    do\n      Result := c_new_type_instance_of (type_id)\n    ensure\n      result_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  is_special_any_type (type_id: INTEGER): BOOLEAN\n      -- Is type represented by `type_id' represent\n      -- a SPECIAL [XX] where XX is a reference type.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C signature (EIF_INTEGER): EIF_BOOLEAN use %\"eif_internal.h%\"\"\n    alias\n      \"eif_special_any_type\"\n    end\n\n  is_special_type (type_id: INTEGER): BOOLEAN\n      -- Is type represented by `type_id' represent\n      -- a SPECIAL [XX] where XX is a reference type\n      -- or a basic type.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C signature (EIF_INTEGER): BOOLEAN use %\"eif_internal.h%\"\"\n    alias\n      \"eif_is_special_type\"\n    end\n\n  is_tuple_type (type_id: INTEGER): BOOLEAN\n      -- Is type represented by `type_id' represent a TUPLE?\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C signature (EIF_INTEGER): BOOLEAN use %\"eif_internal.h%\"\"\n    alias\n      \"eif_is_tuple_type\"\n    end\n\n  is_attached_type (a_type_id: INTEGER): BOOLEAN\n      -- Is `a_type_id' an attached type?\n    require\n      a_type_non_negative: a_type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.is_attached_type (a_type_id)\n    end\n\n  is_field_transient_of_type (i: INTEGER; a_type_id: INTEGER): BOOLEAN\n      -- Is `i'-th field of `object' a transient attribute?\n      -- I.e. an attribute that does not need to be stored?\n    require\n      a_type_non_negative: a_type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (a_type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.is_field_transient_of_type (i, a_type_id)\n    end\n\n  is_field_expanded_of_type (i: INTEGER; a_type_id: INTEGER): BOOLEAN\n      -- Is `i'-th field of type `a_type_id' a user-defined expanded attribute?\n    require\n      a_type_non_negative: a_type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (a_type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.is_field_expanded_of_type (i, a_type_id)\n    end\n\nfeature -- Access\n\n  class_name_of_type (type_id: INTEGER): STRING\n      -- Name of class associated with dynamic type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.generator_of_type (type_id)\n    end\n\n  type_name_of_type (type_id: INTEGER): STRING\n      -- Name of `type_id''s generating type (type of which `type_id'\n      -- is a direct instance).\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.generating_type_of_type (type_id)\n    end\n\n  attached_type (type_id: INTEGER): INTEGER\n      -- Attached version of `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.attached_type (type_id)\n    ensure\n      unchanged_if_attached: is_attached_type (type_id) implies type_id = Result\n    end\n\n  detachable_type (type_id: INTEGER): INTEGER\n      -- Detachable version of `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.detachable_type (type_id)\n    ensure\n      unchanged_if_detachable: not is_attached_type (type_id) implies type_id = Result\n    end\n\n  generic_count_of_type (type_id: INTEGER): INTEGER\n      -- Number of generic parameter in `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.generic_parameter_count (type_id)\n    end\n\n  generic_dynamic_type_of_type (type_id: INTEGER; i: INTEGER): INTEGER\n      -- Dynamic type of generic parameter of `type_id' at position `i'.\n    require\n      type_id_nonnegative: type_id >= 0\n      type_id_generic: generic_count_of_type (type_id) > 0\n      i_valid: i > 0 and i <= generic_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.eif_gen_param_id (type_id, i)\n    ensure\n      dynamic_type_nonnegative: Result >= 0\n    end\n\n  storable_version_of_type (a_type_id: INTEGER): detachable IMMUTABLE_STRING_8\n      -- Storable version if any specified.\n    require\n      a_type_id_nonnegative: a_type_id >= 0\n    local\n      l_result, l_null: POINTER\n    external\n      \"built_in\"\n      -- id_to_storable_version.search (a_type_id)\n      -- if id_to_storable_version.found then\n      --   Result := id_to_storable_version.found_item\n      -- else\n      --   l_result := {ISE_RUNTIME}.storable_version_of_type (a_type_id)\n      --   if l_result /= l_null then\n      --     create Result.make_from_c (l_result)\n      --     if Result.is_empty then\n      --       Result := Void\n      --     end\n      --   end\n      --   id_to_storable_version.put (Result, a_type_id)\n      -- end\n    end\n\n  field_name_of_type (i: INTEGER; type_id: INTEGER): STRING\n      -- Name of `i'-th field of dynamic type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enought: i <= field_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- create Result.make_from_c ({ISE_RUNTIME}.field_name_of_type (i, type_id))\n    end\n\n  field_type_of_type (i: INTEGER; type_id: INTEGER): INTEGER\n      -- Abstract type of `i'-th field of dynamic type `type_id'\n    require\n      type_id_nonnegative: type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.field_type_of_type (i, type_id)\n    ensure\n      field_type_nonnegative: Result >= 0\n    end\n\n  field_static_type_of_type (i: INTEGER; type_id: INTEGER): INTEGER\n      -- Static type of declared `i'-th field of dynamic type `type_id'\n    require\n      type_id_nonnegative: type_id >= 0\n      index_large_enough: i >= 1\n      index_small_enough: i <= field_count_of_type (type_id)\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.field_static_type_of_type (i, type_id)\n    ensure\n      field_type_nonnegative: Result >= 0\n    end\n\nfeature -- Version\n\n  compiler_version: INTEGER\n    do\n      Result := 0\n    end\n\nfeature -- Measurement\n\n  field_count_of_type (type_id: INTEGER): INTEGER\n      -- Number of logical fields in dynamic type `type_id'.\n    require\n      type_id_nonnegative: type_id >= 0\n    external\n      \"C macro signature (EIF_INTEGER): EIF_INTEGER use %\"eif_internal.h%\"\"\n    alias\n      \"ei_count_field_of_type\"\n    end\n\n  persistent_field_count_of_type (a_type_id: INTEGER): INTEGER\n      -- Number of logical fields in dynamic type `type_id' that are not transient.\n    require\n      a_type_non_negative: a_type_id >= 0\n    external\n      \"built_in\"\n      -- Result := {ISE_RUNTIME}.persistent_field_count_of_type (a_type_id)\n    end\n\nfeature {NONE} -- Implementation\n\n  internal_dynamic_type_string_table: STRING_TABLE [INTEGER]\n      -- Table of dynamic type indexed by type name\n    once\n      create Result.make (100)\n    ensure\n      internal_dynamic_type_string_table_not_void: Result /= Void\n    end\n\n  id_to_storable_version: HASH_TABLE [detachable IMMUTABLE_STRING_8, INTEGER]\n      -- Buffer for `storable_version_of_type' lookups index by type_id.\n    once\n      create Result.make (100)\n    ensure\n      id_to_storable_version_not_void: Result /= Void\n    end\n\n  c_new_instance_of (type_id: INTEGER): ANY\n      -- New instance of dynamic `type_id'.\n      -- Note: returned object is not initialized and may\n      -- hence violate its invariant.\n      -- `type_id' cannot represent a SPECIAL type, use\n      -- `new_special_any_instance' instead.\n    external\n      \"C macro use %\"eif_macros.h%\"\"\n    alias\n      \"RTLNSMART\"\n    end\n\n  c_new_tuple_instance_of (type_id: INTEGER): TUPLE\n      -- New instance of tuple of type `type_id'.\n      -- Note: returned object is not initialized and may\n      -- hence violate its invariant.\n    external\n      \"C macro use %\"eif_macros.h%\"\"\n    alias\n      \"RTLNT\"\n    end\n\n  c_new_type_instance_of (type_id: INTEGER): TYPE [detachable ANY]\n      -- New instance of TYPE for object of type `type_id'.\n    external\n      \"C macro use %\"eif_macros.h%\"\"\n    alias\n      \"RTLNTY\"\n    end\n\n  c_set_dynamic_type (obj: SPECIAL [detachable ANY]; dtype: INTEGER)\n      -- Set `obj' dynamic type to `dtype'.\n    external\n      \"built_in static\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"reflector_constants.e","content":"note\n  description: \"Constants to represent abstract types in {REFFLECTOR} and {OBJECT_PROXY}.\"\n  cecil: \"The values are in sync with CECIL constants EIF_*_TYPE.\"\n  runtime: \"The values represent abstract types used by run-time, e.g. {ISE_RUNTIME}.field_type_of_type.\"\n  date: \"$Date: 2013-05-20 16:15:17 -0700 (Mon, 20 May 2013) $\"\n  revision: \"$Revision: 92557 $\"\n\nclass\n  REFLECTOR_CONSTANTS\n\nfeature -- Access\n\n  none_type: INTEGER = -2\n      -- Type ID representation for NONE.\n\n  pointer_type: INTEGER = 0\n      -- Abstract type ID for predefined type {POINTER}.\n\n  reference_type: INTEGER = 1\n      -- Abstract type ID for a reference type.\n\n  character_8_type, character_type: INTEGER = 2\n      -- Abstract type ID for predefined type {CHARACTER_8}.\n\n  boolean_type: INTEGER = 3\n      -- Abstract type ID for predefined type {BOOLEAN}.\n\n  integer_32_type, integer_type: INTEGER = 4\n      -- Abstract type ID for predefined type {INTEGER_32}.\n\n  real_32_type, real_type: INTEGER = 5\n      -- Abstract type ID for predefined type {REAL_32}.\n\n  real_64_type, double_type: INTEGER = 6\n      -- Abstract type ID for predefined type {REAL_64}.\n\n  expanded_type: INTEGER = 7\n      -- Abstract type ID for a non-predefined expanded type.\n\n  bit_type: INTEGER = 8\n      -- This type is obsolete and is not used anymore.\n\n  integer_8_type: INTEGER = 9\n      -- Abstract type ID for predefined type {INTEGER_8}.\n\n  integer_16_type: INTEGER = 10\n      -- Abstract type ID for predefined type {INTEGER_16}.\n\n  integer_64_type: INTEGER = 11\n      -- Abstract type ID for predefined type {INTEGER_64}.\n\n  character_32_type, wide_character_type: INTEGER = 12\n      -- Abstract type ID for predefined type {CHARACTER_32}.\n\n  natural_8_type: INTEGER = 13\n      -- Abstract type ID for predefined type {NATURAL_8}.\n\n  natural_16_type: INTEGER = 14\n      -- Abstract type ID for predefined type {NATURAL_16}.\n\n  natural_32_type: INTEGER = 15\n      -- Abstract type ID for predefined type {NATURAL_32}.\n\n  natural_64_type: INTEGER = 16\n      -- Abstract type ID for predefined type {NATURAL_64}.\n\n  min_predefined_type: INTEGER = -2\n  max_predefined_type: INTEGER = 16\n\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license: \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\nend\n"});
__eiffel_builtin.push({"filename":"reflector_helper.e","content":"note\n  description: \"Helper for routines in INTERNAL class.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-03-04 15:01:25 -0800 (Mon, 04 Mar 2013) $\"\n  revision: \"$Revision: 92178 $\"\n\nclass\n  REFLECTOR_HELPER\n\nfeature -- Status report\n\n  is_pre_ecma_mapping_disabled: BOOLEAN\n      -- Are we mapping old names to new ECMA names?\n      -- False means mapping STRING to STRING_8, INTEGER to INTEGER_32,...\n      -- Redefine in descendants of REFLECTOR to modify the behavior of inspection queries of REFLECTOR.\n    do\n      Result := False\n    end\n\n  is_valid_type_string (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `s' a valid string representation for a TYPE.\n    local\n      l_type_name: STRING_32\n      l_start_pos, l_end_pos: INTEGER\n      l_class_type_name: STRING_32\n      l_parameters: like parameters_decomposition\n    do\n      if s /= Void and then not s.is_empty then\n        create l_class_type_name.make_from_string_general (s)\n        l_class_type_name.left_adjust\n        l_class_type_name.right_adjust\n\n          -- Let's see if it is a generic type.\n        l_start_pos := l_class_type_name.index_of ('[', 1)\n\n        if l_start_pos > 1 then\n            -- Looks like it is a generic class.\n          l_end_pos := l_class_type_name.count\n          if l_class_type_name.item (l_end_pos) /= ']' then\n            l_end_pos := 0\n          end\n          if\n            l_end_pos = l_class_type_name.count and l_start_pos < l_end_pos and\n            l_class_type_name.occurrences ('[') = l_class_type_name.occurrences (']')\n          then\n              -- A well formed generic class.\n            l_type_name := l_class_type_name.substring (1, l_start_pos - 1)\n            l_type_name.left_adjust\n            l_type_name.right_adjust\n\n            if is_valid_identifier (l_type_name) then\n              l_parameters := parameters_decomposition (\n                l_class_type_name.substring (l_start_pos + 1, l_end_pos - 1))\n              if l_parameters /= Void then\n                from\n                  Result := True\n                  l_parameters.start\n                until\n                  l_parameters.after or not Result\n                loop\n                  Result := is_valid_type_string (l_parameters.item)\n                  l_parameters.forth\n                end\n              end\n            end\n          end\n        else\n            -- Ensures that it is a valid type name.\n          Result := is_valid_identifier (l_class_type_name)\n        end\n      end\n    end\n\n  mapped_type (a_type: READABLE_STRING_GENERAL): READABLE_STRING_GENERAL\n      -- If `is_pre_ecma_mapping_disabled' `a_type', otherwise\n      -- the mapped typed.\n    require\n      a_type_not_void: a_type /= Void\n    local\n      l_table: like pre_ecma_type_mapping\n      r: detachable READABLE_STRING_GENERAL\n    do\n      if not is_pre_ecma_mapping_disabled then\n        l_table := pre_ecma_type_mapping\n        l_table.search (a_type)\n        if l_table.found then\n          r := l_table.found_item\n        end\n      end\n      if r = Void then\n        r := a_type\n      end\n      Result := r\n    ensure\n      mapped_type_not_void: Result /= Void\n    end\n\nfeature {NONE} -- Implementation: status report\n\n  is_valid_identifier (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `s' a valid Eiffel identifier?\n    require\n      name_not_void: s /= Void\n    local\n      i, nb: INTEGER\n      cc: CHARACTER_32\n    do\n      if not s.is_empty then\n        cc := s.item (1)\n        nb := s.count + 1\n        if cc = attached_mark or cc = detachable_mark then\n          i := 2\n        elseif s.substring_index (attached_keyword, 1) = 1 then\n          i := attached_keyword.count + 1\n        elseif s.substring_index (detachable_keyword, 1) = 1 then\n          i := detachable_keyword.count + 1\n        elseif s.substring_index (expanded_keyword, 1) = 1 then\n          i := expanded_keyword.count + 1\n        else\n          i := 1\n        end\n        if i > 1 then\n            -- Remove any whitespace between the attachment mark and the type name.\n          from\n          until\n            i = nb or not s.item (i).is_space\n          loop\n            i := i + 1\n          end\n        end\n        if s.item (i).is_alpha then\n          from\n            Result := True\n          until\n            i = nb\n          loop\n            cc := s.item (i)\n            if not (cc.is_alpha or cc.is_digit or cc = '_') then\n              Result := False\n              i := nb - 1\n            end\n            i := i + 1\n          end\n        end\n      end\n    end\n\nfeature {NONE} -- Decompose string type\n\n  parameters_decomposition (a_str: READABLE_STRING_32): detachable ARRAYED_LIST [READABLE_STRING_32]\n      -- Decompose `a_str' which should be of the form \"A, B, D [G], H [E ,F]\"\n      -- into a list of strings \"A\", \"B\", \"D [G]\", \"H [E, F]\"\n      -- If decomposition is not possible, Void.\n    require\n      a_str_not_void: a_str /= Void\n    local\n      i, nb: INTEGER\n      l_invalid: BOOLEAN\n      l_first_pos: INTEGER\n      l_nesting: INTEGER\n    do\n      from\n        create Result.make (5)\n        i := 1\n        l_first_pos := 1\n        nb := a_str.count\n      until\n        i > nb or l_invalid\n      loop\n        inspect\n          a_str.item (i)\n        when ',' then\n          if l_nesting = 0 then\n            Result.extend (a_str.substring (l_first_pos, i - 1))\n            l_first_pos := i + 1\n          end\n        when '[' then\n          l_nesting := l_nesting + 1\n        when ']' then\n          l_nesting := l_nesting - 1\n          l_invalid := l_nesting < 0\n        else\n          -- Do nothing\n        end\n        i := i + 1\n      end\n      if not l_invalid and then l_nesting = 0 then\n        Result.extend (a_str.substring (l_first_pos, i - 1))\n      else\n        Result := Void\n      end\n    end\n\nfeature {NONE} -- ECMA mapping helper\n\n  pre_ecma_type_mapping: STRING_TABLE [STRING]\n      -- Mapping between pre-ECMA type naming and new names.\n    once\n      create Result.make (12)\n      Result.put (\"STRING_8\", \"STRING\")\n      Result.put (\"INTEGER_32\", \"INTEGER\")\n      Result.put (\"INTEGER_32_REF\", \"INTEGER_REF\")\n      Result.put (\"CHARACTER_8\", \"CHARACTER\")\n      Result.put (\"CHARACTER_8_REF\", \"CHARACTER_REF\")\n      Result.put (\"CHARACTER_32\", \"WIDE_CHARACTER\")\n      Result.put (\"CHARACTER_32_REF\", \"WIDE_CHARACTER_REF\")\n      Result.put (\"REAL_32\", \"REAL\")\n      Result.put (\"REAL_32_REF\", \"REAL_REF\")\n      Result.put (\"REAL_64\", \"DOUBLE\")\n      Result.put (\"REAL_64_REF\", \"DOUBLE_REF\")\n    ensure\n      pre_ecma_type_mapping_not_void: Result /= Void\n    end\n\n  attached_mark: CHARACTER_32 = '!'\n  detachable_mark: CHARACTER_32 = '?'\n  attached_keyword: STRING = \"attached\"\n  detachable_keyword: STRING = \"detachable\"\n  expanded_keyword: STRING = \"expanded\"\n      -- Symbols use for attachment marks.\n\nfeature {NONE} -- Type creation\n\n  type_keyword: STRING = \"TYPE\";\n      -- Used for creating type objects.\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"resizable.e","content":"note\n  description: \"Finite structures whose item count is subject to change\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  size: resizable;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class RESIZABLE [G] inherit\n\n  BOUNDED [G]\n\nfeature -- Measurement\n\n  Growth_percentage: INTEGER = 50\n      -- Percentage by which structure will grow automatically\n\n  Minimal_increase: INTEGER = 5\n      -- Minimal number of additional items\n\n  additional_space: INTEGER\n      -- Proposed number of additional items\n      --| Result is a reasonable value, resulting from a space-time tradeoff.\n    do\n        -- To prevent overflow we do not use `growth_percentage' but its known value.\n      Result := (capacity // 2).max (Minimal_increase)\n    ensure\n      At_least_one: Result >= 1\n    end\n\nfeature -- Status report\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed? (Answer: yes.)\n    do\n      Result := True\n    end\n\nfeature -- Resizing\n\n  automatic_grow\n      -- Change the capacity to accommodate at least\n      -- `Growth_percentage' more items.\n      --| Trades space for time:\n      --| allocates fairly large chunks of memory but not very often.\n    require\n      resizable: resizable\n    do\n      grow (capacity + additional_space)\n    ensure\n      increased_capacity: capacity >= old capacity + old additional_space\n    end\n\n  grow (i: INTEGER)\n      -- Ensure that capacity is at least `i'.\n    require\n      resizable: resizable\n    deferred\n    ensure\n      new_capacity: capacity >= i\n    end\n\n  trim\n      -- Decrease `capacity' to the minimum value.\n      -- Apply to reduce allocated storage.\n    deferred\n    ensure\n      same_count: count = old count\n      minimal_capacity: capacity = count\n    end\n\ninvariant\n\n  increase_by_at_least_one: Minimal_increase >= 1\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"routine.e","content":"note\n  description: \"[\n    Objects representing delayed calls to a routine,\n    with some operands possibly still open\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-28 14:35:23 -0800 (Tue, 28 Jan 2014) $\"\n  revision: \"$Revision: 94109 $\"\n\ndeferred class\n  ROUTINE [BASE_TYPE -> detachable ANY, OPEN_ARGS -> detachable TUPLE create default_create end]\n\ninherit\n  HASHABLE\n    redefine\n      copy,\n      is_equal\n    end\n\n  REFLECTOR\n    export\n      {NONE} all\n    redefine\n      copy,\n      is_equal\n    end\n\nfeature -- Initialization\n\n  adapt (other: like Current)\n      -- Initialize from `other'.\n      -- Useful in descendants.\n    require\n      other_exists: other /= Void\n      conforming: conforms_to (other)\n    do\n      rout_disp := other.rout_disp\n      encaps_rout_disp := other.encaps_rout_disp\n      calc_rout_addr := other.calc_rout_addr\n      closed_operands := other.closed_operands\n      operands := other.operands\n      routine_id := other.routine_id\n      is_basic := other.is_basic\n      is_target_closed := other.is_target_closed\n      written_type_id_inline_agent := other.written_type_id_inline_agent\n      open_count := other.open_count\n    end\n\nfeature -- Access\n\n  frozen operands: detachable OPEN_ARGS\n\n  target: detachable ANY\n      -- Target of call\n    local\n      c: like closed_operands\n    do\n        -- Because a target object is never separate relative to the routine object,\n        -- the first argument is checked against {ANY} rather than {separate ANY}.\n      if is_target_closed then\n        c := closed_operands\n        if c /= Void and then c.count > 0 and then attached {ANY} c.item (1) as r then\n          Result := r\n        end\n      elseif attached {TUPLE} operands as o and then o.count > 0 and then attached {ANY} o.item (1) as r then\n        Result := r\n      end\n    end\n\n  hash_code: INTEGER\n      -- Hash code value.\n    do\n      Result := rout_disp.hash_code.bit_xor (routine_id.hash_code)\n    end\n\n  precondition (args: like operands): BOOLEAN\n      -- Do `args' satisfy routine's precondition\n      -- in current state?\n    do\n      Result := True\n      --| FIXME compiler support needed!\n    end\n\n  postcondition (args: like operands): BOOLEAN\n      -- Does current state satisfy routine's\n      -- postcondition for `args'?\n    do\n      Result := True\n      --| FIXME compiler support needed!\n    end\n\n  empty_operands: attached OPEN_ARGS\n      -- Empty tuple matching open operands.\n    obsolete \"This function will be removed as non-void-safe. [22.07.2013]\"\n    do\n      create Result\n    ensure\n      empty_operands_not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  callable: BOOLEAN = True\n      -- Can routine be called on current object?\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is associated routine the same as the one\n      -- associated with `other'.\n    do\n      --| Do not compare implementation data\n      Result := closed_operands ~ other.closed_operands\n        and then operands ~ other.operands\n        and then open_map ~ other.open_map\n        and then (rout_disp = other.rout_disp)\n        and then (routine_id = other.routine_id)\n        and then (written_type_id_inline_agent = other.written_type_id_inline_agent)\n        and then (encaps_rout_disp = other.encaps_rout_disp)\n        and then (calc_rout_addr = other.calc_rout_addr)\n    end\n\n  valid_operands (args: detachable separate TUPLE): BOOLEAN\n      -- Are `args' valid operands for this routine?\n    local\n      i, arg_type_code: INTEGER\n      arg: like {TUPLE}.item\n      open_type_codes: STRING\n      l_type: INTEGER\n    do\n      if args = Void then\n          -- Void operands are only allowed\n          -- if object has no open operands.\n        Result := (open_count = 0)\n      elseif args.count >= open_count then\n        from\n          Result := True\n          open_type_codes := eif_gen_typecode_str ($Current)\n          i := 1\n        until\n          i > open_count or not Result\n        loop\n          arg_type_code := args.item_code (i)\n          Result := arg_type_code = open_type_codes.item (i + 1).code\n          if Result and then arg_type_code = {TUPLE}.reference_code then\n            arg := args.item (i)\n            l_type := open_operand_type (i)\n              -- If expected type is attached, then we need to verify that the actual\n              -- is indeed attached.\n            if is_attached_type (l_type) then\n              Result := arg /= Void and then\n                field_conforms_to (type_id_of (arg), l_type)\n            else\n              Result := arg = Void or else\n                field_conforms_to (type_id_of (arg), l_type)\n            end\n          end\n          i := i + 1\n        end\n      end\n      if Result and then not is_target_closed and then args /= Void then\n        Result := args.item (1) /= Void\n      end\n    end\n\n  valid_target (args: detachable TUPLE): BOOLEAN\n      -- Is the first element of tuple `args' a valid target\n    do\n      if args /= Void and then args.count > 0 then\n        if args.is_reference_item (1) then\n          Result := args.reference_item (1) /= Void\n        else\n          Result := True\n        end\n      end\n    end\n\n  is_target_closed: BOOLEAN\n      -- Is target for current agent closed, i.e. specified at creation time?\n\nfeature -- Measurement\n\n  open_count: INTEGER\n      -- Number of open operands.\n\nfeature -- Settings\n\n  frozen set_operands (args: detachable OPEN_ARGS)\n      -- Use `args' as operands for next call.\n    require\n      valid_operands: valid_operands (args)\n    do\n      operands := args\n    ensure\n      operands_set: (operands /= Void implies (operands ~ args)) or\n        (operands = Void implies (args = Void or else args.is_empty))\n    end\n\n  set_target (a_target: like target)\n      -- Set `a_target' as the next `target' for remaining calls to Current.\n    require\n      a_target_not_void: a_target /= Void\n      is_target_closed: is_target_closed\n      target_not_void: target /= Void\n      same_target_type: attached target as t and then t.same_type (a_target)\n    local\n      c: like closed_operands\n    do\n      c := closed_operands\n      if c /= Void then\n        c.put (a_target, 1)\n      end\n    ensure\n      target_set: target = a_target\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Use same routine as `other'.\n    do\n      if other /= Current then\n        standard_copy (other)\n        if attached operands as l_operands then\n          operands := l_operands.twin\n        end\n      end\n    ensure then\n      same_call_status: other.callable implies callable\n    end\n\nfeature -- Basic operations\n\n  call (args: detachable separate OPEN_ARGS)\n      -- Call routine with `args'.\n    require\n      valid_operands: valid_operands (args)\n    deferred\n    end\n\n  apply\n      -- Call routine with `operands' as last set.\n    require\n      valid_operands: valid_operands (operands)\n    deferred\n    end\n\nfeature -- Extended operations\n\n  flexible_call (a: detachable separate TUPLE)\n      -- Call routine with arguments `a'.\n      -- Compared to `call' the type of `a' may be different from `{OPEN_ARGS}'.\n    require\n      valid_operands: valid_operands (a)\n    local\n      default_arguments: detachable OPEN_ARGS\n    do\n      if not attached a then\n        call (default_arguments)\n      else\n        -- TODO implement in javascript\n        -- check\n        --   from_precondition: attached {OPEN_ARGS} new_tuple_from_tuple (({OPEN_ARGS}).type_id, a) as x\n        -- then\n        --   call (x)\n        -- end\n      end\n    end\n\nfeature -- Obsolete\n\n  adapt_from (other: like Current)\n      -- Adapt from `other'. Useful in descendants.\n    obsolete\n      \"Please use `adapt' instead (it's also a creation procedure)\"\n    require\n      other_exists: other /= Void\n      conforming: conforms_to (other)\n    do\n      adapt (other)\n    end\n\nfeature {ROUTINE} -- Implementation\n\n  frozen closed_operands: detachable TUPLE\n      -- All closed arguments provided at creation time\n\n  closed_count: INTEGER\n      -- The number of closed operands (including the target if it is closed)\n    local\n      c: detachable TUPLE\n    do\n      c := closed_operands\n      if c /= Void then\n        Result := c.count\n      end\n    end\n\n  frozen rout_disp: POINTER\n      -- Routine dispatcher\n\n  frozen calc_rout_addr: POINTER\n      -- Address of the final routine\n\n  frozen open_map: detachable ARRAY [INTEGER]\n      -- Index map for open arguments\n\n  frozen encaps_rout_disp: POINTER\n      -- Eiffel routine dispatcher\n\n  frozen routine_id: INTEGER\n\n  frozen is_basic: BOOLEAN\n\n  frozen written_type_id_inline_agent: INTEGER\n\n  frozen set_rout_disp (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: POINTER;\n              a_routine_id: INTEGER; a_open_map: like open_map;\n              a_is_basic, a_is_target_closed: BOOLEAN; a_written_type_id_inline_agent: INTEGER;\n              a_closed_operands: TUPLE; a_open_count: INTEGER)\n      -- Initialize object.\n    require\n      target_valid: a_is_target_closed implies valid_target (a_closed_operands)\n    do\n      set_rout_disp_int (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr, a_routine_id,\n                 a_open_map, a_is_basic, a_is_target_closed,\n                 a_written_type_id_inline_agent, a_closed_operands, a_open_count)\n    end\n\n  frozen set_rout_disp_final (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: POINTER\n                  a_closed_operands: TUPLE; a_is_target_closed: BOOLEAN; a_open_count: INTEGER)\n      -- Initialize object.\n    do\n      rout_disp := a_rout_disp\n      encaps_rout_disp := a_encaps_rout_disp\n      calc_rout_addr := a_calc_rout_addr\n      closed_operands := a_closed_operands\n      is_target_closed := a_is_target_closed\n      open_count := a_open_count\n    end\n\n  frozen set_rout_disp_int (a_rout_disp, a_encaps_rout_disp, a_calc_rout_addr: POINTER;\n                  a_routine_id: INTEGER; a_open_map: like open_map;\n                a_is_basic, a_is_target_closed: BOOLEAN; a_written_type_id_inline_agent: INTEGER;\n                a_closed_operands: TUPLE; a_open_count: INTEGER)\n      -- Initialize object.\n    require\n      a_routine_id_valid: a_routine_id > -1\n    do\n      rout_disp := a_rout_disp\n      encaps_rout_disp := a_encaps_rout_disp\n      calc_rout_addr := a_calc_rout_addr\n      routine_id := a_routine_id\n      open_map := a_open_map\n      is_basic := a_is_basic\n      is_target_closed := a_is_target_closed\n      written_type_id_inline_agent := a_written_type_id_inline_agent\n      closed_operands := a_closed_operands\n      open_count := a_open_count\n    ensure\n      rout_disp_set: rout_disp = a_rout_disp\n      encaps_rout_disp_set: encaps_rout_disp = a_encaps_rout_disp\n      calc_rout_addr_set: calc_rout_addr = a_calc_rout_addr\n      routine_id_set: routine_id = a_routine_id\n      open_map_set: open_map = a_open_map\n      is_target_closed_set: is_target_closed = a_is_target_closed\n      is_basic_set: is_basic = a_is_basic\n      written_type_id_inline_agent_set: written_type_id_inline_agent = a_written_type_id_inline_agent\n      closed_operands_set: closed_operands = a_closed_operands\n      open_count_set: open_count = a_open_count\n    end\n\nfeature {NONE} -- Implementation\n\n  frozen open_types: detachable ARRAY [INTEGER]\n      -- Types of open operands\n\n  open_operand_type (i: INTEGER): INTEGER\n      -- Type of `i'th open operand.\n    require\n      positive: i >= 1\n      within_bounds: i <= open_count\n    local\n      o: like open_types\n    do\n      o := open_types\n      if o = Void then\n        create o.make_filled (-1, 1, open_count)\n        open_types := o\n      end\n      Result := o.item (i)\n      if Result = -1 then\n        Result := ({OPEN_ARGS}).generic_parameter_type (i).type_id\n        o.put (Result, i)\n      end\n    end\n\n  type_id_of (a: separate ANY): INTEGER\n      -- Type ID of an object `a'.\n    do\n      Result := a.generating_type.type_id\n    end\n\nfeature {NONE} -- Externals\n\n  eif_gen_typecode_str (obj: POINTER): STRING\n      -- Code name for generic parameter `pos' in `obj'.\n    external\n      \"C signature (EIF_REFERENCE): EIF_REFERENCE use %\"eif_gen_conf.h%\"\"\n    end\n\nfeature -- Obsolete\n\n  arguments: detachable OPEN_ARGS\n    obsolete\n      \"use operands\"\n    do\n      Result := operands\n    end\n\n  set_arguments (args: detachable OPEN_ARGS)\n    obsolete\n      \"use set_operands\"\n    do\n      set_operands (args)\n    end\n\n  valid_arguments (args: detachable OPEN_ARGS): BOOLEAN\n    obsolete\n      \"use valid_operands\"\n    do\n      Result := valid_operands (args)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"sequence.e","content":"note\n  description: \"[\n    Finite sequences: structures where existing items are arranged\n    and accessed sequentially, and new ones can be added at the end.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: sequence;\n  access: cursor, membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class SEQUENCE [G] inherit\n\n  ACTIVE [G]\n    redefine\n      prune_all\n    end\n\n  BILINEAR [G]\n\n  FINITE [G]\n\nfeature -- Status report\n\n  readable: BOOLEAN\n      -- Is there a current item that may be read?\n    do\n      Result := not off\n    end\n\n\n  writable: BOOLEAN\n      -- Is there a current item that may be modified?\n    do\n      Result := not off\n    end\n\nfeature -- Element change\n\n  force (v: like item)\n      -- Add `v' to end.\n    require\n      extendible: extendible\n    do\n      extend (v)\n    ensure then\n      new_count: count = old count + 1\n      item_inserted: has (v)\n    end\n\n  append (s: SEQUENCE [G])\n      -- Append a copy of `s'.\n    require\n      argument_not_void: s /= Void\n    local\n      l: like s\n    do\n      l := s\n      if s = Current then\n        l := twin\n      end\n      from\n        l.start\n      until\n        l.exhausted\n      loop\n        extend (l.item)\n        l.forth\n      end\n    ensure\n      new_count: count >= old count\n    end\n\n  put (v: like item)\n      -- Add `v' to end.\n    do\n      extend (v)\n    ensure then\n      new_count: count = old count + 1\n    end\n\nfeature -- Removal\n\n  prune (v: like item)\n      -- Remove the first occurrence of `v' if any.\n      -- If no such occurrence go `off'.\n    do\n      start\n      search (v)\n      if not exhausted then\n        remove\n      end\n    end\n\n  prune_all (v: like item)\n      -- Remove all occurrences of `v'; go `off'.\n    do\n      from\n        start\n      until\n        exhausted\n      loop\n        search (v)\n        if not exhausted then\n          remove\n        end\n      end\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"special.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-03-04 15:01:25 -0800 (Mon, 04 Mar 2013) $\"\n  revision: \"$Revision: 92178 $\"\n\nfrozen class\n  SPECIAL [T]\n\ninherit\n  ABSTRACT_SPECIAL\n    redefine\n      debug_output\n    end\n\n  READABLE_INDEXABLE [T]\n\ncreate\n  make_empty,\n  make_filled,\n  make_from_native_array\n\nfeature {NONE} -- Initialization\n\n  make_empty (n: INTEGER)\n      -- Create a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    external\n      \"built_in\"\n    ensure\n      capacity_set: capacity = n\n      count_set: count = 0\n    end\n\n  make_filled (v: T; n: INTEGER)\n      -- Create a special object for `n' entries initialized with `v'.\n    require\n      non_negative_argument: n >= 0\n    do\n      make_empty (n)\n      fill_with (v, 0, n - 1)\n    ensure\n      capacity_set: capacity = n\n      count_set: count = n\n      filled: filled_with (v, 0, n - 1)\n    end\n\n  make_from_native_array (an_array: like native_array)\n      -- Create a special object from `an_array'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      an_array_not_void: an_array /= Void\n    do\n    end\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): T assign put\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    external\n      \"built_in\"\n    end\n\n  at alias \"@\" (i: INTEGER): T\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    require\n      valid_index: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  index_of (v: T; start_position: INTEGER): INTEGER\n      -- Index of first occurrence of item identical to `v'.\n      -- -1 if none.\n      -- (Use object equality for comparison.)\n    require\n      valid_start_position: start_position >= 0\n    local\n      nb: INTEGER\n    do\n      from\n        Result := start_position\n        nb := count\n      until\n        Result >= nb or else item (Result) ~ v\n      loop\n        Result := Result + 1\n      end\n      if Result >= nb then\n        Result := -1\n      end\n    ensure\n      found_or_not_found: Result = -1 or else (Result >= 0 and then Result < count)\n    end\n\n  item_address (i: INTEGER): POINTER\n      -- Address of element at position `i'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    do\n      Result := base_address + i * element_size\n    ensure\n      element_address_not_null: Result /= default_pointer\n    end\n\n  base_address: POINTER\n      -- Address of element at position `0'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n    external\n      \"built_in\"\n    ensure\n      base_address_not_null: Result /= default_pointer\n    end\n\n  native_array: NATIVE_ARRAY [T]\n      -- Only for compatibility with .NET\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      create Result\n    end\n\n  to_array: ARRAY [T]\n      -- Build an array representation of Current from `1' to `count'.\n    do\n      create Result.make_from_special (Current)\n    ensure\n      to_array_attached: Result /= Void\n      to_array_lower_set: Result.lower = 1\n      to_array_upper_set: Result.upper = count\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- <Precursor>\n    do\n      create Result.make (lower, upper)\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER = 0\n      -- Minimum index of Current\n\n  upper: INTEGER\n      -- Maximum index of Current\n    do\n      Result := count - 1\n    ensure\n      definition: lower <= Result + 1\n    end\n\n  count: INTEGER\n      -- Count of special area\n    external\n      \"built_in\"\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  filled_with (v: T; start_index, end_index: INTEGER): BOOLEAN\n      -- Are all items between index `start_index' and `end_index'\n      -- set to `v'?\n      -- (Use reference equality for comparison.)\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    local\n      i: INTEGER\n    do\n      from\n        Result := True\n        i := start_index\n      until\n        i > end_index or else not Result\n      loop\n        Result := item (i) = v\n        i := i + 1\n      end\n    end\n\n  same_items (other: like Current; source_index, destination_index, n: INTEGER): BOOLEAN\n      -- Are the `n' elements of `other' from `source_index' position the same as\n      -- the `n' elements of `Current' from `destination_index'?\n      -- (Use reference equality for comparison.)\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= count\n    local\n      i, j, nb: INTEGER\n    do\n      Result := True\n      if other /= Current then\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          if other.item (i) /= item (j) then\n            Result := False\n            i := nb - 1\n          end\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      valid_on_empty_area: (n = 0) implies Result\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := (0 <= i) and (i < count)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    external\n      \"built_in\"\n    ensure\n      inserted: item (i) = v\n      same_count: count = old count\n      same_capacity: capacity = old capacity\n    end\n\n  force (v: T; i: INTEGER)\n      -- If `i' is equal to `count' increase `count' by one and insert `v' at index `count',\n      -- otherwise replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i <= count\n      not_full: i = count implies count < capacity\n    do\n      if i < count then\n        put (v, i)\n      else\n        extend (v)\n      end\n    ensure\n      count_updated: count = (i + 1).max (old count)\n      same_capacity: capacity = old capacity\n      inserted: item (i) = v\n    end\n\n  extend (v: T)\n      -- Add `v' at index `count'.\n    require\n      count_small_enough: count < capacity\n    external\n      \"built_in\"\n    ensure\n      count_increased: count = old count + 1\n      same_capacity: capacity = old capacity\n      inserted: item (count - 1) = v\n    end\n\n  extend_filled (v: T)\n      -- Set items between `count' and `capacity - 1' with `v'.\n    do\n      fill_with (v, count, capacity - 1)\n    ensure\n      same_capacity: capacity = old capacity\n      count_increased: count = capacity\n      filled: filled_with (v, old count, capacity - 1)\n    end\n\n  fill_with (v: T; start_index, end_index: INTEGER)\n      -- Set items between `start_index' and `end_index' with `v'.\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_in_bound: start_index <= count\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < capacity\n    local\n      i, nb: INTEGER\n      l_count: like count\n    do\n      from\n        i := start_index\n        l_count := count.min (end_index + 1)\n        nb := l_count\n      until\n        i = nb\n      loop\n        put (v, i)\n        i := i + 1\n      end\n      from\n        i := l_count\n        nb := end_index + 1\n      until\n        i = nb\n      loop\n        extend (v)\n        i := i + 1\n      end\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = (old count).max (end_index + 1)\n      filled: filled_with (v, start_index, end_index)\n    end\n\n  fill_with_default (start_index, end_index: INTEGER)\n      -- Clear items between `start_index' and `end_index'.\n    require\n      is_self_initializing: ({T}).has_default\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    do\n      fill_with (({T}).default, start_index, end_index)\n    ensure\n      filled: filled_with (({T}).default, start_index, end_index)\n    end\n\n  insert_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Insert `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index' and shift elements between `destination_index' and `count'\n      -- to the right. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: count + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      l_remaining_items, l_offset, l_nb_items_left: INTEGER\n      l_source_index, l_end_index, l_destination_index: INTEGER\n    do\n      l_remaining_items := count - destination_index\n      if l_remaining_items = 0 then\n          -- It is being added at the end of Current, therefore we can simply extend.\n        copy_data (other, source_index, destination_index, n)\n      elseif n <= l_remaining_items then\n          -- Simple case where we can perform a move of the existing items to the end\n          -- and then copy the elements of `other'.\n        move_data (destination_index, destination_index + n, l_remaining_items)\n        copy_data (other, source_index, destination_index, n)\n      else\n          -- Because we cannot have uninitialized items, we cannot move all the remaining items beyond count\n          -- instead we copy by chunks of `l_remaining_items'.\n        from\n          l_source_index := source_index\n          l_destination_index := destination_index\n          l_end_index := source_index + n\n          l_nb_items_left := n\n          l_offset := l_remaining_items\n        until\n          l_source_index >= l_end_index\n        loop\n          move_data (l_destination_index, l_destination_index + l_offset, l_remaining_items)\n          copy_data (other, l_source_index, l_destination_index, l_offset)\n          l_destination_index := l_destination_index + l_offset\n          l_source_index := l_source_index + l_offset\n            -- Compute how many more items we have to copy.\n          l_nb_items_left := l_nb_items_left - l_remaining_items\n          l_offset := l_offset.min (l_nb_items_left)\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = old count + n\n    end\n\n  copy_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Copy `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index'. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      i, j, nb: INTEGER\n    do\n      if other = Current then\n        move_data (source_index, destination_index, n)\n      else\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          force (other.item (i), j)\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  move_data (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    do\n      if source_index = destination_index then\n      elseif source_index > destination_index then\n        if destination_index + n < source_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      else\n        if source_index + n < destination_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      if source_index < destination_index then\n          -- We shift from left to right starting from the end\n          -- due to possible overlapping.\n        from\n          i := source_index + n - 1\n          nb := source_index - 1\n          l_offset := destination_index - source_index\n          if (destination_index + n >= count) then\n              -- Initialize elements above `count' to a dummy item.\n            fill_with (item (source_index), count, destination_index + n - 1)\n          end\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          put (item (i), i + l_offset)\n          i := i - 1\n        end\n      else\n          -- We shift from right to left.\n        from\n          i := source_index\n          nb := source_index + n\n          l_offset := source_index - destination_index\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          force (item (i), i - l_offset)\n          i := i + 1\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  non_overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      non_overlapping:\n        (source_index < destination_index implies source_index + n < destination_index) or\n        (source_index > destination_index implies destination_index + n < source_index)\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      from\n        i := source_index\n        nb := source_index + n\n        l_offset := destination_index - source_index\n      until\n        i = nb\n      loop\n        force (item (i), i + l_offset)\n        i := i + 1\n      end\n    ensure\n      moved: same_items (Current, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\nfeature -- Resizing\n\n  keep_head (n: INTEGER)\n      -- Keep the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, 0, 0, n)\n    end\n\n  keep_tail (n: INTEGER)\n      -- Keep the last `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      overlapping_move (count - n, 0, n)\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, n, 0, n)\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_tail (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, n, 0, count)\n    end\n\n  remove_tail (n: INTEGER)\n      -- Keep the first  `count - n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_head (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, 0, 0, count)\n    end\n\n  resized_area (n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n'\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      Result.copy_data (Current, 0, 0, n.min (count))\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n' where not yet initialized\n      -- entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      if n > count then\n        Result.copy_data (Current, 0, 0, count)\n        Result.fill_with (a_default_value, count, n - 1)\n      else\n        Result.copy_data (Current, 0, 0, n)\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area (n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy\n    require\n      n_non_negative: n >= 0\n    external\n      \"built_in\"\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy. Non yet initialized entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      Result := aliased_resized_area (n)\n      Result.fill_with (a_default_value, Result.count, n - 1)\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\nfeature -- Removal\n\n  replace_all (v: T)\n      -- Replace all items with `v'.\n    local\n      i: INTEGER\n    do\n      from\n        i := count - 1\n      until\n        i < 0\n      loop\n        put (v, i)\n        i := i - 1\n      end\n    ensure\n      cleared: filled_with (v, 0, upper)\n    end\n\n  wipe_out\n      -- Reset count to zero.\n    do\n      set_count (0)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = 0\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    obsolete\n      \"Because of the new precondition, it is recommended to use `fill_with' instead.\"\n    require\n      has_default: ({T}).has_default\n    do\n      fill_with_default (0, upper)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = old count\n    end\n\nfeature -- Iteration\n\n  do_all_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_if_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i)]) then\n          action.call ([item (i)])\n        end\n        i := i + 1\n      end\n    end\n\n  there_exists_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb or Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  for_all_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n        Result := True\n      until\n        i > nb or not Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_all_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; test: FUNCTION [ANY, TUPLE [T, INTEGER], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i), j]) then\n          action.call ([item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      Result := Precursor\n      Result.append_string (\", capacity=\")\n      Result.append_integer (capacity)\n    end\n\nfeature {NONE} -- Implementation\n\n  element_size: INTEGER\n      -- Size of elements\n    external\n      \"built_in\"\n    ensure\n      element_size_non_negative: Result >= 0\n    end\n\n  set_count (n: INTEGER)\n      -- Set `count' with `n'.\n    require\n      n_non_negative: n >= 0\n      valid_new_count: n <= count\n    external\n      \"built_in\"\n    ensure\n      count_set: count = n\n      capacity_preserved: capacity = old capacity\n    end\n\ninvariant\n  count_less_than_capacity: count <= capacity\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    extern\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_32.e","content":"note\n  description: \"[\n    Sequences of 32-bit characters, accessible through integer indices\n    in a contiguous range.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-25 20:46:54 -0700 (Tue, 25 Mar 2014) $\"\n  revision: \"$Revision: 94717 $\"\n\nclass\n  STRING_32\n\ninherit\n  READABLE_STRING_32\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    redefine\n      area\n    end\n\n  STRING_GENERAL\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil,\n  make_from_separate\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    local\n      l_first_pos, l_next_pos: INTEGER\n      l_orig_count, l_new_count, l_new_lower, l_count, i, l_index_count: INTEGER\n      l_src_index, l_dest_index, l_prev_index, l_copy_delta: INTEGER\n      l_area, l_new_area: like area\n      l_offset: INTEGER\n      l_string_searcher: like string_searcher\n      l_index_list: SPECIAL [INTEGER]\n    do\n      if not is_empty then\n        l_count := count\n        l_string_searcher := string_searcher\n        l_string_searcher.initialize_deltas (original)\n        l_orig_count := original.count\n        l_new_count := new.count\n        if l_orig_count >= l_new_count then\n          l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, 1, l_count)\n          if l_first_pos > 0 then\n            if l_orig_count = l_new_count then\n                -- String will not be resized, simply perform character substitution\n              from\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_first_pos = 0\n              loop\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1, l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_new_count, l_count)\n                else\n                  l_first_pos := 0\n              end\n            end\n          elseif l_orig_count > l_new_count then\n              -- New string is smaller than previous string, we can optimize\n              -- substitution by only moving block between two occurrences of `orginal'.\n            from\n              l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n              l_area := area\n              l_new_area := new.area\n              l_new_lower := new.area_lower\n            until\n              l_next_pos = 0\n            loop\n                -- Copy new string into Current\n              l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                -- Shift characters between `l_first_pos' and `l_next_pos'\n              l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                l_first_pos + l_new_count - 1 - l_offset, l_next_pos - l_first_pos - l_orig_count)\n              l_first_pos := l_next_pos\n              l_offset := l_offset + (l_orig_count - l_new_count)\n              if l_first_pos + l_new_count <= l_count then\n                l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n              else\n                l_next_pos := 0\n              end\n            end\n              -- Perform final substitution:\n              -- Copy new string into Current\n            l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n              -- Shift characters between `l_first_pos' and the end of the string\n            l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n              l_first_pos + l_new_count - 1 - l_offset, l_count + 1 - l_first_pos - l_orig_count)\n                -- Perform last substitution\n            l_offset := l_offset + (l_orig_count - l_new_count)\n\n              -- Update `count'\n            set_count (l_count - l_offset)\n            end\n              -- String was modified we need to recompute the `hash_code'.\n            internal_hash_code := 0\n          end\n        elseif attached l_string_searcher.substring_index_list_with_deltas (Current, original, 1, l_count) as l_list then\n            -- Get the number of substitution to be performed by getting a list\n            -- of location where `original' appears.\n          l_index_list := l_list.area\n          l_index_count := l_index_list.count\n            -- Store the index of the last character up to which we need to move\n            -- characters in the reallocated string.\n          l_prev_index := l_count\n            -- Resize Current with the appropriate number of characters\n          l_copy_delta := l_new_count - l_orig_count\n          l_count := l_count + (l_index_count * l_copy_delta)\n          l_area := area.resized_area_with_default ('%U', l_count + 1)\n          area := l_area\n            -- Perform the substitution starting from the end.\n          from\n            i := l_index_count\n            l_new_lower := new.area_lower\n            l_new_area := new.area\n          until\n            i = 0\n          loop\n            i := i - 1\n            l_src_index := l_index_list.item (i)\n            l_dest_index := l_src_index + i * l_copy_delta\n              -- Shift non-matching characters to the right of the newly replaced string.\n            l_area.overlapping_move (l_src_index + l_orig_count - 1, l_dest_index + l_new_count - 1, l_prev_index - l_src_index - l_orig_count + 1)\n              -- Store new end of string where characters will be moved.\n            l_prev_index := l_src_index - 1\n\n              -- Copy `new' to its appropriate position\n            l_area.copy_data (l_new_area, l_new_lower, l_dest_index - 1, l_new_count)\n          end\n            -- Update the new `count' which also resets the `hash_code'.\n          set_count (l_count)\n        end\n      end\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-26 14:49:40 -0700 (Wed, 26 Mar 2014) $\"\n  revision: \"$Revision: 94721 $\"\n\nclass\n  STRING_8\n\ninherit\n  READABLE_STRING_8\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    redefine\n      area\n    end\n\n  STRING_GENERAL\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    undefine\n      copy, is_equal, out\n    redefine\n      append_string_general,\n      prepend_string_general\n    end\n\n  INDEXABLE [CHARACTER_8, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_8]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_8]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_32: {READABLE_STRING_32, STRING_32}\n\nfeature -- Initialization\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_8): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8 assign put\n      -- Character at position `i'.\n    do\n      Result := area.item (i - 1)\n    end\n\n  character_32_item (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    do\n        -- We should be using `area.item (i - 1).to_character_32'\n        -- but some descendants of STRING that have their content encoded\n        -- in UTF-8 for example relies on `code' to get the corresponding\n        -- CHARACTER_32 by reading more than one byte. Once they have\n        -- been updated to use `character_32_item' we can revert the code\n        -- back to using `area' directly.\n      Result := code (i).to_character_32\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Numeric code of character at position `i'.\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n      -- Use `code' instead for consistency with Unicode handling.\n      --| Not obsolete because old code using just ASCII is safe.\n    do\n      Result := area.item (i - 1).code\n    end\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters.\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_8; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_8\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_8)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    local\n      l_first_pos, l_next_pos: INTEGER\n      l_orig_count, l_new_count, l_new_lower, l_count, i, l_index_count: INTEGER\n      l_src_index, l_dest_index, l_prev_index, l_copy_delta: INTEGER\n      l_area, l_new_area: like area\n      l_offset: INTEGER\n      l_string_searcher: like string_searcher\n      l_index_list: SPECIAL [INTEGER]\n    do\n      if not is_empty then\n        l_count := count\n        l_string_searcher := string_searcher\n        l_string_searcher.initialize_deltas (original)\n        l_orig_count := original.count\n        l_new_count := new.count\n        if l_orig_count >= l_new_count then\n          l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, 1, l_count)\n          if l_first_pos > 0 then\n            if l_orig_count = l_new_count then\n                -- String will not be resized, simply perform character substitution\n              from\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_first_pos = 0\n              loop\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1, l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_new_count, l_count)\n                else\n                  l_first_pos := 0\n                end\n              end\n            elseif l_orig_count > l_new_count then\n                -- New string is smaller than previous string, we can optimize\n                -- substitution by only moving block between two occurrences of `orginal'.\n              from\n                l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_next_pos = 0\n              loop\n                  -- Copy new string into Current\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                  -- Shift characters between `l_first_pos' and `l_next_pos'\n                l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                  l_first_pos + l_new_count - 1 - l_offset, l_next_pos - l_first_pos - l_orig_count)\n                l_first_pos := l_next_pos\n                l_offset := l_offset + (l_orig_count - l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                else\n                  l_next_pos := 0\n                end\n              end\n                -- Perform final substitution:\n                -- Copy new string into Current\n              l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                -- Shift characters between `l_first_pos' and the end of the string\n              l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                l_first_pos + l_new_count - 1 - l_offset, l_count + 1 - l_first_pos - l_orig_count)\n                  -- Perform last substitution\n              l_offset := l_offset + (l_orig_count - l_new_count)\n\n                -- Update `count'\n              set_count (l_count - l_offset)\n            end\n              -- String was modified we need to recompute the `hash_code'.\n            internal_hash_code := 0\n          end\n        elseif attached l_string_searcher.substring_index_list_with_deltas (Current, original, 1, l_count) as l_list then\n            -- Get the number of substitution to be performed by getting a list\n            -- of location where `original' appears.\n          l_index_list := l_list.area\n          l_index_count := l_index_list.count\n            -- Store the index of the last character up to which we need to move\n            -- characters in the reallocated string.\n          l_prev_index := l_count\n            -- Resize Current with the appropriate number of characters\n          l_copy_delta := l_new_count - l_orig_count\n          l_count := l_count + (l_index_count * l_copy_delta)\n          l_area := area.resized_area_with_default ('%U', l_count + 1)\n          area := l_area\n            -- Perform the substitution starting from the end.\n          from\n            i := l_index_count\n            l_new_lower := new.area_lower\n            l_new_area := new.area\n          until\n            i = 0\n          loop\n            i := i - 1\n            l_src_index := l_index_list.item (i)\n            l_dest_index := l_src_index + i * l_copy_delta\n              -- Shift non-matching characters to the right of the newly replaced string.\n            l_area.overlapping_move (l_src_index + l_orig_count - 1, l_dest_index + l_new_count - 1, l_prev_index - l_src_index - l_orig_count + 1)\n              -- Store new end of string where characters will be moved.\n            l_prev_index := l_src_index - 1\n\n              -- Copy `new' to its appropriate position\n            l_area.copy_data (l_new_area, l_new_lower, l_dest_index - 1, l_new_count)\n          end\n            -- Update the new `count' which also resets the `hash_code'.\n          set_count (l_count)\n        end\n      end\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_area.item (nb_space).is_space\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0 or else not l_area.item (i).is_space\n      loop\n        nb_space := nb_space + 1\n        i := i - 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_8)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_8; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_8, i - 1)\n      internal_hash_code := 0\n    end\n\n  precede, prepend_character (c: CHARACTER_8)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        prepend (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  prepend (s: READABLE_STRING_8)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_8)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        append (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_8)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_8)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_8)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append (b.out)\n    end\n\n  insert (s: READABLE_STRING_8; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_8; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_8; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_8)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_8)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_8\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_8)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_8)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_area.item (left_nb_space).is_space\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_area.item (i).is_space\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_8; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_8]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_8]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n      -- Nothing to be done because we only added `internal_hash_code' that will\n      -- be recomputed next time we query `hash_code'.\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: SPECIAL [CHARACTER_8]\n      -- Empty `area' to avoid useless creation of empty areas when wiping out a STRING.\n    obsolete\n      \"Simply create `area' directly.\"\n    do\n      create Result.make_empty (1)\n      Result.extend ('%U')\n    ensure\n      empty_area_not_void: Result /= Void\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 07:36:10 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94633 $\"\n\ndeferred class\n  STRING_GENERAL\n\ninherit\n  READABLE_STRING_GENERAL\n    export\n      {ANY} copy, standard_copy, deep_copy\n    end\n\nconvert\n  as_string_32: {READABLE_STRING_32, STRING_32},\n  to_cil: {SYSTEM_STRING}\n\nfeature -- Settings\n\n  put_code (v: like code; i: INTEGER)\n      -- Put code `v' at position `i'.\n    require\n      valid_code: valid_code (v)\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      inserted: code (i) = v\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\nfeature {STRING_HANDLER} -- Settings\n\n  set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    require\n      valid_count: 0 <= number and number <= capacity\n    deferred\n    ensure\n      new_count: count = number\n    end\n\n  set_internal_hash_code (v: like internal_hash_code)\n      -- Set `internal_hash_code' with `v'.\n    require\n      v_nonnegative: v >= 0\n    do\n      internal_hash_code := v\n    ensure\n      internal_hash_code_set: internal_hash_code = v\n    end\n\nfeature -- Element change\n\n  append_code (c: like code)\n      -- Append `c' at end.\n    require\n      valid_code: valid_code (c)\n    local\n      current_count: INTEGER\n    do\n      current_count := count + 1\n      if current_count > capacity then\n        resize (current_count)\n      end\n      set_count (current_count)\n      put_code (c, current_count)\n    ensure then\n      item_inserted: code (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (to_string_32 + s))\n    end\n\n  append_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := start_index\n        until\n          i > end_index\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      appended: elks_checking implies same_string (old (to_string_32 + s.substring (start_index, end_index)))\n    end\n\n  prepend (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          put_code (s.code (i), i)\n          i := i + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s.to_string_32 + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i, j: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := start_index\n          j := 1\n        until\n          i > end_index\n        loop\n          put_code (s.code (i), j)\n          i := i + 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index).to_string_32 + Current))\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (1, n.min (count)))\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (count - n.min(count) + 1, count))\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (1).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (old count - count + 1, old count))\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (count).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (1, count))\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\n  adjust\n      -- Remove leading and/or trailing whitespace.\n    do\n      left_adjust\n      right_adjust\n    ensure\n      valid_count: count <= old count\n      new_count_left: not is_empty implies not item (1).is_space\n      new_count_right: not is_empty implies not item (count).is_space\n      kept: elks_checking implies (old twin).has_substring (Current)\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    require\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      new_count: count = old count - 1\n      removed: elks_checking implies\n        to_string_32 ~ (old substring (1, i - 1).to_string_32 + old substring (i + 1, count).to_string_32)\n    end\n\nfeature -- Resizing\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    require\n      new_size_large_enough: newsize >= count\n    deferred\n    ensure\n      same_count: count = old count\n      capacity_large_enough: capacity >= newsize\n      same_content: elks_checking implies same_string (old twin)\n    end\n\ninvariant\n  mutable: not is_immutable\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_handler.e","content":"note\n  description: \"Objects that can access `set_count' from STRING\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  STRING_HANDLER\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"system_string.e","content":"note\n  description: \"Fake abstraction of a .NET SYSTEM_STRING in a non-.NET system\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  SYSTEM_STRING\n\nfeature -- Access\n\n  length: INTEGER do end\n\ninvariant\n  is_dotnet: {PLATFORM}.is_dotnet\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"table.e","content":"note\n  description: \"Containers whose items are accessible through keys\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: table, access;\n  access: key, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class TABLE [G, H] inherit\n\n  BAG [G]\n    rename\n      put as bag_put\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (k: H): G assign force\n      -- Entry of key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\nfeature -- Status report\n\n  valid_key (k: H): BOOLEAN\n      -- Is `k' a valid key?\n    deferred\n    end\n\nfeature -- Element change\n\n  put (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\n  force (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    ensure\n      inserted: item (k) = v\n    end\n\nfeature {NONE} -- Inapplicable\n\n  bag_put (v: G)\n    do\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"to_special.e","content":"note\n  description: \"References to special objects, for direct access to arrays and strings\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass TO_SPECIAL [T]\n\ncreate\n  make_empty_area,\n  make_filled_area\n\nfeature -- Access\n\n  area: SPECIAL [T]\n      -- Special data zone\n\nfeature {NONE} -- Initialization\n\n  make_empty_area (n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_empty (n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = 0\n    end\n\n  make_filled_area (a_default_value: T; n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_filled (a_default_value, n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = n\n      area_filled: area.filled_with (a_default_value, 0, n - 1)\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): T assign put\n      -- Entry at index `i', if in index interval\n    require\n      valid_index: valid_index (i)\n    do\n      Result := area.item (i)\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := area.valid_index (i)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_index: valid_index (i)\n    do\n      area.put (v, i)\n    ensure\n      inserted: item (i) = v\n    end\n\nfeature {NONE} -- Element change\n\n  set_area (other: like area)\n      -- Make `other' the new `area'\n    do\n      area := other\n    ensure\n      area_set: area = other\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"traversable.e","content":"note\n  description: \"[\n    Structures for which there exists a traversal policy\n    that will visit every element exactly once.\n    ]\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: traversable, traversing;\n  access: cursor;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class\n  TRAVERSABLE [G]\n\ninherit\n\n  CONTAINER [G]\n\nfeature -- Access\n\n  item: G\n      -- Item at current position\n    require\n      not_off: not off\n    deferred\n    end\n\nfeature -- Status report\n\n  off: BOOLEAN\n      -- Is there no current item?\n    deferred\n    end\n\nfeature -- Cursor movement\n\n  start\n      -- Move to first position if any.\n    deferred\n    end\n\nfeature -- Iteration\n\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_exists: action /= Void\n    do\n      linear_representation.do_all (action)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]];\n   test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test'.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_exists: action /= Void\n      test_exists: test /= Void\n      -- test.is_pure\n    do\n      linear_representation.do_if (action, test)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_exists: test /= Void\n      -- test.is_pure\n    do\n      Result := linear_representation.there_exists (test)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_exists: test /= Void\n      -- test.is_pure\n    do\n      Result := linear_representation.for_all (test)\n    end\n\ninvariant\n\n  empty_constraint: is_empty implies off\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"tuple.e","content":"note\n  description: \"Implementation of TUPLE\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-01-01 04:33:47 -0800 (Wed, 01 Jan 2014) $\"\n  revision: \"$Revision: 93865 $\"\n\nclass\n  TUPLE\n\ninherit\n  HASHABLE\n    redefine\n      is_equal\n    end\n\n  MISMATCH_CORRECTOR\n    redefine\n      correct_mismatch, is_equal\n    end\n\n  READABLE_INDEXABLE [detachable separate ANY]\n    redefine\n      is_equal\n    end\n\ncreate\n  default_create\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (index: INTEGER): detachable separate ANY assign put\n      -- Entry of key `index'.\n    do\n      inspect eif_item_type ($Current, index)\n      when boolean_code then Result := eif_boolean_item ($Current, index)\n      when character_8_code then Result := eif_character_8_item ($Current, index)\n      when character_32_code then Result := eif_character_32_item ($Current, index)\n      when real_64_code then Result := eif_real_64_item ($Current, index)\n      when real_32_code then Result := eif_real_32_item ($Current, index)\n      when pointer_code then Result := eif_pointer_item ($Current, index)\n      when natural_8_code then Result := eif_natural_8_item ($Current, index)\n      when natural_16_code then Result := eif_natural_16_item ($Current, index)\n      when natural_32_code then Result := eif_natural_32_item ($Current, index)\n      when natural_64_code then Result := eif_natural_64_item ($Current, index)\n      when integer_8_code then Result := eif_integer_8_item ($Current, index)\n      when integer_16_code then Result := eif_integer_16_item ($Current, index)\n      when integer_32_code then Result := eif_integer_32_item ($Current, index)\n      when integer_64_code then Result := eif_integer_64_item ($Current, index)\n      when Reference_code then Result := eif_reference_item ($Current, index)\n      end\n    end\n\n  reference_item (index: INTEGER): detachable separate ANY\n      -- Reference item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_reference: is_reference_item (index)\n    do\n      Result := eif_reference_item ($Current, index)\n    end\n\n  boolean_item (index: INTEGER): BOOLEAN\n      -- Boolean item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_boolean: is_boolean_item (index)\n    do\n      Result := eif_boolean_item ($Current, index)\n    end\n\n  character_8_item, character_item (index: INTEGER): CHARACTER_8\n      -- Character item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_character_8: is_character_8_item (index)\n    do\n      Result := eif_character_8_item ($Current, index)\n    end\n\n  character_32_item, wide_character_item (index: INTEGER): CHARACTER_32\n      -- Character item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_character_32: is_character_32_item (index)\n    do\n      Result := eif_character_32_item ($Current, index)\n    end\n\n  real_64_item, double_item (index: INTEGER): REAL_64\n      -- Double item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_numeric: is_double_item (index)\n    do\n      Result := eif_real_64_item ($Current, index)\n    end\n\n  natural_8_item (index: INTEGER): NATURAL_8\n      -- NATURAL_8 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_8_item (index)\n    do\n      Result := eif_natural_8_item ($Current, index)\n    end\n\n  natural_16_item (index: INTEGER): NATURAL_16\n      -- NATURAL_16 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_16_item (index)\n    do\n      Result := eif_natural_16_item ($Current, index)\n    end\n\n  natural_32_item (index: INTEGER): NATURAL_32\n      -- NATURAL_32 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_32_item (index)\n    do\n      Result := eif_natural_32_item ($Current, index)\n    end\n\n  natural_64_item (index: INTEGER): NATURAL_64\n      -- NATURAL_64 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_natural_64_item (index)\n    do\n      Result := eif_natural_64_item ($Current, index)\n    end\n\n  integer_8_item (index: INTEGER): INTEGER_8\n      -- INTEGER_8 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_8_item (index)\n    do\n      Result := eif_integer_8_item ($Current, index)\n    end\n\n  integer_16_item (index: INTEGER): INTEGER_16\n      -- INTEGER_16 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_16_item (index)\n    do\n      Result := eif_integer_16_item ($Current, index)\n    end\n\n  integer_item, integer_32_item (index: INTEGER): INTEGER_32\n      -- INTEGER_32 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_32_item (index)\n    do\n      Result := eif_integer_32_item ($Current, index)\n    end\n\n  integer_64_item (index: INTEGER): INTEGER_64\n      -- INTEGER_64 item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_integer: is_integer_64_item (index)\n    do\n      Result := eif_integer_64_item ($Current, index)\n    end\n\n  pointer_item (index: INTEGER): POINTER\n      -- Pointer item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_pointer: is_pointer_item (index)\n    do\n      Result := eif_pointer_item ($Current, index)\n    end\n\n  real_32_item, real_item (index: INTEGER): REAL_32\n      -- real item at `index'.\n    require\n      valid_index: valid_index (index)\n      is_real_or_integer: is_real_item (index)\n    do\n      Result := eif_real_32_item ($Current, index)\n    end\nfeature -- Comparison\n\n  object_comparison: BOOLEAN\n      -- Must search operations use `equal' rather than `='\n      -- for comparing references? (Default: no, use `='.)\n    do\n      Result := eif_boolean_item ($Current, 0)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    local\n      i, nb: INTEGER\n      l_object_compare: BOOLEAN\n    do\n      l_object_compare := object_comparison\n      if l_object_compare = other.object_comparison then\n        if l_object_compare then\n          nb := count\n          if nb = other.count then\n            from\n              Result := True\n              i := 1\n            until\n              i > nb or not Result\n            loop\n              Result := item (i) ~ other.item (i)\n              i := i + 1\n            end\n          end\n        else\n          Result := Precursor {HASHABLE} (other)\n        end\n      end\n    end\n\nfeature -- Status setting\n\n  compare_objects\n      -- Ensure that future search operations will use `equal'\n      -- rather than `=' for comparing references.\n    do\n      eif_put_boolean_item ($Current, 0, True)\n    ensure\n      object_comparison: object_comparison\n    end\n\n  compare_references\n      -- Ensure that future search operations will use `='\n      -- rather than `equal' for comparing references.\n    do\n      eif_put_boolean_item ($Current, 0, False)\n    ensure\n      reference_comparison: not object_comparison\n    end\n\nfeature -- Status report\n\n  hash_code: INTEGER\n      -- Hash code value\n    local\n      i, nb, l_hash: INTEGER\n    do\n      from\n        i := 1\n        nb := count\n      until\n        i > nb\n      loop\n        inspect eif_item_type($Current, i)\n        when boolean_code then l_hash := eif_boolean_item ($Current, i).hash_code\n        when character_8_code then l_hash := eif_character_8_item ($Current, i).hash_code\n        when character_32_code then l_hash := eif_character_32_item ($Current, i).hash_code\n        when real_64_code then l_hash := eif_real_64_item ($Current, i).hash_code\n        when real_32_code then l_hash := eif_real_32_item ($Current, i).hash_code\n        when pointer_code then l_hash := eif_pointer_item ($Current, i).hash_code\n        when natural_8_code then l_hash := eif_natural_8_item ($Current, i).hash_code\n        when natural_16_code then l_hash := eif_natural_16_item ($Current, i).hash_code\n        when natural_32_code then l_hash := eif_natural_32_item ($Current, i).hash_code\n        when natural_64_code then l_hash := eif_natural_64_item ($Current, i).hash_code\n        when integer_8_code then l_hash := eif_integer_8_item ($Current, i).hash_code\n        when integer_16_code then l_hash := eif_integer_16_item ($Current, i).hash_code\n        when integer_32_code then l_hash := eif_integer_32_item ($Current, i).hash_code\n        when integer_64_code then l_hash := eif_integer_64_item ($Current, i).hash_code\n        when reference_code then\n          if attached {HASHABLE} eif_reference_item ($Current, i) as l_key then\n            l_hash := l_key.hash_code\n          else\n            l_hash := 0\n          end\n        end\n        Result := Result + l_hash * internal_primes.i_th (i)\n        i := i + 1\n      end\n        -- Ensure it is a positive value.\n      Result := Result.hash_code\n    end\n\n  valid_index (k: INTEGER): BOOLEAN\n      -- Is `k' a valid key?\n    do\n      Result := k >= 1 and then k <= count\n    end\n\n  valid_type_for_index (v: detachable separate ANY; index: INTEGER): BOOLEAN\n      -- Is object `v' a valid target for element at position `index'?\n    require\n      valid_index: valid_index (index)\n    local\n      l_reflector: REFLECTOR\n    do\n      if v = Void then\n          -- A Void entry is valid only for references and as long as the expected type\n          -- is detachable.\n        if eif_item_type ($Current, index) = reference_code then\n          Result := not generating_type.generic_parameter_type (index).is_attached\n        end\n      else\n        inspect eif_item_type ($Current, index)\n        when boolean_code then Result := attached {BOOLEAN_REF} v as l_b\n        when character_8_code then Result := attached {CHARACTER_8_REF} v as l_c\n        when character_32_code then Result := attached {CHARACTER_32_REF} v as l_wc\n        when real_64_code then Result := attached {REAL_64_REF} v as l_d\n        when real_32_code then Result := attached {REAL_32_REF} v as l_r\n        when pointer_code then Result := attached {POINTER_REF} v as l_p\n        when natural_8_code then Result := attached {NATURAL_8_REF} v as l_ui8\n        when natural_16_code then Result := attached {NATURAL_16_REF} v as l_ui16\n        when natural_32_code then Result := attached {NATURAL_32_REF} v as l_ui32\n        when natural_64_code then Result := attached {NATURAL_64_REF} v as l_ui64\n        when integer_8_code then Result := attached {INTEGER_8_REF} v as l_i8\n        when integer_16_code then Result := attached {INTEGER_16_REF} v as l_i16\n        when integer_32_code then Result := attached {INTEGER_32_REF} v as l_i32\n        when integer_64_code then Result := attached {INTEGER_64_REF} v as l_i64\n        when Reference_code then\n            -- Let's check that type of `v' conforms to specified type of `index'-th\n            -- arguments of current TUPLE.\n          create l_reflector\n          Result := l_reflector.field_conforms_to (v.generating_type.type_id, generating_type.generic_parameter_type (index).type_id)\n        end\n      end\n    end\n\n  count: INTEGER\n      -- Number of element in Current.\n    external\n      \"built_in\"\n    end\n\n  lower: INTEGER = 1\n      -- Lower bound of TUPLE.\n\n  upper: INTEGER\n      -- Upper bound of TUPLE.\n    do\n      Result := count\n    end\n\n  is_empty: BOOLEAN\n      -- Is Current empty?\n    do\n      Result := count = 0\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    end\n\nfeature -- Element change\n\n  put (v: detachable separate ANY; index: INTEGER)\n      -- Insert `v' at position `index'.\n    require\n      valid_index: valid_index (index)\n      valid_type_for_index: valid_type_for_index (v, index)\n    do\n      inspect eif_item_type ($Current, index)\n      when boolean_code then eif_put_boolean_item_with_object ($Current, index, $v)\n      when character_8_code then eif_put_character_8_item_with_object ($Current, index, $v)\n      when character_32_code then eif_put_character_32_item_with_object ($Current, index, $v)\n      when real_64_code then eif_put_real_64_item_with_object ($Current, index, $v)\n      when real_32_code then eif_put_real_32_item_with_object ($Current, index, $v)\n      when pointer_code then eif_put_pointer_item_with_object ($Current, index, $v)\n      when natural_8_code then eif_put_natural_8_item_with_object ($Current, index, $v)\n      when natural_16_code then eif_put_natural_16_item_with_object ($Current, index, $v)\n      when natural_32_code then eif_put_natural_32_item_with_object ($Current, index, $v)\n      when natural_64_code then eif_put_natural_64_item_with_object ($Current, index, $v)\n      when integer_8_code then eif_put_integer_8_item_with_object ($Current, index, $v)\n      when integer_16_code then eif_put_integer_16_item_with_object ($Current, index, $v)\n      when integer_32_code then eif_put_integer_32_item_with_object ($Current, index, $v)\n      when integer_64_code then eif_put_integer_64_item_with_object ($Current, index, $v)\n      when Reference_code then eif_put_reference_item_with_object ($Current, index, $v)\n      end\n    end\n\n  put_reference (v: detachable separate ANY; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type_for_index: valid_type_for_index (v, index)\n      valid_type: is_reference_item (index)\n    do\n      eif_put_reference_item_with_object ($Current, index, $v)\n    end\n\n  put_boolean (v: BOOLEAN; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_boolean_item (index)\n    do\n      eif_put_boolean_item ($Current, index, v)\n    end\n\n  put_character_8, put_character (v: CHARACTER_8; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_character_8_item (index)\n    do\n      eif_put_character_8_item ($Current, index, v)\n    end\n\n  put_character_32, put_wide_character (v: CHARACTER_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_character_32_item (index)\n    do\n      eif_put_character_32_item ($Current, index, v)\n    end\n\n  put_real_64, put_double (v: REAL_64; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_double_item (index)\n    do\n      eif_put_real_64_item ($Current, index, v)\n    end\n\n  put_real_32, put_real (v: REAL_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_real_item (index)\n    do\n      eif_put_real_32_item ($Current, index, v)\n    end\n\n  put_pointer (v: POINTER; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_pointer_item (index)\n    do\n      eif_put_pointer_item ($Current, index, v)\n    end\n\n  put_natural_8 (v: NATURAL_8; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_8_item (index)\n    do\n      eif_put_natural_8_item ($Current, index, v)\n    end\n\n  put_natural_16 (v: NATURAL_16; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_16_item (index)\n    do\n      eif_put_natural_16_item ($Current, index, v)\n    end\n\n  put_natural_32 (v: NATURAL_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_32_item (index)\n    do\n      eif_put_natural_32_item ($Current, index, v)\n    end\n\n  put_natural_64 (v: NATURAL_64; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_natural_64_item (index)\n    do\n      eif_put_natural_64_item ($Current, index, v)\n    end\n\n  put_integer, put_integer_32 (v: INTEGER_32; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_32_item (index)\n    do\n      eif_put_integer_32_item ($Current, index, v)\n    end\n\n  put_integer_8 (v: INTEGER_8; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_8_item (index)\n    do\n      eif_put_integer_8_item ($Current, index, v)\n    end\n\n  put_integer_16 (v: INTEGER_16; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_16_item (index)\n    do\n      eif_put_integer_16_item ($Current, index, v)\n    end\n\n  put_integer_64 (v: INTEGER_64; index: INTEGER)\n      -- Put `v' at position `index' in Current.\n    require\n      valid_index: valid_index (index)\n      valid_type: is_integer_64_item (index)\n    do\n      eif_put_integer_64_item ($Current, index, v)\n    end\n\nfeature -- Type queries\n\n  is_boolean_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a BOOLEAN?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = boolean_code)\n    end\n\n  is_character_8_item, is_character_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a CHARACTER_8?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = character_8_code)\n    end\n\n  is_character_32_item, is_wide_character_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a CHARACTER_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = character_32_code)\n    end\n\n  is_double_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a REAL_64?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = real_64_code)\n    end\n\n  is_natural_8_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_8?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_8_code)\n    end\n\n  is_natural_16_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_16?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_16_code)\n    end\n\n  is_natural_32_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_32_code)\n    end\n\n  is_natural_64_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an NATURAL_64?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = natural_64_code)\n    end\n\n  is_integer_8_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_8?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_8_code)\n    end\n\n  is_integer_16_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_16?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_16_code)\n    end\n\n  is_integer_item, is_integer_32_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_32_code)\n    end\n\n  is_integer_64_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' an INTEGER_64?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = integer_64_code)\n    end\n\n  is_pointer_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a POINTER?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = pointer_code)\n    end\n\n  is_real_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a REAL_32?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = real_32_code)\n    end\n\n  is_reference_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a REFERENCE?\n    require\n      valid_index: valid_index (index)\n    do\n      Result := (eif_item_type ($Current, index) = reference_code)\n    end\n\n  is_numeric_item (index: INTEGER): BOOLEAN\n      -- Is item at `index' a number?\n    obsolete\n      \"Use the precise type query instead.\"\n    require\n      valid_index: valid_index (index)\n    local\n      tcode: like item_code\n    do\n      tcode := eif_item_type ($Current, index)\n      inspect tcode\n      when\n        integer_8_code, integer_16_code, integer_32_code,\n        integer_64_code, real_32_code, real_64_code\n      then\n        Result := True\n      else\n        -- Nothing to do here since Result already initialized to False.\n      end\n    end\n\n  is_uniform: BOOLEAN\n      -- Are all items of the same basic type or all of reference type?\n    do\n      Result := is_tuple_uniform (any_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_boolean: BOOLEAN\n      -- Are all items of type BOOLEAN?\n    do\n      Result := is_tuple_uniform (boolean_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_character_8, is_uniform_character: BOOLEAN\n      -- Are all items of type CHARACTER_8?\n    do\n      Result := is_tuple_uniform (character_8_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_character_32, is_uniform_wide_character: BOOLEAN\n      -- Are all items of type CHARACTER_32?\n    do\n      Result := is_tuple_uniform (character_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_double: BOOLEAN\n      -- Are all items of type REAL_64?\n    do\n      Result := is_tuple_uniform (real_64_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_8: BOOLEAN\n      -- Are all items of type NATURAL_8?\n    do\n      Result := is_tuple_uniform (natural_8_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_16: BOOLEAN\n      -- Are all items of type NATURAL_16?\n    do\n      Result := is_tuple_uniform (natural_16_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_32: BOOLEAN\n      -- Are all items of type NATURAL_32?\n    do\n      Result := is_tuple_uniform (natural_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_natural_64: BOOLEAN\n      -- Are all items of type NATURAL_64?\n    do\n      Result := is_tuple_uniform (natural_64_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer_8: BOOLEAN\n      -- Are all items of type INTEGER_8?\n    do\n      Result := is_tuple_uniform (integer_8_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer_16: BOOLEAN\n      -- Are all items of type INTEGER_16?\n    do\n      Result := is_tuple_uniform (integer_16_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer, is_uniform_integer_32: BOOLEAN\n      -- Are all items of type INTEGER?\n    do\n      Result := is_tuple_uniform (integer_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_integer_64: BOOLEAN\n      -- Are all items of type INTEGER_64?\n    do\n      Result := is_tuple_uniform (integer_64_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_pointer: BOOLEAN\n      -- Are all items of type POINTER?\n    do\n      Result := is_tuple_uniform (pointer_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_real: BOOLEAN\n      -- Are all items of type REAL_32?\n    do\n      Result := is_tuple_uniform (real_32_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  is_uniform_reference: BOOLEAN\n      -- Are all items of reference type?\n    do\n      Result := is_tuple_uniform (reference_code)\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\nfeature -- Access\n\n  plus alias \"+\" (a_other: TUPLE): detachable like Current\n      -- Concatenation of `Current' with `a_other'\n      --| note: it may be Void if the result exceeds the allowed capacity for a tuple.\n      --| warning: this function has poor performance, use it with parsimony.\n    local\n      l_reflector: REFLECTOR\n      i, n1,n2: INTEGER\n      t1, t2: TYPE [detachable TUPLE]\n      l_type_id: INTEGER\n      l_items: SPECIAL [detachable separate ANY]\n      l_type_string: STRING\n    do\n      n1 := count\n      n2 := a_other.count\n\n      if n1 = 0 then\n        Result := a_other.twin\n      elseif n2 = 0 then\n        Result := twin\n      else\n        create l_type_string.make_from_string (\"TUPLE [\")\n\n        create l_items.make_empty (n1 + n2)\n        from\n          t1 := generating_type\n          check same_count: t1.generic_parameter_count = n1 end\n          i := 1\n        until\n          i > n1\n        loop\n          if i > 1 then\n            l_type_string.append_character (',')\n          end\n          l_type_string.append (t1.generic_parameter_type (i).name)\n          l_items.force (item (i), i - 1)\n          i := i + 1\n        end\n        from\n          t2 := a_other.generating_type\n          check same_count: t2.generic_parameter_count = n2 end\n        until\n          i > n1 + n2\n        loop\n          l_type_string.append_character (',')\n          l_type_string.append (t2.generic_parameter_type (i - n1).name)\n          l_items.force (a_other.item (i - n1), i - 1)\n          i := i + 1\n        end\n\n        l_type_string.append_character (']')\n        create l_reflector\n        l_type_id := l_reflector.dynamic_type_from_string (l_type_string)\n        if l_type_id >= 0 then\n          if attached {like plus} l_reflector.new_tuple_from_special (l_type_id, l_items) as res then\n            Result := res\n          end\n        else\n            --| It may be that the maximum tuple capacity was reached.\n            --| better return Void than a truncated tuple.\n        end\n      end\n    ensure\n      has_expected_count: Result /= Void implies Result.count = count + a_other.count\n      has_expected_items: Result /= Void implies (\n            (across 1 |..| count as ic_1 all Result[ic_1.item] = item (ic_1.item) end) and\n            (across 1 |..| a_other.count as ic_2 all Result[count + ic_2.item] = a_other [ic_2.item] end)\n          )\n    end\n\nfeature -- Type conversion queries\n\n  convertible_to_double: BOOLEAN\n      -- Is current convertible to an array of doubles?\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n      tcode: like item_code\n    do\n      Result := True\n      from\n        i := 1\n        cnt := count\n      until\n        i > cnt or else not Result\n      loop\n        tcode := eif_item_type ($Current, i)\n        inspect tcode\n        when\n          integer_8_code, integer_16_code, integer_32_code,\n          integer_64_code, real_32_code, real_64_code\n        then\n          Result := True\n        else\n          Result := False\n        end\n        i := i + 1\n      end\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\n  convertible_to_real: BOOLEAN\n      -- Is current convertible to an array of reals?\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n      tcode: like item_code\n    do\n      Result := True\n      from\n        i := 1\n        cnt := count\n      until\n        i > cnt or else not Result\n      loop\n        tcode := eif_item_type ($Current, i)\n        inspect tcode\n        when\n          integer_8_code, integer_16_code, integer_32_code,\n          integer_64_code, real_32_code\n        then\n          Result := True\n        else\n          Result := False\n        end\n        i := i + 1\n      end\n    ensure\n      yes_if_empty: (count = 0) implies Result\n    end\n\nfeature -- Conversion\n\n  arrayed: ARRAY [detachable separate ANY]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (Void, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  boolean_arrayed: ARRAY [BOOLEAN]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_boolean: is_uniform_boolean\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (False, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (boolean_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  character_8_arrayed, character_arrayed: ARRAY [CHARACTER_8]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_character: is_uniform_character\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (' ', 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (character_8_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  double_arrayed: ARRAY [REAL_64]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      convertible: convertible_to_double\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled ({REAL_64} 0.0, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (double_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  integer_arrayed: ARRAY [INTEGER]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_integer: is_uniform_integer\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled ({INTEGER} 0, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (integer_32_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  pointer_arrayed: ARRAY [POINTER]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      is_uniform_pointer: is_uniform_pointer\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (Default_pointer, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (pointer_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  real_arrayed: ARRAY [REAL_32]\n      -- Items of Current as array\n    obsolete\n      \"Will be removed in future releases\"\n    require\n      convertible: convertible_to_real\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled ({REAL_32} 0.0, 1, cnt)\n      until\n        i > cnt\n      loop\n        Result.put (real_item (i), i)\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n      same_items: -- Items are the same in same order\n    end\n\n  string_arrayed: ARRAY [detachable STRING]\n      -- Items of Current as array\n      -- NOTE: Items with a type not cconforming to\n      --       type STRING are set to Void.\n    obsolete\n      \"Will be removed in future releases\"\n    local\n      i, cnt: INTEGER\n    do\n      from\n        i := 1\n        cnt := count\n        create Result.make_filled (Void, 1, cnt)\n      until\n        i > cnt\n      loop\n        if attached {STRING} item (i) as s then\n          Result.put (s, i)\n        end\n        i := i + 1\n      end\n    ensure\n      exists: Result /= Void\n      same_count: Result.count = count\n    end\n\nfeature -- Retrieval\n\n  correct_mismatch\n      -- Attempt to correct object mismatch using `mismatch_information'.\n    local\n      i, nb: INTEGER\n      l_any: ANY\n    do\n        -- Old version of TUPLE had a SPECIAL [ANY] to store all values.\n        -- If we can get access to it, then most likely we can recover this\n        -- old TUPLE implementation.\n      if attached {SPECIAL [ANY]} Mismatch_information.item (area_name) as l_area then\n        from\n          i := 1\n          nb := l_area.count\n        until\n          i > nb\n        loop\n          l_any := l_area.item (i - 1)\n          if valid_type_for_index (l_any, i) then\n            put (l_any, i)\n          else\n              -- We found an unexpected type in old special. We cannot go on.\n            Precursor {MISMATCH_CORRECTOR}\n          end\n          i := i + 1\n        end\n      else\n        Precursor {MISMATCH_CORRECTOR}\n      end\n    end\n\nfeature -- Access\n\n  item_code (index: INTEGER): NATURAL_8\n      -- Type code of item at `index'. Used for\n      -- argument processing in ROUTINE\n    require\n      valid_index: valid_index (index)\n    do\n      Result := eif_item_type ($Current, index)\n    end\n\n  reference_code: NATURAL_8 = 0x00\n  boolean_code: NATURAL_8 = 0x01\n  character_8_code, character_code: NATURAL_8 = 0x02\n  real_64_code: NATURAL_8 = 0x03\n  real_32_code: NATURAL_8 = 0x04\n  pointer_code: NATURAL_8 = 0x05\n  integer_8_code: NATURAL_8 = 0x06\n  integer_16_code: NATURAL_8 = 0x07\n  integer_32_code: NATURAL_8 = 0x08\n  integer_64_code: NATURAL_8 = 0x09\n  natural_8_code: NATURAL_8 = 0x0A\n  natural_16_code: NATURAL_8 = 0x0B\n  natural_32_code: NATURAL_8 = 0x0C\n  natural_64_code: NATURAL_8 = 0x0D\n  character_32_code, wide_character_code: NATURAL_8 = 0x0E\n  any_code: NATURAL_8 = 0xFF\n      -- Code used to identify type in TUPLE.\n\nfeature {NONE} -- Implementation\n\n  area_name: STRING = \"area\"\n      -- Name of attributes where TUPLE elements were stored.\n\n  is_tuple_uniform (code: like item_code): BOOLEAN\n      -- Are all items of type `code'?\n    local\n      i, nb: INTEGER\n      l_code: like item_code\n    do\n      Result := True\n      if count > 0 then\n        from\n          nb := count\n          if code = any_code then\n              -- We take first type code and compare all the remaining ones\n              -- against it.\n            i := 2\n            l_code := eif_item_type ($Current, 1)\n          else\n            i := 1\n            l_code := code\n          end\n        until\n          i > nb or not Result\n        loop\n          Result := l_code = eif_item_type ($Current, i)\n          i := i + 1\n        end\n      end\n    end\n\n  internal_primes: PRIMES\n      -- For quick access to prime numbers.\n    once\n      create Result\n    end\n\nfeature {NONE} -- Externals: Access\n\n  eif_item_type (obj: POINTER; pos: INTEGER): NATURAL_8\n      -- Code for generic parameter `pos' in `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    alias\n      \"eif_item_type\"\n    end\n\n  eif_boolean_item (obj: POINTER; pos: INTEGER): BOOLEAN\n      -- Boolean item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_character_8_item (obj: POINTER; pos: INTEGER): CHARACTER_8\n      -- Character item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_character_32_item (obj: POINTER; pos: INTEGER): CHARACTER_32\n      -- Wide character item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_real_64_item (obj: POINTER; pos: INTEGER): REAL_64\n      -- Double item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_real_32_item (obj: POINTER; pos: INTEGER): REAL_32\n      -- Real item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_pointer_item (obj: POINTER; pos: INTEGER): POINTER\n      -- Pointer item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_8_item (obj: POINTER; pos: INTEGER): NATURAL_8\n      -- NATURAL_8 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_16_item (obj: POINTER; pos: INTEGER):  NATURAL_16\n      -- NATURAL_16 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_32_item (obj: POINTER; pos: INTEGER):  NATURAL_32\n      -- NATURAL_32 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_natural_64_item (obj: POINTER; pos: INTEGER):  NATURAL_64\n      -- NATURAL_64 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_8_item (obj: POINTER; pos: INTEGER): INTEGER_8\n      -- INTEGER_8 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_16_item (obj: POINTER; pos: INTEGER): INTEGER_16\n      -- INTEGER_16 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_32_item (obj: POINTER; pos: INTEGER): INTEGER_32\n      -- INTEGER_32 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_integer_64_item (obj: POINTER; pos: INTEGER): INTEGER_64\n      -- INTEGER_64 item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_reference_item (obj: POINTER; pos: INTEGER): detachable ANY\n      -- Reference item at position `pos' in tuple `obj'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\nfeature {NONE} -- Externals: Setting\n\n  eif_put_boolean_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set boolean item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_8_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set character item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set wide character item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_64_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set double item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set real item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_pointer_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set pointer item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_8_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_16_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_64_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set NATURAL_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_8_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_16_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_32_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_64_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set integer_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_reference_item_with_object (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set reference item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_boolean_item (obj: POINTER; pos: INTEGER; v: BOOLEAN)\n      -- Set boolean item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_8_item (obj: POINTER; pos: INTEGER; v: CHARACTER_8)\n      -- Set character_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_character_32_item (obj: POINTER; pos: INTEGER; v: CHARACTER_32)\n      -- Set character_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_64_item (obj: POINTER; pos: INTEGER; v: REAL_64)\n      -- Set double item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_real_32_item (obj: POINTER; pos: INTEGER; v: REAL_32)\n      -- Set real item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_pointer_item (obj: POINTER; pos: INTEGER; v: POINTER)\n      -- Set pointer item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_8_item (obj: POINTER; pos: INTEGER; v: NATURAL_8)\n      -- Set NATURAL_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_16_item (obj: POINTER; pos: INTEGER; v: NATURAL_16)\n      -- Set NATURAL_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_32_item (obj: POINTER; pos: INTEGER; v: NATURAL_32)\n      -- Set NATURAL_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_natural_64_item (obj: POINTER; pos: INTEGER; v: NATURAL_64)\n      -- Set NATURAL_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_8_item (obj: POINTER; pos: INTEGER; v: INTEGER_8)\n      -- Set integer_8 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_16_item (obj: POINTER; pos: INTEGER; v: INTEGER_16)\n      -- Set integer_16 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_32_item (obj: POINTER; pos: INTEGER; v: INTEGER_32)\n      -- Set integer_32 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\n  eif_put_integer_64_item (obj: POINTER; pos: INTEGER; v: INTEGER_64)\n      -- Set integer_64 item at position `pos' in tuple `obj' with `v'.\n    external\n      \"C macro use %\"eif_rout_obj.h%\"\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"type.e","content":"note\n  description: \"Representation of an Eiffel type.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-09-05 03:29:24 -0700 (Thu, 05 Sep 2013) $\"\n  revision: \"$Revision: 92913 $\"\n\nclass\n  TYPE [G]\n\ninherit\n  HASHABLE\n    rename\n      default as any_default\n    redefine\n      is_equal, out\n    end\n\n  PART_COMPARABLE\n    rename\n      default as any_default,\n      is_less as is_strictly_conforming_to alias \"<\",\n      is_less_equal as is_conforming_to alias \"<=\"\n    redefine\n      is_conforming_to, is_equal, out\n    end\n\n  DEBUG_OUTPUT\n    rename\n      default as any_default\n    redefine\n      is_equal, out\n    end\n\ncreate {NONE}\n  -- Creation is done either by using manifest types\n  -- or by calling ANY.generating_type.\n\nconvert\n    -- Conversion useful for the transition period because of the\n    -- modification in ANY:\n    --    generating_type: STRING\n    -- becomes:\n    --    generating_type: TYPE [like Current]\n  to_string_8: {STRING_8, STRING_GENERAL, READABLE_STRING_GENERAL, READABLE_STRING_8},\n  to_string_32: {STRING_32, READABLE_STRING_32}\n\nfeature -- Access\n\n  name: IMMUTABLE_STRING_8\n      -- Name of Eiffel type represented by `Current', using Eiffel style guidelines\n      -- as specified in OOSC2 (e.g. COMPARABLE, HASH_TABLE [FOO, BAR], ...)\n    do\n      if attached internal_name as l_name then\n        Result := l_name\n      else\n        create Result.make_from_string (runtime_name)\n        internal_name := Result\n      end\n    ensure\n      name_not_void: Result /= Void\n    end\n\n  generic_parameter_type (i: INTEGER): TYPE [detachable ANY]\n      -- `i'-th generic parameter of Eiffel type represented by `Current'\n    require\n      i_large_enough: i >= 1\n      i_small_enough: i <= generic_parameter_count\n    external\n      \"built_in\"\n    ensure\n      generic_parameter_not_void: Result /= Void\n    end\n\n  type_id: INTEGER\n      -- Id of the Eiffel type represented by `Current'\n    external\n      \"built_in\"\n    ensure\n      type_id_not_negative: Result >= 0\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := type_id\n    end\n\nfeature -- Measurement\n\n  generic_parameter_count: INTEGER\n      -- Number of generic parameters in Eiffel type represented by `Current'\n    external\n      \"built_in\"\n    ensure\n      generic_parameter_count_not_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  has_default: BOOLEAN\n      -- Is current type a type that has a default value?\n      -- I.e. a detachable type or an expanded type.\n    external\n      \"built_in\"\n    end\n\n  is_expanded: BOOLEAN\n      -- Is current type an expanded type?\n    external\n      \"built_in\"\n    end\n\n  is_attached: BOOLEAN\n      -- Is current type attached?\n    external\n      \"built_in\"\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    do\n      Result := type_id = other.type_id\n    end\n\n  is_strictly_conforming_to alias \"<\" (other: like Current): BOOLEAN\n      -- Does type represented by `Current' conform to type represented by `other' and differ from it?\n    do\n      Result := type_id /= other.type_id and then is_conforming_to (other)\n    end\n\n  is_conforming_to alias \"<=\" (other: like Current): BOOLEAN\n      -- Does type represented by `Current' conform to type represented by `other'?\n    external\n      \"magic\"\n      -- Result := {ISE_RUNTIME}.type_conforms_to (type_id, other.type_id)\n    end\n\nfeature -- Conversion\n\n  adapt alias \"[]\" (g: detachable G): detachable G\n      -- Adapts `g' or calls necessary conversion routine to adapt `g'\n    do\n      Result := g\n    ensure\n      adapted: Result ~ g\n    end\n\n  attempt alias \"#?\" (obj: detachable separate ANY): detachable G\n      -- Result of assignment attempt of `obj' to entity of type G\n    do\n      if attached {G} obj as l_g then\n        Result := l_g\n      end\n    ensure\n      assigned_or_void: Result = obj or Result = default_detachable_value\n    end\n\n  default_detachable_value: detachable G\n    do\n    end\n\n  default: G\n    require\n      has_default: has_default\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- <Precursor>\n    do\n      create Result.make_from_string (name)\n    end\n\n  debug_output: STRING\n      -- <Precursor>\n    do\n      create Result.make_from_string (name)\n    end\n\nfeature -- Features from STRING needed here for the transition period (see convert clause)\n\n  plus alias \"+\" (other: STRING): STRING\n      -- Append a copy of 's' at the end of a copy of the name of the\n      -- Eiffel type represented by `Current', then return the Result.\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name + other' instead (or 'out + other' during the transition period).\"\n    require\n      argument_not_void: other /= Void\n    do\n      create Result.make (name.count + other.count)\n      Result.append (name)\n      Result.append (other)\n    ensure\n      result_exists: Result /= Void\n      definition: Result.same_string (name + other)\n    end\n\n  same_string (other: STRING): BOOLEAN\n      -- Do the name of the Eiffel type represented by `Current'\n      -- and `other' have same character sequence?\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.same_string (other)' instead (or 'out.same_string (other)' during the transition period).\"\n    require\n      other_not_void: other /= Void\n    do\n      Result := name.same_string (other)\n    ensure\n      definition: Result = name.same_string (other)\n    end\n\n  is_case_insensitive_equal (other: STRING): BOOLEAN\n      -- Is the name of the Eiffel type represented by `Current'\n      -- made of same character sequence as `other' regardless\n      -- of casing (possibly with a different capacity)?\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.is_case_insensitive_equal (other)' instead (or 'out.is_case_insensitive_equal (other)' during the transition period).\"\n    require\n      other_not_void: other /= Void\n    do\n      Result := name.is_case_insensitive_equal (other)\n    ensure\n      definition: Result = name.is_case_insensitive_equal (other)\n    end\n\n  as_lower: STRING\n      -- New object with all letters of the name of the Eiffel type\n      -- represented by `Current' in lower case.\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.as_lower' instead (or 'out.as_lower' during the transition period).\"\n    do\n      create Result.make_from_string (name)\n      Result.to_lower\n    ensure\n      as_lower_not_void: Result /= Void\n      definition: Result.same_string (name.as_lower)\n    end\n\n  as_upper: STRING\n      -- New object with all letters of the name of the Eiffel type\n      -- represented by `Current' in upper case.\n      -- This feature from STRING is needed here for the\n      -- transition period (see convert clause).\n    obsolete\n      \"[070813] Use 'name.as_upper' instead (or 'out.as_upper' during the transition period).\"\n    do\n      create Result.make_from_string (name)\n      Result.to_upper\n    ensure\n      as_upper_not_void: Result /= Void\n      definition: Result.same_string (name.as_upper)\n    end\n\n  to_string_8: STRING_8\n    obsolete\n      \"Use `name' instead (or `out' during the transition period).\"\n    do\n      create Result.make_from_string (name)\n    ensure\n      to_string_8_not_void: Result /= Void\n    end\n\n  to_string_32: STRING_32\n      -- Name of type\n    obsolete\n      \"[080717] Use 'name' instead (or 'out' during the transition period).\"\n    do\n      create Result.make_from_string_general (name)\n    ensure\n      to_string_32_not_void: Result /= Void\n    end\n\nfeature {NONE} -- Implementation: Access\n\n  internal_name: detachable IMMUTABLE_STRING_8\n      -- Storage for once per object `name'\n\nfeature {NONE} -- Implementation\n\n  runtime_name: STRING\n      -- Name of Eiffel type represented by `Current', using Eiffel style guidelines\n      -- as specified in OOSC2 (e.g. COMPARABLE, HASH_TABLE [FOO, BAR], ...)\n    external\n      \"built_in\"\n    ensure\n      name_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"unbounded.e","content":"note\n  description: \"Finite structures whose item count is not bounded\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: unbounded, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class UNBOUNDED [G] inherit\n\n  FINITE [G]\n\nfeature -- Status report\n\n  --extendible: BOOLEAN is true;\n    -- Can new items be added? (Answer: yes)\n\n-- invariant\n\n  -- extendible: extendible\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
__eiffel_builtin.push({"filename":"utf_converter.e","content":"note\n  description: \"[\n      Converter from/to UTF-8, UTF-16 and UTF-32 encodings.\n\n      Handling of invalid encodings\n      =============================\n\n      Whenever a UTF-8 or UTF-16 sequence is decoded, the decoding routines also check\n      that the sequence is valid. If it is not, it will replace the invalid unit (e.g. a byte\n      for UTF-8 and a 2-byte for UTF-16 by the replacement character U+FFFD as described by\n      variant #3 of the recommended practice for replacement character in Unicode (see\n      http://www.unicode.org/review/pr-121.html for more details).\n\n      However it means that you cannot roundtrip incorrectly encoded sequence back and forth\n      between the encoded version and the decoded STRING_32 version. To allow roundtrip, an\n      escaped representation of a bad encoded sequence has been introduced. It is adding a\n      a fourth variant (which is a slight modification of variant #3) to the recommended\n      practice where the replacement character is followed by the printed hexadecimal value\n      of the invalid byte or the invalid 2-byte sequence.\n\n      To provide an example (assuming that the Unicode character U+FFFD is represented as\n      ? textually):\n      1 - on UNIX, any invalid UTF-8 byte sequence such as 0x8F 0x8F is encoded as the\n      following Unicode sequence: U+FFFD U+0038 U+0046 U+FFFF U+0038 U+0046, and textually\n      it looks like \"?8F?8F\".\n      2 - on Windows, any invalid UTF-16 2-byte sequence such as 0xD800 0x0054 is encoded as the\n      following Unicode sequence: U+FFFD U+0075 U+0044 U+0038 U+0030 U+0030 U+FFFD U+0035 U+0033,\n      and textually it looks like \"?uD800?54\". The rule is that if the 2-byte sequence does not fit\n      into 1 byte, it uses the letter `u' followed by the hexadecimal value of the 2-byte sequence,\n      otherwise it simply uses the 1-byte hexadecimal representation.\n    ]\"\n  date: \"$Date: 2014-04-29 14:26:38 -0700 (Tue, 29 Apr 2014) $\"\n  revision: \"$Revision: 94920 $\"\n\nexpanded class\n  UTF_CONVERTER\n\nfeature -- Access\n\n  escape_character: CHARACTER_32 = '%/0xFFFD/'\n      -- Unicode replacement character to escape invalid UTF-8 or UTF-16 encoding.\n      -- UTF-8 encoding: 0xEF 0xBF 0xBD\n      -- Binary UTF-8 encoding: 11101111 10111111 10111101\n      -- UTF-16 encoding: 0xFFFD\n\nfeature -- Status report\n\n  is_valid_utf_8_string_8 (s: READABLE_STRING_8): BOOLEAN\n      -- Is `s' a valid UTF-8 Unicode sequence?\n    local\n      c: NATURAL_32\n      i, nb: INTEGER\n    do\n      from\n        nb := s.count\n        Result := True\n      until\n        i >= nb or not Result\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 127 then\n            -- Form 0xxxxxxx.\n        elseif (c & 0xE0) = 0xC0 and i < nb then\n            -- Form 110xxxxx 10xxxxxx.\n          i := i + 1\n          Result := (s.code (i) & 0xC0) = 0x80\n        elseif (c & 0xF0) = 0xE0 and i + 1 < nb then\n          -- Form 1110xxxx 10xxxxxx 10xxxxxx.\n          i := i + 2\n          Result := (s.code (i - 1) & 0xC0) = 0x80 and\n            (s.code (i) & 0xC0) = 0x80\n        elseif (c & 0xF8) = 0xF0 and i + 2 < nb then\n          -- Form 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx.\n          i := i + 3\n          Result := (s.code (i - 2) & 0xC0) = 0x80 and\n            (s.code (i - 1) & 0xC0) = 0x80 and\n            (s.code (i) & 0xC0) = 0x80\n        else\n            -- Anything else is not a valid UTF-8 sequence that would yield a valid Unicode character.\n          Result := False\n        end\n      end\n    end\n\n  is_valid_utf_16le_string_8 (s: READABLE_STRING_8): BOOLEAN\n      -- Is `s' a valid UTF-16LE Unicode sequence?\n    local\n      c1, c2: NATURAL_32\n      i, nb: INTEGER\n    do\n      nb := s.count\n        -- If `nb' is not even, then clearly not a valid UTF-16 string.\n      if (nb \\\\ 2) = 0 then\n        from\n          Result := True\n        until\n          i >= nb or not Result\n        loop\n          i := i + 2\n          c1 := s.code (i - 1) | (s.code (i) |<< 8)\n          if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n          elseif c1 <= 0xDBFF then\n            i := i + 2\n            if i <= nb then\n              c2 := s.code (i - 1) | (s.code (i) |<< 8)\n              Result := 0xDC00 <= c2 and c2 <= 0xDFF\n            else\n                -- Surrogate pair is incomplete, clearly not a valid UTF-16 sequence.\n              Result := False\n            end\n          else\n              -- Invalid starting surrogate pair which should be between 0xD800 and 0xDBFF.\n            Result := False\n          end\n        end\n      end\n    end\n\n  is_valid_utf_16_subpointer (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): BOOLEAN\n      -- Is `p' a valid UTF-16 Unicode sequence between code unit `start_pos' and `end_pos'?\n      -- If `a_stop_at_null' we stop checking after finding a null character.\n    local\n      i, n: INTEGER\n      c1, c2: NATURAL_32\n    do\n      if p.count >= 2 and start_pos >= 0 and start_pos <= end_pos + 1 and end_pos < (p.count // 2) then\n        from\n          i := start_pos * 2\n          n := end_pos * 2\n          Result := True\n        until\n          i > n or not Result\n        loop\n          c1 := p.read_natural_16 (i)\n          if c1 = 0 and a_stop_at_null then\n              -- We hit our null terminating character, we can stop\n            i := n + 1\n          else\n            if c1 < 0xD800 or c1 >= 0xE000 then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n              i := i + 1\n            elseif c1 <= 0xDBFF then\n              i := i + 2\n              if i <= n then\n                c2 := p.read_natural_16 (i)\n                Result := 0xDC00 <= c2 and c2 <= 0xDFF\n              else\n                  -- Surrogate pair is incomplete, clearly not a valid UTF-16 sequence.\n                Result := False\n              end\n            else\n                -- Invalid starting surrogate pair which should be between 0xD800 and 0xDBFF.\n              Result := False\n            end\n          end\n        end\n      end\n    end\n\n  is_valid_utf_16 (s: SPECIAL [NATURAL_16]): BOOLEAN\n      -- Is `s' a valid UTF-16 Unicode sequence?\n    local\n      i, n: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n        i := 0\n        n := s.count\n        Result := True\n      until\n        i > n or not Result\n      loop\n        c1 := s.item (i)\n        if c1 = 0 then\n            -- We hit our null terminating character, we can stop\n          i := n + 1\n        else\n          if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n          elseif c1 <= 0xDBFF then\n            i := i + 1\n            if i <= n then\n              c2 := s.item (i)\n              Result := 0xDC00 <= c2 and c2 <= 0xDFF\n            else\n                -- Surrogate pair is incomplete, clearly not a valid UTF-16 sequence.\n              Result := False\n            end\n          else\n              -- Invalid starting surrogate pair which should be between 0xD800 and 0xDBFF.\n            Result := False\n          end\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  utf_8_bytes_count (s: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Number of bytes necessary to encode in UTF-8 `s.substring (start_pos, end_pos)'.\n      -- Note that this feature can be used for both escaped and non-escaped string.\n      -- In the case of escaped strings, the result will be possibly higher than really needed.\n      -- It does not include the terminating null character.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n    local\n      i: INTEGER\n      c: NATURAL_32\n    do\n      from\n        i := start_pos\n      until\n        i > end_pos\n      loop\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx.\n          Result := Result + 1\n        elseif c <= 0x7FF then\n            -- 110xxxxx 10xxxxxx\n          Result := Result + 2\n        elseif c <= 0xFFFF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          Result := Result + 3\n        else\n            -- c <= 1FFFFF - there are no higher code points\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          Result := Result + 4\n        end\n        i := i + 1\n      end\n    end\n\n  utf_16_characters_count_form_pointer (m: MANAGED_POINTER; start_pos, end_pos: INTEGER): INTEGER\n      -- Number of characters of the UTF-16 encoded `m' starting at `start_pos' in `m' up to `end_pos - 1'.\n      -- It does not include the terminating null character.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position: start_pos <= end_pos + 2\n      end_pos_small_enought: end_pos < m.count\n      even_start_position: start_pos \\\\ 2 = 0\n      even_end_position: end_pos \\\\ 2 = 0\n    local\n      i, n: INTEGER\n      c: NATURAL_32\n    do\n      from\n        i := start_pos\n        n := end_pos\n      until\n        i >= end_pos\n      loop\n        c := m.read_natural_16 (i)\n        if c < 0xD800 or c >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          i := i + 2\n        elseif i <= n then\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          i := i + 4\n        end\n        Result := Result + 1\n      end\n    end\n\n  utf_16_bytes_count (s: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Number of bytes necessary at the very least to encode in UTF-16 `s.substring (start_pos, end_pos)'.\n      -- Note that this feature can be used for both escaped and non-escaped string.\n      -- In the case of escaped strings, the result will be possibly higher than really needed.\n      -- It does not include the terminating null character.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n    local\n      i: INTEGER\n      c: NATURAL_32\n    do\n      from\n        i := start_pos\n      until\n        i > end_pos\n      loop\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Code point from Basic Multilingual Plane: one 16-bit code unit.\n          Result := Result + 2\n        else\n          Result := Result + 4\n        end\n        i := i + 1\n      end\n    end\n\n  utf_8_to_string_32_count (s: SPECIAL [CHARACTER]; start_pos, end_pos: INTEGER): INTEGER\n      -- Count of characters corresponding to UTF-8 sequence `s'.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < s.count\n    local\n      i: INTEGER\n      n: INTEGER\n      c: INTEGER\n    do\n      from\n        i := start_pos\n        n := end_pos\n      until\n        i > n\n      loop\n        c := s [i].code\n        if c <= 0x7F then\n            -- 0xxxxxxx\n          i := i + 1\n          Result := Result + 1\n        elseif c <= 0xDF then\n            -- 110xxxxx 10xxxxxx\n          i := i + 2\n          if i <= n then\n            Result := Result + 1\n          end\n        elseif c <= 0xEF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          i := i + 3\n          if i <= n then\n            Result := Result + 1\n          end\n        elseif c <= 0xF7 then\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          i := i + 4\n          if i <= n then\n            Result := Result + 1\n          end\n        end\n      end\n    end\n\nfeature -- UTF-32 to UTF-8\n\n  string_32_to_utf_8_string_8 (s: READABLE_STRING_32): STRING_8\n      -- UTF-8 sequence corresponding to `s'.\n    do\n      Result := utf_32_string_to_utf_8_string_8 (s)\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (Result).same_string (s)\n    end\n\n  string_32_into_utf_8_string_8 (s: READABLE_STRING_32; a_result: STRING_8)\n      -- Copy the UTF-8 sequence corresponding to `s' appended into `a_result'.\n    do\n      utf_32_string_into_utf_8_string_8 (s, a_result)\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\n  utf_32_string_to_utf_8_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence.\n    do\n      create Result.make (s.count)\n      utf_32_string_into_utf_8_string_8 (s, Result)\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (Result).same_string_general (s)\n    end\n\n  utf_32_string_into_utf_8_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy the UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence\n      -- appended into `a_result'.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c.to_character_8)\n        elseif c <= 0x7FF then\n            -- 110xxxxx 10xxxxxx\n          a_result.extend (((c |>> 6) | 0xC0).to_character_8)\n          a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n        elseif c <= 0xFFFF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          a_result.extend (((c |>> 12) | 0xE0).to_character_8)\n          a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n          a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n        else\n            -- c <= 1FFFFF - there are no higher code points\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          a_result.extend (((c |>> 18) | 0xF0).to_character_8)\n          a_result.extend ((((c |>> 12) & 0x3F) | 0x80).to_character_8)\n          a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n          a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\n  escaped_utf_32_substring_into_utf_8_0_pointer (\n        s: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER; p: MANAGED_POINTER;\n        p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER]\n    )\n      -- Write UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence that could\n      -- be escaped, with terminating zero to address `p + p_offset' and update the size of `p' to the\n      -- number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      p_offset_non_negative: p_offset >= 0\n    local\n      i, n, m, l_count: INTEGER\n      c: NATURAL_32\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded, l_resized: BOOLEAN\n    do\n        -- Basic assumptions that there will be only one-byte code units.\n      n := end_pos - start_pos + 1\n      l_count := p.count\n        -- Check that there is at least `n' bytes available plus the terminating null character.\n      if l_count - p_offset < (n + 1) then\n          -- Optimize resizing, once we have to resize, we actually perform the resizing\n          -- only once.\n        l_count := p_offset + utf_8_bytes_count (s, start_pos, end_pos) + 1\n        p.resize (l_count)\n        l_resized := True\n      end\n\n      from\n        m := p_offset\n        i := start_pos - 1\n      until\n        i >= end_pos\n      loop\n        i := i + 1\n        c := s.code (i)\n\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n            -- In the Unix case, we only accept the 1-byte encoded format.\n          if i < n and then s.item (i + 1) = escape_character then\n              -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n            i := i + 1\n          elseif i + 1 < n then\n              -- We have at least 2 characters to read, make sure they represent an hexadecimal\n              -- value.\n            l_encoded_value := s.substring (i + 1, i + 2)\n            if is_hexa_decimal (l_encoded_value) then\n              c := to_natural_32 (l_encoded_value)\n              if c <= 0x7F then\n                  -- Value was encoded when it should not have been\n                  -- do nothing, we leave the original content as is.\n                c := escape_character.natural_32_code\n              else\n                l_decoded := True\n                i := i + 2\n              end\n            else\n              -- Not an hexadecimal value, it was not escaped.\n            end\n          else\n            -- Not enough to read to make it valid, it was not escaped.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0x7F then\n              -- 0xxxxxxx\n            p.put_natural_8 (c.to_natural_8, m)\n            m := m + 1\n          else\n              -- Make sure there is sufficient room for all the remaining characters and\n              -- at least 5 bytes, i.e. 4 bytes for the maximum UTF-8 encoding,\n              -- and one byte for the terminating null character. Note that we do not\n              -- take into account `p_offset' because `m' already includes it.\n              -- Note that `end_pos - i' represents the number of remaining characters\n              -- to process in the current string.\n            if not l_resized and then (m + 5 + (end_pos - i) > l_count) then\n                -- Optimize resizing, once we have to resize, we actually perform the resizing\n                -- only once.\n              l_count := m + utf_8_bytes_count (s, i, end_pos) + 1\n              p.resize (l_count)\n              l_resized := True\n            end\n            if c <= 0x7FF then\n                -- 110xxxxx 10xxxxxx\n              p.put_natural_8 (((c |>> 6) | 0xC0).to_natural_8, m)\n              p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 1)\n              m := m + 2\n            elseif c <= 0xFFFF then\n                -- 1110xxxx 10xxxxxx 10xxxxxx\n              p.put_natural_8 (((c |>> 12) | 0xE0).to_natural_8, m)\n              p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 1)\n              p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 2)\n              m := m + 3\n            else\n                -- c <= 1FFFFF - there are no higher code points\n                -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n              p.put_natural_8 (((c |>> 18) | 0xF0).to_natural_8, m)\n              p.put_natural_8 ((((c |>> 12) & 0x3F) | 0x80).to_natural_8, m + 1)\n              p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 2)\n              p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 3)\n              m := m + 4\n            end\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          p.put_natural_8 (c.to_natural_8, m)\n          m := m + 1\n        end\n      end\n      if l_resized then\n          -- `p' was resized so we adjust it to accommodate up to the terminating null character.\n        p.resize (m + 1)\n      end\n      p.put_natural_8 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, a_new_upper.item - 1, False).same_string_general (s.substring (start_pos, end_pos))\n      roundtrip: (a_new_upper = Void and then not s.substring (start_pos, end_pos).has ('%U')) implies\n         utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, p.count, True).same_string_general (s.substring (start_pos, end_pos))\n    end\n\n  escaped_utf_32_string_to_utf_8_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence that could be escaped.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    do\n      create Result.make (s.count)\n      escaped_utf_32_string_into_utf_8_string_8 (s, Result)\n    ensure\n      roundtrip: utf_8_string_8_to_escaped_string_32 (Result).same_string_general (s)\n    end\n\n  escaped_utf_32_string_into_utf_8_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy the UTF-8 sequence corresponding to `s' interpreted as a UTF-32 sequence that could\n      -- be escaped appended into `a_result'.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded: BOOLEAN\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n            -- In the Unix case, we only accept the 1-byte encoded format.\n          if i < n and then s.item (i + 1) = escape_character then\n              -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n            i := i + 1\n          elseif i + 1 < n then\n              -- We have at least 2 characters to read, make sure they represent an hexadecimal\n              -- value.\n            l_encoded_value := s.substring (i + 1, i + 2)\n            if is_hexa_decimal (l_encoded_value) then\n              c := to_natural_32 (l_encoded_value)\n              if c <= 0x7F then\n                  -- Value was encoded when it should not have been\n                  -- do nothing, we leave the original content as is.\n                c := escape_character.natural_32_code\n              else\n                l_decoded := True\n                i := i + 2\n              end\n            else\n              -- Not an hexadecimal value, it was not escaped.\n            end\n          else\n            -- Not enough to read to make it valid, it was not escaped.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0x7F then\n              -- 0xxxxxxx\n            a_result.extend (c.to_character_8)\n          elseif c <= 0x7FF then\n              -- 110xxxxx 10xxxxxx\n            a_result.extend (((c |>> 6) | 0xC0).to_character_8)\n            a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n          elseif c <= 0xFFFF then\n              -- 1110xxxx 10xxxxxx 10xxxxxx\n            a_result.extend (((c |>> 12) | 0xE0).to_character_8)\n            a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n            a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n          else\n              -- c <= 1FFFFF - there are no higher code points\n              -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            a_result.extend (((c |>> 18) | 0xF0).to_character_8)\n            a_result.extend ((((c |>> 12) & 0x3F) | 0x80).to_character_8)\n            a_result.extend ((((c |>> 6) & 0x3F) | 0x80).to_character_8)\n            a_result.extend (((c & 0x3F) | 0x80).to_character_8)\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          a_result.extend (c.to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_8_string_8_to_escaped_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\n  string_32_into_utf_8_0_pointer (s: READABLE_STRING_32; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-8 sequence corresponding to `s' with terminating zero\n      -- to address `p + p_offset' and update the size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      p_offset_non_negative: p_offset >= 0\n    do\n      utf_32_string_into_utf_8_0_pointer (s, p, p_offset, a_new_upper)\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, a_new_upper.item - 1, False).same_string (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies\n         utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, p.count, True).same_string_general (s)\n    end\n\n  utf_32_string_into_utf_8_0_pointer (s: READABLE_STRING_GENERAL; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence,\n      -- with terminating zero to address `p + p_offset' and update the size of `p' to the\n      -- number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      p_offset_non_negative: p_offset >= 0\n    local\n      m: INTEGER\n      i, n, l_count: INTEGER\n      c: NATURAL_32\n      l_resized: BOOLEAN\n    do\n        -- Basic assumptions that there will be only one-byte code units.\n      n := s.count\n      l_count := p.count\n        -- Check that there is at least `n' bytes available plus the terminating null character.\n      if l_count - p_offset < (n + 1) then\n          -- Optimize resizing, once we have to resize, we actually perform the resizing\n          -- only once.\n        l_count := p_offset + utf_8_bytes_count (s, 1, n) + 1\n        p.resize (l_count)\n        l_resized := True\n      end\n\n        -- Fill `p' with the converted data.\n      from\n        i := 0\n        m := p_offset\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx.\n          p.put_natural_8 (c.to_natural_8, m)\n          m := m + 1\n        else\n            -- Make sure there is sufficient room for all the remaining characters and\n            -- at least 5 bytes, i.e. 4 bytes for the maximum UTF-8 encoding,\n            -- and one byte for the terminating null character. Note that we do not\n            -- take into account `p_offset' because `m' already includes it.\n            -- Note that `n - i' represents the number of remaining characters\n            -- to process in the current string.\n          if not l_resized and then (m + 5 + (n - i) > l_count) then\n              -- Optimize resizing, once we have to resize, we actually perform the resizing\n              -- only once.\n            l_count := m + utf_8_bytes_count (s, i, n) + 1\n            p.resize (l_count)\n            l_resized := True\n          end\n\n          if c <= 0x7FF then\n              -- 110xxxxx 10xxxxxx.\n            p.put_natural_8 (((c |>> 6) | 0xC0).to_natural_8, m)\n            p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 1)\n            m := m + 2\n          elseif c <= 0xFFFF then\n              -- 1110xxxx 10xxxxxx 10xxxxxx\n            p.put_natural_8 (((c |>> 12) | 0xE0).to_natural_8, m)\n            p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 1)\n            p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 2)\n            m := m + 3\n          else\n              -- c <= 1FFFFF - there are no higher code points\n              -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            p.put_natural_8 (((c |>> 18) | 0xF0).to_natural_8, m)\n            p.put_natural_8 ((((c |>> 12) & 0x3F) | 0x80).to_natural_8, m + 1)\n            p.put_natural_8 ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 2)\n            p.put_natural_8 (((c & 0x3F) | 0x80).to_natural_8, m + 3)\n            m := m + 4\n          end\n        end\n      end\n      if l_resized then\n          -- `p' was resized so we adjust it to accommodate up to the terminating null character.\n        p.resize (m + 1)\n      end\n      p.put_natural_8 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, a_new_upper.item - 1, False).same_string_general (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies\n         utf_8_0_subpointer_to_escaped_string_32 (p, p_offset, p.count, True).same_string_general (s)\n    end\n\n  utf_32_string_to_utf_8 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_8]\n      -- UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence.\n      -- The sequence is not zero-terminated.\n    do\n      Result := utf_32_string_to_utf_8_0 (s)\n      Result := Result.aliased_resized_area_with_default (0, Result.count - 1)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_8_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = l_ref.code (l_spec.cursor_index) end\n    end\n\n  utf_32_string_to_utf_8_0 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_8]\n      -- UTF-8 sequence corresponding to `s', interpreted as a UTF-32 sequence.\n      -- The sequence is zero-terminated.\n    local\n      m: INTEGER\n      i, n: like {STRING_32}.count\n      c: NATURAL_32\n    do\n      n := s.count\n\n        -- First compute how many bytes we need to convert `s' to UTF-8.\n      m := utf_8_bytes_count (s, 1, n)\n\n        -- Fill `Result' with the converted data.\n      from\n        create Result.make_filled (0, m + 1)\n        i := 0\n        m := 0\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx.\n          Result.put (c.to_natural_8, m)\n          m := m + 1\n        elseif c <= 0x7FF then\n            -- 110xxxxx 10xxxxxx.\n          Result.put (((c |>> 6) | 0xC0).to_natural_8, m)\n          Result.put (((c & 0x3F) | 0x80).to_natural_8, m + 1)\n          m := m + 2\n        elseif c <= 0xFFFF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          Result.put (((c |>> 12) | 0xE0).to_natural_8, m)\n          Result.put ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 1)\n          Result.put (((c & 0x3F) | 0x80).to_natural_8, m + 2)\n          m := m + 3\n        else\n            -- c <= 1FFFFF - there are no higher code points\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          Result.put (((c |>> 18) | 0xF0).to_natural_8, m)\n          Result.put ((((c |>> 12) & 0x3F) | 0x80).to_natural_8, m + 1)\n          Result.put ((((c |>> 6) & 0x3F) | 0x80).to_natural_8, m + 2)\n          Result.put (((c & 0x3F) | 0x80).to_natural_8, m + 3)\n          m := m + 4\n        end\n      end\n      Result.put (0, m)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_8_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = l_ref.code (l_spec.cursor_index) end\n    end\n\nfeature -- UTF-8 to UTF-32\n\n  utf_8_0_pointer_to_escaped_string_32 (p: MANAGED_POINTER): STRING_32\n      -- {STRING_32} object corresponding to UTF-8 sequence `p' which is zero-terminated,\n      -- where invalid UTF-8 sequences are escaped.\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_8_0_pointer_into_escaped_string_32 (p, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (Result) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_0_pointer_into_escaped_string_32 (p: MANAGED_POINTER; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-8 sequence `p' which is zero-terminated,\n      -- where invalid UTF-8 sequences are escaped, appended into `a_result'.\n    do\n      utf_8_0_subpointer_into_escaped_string_32 (p, 0, p.count - 1, True, a_result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_0_subpointer_to_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): STRING_32\n      -- {STRING_32} object corresponding to UTF-8 sequence `p' between indexes `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-8 sequences are escaped.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_8_0_subpointer_into_escaped_string_32 (p, start_pos, end_pos, a_stop_at_null, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (Result) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (start_pos + l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_0_subpointer_into_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-8 sequence `p' between indexes `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-8 sequences are escaped, appended into `a_result'.\n    require\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count\n    local\n      i: like {STRING_8}.count\n      c1, c2, c3, c4: NATURAL_8\n      l_last_char: CHARACTER_32\n    do\n      from\n        a_result.grow (a_result.count + end_pos - start_pos + 1)\n        i := start_pos\n      until\n        i > end_pos\n      loop\n        c1 := p.read_natural_8 (i)\n        if c1 = 0 and a_stop_at_null then\n            -- We hit our null terminating character, we can stop\n          i := end_pos + 1\n        elseif c1 <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c1.to_character_32)\n          i := i + 1\n        elseif (c1 & 0xE0) = 0xC0 then\n          if i < end_pos then\n            c2 := p.read_natural_8 (i + 1)\n            if (c2 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 110xxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x1F) |<< 6) |\n                (c2.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 2\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n              i := i + 1\n            end\n          else\n              -- Invalid UTF-8 sequence, we escape the first byte.\n            escape_code_into (a_result, c1)\n            i := i + 1\n          end\n        elseif (c1 & 0xF0) = 0xE0 then\n          if i + 1 < end_pos then\n            c2 := p.read_natural_8 (i + 1)\n            c3 := p.read_natural_8 (i + 2)\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 1110xxxx 10xxxxxx 10xxxxxx\n              l_last_char := (((c1.as_natural_32 & 0xF) |<< 12) |\n                ((c2.as_natural_32 & 0x3F) |<< 6) |\n                (c3.as_natural_32 & 0x3F)\n                ).to_character_32\n              a_result.extend (l_last_char)\n              i := i + 3\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n              i := i + 1\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n            i := i + 1\n          end\n        elseif (c1 & 0xF8) = 0xF0 then\n          if i + 2 < end_pos then\n            c2 := p.read_natural_8 (i + 1)\n            c3 := p.read_natural_8 (i + 2)\n            c4 := p.read_natural_8 (i + 3)\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 and (c4 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x7) |<< 18) |\n                ((c2.as_natural_32 & 0x3F) |<< 12) |\n                ((c3.as_natural_32 & 0x3F) |<< 6) |\n                (c4.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 4\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n              i := i + 1\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n            i := i + 1\n          end\n\n        else\n            -- Clearly invalid UTF-8\n          escape_code_into (a_result, c1)\n          i := i + 1\n        end\n      end\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_str and then\n        across l_str as l_char all l_char.item = p.read_natural_8 (start_pos + l_char.cursor_index - 1).to_character_8 end\n    end\n\n  utf_8_string_8_to_string_32 (s: READABLE_STRING_8): STRING_32\n      -- STRING_32 corresponding to UTF-8 sequence `s'.\n    do\n      create Result.make (s.count)\n      utf_8_string_8_into_string_32 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_32_string_to_utf_8_string_8 (Result).same_string (s)\n    end\n\n  utf_8_string_8_into_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy STRING_32 corresponding to UTF-8 sequence `s' appended into `a_result'.\n    local\n      i: like {STRING_8}.count\n      n: like {STRING_8}.count\n      c: NATURAL_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c.to_character_32)\n        elseif c <= 0xDF then\n            -- 110xxxxx 10xxxxxx\n          i := i + 1\n          if i <= n then\n            a_result.extend ((\n              ((c & 0x1F) |<< 6) |\n              (s.code (i) & 0x3F)\n            ).to_character_32)\n          end\n        elseif c <= 0xEF then\n            -- 1110xxxx 10xxxxxx 10xxxxxx\n          i := i + 2\n          if i <= n then\n            a_result.extend ((\n              ((c & 0xF) |<< 12) |\n              ((s.code (i - 1) & 0x3F) |<< 6) |\n              (s.code (i) & 0x3F)\n            ).to_character_32)\n          end\n        elseif c <= 0xF7 then\n            -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n          i := i + 3\n          if i <= n then\n            a_result.extend ((\n              ((c & 0x7) |<< 18) |\n              ((s.code (i - 2) & 0x3F) |<< 12) |\n              ((s.code (i - 1) & 0x3F) |<< 6) |\n              (s.code (i) & 0x3F)\n            ).to_character_32)\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\n  utf_8_string_8_to_escaped_string_32 (s: READABLE_STRING_8): STRING_32\n      -- STRING_32 corresponding to UTF-8 sequence `s', where invalid UTF-8 sequences are escaped.\n    do\n      create Result.make (s.count)\n      utf_8_string_8_into_escaped_string_32 (s, Result)\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_8_string_8 (Result).same_string (s)\n    end\n\n  utf_8_string_8_into_escaped_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy STRING_32 corresponding to UTF-8 sequence `s', where invalid UTF-8 sequences are escaped,\n      -- appended into `a_result'.\n    local\n      i: like {STRING_8}.count\n      n: like {STRING_8}.count\n      c1, c2, c3, c4: NATURAL_8\n      l_last_char: CHARACTER_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c1 := s.code (i).as_natural_8\n        if c1 <= 0x7F then\n            -- 0xxxxxxx\n          a_result.extend (c1.to_character_32)\n        elseif (c1 & 0xE0) = 0xC0 then\n          if i < n then\n            c2 := s.code (i + 1).as_natural_8\n            if (c2 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 110xxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x1F) |<< 6) |\n                (c2.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 1\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n            end\n          else\n              -- Invalid UTF-8 sequence, we escape the first byte.\n            escape_code_into (a_result, c1)\n          end\n        elseif (c1 & 0xF0) = 0xE0 then\n          if i + 1 < n then\n            c2 := s.code (i + 1).as_natural_8\n            c3 := s.code (i + 2).as_natural_8\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 1110xxxx 10xxxxxx 10xxxxxx\n              l_last_char := (((c1.as_natural_32 & 0xF) |<< 12) |\n                ((c2.as_natural_32 & 0x3F) |<< 6) |\n                (c3.as_natural_32 & 0x3F)\n                ).to_character_32\n              a_result.extend (l_last_char)\n              i := i + 2\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n          end\n        elseif (c1 & 0xF8) = 0xF0 then\n          if i + 2 < n then\n            c2 := s.code (i + 1).as_natural_8\n            c3 := s.code (i + 2).as_natural_8\n            c4 := s.code (i + 3).as_natural_8\n            if (c2 & 0xC0) = 0x80 and (c3 & 0xC0) = 0x80 and (c4 & 0xC0) = 0x80 then\n                -- Valid UTF-8 sequence:\n                -- 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n              a_result.extend ((\n                ((c1.as_natural_32 & 0x7) |<< 18) |\n                ((c2.as_natural_32 & 0x3F) |<< 12) |\n                ((c3.as_natural_32 & 0x3F) |<< 6) |\n                (c4.as_natural_32 & 0x3F)\n                ).to_character_32)\n              i := i + 3\n            else\n                -- Invalid UTF-8 sequence, we escape the first byte\n                -- and try with the next one to see if it is the starting\n                -- byte of a valid UTF-8 sequence.\n              escape_code_into (a_result, c1)\n            end\n          else\n              -- Invalid UTF-8 sequence.\n            escape_code_into (a_result, c1)\n          end\n\n        else\n            -- Clearly invalid UTF-8\n          escape_code_into (a_result, c1)\n        end\n      end\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_8_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\nfeature -- UTF-32 to UTF-16\n\n  string_32_to_utf_16 (s: READABLE_STRING_32): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s'.\n      -- The sequence is not zero-terminated.\n    do\n      Result := utf_32_string_to_utf_16 (s)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 16)) end\n    end\n\n  utf_32_string_to_utf_16 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s' interpreted as a UTF-32 sequence.\n      -- The sequence is not zero-terminated.\n    do\n      Result := utf_32_string_to_utf_16_0 (s)\n      Result := Result.aliased_resized_area_with_default (0, Result.count - 1)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result as l_spec all l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 8)) end\n    end\n\n  string_32_to_utf_16_0 (s: READABLE_STRING_32): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s' with terminating zero.\n    do\n      Result := utf_32_string_to_utf_16_0 (s)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result.resized_area_with_default (0, Result.count - 1) as l_spec all\n          l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 8))\n        end\n    end\n\n  utf_32_string_to_utf_16_0 (s: READABLE_STRING_GENERAL): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to `s', interpreted as a UTF-32 sequence,\n      -- with terminating zero.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      m: like {STRING_32}.count\n      p: like {STRING_32}.count\n      c: NATURAL_32\n    do\n      from\n        m := 0\n        n := s.count\n        p := n\n        create Result.make_empty (p + 1)\n      invariant\n        m = Result.count\n        p + 1 = Result.capacity\n      until\n        i >= n\n      loop\n        i := i + 1\n          -- Make sure there is sufficient room for at least 2 code units.\n        if p < m + 2 then\n          p := m + (n - i) + 2\n          Result := Result.aliased_resized_area (p + 1)\n        end\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          Result.extend (c.to_natural_16)\n          m := m + 1\n        else\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          Result.extend ((0xD7C0 + (c |>> 10)).to_natural_16)\n          Result.extend ((0xDC00 + (c & 0x3FF)).to_natural_16)\n          m := m + 2\n        end\n      end\n      Result.extend (0)\n    ensure\n      roundtrip: attached utf_32_string_to_utf_16le_string_8 (s) as l_ref and then\n        across Result.resized_area_with_default (0, Result.count - 1) as l_spec all\n          l_spec.item = (l_ref.code (l_spec.cursor_index * 2 - 1) | (l_ref.code (l_spec.cursor_index * 2) |<< 8))\n        end\n    end\n\n  string_32_into_utf_16_pointer (s: READABLE_STRING_32; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to `s' to address `p + p_offset'\n      -- and update the size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is not zero-terminated.\n    require\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    do\n      utf_32_substring_into_utf_16_pointer (s, 1, s.count, p, p_offset, a_new_upper)\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string (s)\n    end\n\n  string_32_into_utf_16_0_pointer (s: READABLE_STRING_32; p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to `s' with terminating zero\n      -- to address `p + p_offset' and update the size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    do\n      utf_32_substring_into_utf_16_0_pointer (s, 1, s.count, p, p_offset, a_new_upper)\n    ensure\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string (s)\n    end\n\n  utf_32_substring_into_utf_16_pointer\n      (s: READABLE_STRING_GENERAL;\n      start_pos, end_pos: like {READABLE_STRING_32}.count;\n      p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to the substring of `s',\n      -- interpreted as a UTF-32 sequence, starting at index `start_pos'\n      -- and ending at index `end_pos' to address `p + p_offset' and update the\n      -- size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is not zero-terminated.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    local\n      m: INTEGER\n    do\n      m := p.count\n      utf_32_substring_into_utf_16_0_pointer (s, start_pos, end_pos, p, p_offset, a_new_upper)\n      if m < p.count then\n          -- Remove the null terminating character.\n        p.resize (p.count - 2)\n        if a_new_upper /= Void then\n          a_new_upper.put (p.count - 2)\n        end\n      end\n    ensure\n      p_count_may_increase: p.count >= old p.count\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string_general (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string_general (s)\n    end\n\n  utf_32_substring_into_utf_16_0_pointer\n      (s: READABLE_STRING_GENERAL;\n      start_pos, end_pos: like {READABLE_STRING_32}.count;\n      p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER])\n      -- Write UTF-16 sequence corresponding to the substring of `s',\n      -- interpreted as a UTF-32 sequence, starting at index `start_pos'\n      -- and ending at index `end_pos' to address `p + p_offset' and update the\n      -- size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is zero-terminated.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    local\n      i: like {READABLE_STRING_GENERAL}.count\n      c: NATURAL_32\n      m, l_count: like {MANAGED_POINTER}.count\n      l_resized: BOOLEAN\n    do\n        -- Write UTF-16 sequence.\n      from\n        i := end_pos - start_pos + 1\n        l_count := p.count\n          -- Check that there is at least `i * 2' bytes available plus the terminating null character.\n        if l_count - p_offset < (i + 1) * 2  then\n            -- Optimize resizing, once we have to resize, we actually perform the resizing\n            -- only once.\n          l_count := p_offset + utf_16_bytes_count (s, start_pos, end_pos) + 2\n          p.resize (l_count)\n          l_resized := True\n        end\n        i := start_pos - 1\n        m := p_offset\n      until\n        i >= end_pos\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          p.put_natural_16 (c.to_natural_16, m)\n          m := m + 2\n        else\n            -- Make sure there is sufficient room for all the remaining characters and\n            -- at least 3 code units of 2 bytes each, i.e. 2 code unit for the surrogate\n            -- pair, and one unit for the terminating null character. Note that we do not\n            -- take into account `p_offset' because `m' already includes it.\n            -- Note that `end_pos - i' represents the number of remaining characters\n            -- to process in the current string.\n          if not l_resized and then (m + 6 + (end_pos - i) * 2 > l_count) then\n              -- Optimize resizing, once we have to resize, we actually perform the resizing\n              -- only once.\n            l_count := m + utf_16_bytes_count (s, i, end_pos) + 2\n            p.resize (l_count)\n            l_resized := True\n          end\n\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          p.put_natural_16 ((0xD7C0 + (c |>> 10)).to_natural_16, m)\n          p.put_natural_16 ((0xDC00 + (c & 0x3FF)).to_natural_16, m + 2)\n          m := m + 4\n        end\n      end\n        -- Adjust number of written bytes and add terminating zero at the end.\n      if l_resized then\n          -- We had to add a code unit on 4 bytes. We adjust the size.\n        p.resize (m + 2)\n      end\n      p.put_natural_16 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      p_count_may_increase: p.count >= old p.count\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string_general (s)\n      roundtrip: (a_new_upper = Void and then not s.has ('%U')) implies utf_16_0_subpointer_to_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string_general (s)\n    end\n\n  utf_32_string_to_utf_16le_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence\n    do\n        -- We would need at least 2-bytes per characters in `s'.\n      create Result.make (s.count * 2)\n      utf_32_string_into_utf_16le_string_8 (s, Result)\n    ensure\n      roundtrip: utf_16le_string_8_to_string_32 (Result).same_string_general (s)\n    end\n\n  utf_32_string_into_utf_16le_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence\n      -- appended into `a_result'.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n      l_nat16: NATURAL_16\n    do\n      from\n        n := s.count\n          -- We would need at least 2-bytes per characters in `s'.\n        a_result.grow (a_result.count + n * 2)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c <= 0xFFFF then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          a_result.extend ((c & 0x00FF).to_character_8)\n          a_result.extend (((c & 0xFF00) |>> 8).to_character_8)\n        else\n            -- Write the lead surrogate pair.\n          l_nat16 := (0xD7C0 + (c |>> 10)).to_natural_16\n          a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n          a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n\n            -- Write the trail surrogate pair.\n          l_nat16 := (0xDC00 + (c & 0x3FF)).to_natural_16\n          a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n          a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_16le_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\n  escaped_utf_32_substring_into_utf_16_0_pointer (\n        s: READABLE_STRING_GENERAL; start_pos, end_pos: like {READABLE_STRING_32}.count;\n        p: MANAGED_POINTER; p_offset: INTEGER; a_new_upper: detachable CELL [INTEGER]\n      )\n      -- Write UTF-16 sequence corresponding to the substring of `s',\n      -- interpreted as a UTF-32 sequence, starting at index `start_pos'\n      -- and ending at index `end_pos' to address `p + p_offset' and update the\n      -- size of `p' to the number of written bytes.\n      -- If `a_new_upper' is provided, the upper index of `p' containing the zero-termination\n      -- is written to `a_new_upper'.\n      -- The sequence is not zero-terminated.\n    require\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos <= s.count\n      even_p_offset: (p_offset \\\\ 2) = 0\n      p_offset_non_negative: p_offset >= 0\n    local\n      i, n, m, l_count: INTEGER\n      c: NATURAL_32\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded: BOOLEAN\n      l_resized: BOOLEAN\n    do\n      from\n        n := end_pos - start_pos + 1\n        l_count := p.count\n          -- Check that there is at least `i * 2' bytes available plus the terminating null character.\n        if l_count - p_offset < (n + 1) * 2  then\n            -- Optimize resizing, once we have to resize, we actually perform the resizing\n            -- only once.\n          l_count := p_offset + utf_16_bytes_count (s, start_pos, end_pos) + 2\n          p.resize (l_count)\n          l_resized := True\n        end\n        i := start_pos - 1\n        m := p_offset\n      until\n        i >= end_pos\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n          if i < n then\n            if s.item (i + 1) = escape_character then\n                -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n              i := i + 1\n            elseif s.item (i + 1) = 'u' then\n              if i + 4 < n then\n                l_encoded_value := s.substring (i + 2, i + 5)\n                if is_hexa_decimal (l_encoded_value) then\n                  c := to_natural_32 (l_encoded_value)\n                  if c < 0xD800 or c > 0xDFFF then\n                      -- Value was encoded when it should not have been\n                      -- do nothing, we leave the original content as is.\n                    c := escape_character.natural_32_code\n                  else\n                    l_decoded := True\n                    i := i + 5\n                  end\n                else\n                    -- Not an hexadecimal value, it was not escaped.\n                end\n              else\n                -- Not enough characters to make a 2-byte value, it was not escaped.\n              end\n            else\n              -- Value was most likely not encoded, because if it did, it would be the\n              -- hexadecimal representation of a byte which clearly did not need to\n              -- be escaped\n            end\n          else\n              -- Nothing more to read, clearly it was not encoded.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0xFFFF then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            p.put_natural_16 (c.to_natural_16, m)\n            m := m + 2\n          else\n              -- Make sure there is sufficient room for all the remaining characters and\n              -- at least 3 code units of 2 bytes each, i.e. 2 code unit for the surrogate\n              -- pair, and one unit for the terminating null character. Note that we do not\n              -- take into account `p_offset' because `m' already includes it.\n              -- Note that `end_pos - i' represents the number of remaining characters\n              -- to process in the current string.\n            if not l_resized and then (m + 6 + (end_pos - i) * 2 > l_count) then\n                -- Optimize resizing, once we have to resize, we actually perform the resizing\n                -- only once.\n              l_count := m + utf_16_bytes_count (s, i, end_pos) + 2\n              p.resize (l_count)\n              l_resized := True\n            end\n\n              -- Write the lead surrogate pair.\n            p.put_natural_16 ((0xD7C0 + (c |>> 10)).to_natural_16, m)\n\n              -- Write the trail surrogate pair.\n            p.put_natural_16 ((0xDC00 + (c & 0x3FF)).to_natural_16, m + 2)\n\n            m := m + 4\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          p.put_natural_16 (c.to_natural_16, m)\n          m := m + 2\n        end\n      end\n      if l_resized then\n          -- We had to add a code unit on 4 bytes. We adjust the size.\n        p.resize (m + 2)\n      end\n      p.put_natural_16 (0, m)\n      if a_new_upper /= Void then\n        a_new_upper.put (m)\n      end\n    ensure\n      p_count_may_increase: p.count >= old p.count\n      roundtrip: a_new_upper /= Void implies utf_16_0_subpointer_to_escaped_string_32 (p, p_offset // 2, (a_new_upper.item // 2) - 1, False).same_string_general (s.substring (start_pos, end_pos))\n      roundtrip: (a_new_upper = Void and then not s.substring (start_pos, end_pos).has ('%U')) implies\n        utf_16_0_subpointer_to_escaped_string_32 (p, p_offset // 2, (p.count // 2) - 1, True).same_string_general (s.substring (start_pos, end_pos))\n    end\n\n  escaped_utf_32_string_to_utf_16le_string_8 (s: READABLE_STRING_GENERAL): STRING_8\n      -- UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence that could be escaped.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    do\n        -- We would need at least 2-bytes per characters in `s'.\n      create Result.make (s.count * 2)\n      escaped_utf_32_string_into_utf_16le_string_8 (s, Result)\n    ensure\n      roundtrip: utf_16le_string_8_to_escaped_string_32 (Result).same_string_general (s)\n    end\n\n  escaped_utf_32_string_into_utf_16le_string_8 (s: READABLE_STRING_GENERAL; a_result: STRING_8)\n      -- Copy UTF-16LE sequence corresponding to `s' interpreted as a UTF-32 sequence that could be\n      -- escaped appended into `a_result'.\n      -- If `s' contains the `escape_character' followed by either \"HH\" or \"uHHHH\" where H stands\n      -- for an hexadecimal digit, then `s' has been escaped and will be converted to what is\n      -- expected by the current platform.\n      -- Otherwise it will be ignored and it will be left as is.\n      -- See the note clause for the class for more details on the encoding.\n    local\n      i: like {STRING_32}.count\n      n: like {STRING_32}.count\n      c: NATURAL_32\n      l_nat16: NATURAL_16\n      l_encoded_value: READABLE_STRING_GENERAL\n      l_decoded: BOOLEAN\n    do\n      from\n        n := s.count\n          -- We would need at least 2-bytes per characters in `s'.\n        a_result.grow (a_result.count + n * 2)\n      until\n        i >= n\n      loop\n        i := i + 1\n        c := s.code (i)\n        if c = escape_character.natural_32_code then\n            -- We might be facing a character that was escaped.\n          if i < n then\n            if s.item (i + 1) = escape_character then\n                -- The `escape_character' was escaped, it meant they really wanted an `escape_character'.\n              i := i + 1\n            elseif s.item (i + 1) = 'u' then\n              if i + 4 < n then\n                l_encoded_value := s.substring (i + 2, i + 5)\n                if is_hexa_decimal (l_encoded_value) then\n                  c := to_natural_32 (l_encoded_value)\n                  if c < 0xD800 or c > 0xDFFF then\n                      -- Value was encoded when it should not have been\n                      -- do nothing, we leave the original content as is.\n                    c := escape_character.natural_32_code\n                  else\n                    l_decoded := True\n                    i := i + 5\n                  end\n                else\n                    -- Not an hexadecimal value, it was not escaped.\n                end\n              else\n                  -- Not enough characters to make a 2-byte value, it was not escaped.\n              end\n            else\n              -- Value was most likely not encoded, because if it did, it would be the\n              -- hexadecimal representation of a byte which clearly did not need to\n              -- be escaped\n            end\n          else\n              -- Nothing more to read, clearly it was not encoded.\n          end\n        end\n\n        if not l_decoded then\n          if c <= 0xFFFF then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            a_result.extend ((c & 0x00FF).to_character_8)\n            a_result.extend (((c & 0xFF00) |>> 8).to_character_8)\n          else\n              -- Write the lead surrogate pair.\n            l_nat16 := (0xD7C0 + (c |>> 10)).to_natural_16\n            a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n            a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n\n                -- Write the trail surrogate pair.\n            l_nat16 := (0xDC00 + (c & 0x3FF)).to_natural_16\n            a_result.extend ((l_nat16 & 0x00FF).to_character_8)\n            a_result.extend (((l_nat16 & 0xFF00) |>> 8).to_character_8)\n          end\n        else\n          l_decoded := False\n            -- Simply put decoded value directly in stream.\n          a_result.extend ((c & 0x00FF).to_character_8)\n          a_result.extend (((c & 0xFF00) |>> 8).to_character_8)\n        end\n      end\n    ensure\n      roundtrip: utf_16le_string_8_to_escaped_string_32 (a_result.substring (old a_result.count + 1, a_result.count)).same_string_general (s)\n    end\n\nfeature -- UTF-16 to UTF-32\n\n  utf_16_0_pointer_to_string_32 (p: MANAGED_POINTER): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_16_0_pointer_into_string_32 (p, Result)\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, 0, p.count // 2, True) implies\n        across string_32_to_utf_16 (Result) as l_spec all l_spec.item = p.read_natural_16 (l_spec.cursor_index * 2) end\n    end\n\n  utf_16_0_pointer_into_string_32 (p: MANAGED_POINTER; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated\n      -- appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n      utf_16_0_subpointer_into_string_32 (p, 0, p.count // 2 - 1, True, a_result)\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, 0, p.count // 2, True) implies\n        across string_32_to_utf_16 (a_result.substring (old a_result.count + 1, a_result.count)) as l_spec all l_spec.item = p.read_natural_16 (l_spec.target_index * 2) end\n    end\n\n  utf_16_0_subpointer_to_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null'.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    do\n      create Result.make (p.count)\n      utf_16_0_subpointer_into_string_32 (p, start_pos, end_pos, a_stop_at_null, Result)\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, start_pos, end_pos, a_stop_at_null) implies\n        across string_32_to_utf_16 (Result) as l_spec all l_spec.item = p.read_natural_16 (l_spec.target_index * 2) end\n    end\n\n  utf_16_0_subpointer_into_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null' appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    local\n      i, n: INTEGER\n      c: NATURAL_32\n    do\n      from\n          -- Allocate Result with the same number of bytes as copied from `p'.\n        a_result.grow (a_result.count + end_pos - start_pos + 1)\n        i := start_pos * 2\n        n := end_pos * 2\n      until\n        i > n\n      loop\n        c := p.read_natural_16 (i)\n        if c = 0 and a_stop_at_null then\n            -- We hit our null terminating character, we can stop\n          i := n + 1\n        else\n          i := i + 2\n          if c < 0xD800 or c >= 0xE000 then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            a_result.extend (c.to_character_32)\n          else\n              -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n            if i <= n then\n              a_result.extend (((c.as_natural_32 |<< 10) + p.read_natural_16 (i) - 0x35FDC00).to_character_32)\n              i := i + 2\n            end\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_16_subpointer (p, start_pos, end_pos, a_stop_at_null) implies\n        across string_32_to_utf_16 (a_result.substring (old a_result.count + 1, a_result.count)) as l_spec all l_spec.item = p.read_natural_16 (l_spec.target_index * 2) end\n    end\n\n  utf_16_0_pointer_to_escaped_string_32 (p: MANAGED_POINTER): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated,\n      -- where invalid UTF-16LE sequences are escaped.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n        -- Allocate Result with the same number of bytes as `p'.\n      create Result.make (p.count)\n      utf_16_0_pointer_into_escaped_string_32 (p, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (Result) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_0_pointer_into_escaped_string_32 (p: MANAGED_POINTER; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' which is zero-terminated,\n      -- where invalid UTF-16LE sequences are escaped, appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      valid_count: p.count \\\\ 2 = 0\n    do\n      utf_16_0_subpointer_into_escaped_string_32 (p, 0, p.count // 2 - 1, True, a_result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_0_subpointer_to_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-16LE sequences are escaped.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    do\n      create Result.make (end_pos - start_pos + 1)\n      utf_16_0_subpointer_into_escaped_string_32 (p, start_pos, end_pos, a_stop_at_null, Result)\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (Result) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (start_pos * 2 + l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_0_subpointer_into_escaped_string_32 (p: MANAGED_POINTER; start_pos, end_pos: INTEGER; a_stop_at_null: BOOLEAN; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `p' between code units `start_pos' and\n      -- `end_pos' or the first null character encountered if `a_stop_at_null', where invalid\n      -- UTF-16LE sequences are escaped, appended into `a_result'.\n    require\n      minimum_size: p.count >= 2\n      start_position_big_enough: start_pos >= 0\n      end_position_big_enough: start_pos <= end_pos + 1\n      end_pos_small_enough: end_pos < p.count // 2\n    local\n      i, n: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n          -- Allocate Result with the same number of bytes as copied from `p'.\n        a_result.grow (a_result.count + end_pos - start_pos + 1)\n        i := start_pos * 2\n        n := end_pos * 2\n      until\n        i > n\n      loop\n        c1 := p.read_natural_16 (i)\n        if c1 = 0 and a_stop_at_null then\n            -- We hit our null terminating character, we can stop\n          i := n + 1\n        else\n          i := i + 2\n          if c1 < 0xD800 or c1 >= 0xE000 then\n              -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n            a_result.extend (c1.to_character_32)\n          elseif c1 <= 0xDBFF and then i <= n then\n              -- Check if a lead surrogate (value between 0xD800 and 0xDBFF) is followed by a trail surrogate.\n            c2 := p.read_natural_16 (i)\n            if c2 >= 0xDC00 and c2 <= 0xDFFF then\n                -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n              a_result.extend (((c1 |<< 10) + c2 - 0x35FDC00).to_character_32)\n              i := i + 2\n            else\n                -- Escape a lead surrogate not followed by a trail one.\n              escape_code_into (a_result, c1.as_natural_16)\n            end\n          else\n              -- Escape a trail surrogate not following a lead one or\n              -- a lead surrogate not followed by a trail one.\n            escape_code_into (a_result, c1.as_natural_16)\n          end\n        end\n      end\n    ensure\n      roundtrip: attached escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)) as l_utf and then\n        across l_utf.new_cursor.incremented (1) as l_str all\n          (l_utf.code (l_str.cursor_index) | (l_utf.code (l_str.cursor_index + 1) |<< 8)) = p.read_natural_16 (start_pos * 2 + l_str.cursor_index - 1)\n        end\n    end\n\n  utf_16_to_string_32 (s: SPECIAL [NATURAL_16]): STRING_32\n      -- {STRING_32} object corresponding to UTF-16 sequence `s'.\n    do\n      create Result.make (s.count)\n      utf_16_into_string_32 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (Result).is_equal (s)\n    end\n\n  utf_16_into_string_32 (s: SPECIAL [NATURAL_16]; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16 sequence `s'\n      -- appended into `a_result'.\n    local\n      i: like {SPECIAL [NATURAL_16]}.count\n      n: like {SPECIAL [NATURAL_16]}.count\n      c: NATURAL_32\n    do\n      from\n        n := s.count\n        a_result.grow (a_result.count + n)\n      until\n        i >= n\n      loop\n        c := s [i]\n        i := i + 1\n        if c < 0xD800 or c >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          a_result.extend (c.to_character_32)\n        else\n            -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n          if i < n then\n            a_result.extend (((c |<< 10) + s [i] - 0x35FDC00).to_character_32)\n            i := i + 1\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (a_result.substring (old a_result.count + 1, a_result.count)).is_equal (s)\n    end\n\n  utf_16le_string_8_to_string_32 (s: READABLE_STRING_8): STRING_32\n      -- {STRING_32} object corresponding to UTF-16LE sequence `s'.\n    do\n        -- There is at least half the characters of `s'.\n      create Result.make (s.count |>> 1)\n      utf_16le_string_8_into_string_32 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies escaped_utf_32_string_to_utf_16le_string_8 (Result).same_string (s)\n    end\n\n  utf_16le_string_8_into_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16LE sequence `s' appended into `a_result'.\n    local\n      i, nb: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n        nb := s.count\n          -- There is at least half the characters of `s'.\n        a_result.grow (a_result.count + (nb |>> 1))\n      until\n        i + 1 >= nb\n      loop\n        i := i + 2\n          -- Extract the first 2-bytes\n        c1 := s.code (i - 1) | (s.code (i) |<< 8)\n        if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit, this is valid Unicode.\n          a_result.extend (c1.to_character_32)\n        else\n          i := i + 2\n          if i <= nb then\n            c2 := s.code (i - 1) | (s.code (i) |<< 8)\n            a_result.extend (((c1 |<< 10) + c2 - 0x35FDC00).to_character_32)\n          end\n        end\n      end\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\n  utf_16le_string_8_to_escaped_string_32 (s: READABLE_STRING_8): STRING_32\n      -- {STRING_32} object corresponding to UTF-16LE sequence `s', where invalid UTF-16LE\n      -- sequences are escaped.\n    do\n        -- There is at least half the characters of `s'.\n      create Result.make (s.count |>> 1)\n      utf_16le_string_8_into_escaped_string_32 (s, Result)\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_16le_string_8 (Result).same_string (s)\n    end\n\n  utf_16le_string_8_into_escaped_string_32 (s: READABLE_STRING_8; a_result: STRING_32)\n      -- Copy {STRING_32} object corresponding to UTF-16LE sequence `s', where invalid UTF-16LE\n      -- sequences are escaped, appended into `a_result'.\n    local\n      i, nb: INTEGER\n      c1, c2: NATURAL_32\n    do\n      from\n        nb := s.count\n          -- There is at least half the characters of `s'.\n        a_result.grow (a_result.count + (nb |>> 1))\n      until\n        i + 1 >= nb\n      loop\n        i := i + 2\n          -- Extract the first 2-bytes\n        c1 := s.code (i - 1) | (s.code (i) |<< 8)\n        if c1 < 0xD800 or c1 >= 0xE000 then\n            -- Codepoint from Basic Multilingual Plane: one 16-bit code unit.\n          a_result.extend (c1.to_character_32)\n        elseif c1 <= 0xDBFF and i + 2 <= nb then\n            -- Check if a lead surrogate is followed by a trail surrogate.\n          c2 := s.code (i + 1) | (s.code (i + 2) |<< 8)\n          if c2 >= 0xDC00 and c2 <= 0xDFFF then\n              -- Supplementary Planes: surrogate pair with lead and trail surrogates.\n            a_result.extend (((c1 |<< 10) + c2 - 0x35FDC00).to_character_32)\n            i := i + 2\n          else\n              -- Escape a lead surrogate not followed by a trail one.\n            escape_code_into (a_result, c1.as_natural_16)\n          end\n        else\n            -- Escape a trail surrogate not following a lead one or\n            -- a lead surrogate not followed by a trail one.\n          escape_code_into (a_result, c1.as_natural_16)\n        end\n      end\n    ensure\n      roundtrip: escaped_utf_32_string_to_utf_16le_string_8 (a_result.substring (old a_result.count + 1, a_result.count)).same_string (s)\n    end\n\nfeature -- UTF-16 to UTF-8\n\n  utf_16_to_utf_8_string_8 (s: SPECIAL [NATURAL_16]): STRING_8\n      -- UTF-8 sequence corresponding to UTF-16 sequence `s'.\n    do\n      debug (\"to_implement\")\n        (create {REFACTORING_HELPER}).to_implement (\"Convert directly from UTF-16 to UTF-8.\")\n      end\n      Result := string_32_to_utf_8_string_8 (utf_16_to_string_32 (s))\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (utf_8_string_8_to_string_32 (Result)).is_equal (s)\n    end\n\n  utf_16_into_utf_8_string_8 (s: SPECIAL [NATURAL_16]; a_result: STRING_8)\n      -- Copy UTF-8 sequence corresponding to UTF-16 sequence `s' appended into `a_result'.\n    do\n      debug (\"to_implement\")\n        (create {REFACTORING_HELPER}).to_implement (\"Convert directly from UTF-16 to UTF-8.\")\n      end\n      string_32_into_utf_8_string_8 (utf_16_to_string_32 (s), a_result)\n    ensure\n      roundtrip: is_valid_utf_16 (s) implies string_32_to_utf_16 (utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count))).is_equal (s)\n    end\n\n  utf_16le_string_8_to_utf_8_string_8 (s: READABLE_STRING_8): STRING_8\n      -- UTF-8 sequence corresponding to UTF-16LE sequence `s'.\n    do\n      create Result.make (s.count)\n      utf_16le_string_8_into_utf_8_string_8 (s, Result)\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies utf_32_string_to_utf_16le_string_8 (utf_8_string_8_to_string_32 (Result)).same_string (s)\n    end\n\n  utf_16le_string_8_into_utf_8_string_8 (s: READABLE_STRING_8; a_result: STRING_8)\n      -- Copy UTF-8 sequence corresponding to UTF-16LE sequence `s' appended into `a_result'.\n    require\n      even_count: (s.count & 1) = 0\n    local\n      v: SPECIAL [NATURAL_16]\n      i: like {STRING_8}.count\n      n: like {STRING_8}.count\n    do\n      from\n        n := s.count\n        create v.make_empty (n |>> 1)\n      until\n        i >= n\n      loop\n        i := i + 2\n        check\n          valid_index: 1 <= i - 1 and i <= s.count\n        end\n        v.extend (s [i - 1].code.as_natural_16 | (s [i].code.as_natural_16 |<< 8))\n      end\n      utf_16_into_utf_8_string_8 (v, a_result)\n    ensure\n      roundtrip: is_valid_utf_16le_string_8 (s) implies utf_32_string_to_utf_16le_string_8 (utf_8_string_8_to_string_32 (a_result.substring (old a_result.count + 1, a_result.count))).same_string (s)\n    end\n\nfeature -- UTF-8 to UTF-16\n\n  utf_8_string_8_to_utf_16 (s: READABLE_STRING_8): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to UTF-8 sequence `s'.\n    do\n      debug (\"to_implement\")\n        (create {REFACTORING_HELPER}).to_implement (\"Convert directly from UTF-8 to UTF-16.\")\n      end\n      Result := string_32_to_utf_16 (utf_8_string_8_to_string_32 (s))\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_16_to_utf_8_string_8 (Result).same_string (s)\n    end\n\n  utf_8_string_8_to_utf_16_0 (s: READABLE_STRING_8): SPECIAL [NATURAL_16]\n      -- UTF-16 sequence corresponding to UTF-8 sequence `s' with terminating zero.\n    do\n      Result := utf_8_string_8_to_utf_16 (s)\n      Result := Result.aliased_resized_area_with_default (0, Result.count + 1)\n    ensure\n      roundtrip: is_valid_utf_8_string_8 (s) implies utf_16_to_utf_8_string_8 (Result).same_string (s)\n    end\n\nfeature -- Byte Order Mark (BOM)\n\n  utf_8_bom_to_string_8: STRING_8 = \"%/239/%/187/%/191/\"\n      -- UTF-8 BOM sequence.\n\n  utf_16be_bom_to_string_8: STRING_8 = \"%/254/%/255/\"\n      -- UTF-16BE BOM sequence.\n\n  utf_16le_bom_to_string_8: STRING_8 = \"%/255/%/254/\"\n      -- UTF-16LE BOM sequence.\n\n  utf_32be_bom_to_string_8: STRING_8 = \"%U%U%/254/%/255/\"\n      -- UTF-32BE BOM sequence.\n\n  utf_32le_bom_to_string_8: STRING_8 = \"%/255/%/254/%U%U\"\n      -- UTF-32LE BOM sequence.\n\nfeature {NONE} -- Implementation\n\n  escape_code_into (a_string: STRING_32; a_code: NATURAL_16)\n      -- Escape `a_code' as documented in the note clause of the class into `a_string'.\n      -- If `a_code' fits into a NATURAL_8, it will be just the `escape_character' followed\n      -- by the 2-digit hexadecimal representation, otherwise `escape_character' followed\n      -- by the letter `u' followed by the 4-digit hexadecimal representation.\n    do\n      a_string.append_character (escape_character)\n      if a_code <= {NATURAL_8}.max_value then\n        a_string.append_string_general (a_code.as_natural_8.to_hex_string)\n      else\n        a_string.append_character ('u')\n        a_string.append_string_general (a_code.to_hex_string)\n      end\n    end\n\n  is_hexa_decimal (a_string: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is `a_string' a valid hexadecimal sequence?\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.reset ({NUMERIC_INFORMATION}.type_natural_32)\n      l_convertor.parse_string_with_type (a_string, {NUMERIC_INFORMATION}.type_natural_32)\n      Result := l_convertor.is_integral_integer\n    end\n\n  to_natural_32 (a_hex_string: READABLE_STRING_GENERAL): NATURAL_32\n      -- Convert hexadecimal value `a_hex_string' to its corresponding NATURAL_32 value.\n    require\n      is_hexa: is_hexa_decimal (a_hex_string)\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (a_hex_string, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_32\n    end\n\n  ctoi_convertor: HEXADECIMAL_STRING_TO_INTEGER_CONVERTER\n      -- Convertor used to convert string to integer or natural\n    once\n      create Result.make\n      Result.set_leading_separators_acceptable (False)\n      Result.set_trailing_separators_acceptable (False)\n    ensure\n      ctoi_convertor_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license: \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkNfU1RSSU5HLmUiLCJhYnN0cmFjdF9zcGVjaWFsLmUiLCJhY3RpdmUuZSIsImFueS5lIiwiYXJyYXkuZSIsImFycmF5ZWRfbGlzdC5lIiwiYmFnLmUiLCJiaWxpbmVhci5lIiwiYm9vbGVhbi5lIiwiYm9vbGVhbl9yZWYuZSIsImJvdW5kZWQuZSIsImJveC5lIiwiY2VsbC5lIiwiY2hhaW4uZSIsImNoYXJhY3Rlcl8zMi5lIiwiY2hhcmFjdGVyXzMyX3JlZi5lIiwiY2hhcmFjdGVyXzguZSIsImNoYXJhY3Rlcl84X3JlZi5lIiwiY29sbGVjdGlvbi5lIiwiY29tcGFyYWJsZS5lIiwiY29udGFpbmVyLmUiLCJjdXJzb3IuZSIsImN1cnNvcl9zdHJ1Y3R1cmUuZSIsImRlYnVnX291dHB1dC5lIiwiZGV2ZWxvcGVyX2V4Y2VwdGlvbi5lIiwiZGlzcG9zYWJsZS5lIiwiZHluYW1pY19jaGFpbi5lIiwiZHluYW1pY19saXN0LmUiLCJleGNlcF9jb25zdC5lIiwiZXhjZXB0aW9uLmUiLCJleGNlcHRpb25fbWFuYWdlci5lIiwiZXhjZXB0aW9uX21hbmFnZXJfZmFjdG9yeS5lIiwiZXhjZXB0aW9ucy5lIiwiZmluaXRlLmUiLCJmdW5jdGlvbi5lIiwiaGFzaGFibGUuZSIsImltbXV0YWJsZV9zdHJpbmdfOC5lIiwiaW1tdXRhYmxlX3N0cmluZ19nZW5lcmFsLmUiLCJpbmRleGFibGUuZSIsImludGVnZXIuZSIsImludGVnZXJfMTYuZSIsImludGVnZXJfMTZfcmVmLmUiLCJpbnRlZ2VyXzMyX3JlZi5lIiwiaW50ZWdlcl82NC5lIiwiaW50ZWdlcl82NF9yZWYuZSIsImludGVnZXJfOC5lIiwiaW50ZWdlcl84X3JlZi5lIiwiaXRlcmFibGUuZSIsImxpbmVhci5lIiwibGlzdC5lIiwibWFuYWdlZF9wb2ludGVyLmUiLCJtaXNtYXRjaF9jb3JyZWN0b3IuZSIsIm5hdGl2ZV9hcnJheS5lIiwibmF0dXJhbF8xNi5lIiwibmF0dXJhbF8xNl9yZWYuZSIsIm5hdHVyYWxfMzIuZSIsIm5hdHVyYWxfMzJfcmVmLmUiLCJuYXR1cmFsXzY0LmUiLCJuYXR1cmFsXzY0X3JlZi5lIiwibmF0dXJhbF84LmUiLCJuYXR1cmFsXzhfcmVmLmUiLCJudW1lcmljLmUiLCJwYXJ0X2NvbXBhcmFibGUuZSIsInBsYXRmb3JtLmUiLCJwb2ludGVyLmUiLCJwb2ludGVyX3JlZi5lIiwicHJvY2VkdXJlLmUiLCJyZWFkYWJsZV9pbmRleGFibGUuZSIsInJlYWRhYmxlX3N0cmluZ18zMi5lIiwicmVhZGFibGVfc3RyaW5nXzguZSIsInJlYWRhYmxlX3N0cmluZ19nZW5lcmFsLmUiLCJyZWFsXzMyLmUiLCJyZWFsXzMyX3JlZi5lIiwicmVhbF82NC5lIiwicmVhbF82NF9yZWYuZSIsInJlZmFjdG9yaW5nX2hlbHBlci5lIiwicmVmbGVjdG9yLmUiLCJyZWZsZWN0b3JfY29uc3RhbnRzLmUiLCJyZWZsZWN0b3JfaGVscGVyLmUiLCJyZXNpemFibGUuZSIsInJvdXRpbmUuZSIsInNlcXVlbmNlLmUiLCJzcGVjaWFsLmUiLCJzdHJpbmcuZSIsInN0cmluZ18zMi5lIiwic3RyaW5nXzguZSIsInN0cmluZ19nZW5lcmFsLmUiLCJzdHJpbmdfaGFuZGxlci5lIiwic3lzdGVtX3N0cmluZy5lIiwidGFibGUuZSIsInRvX3NwZWNpYWwuZSIsInRyYXZlcnNhYmxlLmUiLCJ0dXBsZS5lIiwidHlwZS5lIiwidW5ib3VuZGVkLmUiLCJ1dGZfY29udmVydGVyLmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQ0RBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQSBsb3ctbGV2ZWwgc3RyaW5nIGNsYXNzIHRvIHNvbHZlIHNvbWUgZ2FyYmFnZSAlXG4gICAgJWNvbGxlY3RvciBwcm9ibGVtcyAobWFpbmx5IG9iamVjdHMgbW92aW5nIGFyb3VuZCkgd2hlbiAlXG4gICAgJWludGVyZmFjaW5nIHdpdGggQyBBUElzLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0yMCAxNjozNTowNyAtMDgwMCAoU3VuLCAyMCBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMjggJFwiXG5cbmNsYXNzXG4gIENfU1RSSU5HXG5cbmluaGVyaXRcbiAgU1RSSU5HX0hBTkRMRVJcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfYnlfcG9pbnRlcixcbiAgbWFrZV9ieV9wb2ludGVyX2FuZF9jb3VudCxcbiAgbWFrZV9zaGFyZWRfZnJvbV9wb2ludGVyLFxuICBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50LFxuICBvd25fZnJvbV9wb2ludGVyLFxuICBvd25fZnJvbV9wb2ludGVyX2FuZF9jb3VudFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2UgKGFfc3RyaW5nOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIE1ha2UgYSBDIHN0cmluZyBmcm9tIGBhX3N0cmluZycuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zdHJpbmdfbm90X3ZvaWQ6IGFfc3RyaW5nIC89IFZvaWRcbiAgICAgIGFfc3RyaW5nX2lzX3ZhbGlkX2FzX3N0cmluZ184OiBhX3N0cmluZy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGRvXG4gICAgICBtYWtlX2VtcHR5IChhX3N0cmluZy5jb3VudClcbiAgICAgIHNldF9zdHJpbmcgKGFfc3RyaW5nKVxuICAgIGVuZFxuXG4gIG1ha2VfZW1wdHkgKGFfbGVuZ3RoOiBJTlRFR0VSKVxuICAgICAgLS0gTWFrZSBhbiBlbXB0eSBDIHN0cmluZyBvZiBgYV9sZW5ndGgnIGNoYXJhY3RlcnMuXG4gICAgICAtLSBDIG1lbW9yeSBhcmVhIGlzIG5vdCBpbml0aWFsaXplZC5cbiAgICByZXF1aXJlXG4gICAgICBhX2xlbmd0aF9wb3NpdGl2ZTogYV9sZW5ndGggPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgbWFuYWdlZF9kYXRhLm1ha2UgKGFfbGVuZ3RoICsgMSlcbiAgICAgIGNvdW50IDo9IDBcbiAgICBlbmRcblxuICBtYWtlX2J5X3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSKVxuICAgICAgLS0gTWFrZSBhIGNvcHkgb2Ygc3RyaW5nIHBvaW50ZWQgYnkgYGFfcHRyJy5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG1ha2VfYnlfcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyLCBjX3N0cmxlbiAoYV9wdHIpKVxuICAgIGVuZFxuXG4gIG1ha2VfYnlfcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyOiBQT0lOVEVSOyBhX2xlbmd0aDogSU5URUdFUilcbiAgICAgIC0tIE1ha2UgYSBjb3B5IG9mIGZpcnN0IGBhX2xlbmd0aCcgYnl0ZSBvZiBzdHJpbmcgcG9pbnRlZCBieSBgYV9wdHInLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfcHRyX25vdF9udWxsOiBhX3B0ciAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIGFfbGVuZ3RoX25vbl9uZWdhdGl2ZTogYV9sZW5ndGggPj0gMFxuICAgIGRvXG4gICAgICBjb3VudCA6PSBhX2xlbmd0aFxuICAgICAgY3JlYXRlIG1hbmFnZWRfZGF0YS5tYWtlICgoYV9sZW5ndGggKyAxKSlcbiAgICAgIG1hbmFnZWRfZGF0YS5pdGVtLm1lbW9yeV9jb3B5IChhX3B0ciwgYV9sZW5ndGgpXG4gICAgZW5kXG5cbiAgbWFrZV9zaGFyZWRfZnJvbV9wb2ludGVyIChhX3B0cjogUE9JTlRFUilcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBzaGFyaW5nIGBhX3B0cicuXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfbm90X251bGw6IGFfcHRyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0ciwgY19zdHJsZW4gKGFfcHRyKSlcbiAgICBlbmRcblxuICBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0cjogUE9JTlRFUjsgYV9sZW5ndGg6IElOVEVHRVIpXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugc2hhcmluZyBgYV9wdHInIG9mIGBhX2xlbmd0aCcgYnl0ZS5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBhX2xlbmd0aF9ub25fbmVnYXRpdmU6IGFfbGVuZ3RoID49IDBcbiAgICBkb1xuICAgICAgY291bnQgOj0gYV9sZW5ndGhcbiAgICAgIGNyZWF0ZSBtYW5hZ2VkX2RhdGEuc2hhcmVfZnJvbV9wb2ludGVyIChhX3B0ciwgYV9sZW5ndGggKyAxKVxuICAgIGVuZFxuXG4gIG93bl9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSKVxuICAgICAgLS0gTmV3IGluc3RhbmNlIHVzaW5nIGBhX3B0cicgYXMgbWVtb3J5LiBDdXJyZW50IHdpbGwgZnJlZSBwb2ludGVkIG1lbW9yeVxuICAgICAgLS0gYnkgYGFfcHRyJyB3aGVuIGNvbGxlY3RlZC5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG93bl9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0ciwgY19zdHJsZW4gKGFfcHRyKSlcbiAgICBlbmRcblxuICBvd25fZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoYV9wdHI6IFBPSU5URVI7IGFfbGVuZ3RoOiBJTlRFR0VSKVxuICAgICAgLS0gTmV3IGluc3RhbmNlIHVzaW5nIGBhX3B0cicgYXMgbWVtb3J5LiBDdXJyZW50IHdpbGwgZnJlZSBwb2ludGVkIG1lbW9yeVxuICAgICAgLS0gYnkgYGFfcHRyJyB3aGVuIGNvbGxlY3RlZC5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBhX2xlbmd0aF9ub25fbmVnYXRpdmU6IGFfbGVuZ3RoID49IDBcbiAgICBkb1xuICAgICAgY291bnQgOj0gYV9sZW5ndGhcbiAgICAgIGNyZWF0ZSBtYW5hZ2VkX2RhdGEub3duX2Zyb21fcG9pbnRlciAoYV9wdHIsIGFfbGVuZ3RoKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSKVxuICAgICAgLS0gU2hhcmUgYGFfcHRyJy5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIHNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoYV9wdHIsIGNfc3RybGVuIChhX3B0cikpXG4gICAgZW5kXG5cbiAgc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChhX3B0cjogUE9JTlRFUjsgYV9sZW5ndGg6IElOVEVHRVIpXG4gICAgICAtLSBTaGFyZSBgYV9wdHInIG9mIGBhX2xlbmd0aCcgYnl0ZS5cbiAgICByZXF1aXJlXG4gICAgICBhX3B0cl9ub3RfbnVsbDogYV9wdHIgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBhX2xlbmd0aF9ub25fbmVnYXRpdmU6IGFfbGVuZ3RoID49IDBcbiAgICBkb1xuICAgICAgY291bnQgOj0gYV9sZW5ndGhcbiAgICAgIGlmIG5vdCBtYW5hZ2VkX2RhdGEuaXNfc2hhcmVkIHRoZW5cbiAgICAgICAgY3JlYXRlIG1hbmFnZWRfZGF0YS5zaGFyZV9mcm9tX3BvaW50ZXIgKGFfcHRyLCBhX2xlbmd0aCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIG1hbmFnZWRfZGF0YS5zZXRfZnJvbV9wb2ludGVyIChhX3B0ciwgYV9sZW5ndGggKyAxKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2hhcmVfZnJvbV9wb2ludGVyIChhX3B0cjogUE9JTlRFUilcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBzaGFyaW5nIGBhX3B0cicuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX3NoYXJlZF9mcm9tX3BvaW50ZXInIHRvIGNyZWF0ZSBvYmplY3QgYW5kIGBzZXRfc2hhcmVkX2Zyb21fcG9pbnRlcicgdG8gbW9kaWZ5IGl0LlwiXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfbm90X251bGw6IGFfcHRyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBzZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyLCBjX3N0cmxlbiAoYV9wdHIpKVxuICAgIGVuZFxuXG4gIHNoYXJlX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGFfcHRyOiBQT0lOVEVSOyBhX2xlbmd0aDogSU5URUdFUilcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBzaGFyaW5nIGBhX3B0cicgb2YgYGFfbGVuZ3RoJyBieXRlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZV9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCcgdG8gY3JlYXRlIG9iamVjdCBhbmQgYHNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCcgdG8gbW9kaWZ5IGl0LlwiXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfbm90X251bGw6IGFfcHRyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgYV9sZW5ndGhfbm9uX25lZ2F0aXZlOiBhX2xlbmd0aCA+PSAwXG4gICAgZG9cbiAgICAgIHNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoYV9wdHIsIGFfbGVuZ3RoKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIHN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogU1RSSU5HXG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc2l0aW9uX25vdF90b29fYmlnOiBlbmRfcG9zIDw9IGNhcGFjaXR5XG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsX2NvdW50KVxuICAgICAgUmVzdWx0LnNldF9jb3VudCAobF9jb3VudClcbiAgICAgIHJlYWRfc3Vic3RyaW5nX2ludG8gKFJlc3VsdCwgc3RhcnRfcG9zLCBlbmRfcG9zKVxuICAgIGVuc3VyZVxuICAgICAgc3VzYnN0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBzdHJpbmc6IFNUUklOR1xuICAgICAgLS0gRWlmZmVsIHN0cmluZywgaWdub3JpbmcgYGNvdW50Jy4gUmVhZHMgdW50aWwgYSBudWxsIGNoYXJhY3RlciBpcyBiZWluZyByZWFkLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3Vic3RyaW5nICgxLCBjX3N0cmxlbiAoaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBzdHJpbmdfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY29weV90b19zdHJpbmcgKGFfc3RyaW5nOiBTVFJJTkdfR0VORVJBTDsgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIENvcHkgYG4nIGNoYXJhY3RlcnMgb2YgYEN1cnJlbnQnIGZyb20gYHNvdXJjZV9pbmRleCcgcG9zaXRpb24gdG8gYGFfc3RyaW5nJyBhdFxuICAgICAgLS0gYGRlc3RpbmF0aW9uX2luZGV4Jy4gT3RoZXIgY2hhcmFjdGVycyBvZiBgYV9zdHJpbmcnIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zdHJpbmdfbm90X3ZvaWQ6IGFfc3RyaW5nIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9wb3NpdGl2ZTogc291cmNlX2luZGV4ID49IDFcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X3Bvc2l0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAxXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyAobiAtIDEpIDw9IGNhcGFjaXR5XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgKG4gLSAxKSA8PSBhX3N0cmluZy5jb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2RhdGE6IGxpa2UgbWFuYWdlZF9kYXRhXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc291cmNlX2luZGV4IC0gMVxuICAgICAgICBqIDo9IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIChuIC0gMSlcbiAgICAgICAgbF9kYXRhIDo9IG1hbmFnZWRfZGF0YVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFfc3RyaW5nLnB1dF9jb2RlIChsX2RhdGEucmVhZF9uYXR1cmFsXzggKGkpLCBqKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlYWRfc3Vic3RyaW5nX2ludG8gKGFfc3RyaW5nOiBTVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcycgaW50byBgYV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfc3RyaW5nX25vdF92b2lkOiBhX3N0cmluZyAvPSBWb2lkXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc2l0aW9uX25vdF90b29fYmlnOiBlbmRfcG9zIDw9IGNhcGFjaXR5XG4gICAgICBhX3N0cmluZ19sYXJnZV9lbm91Z2g6IGFfc3RyaW5nLmNvdW50ID49IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfZGF0YTogbGlrZSBtYW5hZ2VkX2RhdGFcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9wb3MgLSAxXG4gICAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3NcbiAgICAgICAgbF9kYXRhIDo9IG1hbmFnZWRfZGF0YVxuICAgICAgICBqIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhX3N0cmluZy5wdXRfY29kZSAobF9kYXRhLnJlYWRfbmF0dXJhbF84IChpKSwgailcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWFkX3N0cmluZ19pbnRvIChhX3N0cmluZzogU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJyBpbnRvIGBhX3N0cmluZycgcmVwbGFjaW5nIGFueVxuICAgICAgLS0gZXhpc3RpbmcgY2hhcmFjdGVycy5cbiAgICByZXF1aXJlXG4gICAgICBhX3N0cmluZ19ub3Rfdm9pZDogYV9zdHJpbmcgLz0gVm9pZFxuICAgICAgYV9zdHJpbmdfbGFyZ2VfZW5vdWdoOiBhX3N0cmluZy5jb3VudCA+PSBjb3VudFxuICAgIGRvXG4gICAgICByZWFkX3N1YnN0cmluZ19pbnRvIChhX3N0cmluZywgMSwgY291bnQpXG4gICAgZW5kXG5cbiAgcmVhZF9zdWJzdHJpbmdfaW50b19jaGFyYWN0ZXJfOF9hcmVhIChhX2FyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl84XTsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcycgaW50byBgYV9hcmVhJy5cbiAgICByZXF1aXJlXG4gICAgICBhX2FyZWFfbm90X3ZvaWQ6IGFfYXJlYSAvPSBWb2lkXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc2l0aW9uX25vdF90b29fYmlnOiBlbmRfcG9zIDw9IGNhcGFjaXR5XG4gICAgICBhX2FyZWFfbGFyZ2VfZW5vdWdoOiBhX2FyZWEuY291bnQgPj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9kYXRhOiBsaWtlIG1hbmFnZWRfZGF0YVxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3Bvc1xuICAgICAgICBsX2RhdGEgOj0gbWFuYWdlZF9kYXRhXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYV9hcmVhLnB1dCAobF9kYXRhLnJlYWRfbmF0dXJhbF84IChpKS50b19jaGFyYWN0ZXJfOCwgailcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvcGllZDogLS0gZm9yIGkgaW4gMC4uZW5kX3BvcyAtIHN0YXJ0X3BvcywgYV9hcmVhIFtpXSA9IEN1cnJlbnQgW2kgKyBzdGFydF9wb3NdXG4gICAgZW5kXG5cbiAgcmVhZF9zdWJzdHJpbmdfaW50b19jaGFyYWN0ZXJfMzJfYXJlYSAoYV9hcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJyBpbnRvIGBhX2FyZWEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfYXJlYV9ub3Rfdm9pZDogYV9hcmVhIC89IFZvaWRcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zaXRpb25fbm90X3Rvb19iaWc6IGVuZF9wb3MgPD0gY2FwYWNpdHlcbiAgICAgIGFfYXJlYV9sYXJnZV9lbm91Z2g6IGFfYXJlYS5jb3VudCA+PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2RhdGE6IGxpa2UgbWFuYWdlZF9kYXRhXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfcG9zIC0gMVxuICAgICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zXG4gICAgICAgIGxfZGF0YSA6PSBtYW5hZ2VkX2RhdGFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhX2FyZWEucHV0IChsX2RhdGEucmVhZF9uYXR1cmFsXzggKGkpLnRvX2NoYXJhY3Rlcl8zMiwgailcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvcGllZDogLS0gZm9yIGkgaW4gMC4uZW5kX3BvcyAtIHN0YXJ0X3BvcywgYV9hcmVhIFtpXSA9IEN1cnJlbnQgW2kgKyBzdGFydF9wb3NdXG4gICAgZW5kXG5cbiAgaXRlbTogUE9JTlRFUlxuICAgICAgLS0gR2V0IHBvaW50ZXIgdG8gYWxsb2NhdGVkIGFyZWEuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBtYW5hZ2VkX2RhdGEuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9ub3RfbnVsbDogUmVzdWx0IC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuZFxuXG4gIG1hbmFnZWRfZGF0YTogTUFOQUdFRF9QT0lOVEVSXG4gICAgICAtLSBIb2xkIGRhdGEgb2YgQ3VycmVudC5cblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbWFuYWdlZF9kYXRhLmNvdW50XG4gICAgZW5kXG5cbiAgYnl0ZXNfY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY291bnRcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gQ3VycmVudC5cblxuICBjaGFyYWN0ZXJfc2l6ZTogSU5URUdFUiA9IDFcbiAgICAgIC0tIFNpemUgb2YgYSBjaGFyYWN0ZXJcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9zdHJpbmcgKGFfc3RyaW5nOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFNldCBgc3RyaW5nJyB3aXRoIGBhX3N0cmluZycuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zdHJpbmdfbm90X3ZvaWQ6IGFfc3RyaW5nIC89IFZvaWRcbiAgICAgIGFfc3RyaW5nX2lzX3N0cmluZ184OiBhX3N0cmluZy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGRvXG4gICAgICBzZXRfc3Vic3RyaW5nIChhX3N0cmluZywgMSwgYV9zdHJpbmcuY291bnQpXG4gICAgZW5kXG5cbiAgc2V0X3N1YnN0cmluZyAoYV9zdHJpbmc6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYHN0cmluZycgd2l0aCBgYV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfc3RyaW5nX25vdF92b2lkOiBhX3N0cmluZyAvPSBWb2lkXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gYV9zdHJpbmcuY291bnRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjb3VudCA6PSBuYlxuXG4gICAgICBuZXdfc2l6ZSA6PSBuYiArIDFcblxuICAgICAgaWYgbWFuYWdlZF9kYXRhLmNvdW50IDwgbmV3X3NpemUgIHRoZW5cbiAgICAgICAgbWFuYWdlZF9kYXRhLnJlc2l6ZSAobmV3X3NpemUpXG4gICAgICBlbmRcblxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDBcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBtYW5hZ2VkX2RhdGEucHV0X25hdHVyYWxfOCAoYV9zdHJpbmcuY29kZSAoaSArIHN0YXJ0X3BvcykudG9fbmF0dXJhbF84LCBpKVxuICAgICAgICBpIDo9IGkgKyAgMVxuICAgICAgZW5kXG4gICAgICBtYW5hZ2VkX2RhdGEucHV0X25hdHVyYWxfOCAoMCwgbmIpXG4gICAgZW5kXG5cbiAgc2V0X2NvdW50IChhX2NvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBjb3VudCcgd2l0aCBgYV9jb3VudCcuXG4gICAgICAtLSBOb3RlOiBDdXJyZW50IGNvbnRlbnQgZnJvbSBpbmRleCBgMScgdG9cbiAgICAgIC0tIGBjb3VudC5taW4gKGFfY291bnQpJyBpcyB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV9jb3VudF9ub25fbmVnYXRpdmU6IGFfY291bnQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBuZXdfc2l6ZSA6PSBhX2NvdW50ICsgMVxuICAgICAgaWYgbWFuYWdlZF9kYXRhLmNvdW50IDwgbmV3X3NpemUgdGhlblxuICAgICAgICBtYW5hZ2VkX2RhdGEucmVzaXplIChuZXdfc2l6ZSlcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0gYV9jb3VudFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IGFfY291bnRcbiAgICBlbmRcblxuICBmaWxsX2JsYW5rXG4gICAgICAtLSBGaWxsIEN1cnJlbnQgd2l0aCB6ZXJvcy5cbiAgICBkb1xuICAgICAgZmlsbF92YWx1ZSAoMClcbiAgICBlbnN1cmVcbiAgICAgIC0tIGFsbF92YWx1ZXM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYDAnXG4gICAgZW5kXG5cbiAgZmlsbF92YWx1ZSAoYV92YWx1ZTogSU5URUdFUl84KVxuICAgICAgLS0gRmlsbCBDdXJyZW50IHdpdGggYGFfdmFsdWUnLlxuICAgIGRvXG4gICAgICBtYW5hZ2VkX2RhdGEuaXRlbS5tZW1vcnlfc2V0IChhX3ZhbHVlLCBtYW5hZ2VkX2RhdGEuY291bnQpXG4gICAgZW5zdXJlXG4gICAgICAtLSBhbGxfdmFsdWVzOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IGBhX3ZhbHVlJ1xuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGNfc3RybGVuIChwdHI6IFBPSU5URVIpOiBJTlRFR0VSXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBzaWduYXR1cmUgKGNoYXIgKik6IEVJRl9JTlRFR0VSIHVzZSA8c3RyaW5nLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJzdHJsZW5cIlxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgbWFuYWdlZF9kYXRhX25vdF92b2lkOiBtYW5hZ2VkX2RhdGEgLz0gVm9pZFxuICBjb3VudF9ub3RfbmVnYXRpdmU6IGNvdW50ID49IDBcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkFuY2VzdG9yIG9mIFNQRUNJQUwgdG8gcGVyZm9ybSBxdWVyaWVzIG9uIFNQRUNJQUwgd2l0aG91dCBrbm93aW5nIGl0cyBhY3R1YWwgZ2VuZXJpYyB0eXBlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wNC0xMiAxNjo1NDo1MCAtMDcwMCAoRnJpLCAxMiBBcHIgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI0NDAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIEFCU1RSQUNUX1NQRUNJQUxcblxuaW5oZXJpdFxuICBERUJVR19PVVRQVVRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBDb3VudCBvZiBzcGVjaWFsIGFyZWFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBDYXBhY2l0eSBvZiBzcGVjaWFsIGFyZWFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgY291bnRfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiBDdXJyZW50P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgZGVidWdfb3V0cHV0OiBTVFJJTkdcbiAgICAgIC0tIFN0cmluZyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGVidWdnZXIgdG8gcmVwcmVzZW50IGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMilcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nIChcImNvdW50PVwiKVxuICAgICAgUmVzdWx0LmFwcGVuZF9pbnRlZ2VyIChjb3VudClcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBgYEFjdGl2ZScnIGRhdGEgc3RydWN0dXJlcywgd2hpY2ggYXQgZXZlcnkgc3RhZ2UgaGF2ZVxuICAgIGEgcG9zc2libHkgdW5kZWZpbmVkIGBgY3VycmVudCBpdGVtJycuXG4gICAgQmFzaWMgYWNjZXNzIGFuZCBtb2RpZmljYXRpb24gb3BlcmF0aW9ucyBhcHBseSB0byB0aGUgY3VycmVudCBpdGVtLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBhY3RpdmUsIGFjY2Vzc1xuICBhY2Nlc3M6IG1lbWJlcnNoaXBcbiAgY29udGVudHM6IGdlbmVyaWNcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEFDVElWRSBbR10gaW5oZXJpdFxuXG4gIEJBRyBbR11cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBHXG4gICAgICAtLSBDdXJyZW50IGl0ZW1cbiAgICByZXF1aXJlXG4gICAgICByZWFkYWJsZTogcmVhZGFibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZWFkYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgYSBjdXJyZW50IGl0ZW0gdGhhdCBtYXkgYmUgcmVhZD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHdyaXRhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBhIGN1cnJlbnQgaXRlbSB0aGF0IG1heSBiZSBtb2RpZmllZD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHJlcGxhY2VhYmxlOiBCT09MRUFOXG4gICAgICAtLSBDYW4gY3VycmVudCBpdGVtIGJlIHJlcGxhY2VkP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcmVwbGFjZSAodjogRylcbiAgICAgIC0tIFJlcGxhY2UgY3VycmVudCBpdGVtIGJ5IGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICB3cml0YWJsZTogd3JpdGFibGVcbiAgICAgIHJlcGxhY2VhYmxlOiByZXBsYWNlYWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3JlcGxhY2VkOiBpdGVtID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmVcbiAgICAgIC0tIFJlbW92ZSBjdXJyZW50IGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgcHJ1bmFibGU6IHBydW5hYmxlXG4gICAgICB3cml0YWJsZTogd3JpdGFibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICB3cml0YWJsZV9jb25zdHJhaW50OiB3cml0YWJsZSBpbXBsaWVzIHJlYWRhYmxlXG4gIGVtcHR5X2NvbnN0cmFpbnQ6IGlzX2VtcHR5IGltcGxpZXMgKG5vdCByZWFkYWJsZSkgYW5kIChub3Qgd3JpdGFibGUpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwiY2xhc3NcbiAgQU5ZXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGNvbmZvcm1zX3RvIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyB0eXBlIG9mIGN1cnJlbnQgb2JqZWN0IGNvbmZvcm0gdG8gdHlwZVxuICAgICAgLS0gb2YgYG90aGVyJyAoYXMgcGVyIEVpZmZlbDogVGhlIExhbmd1YWdlLCBjaGFwdGVyIDEzKT9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBzYW1lX3R5cGUgKG90aGVyOiBBTlkpOiBCT09MRUFOXG4gICAgICAtLSBJcyB0eXBlIG9mIGN1cnJlbnQgb2JqZWN0IGlkZW50aWNhbCB0byB0eXBlIG9mIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY29uZm9ybXNfdG8gKG90aGVyKSBhbmRcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuY29uZm9ybXNfdG8gKEN1cnJlbnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IGNvbnNpZGVyZWRcbiAgICAgIC0tIGVxdWFsIHRvIGN1cnJlbnQgb2JqZWN0P1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlciB+IEN1cnJlbnRcbiAgICAgIGNvbnNpc3RlbnQ6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBmcm96ZW4gc3RhbmRhcmRfaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCwgYW5kIGZpZWxkLWJ5LWZpZWxkIGlkZW50aWNhbCB0byBpdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuc3RhbmRhcmRfaXNfZXF1YWwgKEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgZnJvemVuIGVxdWFsIChhOiBkZXRhY2hhYmxlIEFOWTsgYjogbGlrZSBhKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBhJyBhbmQgYGInIGVpdGhlciBib3RoIHZvaWQgb3IgYXR0YWNoZWRcbiAgICAgIC0tIHRvIG9iamVjdHMgY29uc2lkZXJlZCBlcXVhbD9cbiAgICBkb1xuICAgICAgaWYgYSA9IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYiA9IFZvaWRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGIgLz0gVm9pZCBhbmQgdGhlblxuICAgICAgICAgICAgICBhLmlzX2VxdWFsIChiKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoYSA9IFZvaWQgYW5kIGIgPSBWb2lkKSBvciBlbHNlXG4gICAgICAgICAgICAoKGEgLz0gVm9pZCBhbmQgYiAvPSBWb2lkKSBhbmQgdGhlblxuICAgICAgICAgICAgYS5pc19lcXVhbCAoYikpXG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2VxdWFsIChhOiBkZXRhY2hhYmxlIEFOWTsgYjogbGlrZSBhKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBhJyBhbmQgYGInIGVpdGhlciBib3RoIHZvaWQgb3IgYXR0YWNoZWQgdG9cbiAgICAgIC0tIGZpZWxkLWJ5LWZpZWxkIGlkZW50aWNhbCBvYmplY3RzIG9mIHRoZSBzYW1lIHR5cGU/XG4gICAgICAtLSBBbHdheXMgdXNlcyBkZWZhdWx0IG9iamVjdCBjb21wYXJpc29uIGNyaXRlcmlvbi5cbiAgICBkb1xuICAgICAgaWYgYSA9IFZvaWQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYiA9IFZvaWRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGIgLz0gVm9pZCBhbmQgdGhlblxuICAgICAgICAgICAgICBhLnN0YW5kYXJkX2lzX2VxdWFsIChiKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoYSA9IFZvaWQgYW5kIGIgPSBWb2lkKSBvciBlbHNlXG4gICAgICAgICAgICAoKGEgLz0gVm9pZCBhbmQgYiAvPSBWb2lkKSBhbmQgdGhlblxuICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYikpXG4gICAgZW5kXG5cbiAgZnJvemVuIGlzX2RlZXBfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYEN1cnJlbnQnIGFuZCBgb3RoZXInIGF0dGFjaGVkIHRvIGlzb21vcnBoaWMgb2JqZWN0IHN0cnVjdHVyZXM/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzaGFsbG93X2ltcGxpZXNfZGVlcDogc3RhbmRhcmRfaXNfZXF1YWwgKG90aGVyKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgc2FtZV90eXBlOiBSZXN1bHQgaW1wbGllcyBzYW1lX3R5cGUgKG90aGVyKVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19kZWVwX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBkZWVwX2VxdWFsIChhOiBkZXRhY2hhYmxlIEFOWTsgYjogbGlrZSBhKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBhJyBhbmQgYGInIGVpdGhlciBib3RoIHZvaWRcbiAgICAgIC0tIG9yIGF0dGFjaGVkIHRvIGlzb21vcnBoaWMgb2JqZWN0IHN0cnVjdHVyZXM/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW4gYS5pc19kZWVwX2VxdWFsIChiKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzaGFsbG93X2ltcGxpZXNfZGVlcDogc3RhbmRhcmRfZXF1YWwgKGEsIGIpIGltcGxpZXMgUmVzdWx0XG4gICAgICBib3RoX29yX25vbmVfdm9pZDogKGEgPSBWb2lkKSBpbXBsaWVzIChSZXN1bHQgPSAoYiA9IFZvaWQpKVxuICAgICAgc2FtZV90eXBlOiAoUmVzdWx0IGFuZCAoYSAvPSBWb2lkKSkgaW1wbGllcyAoYiAvPSBWb2lkIGFuZCB0aGVuIGEuc2FtZV90eXBlIChiKSlcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgZGVlcF9lcXVhbCAoYiwgYSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBpbzogU1REX0ZJTEVTXG4gICAgICAtLSBIYW5kbGUgdG8gc3RhbmRhcmQgZmlsZSBzZXR1cFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGlvX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdGFnZ2VkX291dFxuICAgIGVuc3VyZVxuICAgICAgb3V0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0YWdnZWRfb3V0OiBTVFJJTkdcbiAgICAgIC0tIE5ldyBzdHJpbmcgY29udGFpbmluZyB0ZXJzZSBwcmludGFibGUgcmVwcmVzZW50YXRpb25cbiAgICAgIC0tIG9mIGN1cnJlbnQgb2JqZWN0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgdGFnZ2VkX291dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwcmludCAobzogZGV0YWNoYWJsZSBBTlkpXG4gICAgICAtLSBXcml0ZSB0ZXJzZSBleHRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBgbydcbiAgICAgIC0tIG9uIHN0YW5kYXJkIG91dHB1dC5cbiAgICBkb1xuICAgICAgaWYgbyAvPSBWb2lkIHRoZW5cbiAgICAgICAgaW8ucHV0X3N0cmluZyAoby5vdXQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBkZWZhdWx0X2NyZWF0ZVxuICAgICAgLS0gUHJvY2VzcyBpbnN0YW5jZXMgb2YgY2xhc3NlcyB3aXRoIG5vIGNyZWF0aW9uIGNsYXVzZS5cbiAgICAgIC0tIChEZWZhdWx0OiBkbyBub3RoaW5nLilcbiAgICBkb1xuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcbiAgZnJvemVuIGRvX25vdGhpbmdcbiAgICAgIC0tIEV4ZWN1dGUgYSBudWxsIGFjdGlvbi5cbiAgICBkb1xuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgcmVmbGV4aXZlX2VxdWFsaXR5OiBzdGFuZGFyZF9pc19lcXVhbCAoQ3VycmVudClcbiAgcmVmbGV4aXZlX2NvbmZvcm1hbmNlOiBjb25mb3Jtc190byAoQ3VycmVudClcblxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTAxLTI1IDE0OjE4OjIwIC0wODAwIChGcmksIDI1IEphbiAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjEzOCAkXCJcblxuY2xhc3MgQVJSQVkgW0ddIGluaGVyaXRcblxuICBSRVNJWkFCTEUgW0ddXG4gICAgcmVkZWZpbmVcbiAgICAgIGZ1bGwsIGNvcHksIGlzX2VxdWFsLCByZXNpemFibGVcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0csIElOVEVHRVJdXG4gICAgcmVuYW1lXG4gICAgICBpdGVtIGFzIGl0ZW0gYWxpYXMgXCJbXVwiXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgVE9fU1BFQ0lBTCBbR11cbiAgICBleHBvcnRcbiAgICAgIHtBUlJBWX0gc2V0X2FyZWFcbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIGl0ZW0sIHB1dCwgYXQsIHZhbGlkX2luZGV4XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBtYWtlX2VtcHR5LFxuICBtYWtlLFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX2FycmF5LFxuICBtYWtlX2Zyb21fc3BlY2lhbCxcbiAgbWFrZV9mcm9tX2NpbFxuXG5jb252ZXJ0XG4gIHRvX2NpbDoge05BVElWRV9BUlJBWSBbR119LFxuICB0b19zcGVjaWFsOiB7U1BFQ0lBTCBbR119LFxuICBtYWtlX2Zyb21fY2lsICh7TkFUSVZFX0FSUkFZIFtHXX0pXG5cbmZlYXR1cmUgLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2VtcHR5XG4gICAgICAtLSBBbGxvY2F0ZSBlbXB0eSBhcnJheSBzdGFydGluZyBhdCBgMScuXG4gICAgZG9cbiAgICAgIGxvd2VyIDo9IDFcbiAgICAgIHVwcGVyIDo9IDBcbiAgICAgIG1ha2VfZW1wdHlfYXJlYSAoMClcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSAxXG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gMFxuICAgICAgaXRlbXNfc2V0OiBhbGxfZGVmYXVsdFxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkIChhX2RlZmF1bHRfdmFsdWU6IEc7IG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgYXJyYXk7IHNldCBpbmRleCBpbnRlcnZhbCB0b1xuICAgICAgLS0gYG1pbl9pbmRleCcgLi4gYG1heF9pbmRleCc7IHNldCBhbGwgdmFsdWVzIHRvIGRlZmF1bHQuXG4gICAgICAtLSAoTWFrZSBhcnJheSBlbXB0eSBpZiBgbWluX2luZGV4JyA9IGBtYXhfaW5kZXgnICsgMSkuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfYm91bmRzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxvd2VyIDo9IG1pbl9pbmRleFxuICAgICAgdXBwZXIgOj0gbWF4X2luZGV4XG4gICAgICBpZiBtaW5faW5kZXggPD0gbWF4X2luZGV4IHRoZW5cbiAgICAgICAgbiA6PSBtYXhfaW5kZXggLSBtaW5faW5kZXggKyAxXG4gICAgICBlbmRcbiAgICAgIG1ha2VfZmlsbGVkX2FyZWEgKGFfZGVmYXVsdF92YWx1ZSwgbilcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBtaW5faW5kZXhcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBtYXhfaW5kZXhcbiAgICAgIGl0ZW1zX3NldDogZmlsbGVkX3dpdGggKGFfZGVmYXVsdF92YWx1ZSlcbiAgICBlbmRcblxuICBtYWtlIChtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIGFycmF5OyBzZXQgaW5kZXggaW50ZXJ2YWwgdG9cbiAgICAgIC0tIGBtaW5faW5kZXgnIC4uIGBtYXhfaW5kZXgnOyBzZXQgYWxsIHZhbHVlcyB0byBkZWZhdWx0LlxuICAgICAgLS0gKE1ha2UgYXJyYXkgZW1wdHkgaWYgYG1pbl9pbmRleCcgPSBgbWF4X2luZGV4JyArIDEpLlxuICAgIG9ic29sZXRlXG4gICAgICBcIiBgbWFrZScgaXMgbm90IHZvaWQtc2FmZSBzdGF0aWNhbGx5LiBVc2UgYG1ha2VfZW1wdHknIG9yIGBtYWtlX2ZpbGxlZCcgaW5zdGVhZC4gWzA3LTIwMTBdXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9ib3VuZHM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXggKyAxXG4gICAgICBoYXNfZGVmYXVsdDogbWluX2luZGV4IDw9IG1heF9pbmRleCBpbXBsaWVzICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGxvd2VyIDo9IG1pbl9pbmRleFxuICAgICAgdXBwZXIgOj0gbWF4X2luZGV4XG4gICAgICBpZiBtaW5faW5kZXggPD0gbWF4X2luZGV4IHRoZW5cbiAgICAgICAgbWFrZV9maWxsZWRfYXJlYSAoKHtHfSkuZGVmYXVsdCwgbWF4X2luZGV4IC0gbWluX2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgbWFrZV9lbXB0eV9hcmVhICgwKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gbWluX2luZGV4XG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gbWF4X2luZGV4XG4gICAgICBpdGVtc19zZXQ6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2FycmF5IChhOiBBUlJBWSBbR10pXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gdGhlIGl0ZW1zIG9mIGBhJy5cbiAgICAgIC0tIChVc2VmdWwgaW4gcHJvcGVyIGRlc2NlbmRhbnRzIG9mIGNsYXNzIGBBUlJBWScsXG4gICAgICAtLSB0byBpbml0aWFsaXplIGFuIGFycmF5LWxpa2Ugb2JqZWN0IGZyb20gYSBtYW5pZmVzdCBhcnJheS4pXG4gICAgcmVxdWlyZVxuICAgICAgYXJyYXlfZXhpc3RzOiBhIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2FyZWEgKGEuYXJlYSlcbiAgICAgIGxvd2VyIDo9IGEubG93ZXJcbiAgICAgIHVwcGVyIDo9IGEudXBwZXJcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZDogYXJlYSA9IGEuYXJlYVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IGEubG93ZXJcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhLnVwcGVyXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX3NwZWNpYWwgKGE6IFNQRUNJQUwgW0ddKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IGZyb20gaXRlbXMgb2YgYGEnLlxuICAgIHJlcXVpcmVcbiAgICAgIHNwZWNpYWxfYXR0YWNoZWQ6IGEgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfYXJlYSAoYSlcbiAgICAgIGxvd2VyIDo9IDFcbiAgICAgIHVwcGVyIDo9IGEuY291bnRcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZDogYXJlYSA9IGFcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSAxXG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gYS5jb3VudFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jaWwgKG5hOiBOQVRJVkVfQVJSQVkgW2xpa2UgaXRlbV0pXG4gICAgICAtLSBJbml0aWFsaXplIGFycmF5IGZyb20gYG5hJy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgICBuYV9ub3Rfdm9pZDogbmEgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2Zyb21fbmF0aXZlX2FycmF5IChuYSlcbiAgICAgIGxvd2VyIDo9IDFcbiAgICAgIHVwcGVyIDo9IGFyZWEuY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBHIGFzc2lnbiBwdXRcbiAgICAgIC0tIEVudHJ5IGF0IGluZGV4IGBpJywgaWYgaW4gaW5kZXggaW50ZXJ2YWxcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIGxvd2VyKVxuICAgIGVuZFxuXG4gIGVudHJ5IChpOiBJTlRFR0VSKTogR1xuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIChpKVxuICAgIGVuZFxuXG4gIGhhcyAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYHYnIGFwcGVhciBpbiBhcnJheT9cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbmIgOj0gdXBwZXIgLSBsb3dlclxuICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gYW5kIHYgLz0gVm9pZCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpIH4gdlxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpID0gdlxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGxvd2VyOiBJTlRFR0VSXG4gICAgICAtLSBNaW5pbXVtIGluZGV4XG5cbiAgdXBwZXI6IElOVEVHRVJcbiAgICAgIC0tIE1heGltdW0gaW5kZXhcblxuICBjb3VudCwgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBhdmFpbGFibGUgaW5kaWNlc1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdXBwZXIgLSBsb3dlciArIDFcbiAgICBlbnN1cmUgdGhlblxuICAgICAgY29uc2lzdGVudF93aXRoX2JvdW5kczogUmVzdWx0ID0gdXBwZXIgLSBsb3dlciArIDFcbiAgICBlbmRcblxuICBvY2N1cnJlbmNlcyAodjogRyk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycyBpbiBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IHVwcGVyXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSB+IHYgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBsb3dlclxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiB1cHBlclxuICAgICAgICBsb29wXG4gICAgICAgICAgaWYgaXRlbSAoaSkgPSB2IHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobG93ZXIsIHVwcGVyKVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9ib3VuZHM6XG4gICAgICAgICgoUmVzdWx0Lmxvd2VyID0gbG93ZXIpIGFuZCAoUmVzdWx0LnVwcGVyID0gdXBwZXIpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGFycmF5IG1hZGUgb2YgdGhlIHNhbWUgaXRlbXMgYXMgYG90aGVyJz9cbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZWlmIGxvd2VyID0gb3RoZXIubG93ZXIgYW5kIHRoZW4gdXBwZXIgPSBvdGhlci51cHBlciBhbmQgdGhlblxuICAgICAgICBvYmplY3RfY29tcGFyaXNvbiA9IG90aGVyLm9iamVjdF9jb21wYXJpc29uXG4gICAgICB0aGVuXG4gICAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgICAgaSA6PSBsb3dlclxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBub3QgUmVzdWx0IG9yIGkgPiB1cHBlclxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIFJlc3VsdCA6PSBpdGVtIChpKSB+IG90aGVyLml0ZW0gKGkpXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCAwLCAwLCBjb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgYWxsX2RlZmF1bHQ6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgc2V0IHRvIGRlZmF1bHQgdmFsdWVzP1xuICAgIGRvXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gKHtHfSkuaGFzX2RlZmF1bHQgYW5kIHRoZW4gYXJlYS5maWxsZWRfd2l0aCAoKHtHfSkuZGVmYXVsdCwgMCwgdXBwZXIgLSBsb3dlcilcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvdW50ID0gMCBvciBlbHNlXG4gICAgICAgICgobm90IGF0dGFjaGVkIGl0ZW0gKHVwcGVyKSBhcyBpIG9yIGVsc2UgaSA9ICh7R30pLmRlZmF1bHQpIGFuZFxuICAgICAgICBzdWJhcnJheSAobG93ZXIsIHVwcGVyIC0gMSkuYWxsX2RlZmF1bHQpKVxuICAgIGVuZFxuXG4gIGZpbGxlZF93aXRoICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBzZXQgdG8gYHYnP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5maWxsZWRfd2l0aCAodiwgMCwgdXBwZXIgLSBsb3dlcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChjb3VudCA9IDAgb3IgZWxzZVxuICAgICAgICAoaXRlbSAodXBwZXIpID0gdiBhbmQgc3ViYXJyYXkgKGxvd2VyLCB1cHBlciAtIDEpLmZpbGxlZF93aXRoICh2KSkpXG4gICAgZW5kXG5cbiAgZnVsbDogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGZpbGxlZCB0byBjYXBhY2l0eT8gKEFuc3dlcjogeWVzKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG4gIHNhbWVfaXRlbXMgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBEbyBgb3RoZXInIGFuZCBDdXJyZW50IGhhdmUgc2FtZSBpdGVtcz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBjb3VudCA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9ICgoY291bnQgPSBvdGhlci5jb3VudCkgYW5kIHRoZW5cbiAgICAgICAgKGNvdW50ID0gMCBvciBlbHNlIChpdGVtICh1cHBlcikgPSBvdGhlci5pdGVtIChvdGhlci51cHBlcilcbiAgICAgICAgYW5kIHN1YmFycmF5IChsb3dlciwgdXBwZXIgLSAxKS5zYW1lX2l0ZW1zXG4gICAgICAgIChvdGhlci5zdWJhcnJheSAob3RoZXIubG93ZXIsIG90aGVyLnVwcGVyIC0gMSkpKSkpXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIGFycmF5P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGxvd2VyIDw9IGkpIGFuZCB0aGVuIChpIDw9IHVwcGVyKVxuICAgIGVuZFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSBhZGRlZD9cbiAgICAgIC0tIChBbnN3ZXI6IG5vLCBhbHRob3VnaCBhcnJheSBtYXkgYmUgcmVzaXplZC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgIGVuZFxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogbm8uKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICBlbmRcblxuICByZXNpemFibGU6IEJPT0xFQU5cbiAgICAgIC0tIENhbiBhcnJheSBiZSByZXNpemVkIGF1dG9tYXRpY2FsbHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGVuZFxuXG4gIHZhbGlkX2luZGV4X3NldDogQk9PTEVBTlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW5kZXhfc2V0LmNvdW50ID0gY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0ICh2LCBpIC0gbG93ZXIpXG4gICAgZW5kXG5cbiAgZW50ZXIgKHY6IGxpa2UgaXRlbTsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYGknLXRoIGVudHJ5LCBpZiBpbiBpbmRleCBpbnRlcnZhbCwgYnkgYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIGFyZWEucHV0ICh2LCBpIC0gbG93ZXIpXG4gICAgZW5kXG5cbiAgZm9yY2UgKHY6IGxpa2UgaXRlbTsgaTogSU5URUdFUilcbiAgICAgIC0tIEFzc2lnbiBpdGVtIGB2JyB0byBgaSctdGggZW50cnkuXG4gICAgICAtLSBSZXNpemUgdGhlIGFycmF5IGlmIGBpJyBmYWxscyBvdXQgb2YgY3VycmVudGx5IGRlZmluZWQgYm91bmRzOyBwcmVzZXJ2ZSBleGlzdGluZyBpdGVtcy5cbiAgICAgIC0tIEluIHZvaWQtc2FmZSBtb2RlLCBpZiAoe0d9KS5oYXNfZGVmYXVsdCBkb2VzIG5vdCBob2xkLCB0aGVuIHlvdSBjYW4gb25seSBpbnNlcnQgYmV0d2VlblxuICAgICAgLS0gYGxvd2VyIC0gMScgb3IgYHVwcGVyICsgMScgcG9zaXRpb24gaW4gdGhlIEFSUkFZLlxuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0X2lmX3Rvb19sb3c6XG4gICAgICAgIChpIDwgbG93ZXIgLSAxIGFuZCBsb3dlciAvPSB7bGlrZSBsb3dlcn0ubWluX3ZhbHVlKSBpbXBsaWVzICh7R30pLmhhc19kZWZhdWx0XG4gICAgICBoYXNfZGVmYXVsdF9pZl90b29faGlnaDpcbiAgICAgICAgKGkgPiB1cHBlciArIDEgYW5kIHVwcGVyIC89IHtsaWtlIHVwcGVyfS5tYXhfdmFsdWUpIGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBsb2NhbFxuICAgICAgb2xkX3NpemUsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBuZXdfbG93ZXIsIG5ld191cHBlcjogSU5URUdFUlxuICAgICAgbF9jb3VudCwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxfaW5jcmVhc2VkX2J5X29uZTogQk9PTEVBTlxuICAgIGRvXG4gICAgICBuZXdfbG93ZXIgOj0gbG93ZXIubWluIChpKVxuICAgICAgbmV3X3VwcGVyIDo9IHVwcGVyLm1heCAoaSlcbiAgICAgIG5ld19zaXplIDo9IG5ld191cHBlciAtIG5ld19sb3dlciArIDFcbiAgICAgIGxfaW5jcmVhc2VkX2J5X29uZSA6PSAoaSA9IHVwcGVyICsgMSkgb3IgKGkgPSBsb3dlciAtIDEpXG4gICAgICBpZiBlbXB0eV9hcmVhIHRoZW5cbiAgICAgICAgICAtLSBMaXN0IGlzIGVtcHR5LiBGaXJzdCB3ZSBjcmVhdGUgYW4gZW1wdHkgU1BFQ0lBTCBvZiB0aGUgcmlnaHQgY2FwYWNpdHkuXG4gICAgICAgIG1ha2VfZW1wdHlfYXJlYSAobmV3X3NpemUubWF4IChhZGRpdGlvbmFsX3NwYWNlKSlcbiAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIGZpbGwgdGhlIFNQRUNJQUwgZm9yIGAwJyB0byBgbmV3X3NpemUgLSAyJyB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCBuZXdfc2l6ZSAtIDIpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmV4dGVuZCAodilcbiAgICAgIGVsc2VcbiAgICAgICAgb2xkX3NpemUgOj0gYXJlYS5jYXBhY2l0eVxuICAgICAgICBpZiBuZXdfc2l6ZSA+IG9sZF9zaXplIHRoZW5cbiAgICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobmV3X3NpemUubWF4IChvbGRfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpKSlcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIG5ld19sb3dlciA8IGxvd2VyIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhhdmUgaW5zZXJ0ZWQgYmVsb3cgdGhlIHByZXZpb3VzIGBsb3dlcicuIFdlIG5lZWQgdG8gc2hpZnQgZW50cmllcyB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIC0tIGJlZm9yZSB3ZSBjYW4gaW5zZXJ0IGB2Jy5cbiAgICAgICAgICBsX29mZnNldCA6PSBsb3dlciAtIG5ld19sb3dlclxuICAgICAgICAgIGxfY291bnQgOj0gY2FwYWNpdHlcbiAgICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIGFuZCBsX29mZnNldCA+IGxfY291bnQgdGhlblxuICAgICAgICAgICAgICAtLSBXaXRoIHRoZSBgbmV3X2xvd2VyJyBnaXZlbiwgdGhlIGRhdGEgaGFzIHRvIG1vdmVcbiAgICAgICAgICAgICAgLS0gYmV5b25kIHRoZSBgYXJlYScncyBjb3VudCB3aGljaCByZXF1aXJlcyB1cyB0byBmaWxsXG4gICAgICAgICAgICAgIC0tIHRoZSBnYXAgYmV0d2VlbiB0aGUgb2xkIGRhdGEncyBsb2NhdGlvbiBhbmQgdGhlIG5ldyBvbmVcbiAgICAgICAgICAgICAgLS0gd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgICAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCBsX2NvdW50LCBsX29mZnNldCAtIDEpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgYXJlYS5tb3ZlX2RhdGEgKDAsIGxfb2Zmc2V0LCBsX2NvdW50KVxuICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgdGhlblxuICAgICAgICAgICAgICAtLSBXZSBzdGFydCBhdCBgMScgYW5kIG5vdCBgMCcgYmVjYXVzZSBuZXh0IGluc3RydWN0aW9uXG4gICAgICAgICAgICAgIC0tIHdpbGwgdXBkYXRlIHRoZSBpdGVtIGF0IHBvc2l0aW9uIGAwJy5cbiAgICAgICAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCAxLCBsX29mZnNldCAtIDEpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgICAtLSBJbnNlcnQgYHYnIGF0IHRoZSBuZXcgbG93ZXIgcG9zaXRpb24uXG4gICAgICAgICAgYXJlYS5wdXQgKHYsIDApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBuZXdfc2l6ZSA+IGFyZWEuY291bnQgdGhlblxuICAgICAgICAgICAgICAtLSBXZSBhcmUgYWRkaW5nIHRvIHRoZSBuZXcgYHVwcGVyJyBwb3NpdGlvbi4gRmlyc3Qgd2UgZmlsbCB0aGUgbm9uLWluaXRpYWxpemVkXG4gICAgICAgICAgICAgIC0tIGVsZW1lbnRzIGlmIGFueSB1cCB0byBgbmV3X3NpemUgLSAyJyAoaS5lLiB1cCB0aGUgdGhlIGl0ZW0gcHJpb3IgdG8gYHVwcGVyJykuXG4gICAgICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIHRoZW5cbiAgICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIGFyZWEuY291bnQsIG5ld19zaXplIC0gMilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAtLSBBZGQgYHYnIGF0IHVwcGVyIHBvc2l0aW9uLlxuICAgICAgICAgICAgYXJlYS5leHRlbmQgKHYpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBIZXJlIGBsb3dlcicgaGFzbid0IGNoYW5nZWRcbiAgICAgICAgICAgIGFyZWEucHV0ICh2LCBpIC0gbG93ZXIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBsb3dlciA6PSBuZXdfbG93ZXJcbiAgICAgIHVwcGVyIDo9IG5ld191cHBlclxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gdlxuICAgICAgaGlnaGVyX2NvdW50OiBjb3VudCA+PSBvbGQgY291bnRcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSAob2xkIGxvd2VyKS5taW4gKGkpXG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gKG9sZCB1cHBlcikubWF4IChpKVxuICAgIGVuZFxuXG4gIGZpbGxfd2l0aCAodjogRylcbiAgICAgIC0tIFNldCBpdGVtcyBiZXR3ZWVuIGBsb3dlcicgYW5kIGB1cHBlcicgd2l0aCBgdicuXG4gICAgZG9cbiAgICAgIGFyZWEuZmlsbF93aXRoICh2LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X2RlZmluaXRpb246IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBmaWxsZWQ6IGZpbGxlZF93aXRoICh2KVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBBUlJBWSBbbGlrZSBpdGVtXTsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGl0ZW1zIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSB0byBjdXJyZW50IGFycmF5IHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IHN0YXJ0X3BvcyA+PSBvdGhlci5sb3dlclxuICAgICAgdmFsaWRfZW5kX3BvczogZW5kX3BvcyA8PSBvdGhlci51cHBlclxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIHZhbGlkX2luZGV4X3BvczogaW5kZXhfcG9zID49IGxvd2VyXG4gICAgICBlbm91Z2hfc3BhY2U6ICh1cHBlciAtIGluZGV4X3BvcykgPj0gKGVuZF9wb3MgLSBzdGFydF9wb3MpXG4gICAgZG9cbiAgICAgIGFyZWEuY29weV9kYXRhIChvdGhlci5hcmVhLCBzdGFydF9wb3MgLSBvdGhlci5sb3dlciwgaW5kZXhfcG9zIC0gbG93ZXIsIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgIGVuc3VyZVxuICAgICAgLS0gY29waWVkOiBmb3JhbGwgYGknIGluIDAgLi4gKGBlbmRfcG9zJy1gc3RhcnRfcG9zJyksXG4gICAgICAtLSAgICAgaXRlbSAoaW5kZXhfcG9zICsgaSkgPSBvdGhlci5pdGVtIChzdGFydF9wb3MgKyBpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEl0ZXJhdGlvblxuXG4gIGRvX2FsbCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0ddXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhLmRvX2FsbF9pbl9ib3VuZHMgKGFjdGlvbiwgMCwgY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGRvX2lmIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBvciBgdGVzdCcgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhLmRvX2lmX2luX2JvdW5kcyAoYWN0aW9uLCB0ZXN0LCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgdGhlcmVfZXhpc3RzICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGF0IGxlYXN0IG9uZSBpdGVtP1xuICAgIHJlcXVpcmVcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS50aGVyZV9leGlzdHNfaW5fYm91bmRzICh0ZXN0LCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZm9yX2FsbCAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhbGwgaXRlbXM/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLmZvcl9hbGxfaW5fYm91bmRzICh0ZXN0LCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZG9fYWxsX3dpdGhfaW5kZXggKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHLCBJTlRFR0VSXV0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBgYWN0aW9uJyByZWNlaXZlcyBpdGVtIGFuZCBpdHMgaW5kZXguXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDBcbiAgICAgICAgaiA6PSBsb3dlclxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhY3Rpb24uY2FsbCAoW2xfYXJlYS5pdGVtIChpKSwgal0pXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZG9faWZfd2l0aF9pbmRleCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0csIElOVEVHRVJdXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0csIElOVEVHRVJdLCBCT09MRUFOXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBgYWN0aW9uJyBhbmQgYHRlc3QnIHJlY2VpdmUgdGhlIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBvciBgdGVzdCcgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDBcbiAgICAgICAgaiA6PSBsb3dlclxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiB0ZXN0Lml0ZW0gKFtsX2FyZWEuaXRlbSAoaSksIGpdKSB0aGVuXG4gICAgICAgICAgYWN0aW9uLmNhbGwgKFtsX2FyZWEuaXRlbSAoaSksIGpdKVxuICAgICAgICBlbmRcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgd2lwZV9vdXRcbiAgICAgIC0tIE1ha2UgYXJyYXkgZW1wdHkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiTm90IGFwcGxpY2FibGUgc2luY2Ugbm90IGBwcnVuYWJsZScuIFVzZSBgZGlzY2FyZF9pdGVtcycgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBkaXNjYXJkX2l0ZW1zXG4gICAgZW5kXG5cbiAgZGlzY2FyZF9pdGVtc1xuICAgICAgLS0gUmVzZXQgYWxsIGl0ZW1zIHRvIGRlZmF1bHQgdmFsdWVzIHdpdGggcmVhbGxvY2F0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoKHtHfSkuZGVmYXVsdCwgY2FwYWNpdHkpXG4gICAgZW5zdXJlXG4gICAgICBkZWZhdWx0X2l0ZW1zOiBhbGxfZGVmYXVsdFxuICAgIGVuZFxuXG4gIGNsZWFyX2FsbFxuICAgICAgLS0gUmVzZXQgYWxsIGl0ZW1zIHRvIGRlZmF1bHQgdmFsdWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgMCwgYXJlYS5jb3VudCAtIDEpXG4gICAgZW5zdXJlXG4gICAgICBzdGFibGVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBzdGFibGVfdXBwZXI6IHVwcGVyID0gb2xkIHVwcGVyXG4gICAgICBkZWZhdWx0X2l0ZW1zOiBhbGxfZGVmYXVsdFxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgaXRlbXMgZXhjZXB0IGZvciB0aGUgZmlyc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuIDwgY291bnQgdGhlblxuICAgICAgICB1cHBlciA6PSBsb3dlciArIG4gLSAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBzYW1lX2xvd2VyOiBsb3dlciA9IG9sZCBsb3dlclxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgaXRlbXMgZXhjZXB0IGZvciB0aGUgbGFzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgbG93ZXIgOj0gdXBwZXIgLSBuICsgMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAgc2FtZV91cHBlcjogdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBgbicgaXRlbXM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgdXBwZXIgOj0gbG93ZXIgLSAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAoMClcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF90YWlsIChjb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSAob2xkIGNvdW50IC0gbikubWF4ICgwKVxuICAgICAgc2FtZV91cHBlcjogdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBsYXN0IGBuJyBpdGVtcztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICB1cHBlciA6PSBsb3dlciAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhICgwKVxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX2hlYWQgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IChvbGQgY291bnQgLSBuKS5tYXggKDApXG4gICAgICBzYW1lX2xvd2VyOiBsb3dlciA9IG9sZCBsb3dlclxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgZ3JvdyAoaTogSU5URUdFUilcbiAgICAgIC0tIENoYW5nZSB0aGUgY2FwYWNpdHkgdG8gYXQgbGVhc3QgYGknLlxuICAgIGRvXG4gICAgICBpZiBpID4gY2FwYWNpdHkgdGhlblxuICAgICAgICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoKHtHfSkuZGVmYXVsdCwgbG93ZXIsIHVwcGVyICsgaSAtIGNhcGFjaXR5KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY29uc2VydmF0aXZlX3Jlc2l6ZSAobWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2UgYXJyYXkgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGluZGljZXMgZG93biB0byBgbWluX2luZGV4JyBhbmQgdXAgdG8gYG1heF9pbmRleCcuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGl0ZW0uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiIGBjb25zZXJ2YXRpdmVfcmVzaXplJyBpcyBub3Qgdm9pZC1zYWZlIHN0YXRpY2FsbHkuIFVzZSBgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQnIGluc3RlYWQuIFswNy0yMDEwXVwiXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKCh7R30pLmRlZmF1bHQsIG1pbl9pbmRleCwgbWF4X2luZGV4KVxuICAgIGVuc3VyZVxuICAgICAgbm9fbG93X2xvc3Q6IGxvd2VyID0gbWluX2luZGV4IG9yIGVsc2UgbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIG5vX2hpZ2hfbG9zdDogdXBwZXIgPSBtYXhfaW5kZXggb3IgZWxzZSB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0IChhX2RlZmF1bHRfdmFsdWU6IEc7IG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIGFycmF5IHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBpbmRpY2VzIGRvd24gdG8gYG1pbl9pbmRleCcgYW5kIHVwIHRvIGBtYXhfaW5kZXgnLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBpdGVtLlxuICAgIHJlcXVpcmVcbiAgICAgIGdvb2RfaW5kaWNlczogbWluX2luZGV4IDw9IG1heF9pbmRleFxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbmV3X2xvd2VyLCBuZXdfdXBwZXI6IElOVEVHRVJcbiAgICAgIG9mZnNldDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBlbXB0eV9hcmVhIHRoZW5cbiAgICAgICAgc2V0X2FyZWEgKGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0IChhX2RlZmF1bHRfdmFsdWUsIG1heF9pbmRleCAtIG1pbl9pbmRleCArIDEpKVxuICAgICAgICBsb3dlciA6PSBtaW5faW5kZXhcbiAgICAgICAgdXBwZXIgOj0gbWF4X2luZGV4XG4gICAgICBlbHNlXG4gICAgICAgIG5ld19sb3dlciA6PSBtaW5faW5kZXgubWluIChsb3dlcilcbiAgICAgICAgbmV3X3VwcGVyIDo9IG1heF9pbmRleC5tYXggKHVwcGVyKVxuICAgICAgICBuZXdfc2l6ZSA6PSBuZXdfdXBwZXIgLSBuZXdfbG93ZXIgKyAxXG4gICAgICAgIGlmIG5ld19zaXplID4gYXJlYS5jb3VudCB0aGVuXG4gICAgICAgICAgc2V0X2FyZWEgKGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0IChhX2RlZmF1bHRfdmFsdWUsIG5ld19zaXplKSlcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIG5ld19sb3dlciA8IGxvd2VyIHRoZW5cbiAgICAgICAgICBvZmZzZXQgOj0gbG93ZXIgLSBuZXdfbG93ZXJcbiAgICAgICAgICBhcmVhLm1vdmVfZGF0YSAoMCwgb2Zmc2V0LCB1cHBlciAtIGxvd2VyICsgMSlcbiAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlLCAwLCBvZmZzZXQgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgbG93ZXIgOj0gbmV3X2xvd2VyXG4gICAgICAgIHVwcGVyIDo9IG5ld191cHBlclxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub19sb3dfbG9zdDogbG93ZXIgPSBtaW5faW5kZXggb3IgZWxzZSBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgbm9faGlnaF9sb3N0OiB1cHBlciA9IG1heF9pbmRleCBvciBlbHNlIHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgcmVzaXplIChtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBhcnJheSBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gaW5kaWNlcyBkb3duIHRvIGBtaW5faW5kZXgnIGFuZCB1cCB0byBgbWF4X2luZGV4Jy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgaXRlbS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0JyBpbnN0ZWFkIGFzIGZ1dHVyZSB2ZXJzaW9ucyB3aWxsIGltcGxlbWVudCBgcmVzaXplJyBhcyBzcGVjaWZpZWQgaW4gRUxLUy5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGdvb2RfaW5kaWNlczogbWluX2luZGV4IDw9IG1heF9pbmRleFxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0ICgoe0d9KS5kZWZhdWx0LCBtaW5faW5kZXgsIG1heF9pbmRleClcbiAgICBlbnN1cmVcbiAgICAgIG5vX2xvd19sb3N0OiBsb3dlciA9IG1pbl9pbmRleCBvciBlbHNlIGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBub19oaWdoX2xvc3Q6IHVwcGVyID0gbWF4X2luZGV4IG9yIGVsc2UgdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICB0cmltXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBuOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG4gOj0gY291bnRcbiAgICAgIGlmIG4gPCBhcmVhLmNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfaXRlbXM6IHNhbWVfaXRlbXMgKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIHJlYmFzZSAoYV9sb3dlcjogbGlrZSBsb3dlcilcbiAgICAgIC0tIFdpdGhvdXQgY2hhbmdpbmcgdGhlIGFjdHVhbCBjb250ZW50IG9mIGBDdXJyZW50JyB3ZSBzZXQgYGxvd2VyJyB0byBgYV9sb3dlcidcbiAgICAgIC0tIGFuZCBgdXBwZXInIGFjY29yZGluZ2x5IHRvIGBhX2xvd2VyICsgY291bnQgLSAxJy5cbiAgICBsb2NhbFxuICAgICAgbF9vbGRfbG93ZXI6IGxpa2UgbG93ZXJcbiAgICBkb1xuICAgICAgbF9vbGRfbG93ZXIgOj0gbG93ZXJcbiAgICAgIGxvd2VyIDo9IGFfbG93ZXJcbiAgICAgIHVwcGVyIDo9IGFfbG93ZXIgKyAodXBwZXIgLSBsX29sZF9sb3dlcilcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBhX2xvd2VyXG4gICAgICB1cHBlcl9zZXQ6IHVwcGVyID0gYV9sb3dlciArIG9sZCBjb3VudCAtIDFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fYzogQU5ZXG4gICAgICAtLSBBZGRyZXNzIG9mIGFjdHVhbCBzZXF1ZW5jZSBvZiB2YWx1ZXMsXG4gICAgICAtLSBmb3IgcGFzc2luZyB0byBleHRlcm5hbCAobm9uLUVpZmZlbCkgcm91dGluZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2lzX2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhXG4gICAgZW5kXG5cbiAgdG9fY2lsOiBOQVRJVkVfQVJSQVkgW0ddXG4gICAgICAtLSBBZGRyZXNzIG9mIGFjdHVhbCBzZXF1ZW5jZSBvZiB2YWx1ZXMsXG4gICAgICAtLSBmb3IgcGFzc2luZyB0byBleHRlcm5hbCAobm9uLUVpZmZlbCkgcm91dGluZXMuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5uYXRpdmVfYXJyYXlcbiAgICBlbnN1cmVcbiAgICAgIHRvX2NpbF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICB0b19zcGVjaWFsOiBTUEVDSUFMIFtHXVxuICAgICAgLS0gJ2FyZWEnLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYVxuICAgIGVuc3VyZVxuICAgICAgdG9fc3BlY2lhbF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBsaW5lYXJfcmVwcmVzZW50YXRpb246IExJTkVBUiBbR11cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0ddXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSB0ZW1wLm1ha2UgKGNhcGFjaXR5KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGxvd2VyXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gdXBwZXJcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBjb3B5IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gUmVpbml0aWFsaXplIGJ5IGNvcHlpbmcgYWxsIHRoZSBpdGVtcyBvZiBgb3RoZXInLlxuICAgICAgLS0gKFRoaXMgaXMgYWxzbyB1c2VkIGJ5IGBjbG9uZScuKVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgc3RhbmRhcmRfY29weSAob3RoZXIpXG4gICAgICAgIHNldF9hcmVhIChvdGhlci5hcmVhLnR3aW4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZXF1YWxfYXJlYXM6IGFyZWEgfiBvdGhlci5hcmVhXG4gICAgZW5kXG5cbiAgc3ViYXJyYXkgKHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IEFSUkFZIFtHXVxuICAgICAgLS0gQXJyYXkgbWFkZSBvZiBpdGVtcyBvZiBjdXJyZW50IGFycmF5IHdpdGhpblxuICAgICAgLS0gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiB2YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3BvczogZW5kX3BvcyA8PSB1cHBlclxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICBkb1xuICAgICAgaWYgc3RhcnRfcG9zIDw9IGVuZF9wb3MgdGhlblxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZmlsbGVkIChpdGVtIChzdGFydF9wb3MpLCBzdGFydF9wb3MsIGVuZF9wb3MpXG4gICAgICAgICAgLS0gT25seSBjb3B5IGVsZW1lbnRzIGlmIG5lZWRlZC5cbiAgICAgICAgUmVzdWx0LnN1YmNvcHkgKEN1cnJlbnQsIHN0YXJ0X3BvcywgZW5kX3Bvcywgc3RhcnRfcG9zKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIG1ha2UgZW1wdHlcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5XG4gICAgICAgIFJlc3VsdC5yZWJhc2UgKHN0YXJ0X3BvcylcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbG93ZXI6IFJlc3VsdC5sb3dlciA9IHN0YXJ0X3Bvc1xuICAgICAgdXBwZXI6IFJlc3VsdC51cHBlciA9IGVuZF9wb3NcbiAgICAgIC0tIGNvcGllZDogZm9yYWxsIGBpJyBpbiBgc3RhcnRfcG9zJyAuLiBgZW5kX3BvcycsXG4gICAgICAtLSAgICAgUmVzdWx0Lml0ZW0gKGkpID0gaXRlbSAoaSlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5hcHBsaWNhYmxlXG5cbiAgcHJ1bmUgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdicgaWYgYW55LlxuICAgICAgLS0gKFByZWNvbmRpdGlvbiBpcyBGYWxzZS4pXG4gICAgZG9cbiAgICBlbmRcblxuICBleHRlbmQgKHY6IEcpXG4gICAgICAtLSBBZGQgYHYnIHRvIHN0cnVjdHVyZS5cbiAgICAgIC0tIChQcmVjb25kaXRpb24gaXMgRmFsc2UuKVxuICAgIGRvXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZW1wdHlfYXJlYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGFyZWEnIGVtcHR5P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYSA9IFZvaWQgb3IgZWxzZSBhcmVhLmNhcGFjaXR5ID0gMFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBhcmVhX2V4aXN0czogYXJlYSAvPSBWb2lkXG4gIGNvbnNpc3RlbnRfc2l6ZTogY2FwYWNpdHkgPSB1cHBlciAtIGxvd2VyICsgMVxuICBub25fbmVnYXRpdmVfY291bnQ6IGNvdW50ID49IDBcbiAgaW5kZXhfc2V0X2hhc19zYW1lX2NvdW50OiB2YWxpZF9pbmRleF9zZXRcbi0tIEludGVybmFsIGRpc2N1c3Npb24gaGF2ZW4ndCByZWFjaGVkIGFuIGFncmVlbWVudCBvbiB0aGlzIGludmFyaWFudFxuLS0gIGluZGV4X3NldF9oYXNfc2FtZV9ib3VuZHM6ICgoaW5kZXhfc2V0Lmxvd2VyID0gbG93ZXIpIGFuZFxuLS0gICAgICAgIChpbmRleF9zZXQudXBwZXIgPSBsb3dlciArIGNvdW50IC0gMSkpXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJMaXN0cyBpbXBsZW1lbnRlZCBieSByZXNpemFibGUgYXJyYXlzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogc2VxdWVuY2U7XG4gIHJlcHJlc2VudGF0aW9uOiBhcnJheTtcbiAgYWNjZXNzOiBpbmRleCwgY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBzaXplOiBmaXhlZDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBBUlJBWUVEX0xJU1QgW0ddIGluaGVyaXRcblxuICBUT19TUEVDSUFMIFtHXVxuICAgIHJlbmFtZVxuICAgICAgcHV0IGFzIGFycmF5X3B1dCxcbiAgICAgIGF0IGFzIGFycmF5X2F0LFxuICAgICAgaXRlbSBhcyBhcnJheV9pdGVtLFxuICAgICAgdmFsaWRfaW5kZXggYXMgYXJyYXlfdmFsaWRfaW5kZXgsXG4gICAgICBhcmVhIGFzIGFyZWFfdjJcbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIGNvcHlcbiAgICBlbmRcblxuICBSRVNJWkFCTEUgW0ddXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBjb3B5XG4gICAgZW5kXG5cbiAgRFlOQU1JQ19MSVNUIFtHXVxuICAgIHVuZGVmaW5lXG4gICAgICBwdXRfaV90aCxcbiAgICAgIGZvcmNlLCBpc19pbnNlcnRlZCwgY29weVxuICAgIHJlZGVmaW5lXG4gICAgICBmaXJzdCwgbGFzdCwgc3dhcCwgd2lwZV9vdXQsIGlfdGgsIGF0LFxuICAgICAgZ29faV90aCwgbW92ZSwgcHJ1bmFibGUsIHN0YXJ0LCBmaW5pc2gsXG4gICAgICBjb3VudCwgcHJ1bmUsIHJlbW92ZSxcbiAgICAgIHB1dF9sZWZ0LCBtZXJnZV9sZWZ0LFxuICAgICAgbWVyZ2VfcmlnaHQsIGR1cGxpY2F0ZSwgcHJ1bmVfYWxsLCBoYXMsIHNlYXJjaCxcbiAgICAgIGFwcGVuZCwgdmFsaWRfaW5kZXgsIGlzX2VxdWFsLCBjb3B5LFxuICAgICAgZm9yX2FsbCwgdGhlcmVfZXhpc3RzLCBkb19hbGwsIGRvX2lmXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBjb3B5LCBjb3JyZWN0X21pc21hdGNoXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBtYWtlLCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2FycmF5XG5cbmZlYXR1cmUgLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgbGlzdCB3aXRoIGBuJyBpdGVtcy5cbiAgICAgIC0tIChgbicgbWF5IGJlIHplcm8gZm9yIGVtcHR5IGxpc3QuKVxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX251bWJlcl9vZl9pdGVtczogbiA+PSAwXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhX3YyLm1ha2VfZW1wdHkgKG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3JyZWN0X3Bvc2l0aW9uOiBiZWZvcmVcbiAgICAgIGlzX2VtcHR5OiBpc19lbXB0eVxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgbGlzdCB3aXRoIGBuJyBpdGVtcy5cbiAgICAgIC0tIChgbicgbWF5IGJlIHplcm8gZm9yIGVtcHR5IGxpc3QuKVxuICAgICAgLS0gVGhpcyBsaXN0IHdpbGwgYmUgZnVsbC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9udW1iZXJfb2ZfaXRlbXM6IG4gPj0gMFxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGluZGV4IDo9IDBcbiAgICAgIG1ha2VfZmlsbGVkX2FyZWEgKCh7R30pLmRlZmF1bHQsIG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3JyZWN0X3Bvc2l0aW9uOiBiZWZvcmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9hcnJheSAoYTogQVJSQVkgW0ddKVxuICAgICAgLS0gQ3JlYXRlIGxpc3QgZnJvbSBhcnJheSBgYScuXG4gICAgcmVxdWlyZVxuICAgICAgYXJyYXlfZXhpc3RzOiBhIC89IFZvaWRcbiAgICBkb1xuICAgICAgaW5kZXggOj0gMFxuICAgICAgYXJlYV92MiA6PSBhLmFyZWFcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZDogYXJlYSA9IGEuYXJlYVxuICAgICAgY29ycmVjdF9wb3NpdGlvbjogYmVmb3JlXG4gICAgICBmaWxsZWQ6IGNvdW50ID0gYS5jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGFyZWE6IFNQRUNJQUwgW0ddXG4gICAgICAtLSBBY2Nlc3MgdG8gaW50ZXJuYWwgc3RvcmFnZSBvZiBBUlJBWUVEX0xJU1RcbiAgICBkb1xuICAgICAgICAtLSBJbnRlcm5hbCBzdG9yYWdlIGlzIGNhbGxlZCBgYXJlYV92Micgc28gdGhhdCBpdCB0cmlnZ2Vyc1xuICAgICAgICAtLSBhIG1pc21hdGNoIGR1cmluZyByZXRyaWV2YWwuXG4gICAgICBSZXN1bHQgOj0gYXJlYV92MlxuICAgIGVuZFxuXG4gIGl0ZW06IEdcbiAgICAgIC0tIEN1cnJlbnQgaXRlbVxuICAgIHJlcXVpcmUgZWxzZVxuICAgICAgaW5kZXhfaXNfdmFsaWQ6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuaXRlbSAoaW5kZXggLSAxKVxuICAgIGVuZFxuXG4gIGlfdGggYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IGxpa2UgaXRlbSBhc3NpZ24gcHV0X2lfdGhcbiAgICAgIC0tIEl0ZW0gYXQgYGknLXRoIHBvc2l0aW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLml0ZW0gKGkgLSAxKVxuICAgIGVuZFxuXG4gIGZpcnN0OiBsaWtlIGl0ZW1cbiAgICAgIC0tIEl0ZW0gYXQgZmlyc3QgcG9zaXRpb25cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuaXRlbSAoMClcbiAgICBlbmRcblxuICBsYXN0OiBsaWtlIGZpcnN0XG4gICAgICAtLSBJdGVtIGF0IGxhc3QgcG9zaXRpb25cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuaXRlbSAoY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGluZGV4OiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBgaXRlbScsIGlmIHZhbGlkLlxuXG4gIGN1cnNvcjogQVJSQVlFRF9MSVNUX0NVUlNPUlxuICAgICAgLS0gQ3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpbmRleClcbiAgICBlbmRcblxuICBoYXMgKHY6IGxpa2UgaXRlbSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBpbmNsdWRlIGB2Jz9cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhX3YyXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYV92MlxuICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiBhbmQgdiAvPSBWb2lkIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSB2IH4gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSB2ID0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX2FycmF5OiBBUlJBWSBbR11cbiAgICAgIC0tIFNoYXJlIGNvbnRlbnQgdG8gYmUgdXNlZCBhcyBhbiBBUlJBWS5cbiAgICAgIC0tIE5vdGUgdGhhdCBhbHRob3VnaCB0aGUgY29udGVudCBpcyBzaGFyZWQsIGl0IG1pZ2h0XG4gICAgICAtLSBub3QgYmUgc2hhcmVkIHdoZW4gYSByZXNpemluZyBvY2N1ciBpbiBlaXRoZXIgQVJSQVkgb3IgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3BlY2lhbCAoYXJlYV92MilcbiAgICBlbnN1cmVcbiAgICAgIHRvX2FycmF5X2F0dGFjaGVkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgYXJyYXlfbG93ZXJfc2V0OiBSZXN1bHQubG93ZXIgPSAxXG4gICAgICBhcnJheV91cHBlcl9zZXQ6IFJlc3VsdC51cHBlciA9IGNvdW50XG4gICAgICBzaGFyZWRfYXJlYTogUmVzdWx0LmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICBkb1xuICAgICAgYXJlYV92Mi5kb19hbGxfaW5fYm91bmRzIChhY3Rpb24sIDAsIGFyZWFfdjIuY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGRvX2lmIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBvciBgdGVzdCcgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIGRvXG4gICAgICBhcmVhX3YyLmRvX2lmX2luX2JvdW5kcyAoYWN0aW9uLCB0ZXN0LCAwLCBhcmVhX3YyLmNvdW50IC0gMSlcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLnRoZXJlX2V4aXN0c19pbl9ib3VuZHMgKHRlc3QsIDAsIGFyZWFfdjIuY291bnQgLSAxKVxuICAgIGVuZFxuXG4gIGZvcl9hbGwgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYWxsIGl0ZW1zP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV92Mi5mb3JfYWxsX2luX2JvdW5kcyAodGVzdCwgMCwgYXJlYV92Mi5jb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZG9fYWxsX3dpdGhfaW5kZXggKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHLCBJTlRFR0VSXV0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBgYWN0aW9uJyByZWNlaXZlcyBpdGVtIGFuZCBpdHMgaW5kZXguXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhX3YyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAwXG4gICAgICAgIGogOj0gbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhX3YyXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYWN0aW9uLmNhbGwgKFtsX2FyZWEuaXRlbSAoaSksIGpdKVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2lmX3dpdGhfaW5kZXggKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHLCBJTlRFR0VSXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHLCBJTlRFR0VSXSwgQk9PTEVBTl0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gYGFjdGlvbicgYW5kIGB0ZXN0JyByZWNlaXZlIHRoZSBpdGVtIGFuZCBpdHMgaW5kZXguXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhX3YyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAwXG4gICAgICAgIGogOj0gbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhX3YyXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaWYgdGVzdC5pdGVtIChbbF9hcmVhLml0ZW0gKGkpLCBqXSkgdGhlblxuICAgICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBsb3dlcjogSU5URUdFUiA9IDFcbiAgICAgIC0tIExvd2VyIGJvdW5kIGZvciBhY2Nlc3NpbmcgbGlzdCBpdGVtcyB2aWEgaW5kZXhlc1xuXG4gIHVwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBVcHBlciBib3VuZCBmb3IgYWNjZXNzaW5nIGxpc3QgaXRlbXMgdmlhIGluZGV4ZXNcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuY291bnRcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGl0ZW1zXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX3YyLmNvdW50XG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuY2FwYWNpdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBhcnJheSBtYWRlIG9mIHRoZSBzYW1lIGl0ZW1zIGFzIGBvdGhlcic/XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VpZiBjb3VudCA9IG90aGVyLmNvdW50IGFuZCB0aGVuIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgbm90IFJlc3VsdCBvciBpID4gdXBwZXJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBSZXN1bHQgOj0gaV90aCAoaSkgfiBvdGhlci5pX3RoIChpKVxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IGFyZWFfdjIuc2FtZV9pdGVtcyAob3RoZXIuYXJlYV92MiwgMCwgMCwgY291bnQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICB2YWxpZF9jdXJzb3IgKHA6IENVUlNPUik6IEJPT0xFQU5cbiAgICAgIC0tIENhbiB0aGUgY3Vyc29yIGJlIG1vdmVkIHRvIHBvc2l0aW9uIGBwJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0FSUkFZRURfTElTVF9DVVJTT1J9IHAgYXMgYWxfYyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB2YWxpZF9jdXJzb3JfaW5kZXggKGFsX2MuaW5kZXgpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyBhIHZhbGlkIGluZGV4P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKDEgPD0gaSkgYW5kIChpIDw9IGNvdW50KVxuICAgIGVuZFxuXG4gIGlzX2luc2VydGVkICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gSGFzIGB2JyBiZWVuIGluc2VydGVkIGF0IHRoZSBlbmQgYnkgdGhlIG1vc3QgcmVjZW50IGBwdXQnIG9yXG4gICAgICAtLSBgZXh0ZW5kJz9cbiAgICBkb1xuICAgICAgaWYgbm90IGlzX2VtcHR5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh2ID0gbGFzdCkgb3IgZWxzZSAobm90IG9mZiBhbmQgdGhlbiAodiA9IGl0ZW0pKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYWxsX2RlZmF1bHQ6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgc2V0IHRvIGRlZmF1bHQgdmFsdWVzP1xuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV92Mi5maWxsZWRfd2l0aCAoKHtHfSkuZGVmYXVsdCwgMCwgYXJlYV92Mi51cHBlcilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDdXJzb3IgbW92ZW1lbnRcblxuICBtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBjdXJzb3IgYGknIHBvc2l0aW9ucy5cbiAgICBkb1xuICAgICAgaW5kZXggOj0gaW5kZXggKyBpXG4gICAgICBpZiAoaW5kZXggPiBjb3VudCArIDEpIHRoZW5cbiAgICAgICAgaW5kZXggOj0gY291bnQgKyAxXG4gICAgICBlbHNlaWYgKGluZGV4IDwgMCkgdGhlblxuICAgICAgICBpbmRleCA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzdGFydFxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gZmlyc3QgcG9zaXRpb24gaWYgYW55LlxuICAgIGRvXG4gICAgICBpbmRleCA6PSAxXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGFmdGVyX3doZW5fZW1wdHk6IGlzX2VtcHR5IGltcGxpZXMgYWZ0ZXJcbiAgICBlbmRcblxuICBmaW5pc2hcbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIGxhc3QgcG9zaXRpb24gaWYgYW55LlxuICAgIGRvXG4gICAgICBpbmRleCA6PSBjb3VudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBiZWZvcmVfd2hlbl9lbXB0eTogaXNfZW1wdHkgaW1wbGllcyBiZWZvcmVcbiAgICBlbmRcblxuICBmb3J0aFxuICAgICAgLS0gTW92ZSBjdXJzb3Igb25lIHBvc2l0aW9uIGZvcndhcmQuXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IGluZGV4ICsgMVxuICAgIGVuZFxuXG4gIGJhY2tcbiAgICAgIC0tIE1vdmUgY3Vyc29yIG9uZSBwb3NpdGlvbiBiYWNrd2FyZC5cbiAgICBkb1xuICAgICAgaW5kZXggOj0gaW5kZXggLSAxXG4gICAgZW5kXG5cbiAgZ29faV90aCAoaTogSU5URUdFUilcbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIGBpJy10aCBwb3NpdGlvbi5cbiAgICBkb1xuICAgICAgaW5kZXggOj0gaVxuICAgIGVuZFxuXG4gIGdvX3RvIChwOiBDVVJTT1IpXG4gICAgICAtLSBNb3ZlIGN1cnNvciB0byBwb3NpdGlvbiBgcCcuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtBUlJBWUVEX0xJU1RfQ1VSU09SfSBwIGFzIGFsX2MgdGhlblxuICAgICAgICBpbmRleCA6PSBhbF9jLmluZGV4XG4gICAgICBlbHNlXG4gICAgICAgIGNoZWNrXG4gICAgICAgICAgY29ycmVjdF9jdXJzb3JfdHlwZTogRmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzZWFyY2ggKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIE1vdmUgdG8gZmlyc3QgcG9zaXRpb24gKGF0IG9yIGFmdGVyIGN1cnJlbnRcbiAgICAgIC0tIHBvc2l0aW9uKSB3aGVyZSBgaXRlbScgYW5kIGB2JyBhcmUgZXF1YWwuXG4gICAgICAtLSBJZiBzdHJ1Y3R1cmUgZG9lcyBub3QgaW5jbHVkZSBgdicgZW5zdXJlIHRoYXRcbiAgICAgIC0tIGBleGhhdXN0ZWQnIHdpbGwgYmUgdHJ1ZS5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhX3YyXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9mb3VuZDogQk9PTEVBTlxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYV92MlxuICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIC0tIElmIHdlIGFyZSBiZWZvcmUgd2UgbmVlZCB0byBiZSBzdXJlXG4gICAgICAgIC0tIHRoYXQgaSBpcyBwb3NpdGl2ZS5cbiAgICAgIGkgOj0gKGluZGV4IC0gMSkubWF4ICgwKVxuICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gYW5kIHYgLz0gVm9pZCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgbF9mb3VuZFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9mb3VuZCA6PSB2IH4gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBsX2ZvdW5kXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX2ZvdW5kIDo9IHYgPSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICAgIC0tIFNldCBwb3NpdGlvbiBvZiBgaW5kZXgnIHRvIGBpJywgbG9jYXRpb24gb2YgaXRlbSB3aGVuXG4gICAgICAgIC0tIGZvdW5kLCBvdGhlcndpc2UgdG8gYGkgKyAxJyB3aGljaCBjb3JyZXNwb25kcyB0byBgYWZ0ZXInLlxuICAgICAgaWYgbF9mb3VuZCB0aGVuXG4gICAgICAgIGluZGV4IDo9IGlcbiAgICAgIGVsc2VcbiAgICAgICAgaW5kZXggOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0X2Zyb250ICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIHRoZSBiZWdpbm5pbmcuXG4gICAgICAtLSBEbyBub3QgbW92ZSBjdXJzb3IuXG4gICAgZG9cbiAgICAgIGlmIGlzX2VtcHR5IHRoZW5cbiAgICAgICAgZXh0ZW5kICh2KVxuICAgICAgZWxzZVxuICAgICAgICBpbnNlcnQgKHYsIDEpXG4gICAgICBlbmRcbiAgICAgIGluZGV4IDo9IGluZGV4ICsgMVxuICAgIGVuZFxuXG4gIHB1dF9pX3RoICh2OiBsaWtlIGlfdGg7IGk6IElOVEVHRVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYV92Mi5wdXQgKHYsIGkgLSAxKVxuICAgIGVuZFxuXG4gIGZvcmNlLCBleHRlbmQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIEFkZCBgdicgdG8gZW5kLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYV92MlxuICAgIGRvXG4gICAgICBpIDo9IGNvdW50ICsgMVxuICAgICAgbF9hcmVhIDo9IGFyZWFfdjJcbiAgICAgIGlmIGkgPiBsX2FyZWEuY2FwYWNpdHkgdGhlblxuICAgICAgICBsX2FyZWEgOj0gbF9hcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChpICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgYXJlYV92MiA6PSBsX2FyZWFcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhLmV4dGVuZCAodilcbiAgICBlbmRcblxuICBwdXRfbGVmdCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byB0aGUgbGVmdCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGRvXG4gICAgICBpZiBhZnRlciBvciBpc19lbXB0eSB0aGVuXG4gICAgICAgIGV4dGVuZCAodilcbiAgICAgIGVsc2VcbiAgICAgICAgaW5zZXJ0ICh2LCBpbmRleClcbiAgICAgIGVuZFxuICAgICAgaW5kZXggOj0gaW5kZXggKyAxXG4gICAgZW5kXG5cbiAgcHV0X3JpZ2h0ICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIHRoZSByaWdodCBvZiBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGRvXG4gICAgICBpZiBpbmRleCA9IGNvdW50IHRoZW5cbiAgICAgICAgZXh0ZW5kICh2KVxuICAgICAgZWxzZVxuICAgICAgICBpbnNlcnQgKHYsIGluZGV4ICsgMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlcGxhY2UgKHY6IGxpa2UgZmlyc3QpXG4gICAgICAtLSBSZXBsYWNlIGN1cnJlbnQgaXRlbSBieSBgdicuXG4gICAgZG9cbiAgICAgIHB1dF9pX3RoICh2LCBpbmRleClcbiAgICBlbmRcblxuICBtZXJnZV9sZWZ0IChvdGhlcjogQVJSQVlFRF9MSVNUIFtHXSlcbiAgICAgIC0tIE1lcmdlIGBvdGhlcicgaW50byBjdXJyZW50IHN0cnVjdHVyZSBiZWZvcmUgY3Vyc29yLlxuICAgIGxvY2FsXG4gICAgICBvbGRfaW5kZXg6IElOVEVHRVJcbiAgICAgIG9sZF9vdGhlcl9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBvbGRfaW5kZXggOj0gaW5kZXhcbiAgICAgIG9sZF9vdGhlcl9jb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW5kZXggOj0gaW5kZXggLSAxXG4gICAgICBtZXJnZV9yaWdodCAob3RoZXIpXG4gICAgICBpbmRleCA6PSBvbGRfaW5kZXggKyBvbGRfb3RoZXJfY291bnRcbiAgICBlbmRcblxuICBtZXJnZV9yaWdodCAob3RoZXI6IEFSUkFZRURfTElTVCBbR10pXG4gICAgICAtLSBNZXJnZSBgb3RoZXInIGludG8gY3VycmVudCBzdHJ1Y3R1cmUgYWZ0ZXIgY3Vyc29yLlxuICAgIGxvY2FsXG4gICAgICBsX25ld19jb3VudCwgbF9vbGRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgbm90IG90aGVyLmlzX2VtcHR5IHRoZW5cbiAgICAgICAgbF9vbGRfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfY291bnQgOj0gbF9vbGRfY291bnQgKyBvdGhlci5jb3VudFxuICAgICAgICBpZiBsX25ld19jb3VudCA+IGFyZWFfdjIuY2FwYWNpdHkgdGhlblxuICAgICAgICAgIGFyZWFfdjIgOj0gYXJlYV92Mi5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobF9uZXdfY291bnQpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhX3YyLmluc2VydF9kYXRhIChvdGhlci5hcmVhX3YyLCAwLCBpbmRleCwgb3RoZXIuY291bnQpXG4gICAgICAgIG90aGVyLndpcGVfb3V0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFNFUVVFTkNFIFtHXSlcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLlxuICAgIGxvY2FsXG4gICAgICBjLCBvbGRfY291bnQsIG5ld19jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7QVJSQVlFRF9MSVNUIFtHXX0gcyBhcyBhbCB0aGVuIC0tIE9wdGltaXphdGlvbiBmb3IgYXJyYXllZCBsaXN0c1xuICAgICAgICBjIDo9IGFsLmNvdW50XG4gICAgICAgICAgLS0gSWYgYHMnIGlzIGVtcHR5IG5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgaWYgYyA+IDAgdGhlblxuICAgICAgICAgIG9sZF9jb3VudCA6PSBjb3VudFxuICAgICAgICAgIG5ld19jb3VudCA6PSBvbGRfY291bnQgKyBhbC5jb3VudFxuICAgICAgICAgIGlmIG5ld19jb3VudCA+IGFyZWFfdjIuY2FwYWNpdHkgdGhlblxuICAgICAgICAgICAgYXJlYV92MiA6PSBhcmVhX3YyLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuZXdfY291bnQpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgYXJlYV92Mi5jb3B5X2RhdGEgKGFsLmFyZWFfdjIsIDAsIG9sZF9jb3VudCwgYylcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7RFlOQU1JQ19MSVNUfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgZ3JvdyAoaTogSU5URUdFUilcbiAgICAgIC0tIENoYW5nZSB0aGUgY2FwYWNpdHkgdG8gYXQgbGVhc3QgYGknLlxuICAgIGRvXG4gICAgICBpZiBpID4gYXJlYV92Mi5jYXBhY2l0eSB0aGVuXG4gICAgICAgIGFyZWFfdjIgOj0gYXJlYV92Mi5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3X2NhcGFjaXR5OiBJTlRFR0VSKVxuICAgICAgLS0gUmVzaXplIGxpc3Qgc28gdGhhdCBpdCBjYW4gY29udGFpblxuICAgICAgLS0gYXQgbGVhc3QgYG4nIGl0ZW1zLiBEbyBub3QgbG9zZSBhbnkgaXRlbS5cbiAgICByZXF1aXJlXG4gICAgICByZXNpemFibGU6IHJlc2l6YWJsZVxuICAgICAgbmV3X2NhcGFjaXR5X2xhcmdlX2Vub3VnaDogbmV3X2NhcGFjaXR5ID49IGNhcGFjaXR5XG4gICAgZG9cbiAgICAgIGdyb3cgKG5ld19jYXBhY2l0eSlcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X3NldDogY2FwYWNpdHkgPj0gbmV3X2NhcGFjaXR5XG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuIDo9IGNvdW50XG4gICAgICBpZiBuIDwgYXJlYV92Mi5jYXBhY2l0eSB0aGVuXG4gICAgICAgIGFyZWFfdjIgOj0gYXJlYV92Mi5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYW1lX2l0ZW1zOiB0b19hcnJheS5zYW1lX2l0ZW1zIChvbGQgdG9fYXJyYXkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBjb3B5IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gUmVpbml0aWFsaXplIGJ5IGNvcHlpbmcgYWxsIHRoZSBpdGVtcyBvZiBgb3RoZXInLlxuICAgICAgLS0gKFRoaXMgaXMgYWxzbyB1c2VkIGJ5IGBjbG9uZScuKVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgc3RhbmRhcmRfY29weSAob3RoZXIpXG4gICAgICAgIHNldF9hcmVhIChvdGhlci5hcmVhX3YyLnR3aW4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZXF1YWxfYXJlYXM6IGFyZWFfdjIgfiBvdGhlci5hcmVhX3YyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHBydW5lICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdicsIGlmIGFueSxcbiAgICAgIC0tIGFmdGVyIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIHJpZ2h0IG5laWdoYm9yLlxuICAgICAgLS0gKG9yIGBhZnRlcicgaWYgbm8gcmlnaHQgbmVpZ2hib3Igb3IgYHYnIGRvZXMgbm90IG9jY3VyKVxuICAgIGRvXG4gICAgICBpZiBiZWZvcmUgdGhlblxuICAgICAgICBpbmRleCA6PSAxXG4gICAgICBlbmRcbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGFmdGVyIG9yIGVsc2UgaXRlbSB+IHZcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGZvcnRoXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgYWZ0ZXIgb3IgZWxzZSBpdGVtID0gdlxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIG5vdCBhZnRlciB0aGVuXG4gICAgICAgIHJlbW92ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVtb3ZlXG4gICAgICAtLSBSZW1vdmUgY3VycmVudCBpdGVtLlxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gcmlnaHQgbmVpZ2hib3JcbiAgICAgIC0tIChvciBgYWZ0ZXInIGlmIG5vIHJpZ2h0IG5laWdoYm9yKVxuICAgIGRvXG4gICAgICBpZiBpbmRleCA8IGNvdW50IHRoZW5cbiAgICAgICAgYXJlYV92Mi5tb3ZlX2RhdGEgKGluZGV4LCBpbmRleCAtIDEsIGNvdW50IC0gaW5kZXgpXG4gICAgICBlbmRcbiAgICAgIGFyZWFfdjIucmVtb3ZlX3RhaWwgKDEpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGluZGV4OiBpbmRleCA9IG9sZCBpbmRleFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiBgdicuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgb2Zmc2V0OiBJTlRFR0VSXG4gICAgICByZXM6IEJPT0xFQU5cbiAgICAgIG9ial9jbXA6IEJPT0xFQU5cbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhX3YyXG4gICAgZG9cbiAgICAgIG9ial9jbXAgOj0gb2JqZWN0X2NvbXBhcmlzb25cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFfdjJcbiAgICAgICAgaSA6PSAwXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgaWYgaSA8IG5iIC0gb2Zmc2V0IHRoZW5cbiAgICAgICAgICBpZiBvZmZzZXQgPiAwIHRoZW5cbiAgICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChpICsgb2Zmc2V0KSwgaSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpZiBvYmpfY21wIHRoZW5cbiAgICAgICAgICAgIHJlcyA6PSB2IH4gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzIDo9IHYgPSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpZiByZXMgdGhlblxuICAgICAgICAgICAgb2Zmc2V0IDo9IG9mZnNldCArIDFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBsX2FyZWEucmVtb3ZlX3RhaWwgKG9mZnNldClcbiAgICAgIGluZGV4IDo9IGNvdW50ICsgMVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19hZnRlcjogYWZ0ZXJcbiAgICBlbmRcblxuICByZW1vdmVfbGVmdFxuICAgICAgLS0gUmVtb3ZlIGl0ZW0gdG8gdGhlIGxlZnQgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGRvXG4gICAgICBpbmRleCA6PSBpbmRleCAtIDFcbiAgICAgIHJlbW92ZVxuICAgIGVuZFxuXG4gIHJlbW92ZV9yaWdodFxuICAgICAgLS0gUmVtb3ZlIGl0ZW0gdG8gdGhlIHJpZ2h0IG9mIGN1cnNvciBwb3NpdGlvblxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yXG4gICAgZG9cbiAgICAgIGluZGV4IDo9IGluZGV4ICsgMVxuICAgICAgcmVtb3ZlXG4gICAgICBpbmRleCA6PSBpbmRleCAtIDFcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcy5cbiAgICBkb1xuICAgICAgYXJlYV92Mi53aXBlX291dFxuICAgICAgaW5kZXggOj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgc3dhcCAoaTogSU5URUdFUilcbiAgICAgIC0tIEV4Y2hhbmdlIGl0ZW0gYXQgYGknLXRoIHBvc2l0aW9uIHdpdGggaXRlbVxuICAgICAgLS0gYXQgY3Vyc29yIHBvc2l0aW9uLlxuICAgIGxvY2FsXG4gICAgICBvbGRfaXRlbTogbGlrZSBpdGVtXG4gICAgZG9cbiAgICAgIG9sZF9pdGVtIDo9IGl0ZW1cbiAgICAgIHJlcGxhY2UgKGFyZWFfdjIuaXRlbSAoaSAtIDEpKVxuICAgICAgYXJlYV92Mi5wdXQgKG9sZF9pdGVtLCBpIC0gMSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXRyaWV2YWxcblxuICBjb3JyZWN0X21pc21hdGNoXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWZcbiAgICAgICAgbm90IG1pc21hdGNoX2luZm9ybWF0aW9uLmhhcyAoXCJhcmVhX3YyXCIpIGFuZCB0aGVuXG4gICAgICAgIGF0dGFjaGVkIHtTUEVDSUFMIFtHXX0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJhcmVhXCIpIGFzIGxfYXJlYSBhbmQgdGhlblxuICAgICAgICBhdHRhY2hlZCB7SU5URUdFUn0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJjb3VudFwiKSBhcyBsX2NvdW50IGFuZCB0aGVuXG4gICAgICAgIGF0dGFjaGVkIHtCT09MRUFOfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcIm9iamVjdF9jb21wYXJpc29uXCIpIGFzIGxfY29tcCBhbmQgdGhlblxuICAgICAgICBhdHRhY2hlZCB7SU5URUdFUn0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJpbmRleFwiKSBhcyBsX2luZGV4XG4gICAgICB0aGVuXG4gICAgICAgIGNyZWF0ZSBhcmVhX3YyLm1ha2VfZW1wdHkgKGxfY291bnQpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDBcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbF9jb3VudFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXJlYV92Mi5leHRlbmQgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBvYmplY3RfY29tcGFyaXNvbiA6PSBsX2NvbXBcbiAgICAgICAgaW5kZXggOj0gbF9pbmRleFxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgZHVwbGljYXRlIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1Yi1saXN0IGJlZ2lubmluZyBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAtLSBhbmQgaGF2aW5nIG1pbiAoYG4nLCBgY291bnQnIC0gYGluZGV4JyArIDEpIGl0ZW1zLlxuICAgIGxvY2FsXG4gICAgICBlbmRfcG9zOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGFmdGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IG5ld19maWxsZWRfbGlzdCAoMClcbiAgICAgIGVsc2VcbiAgICAgICAgZW5kX3BvcyA6PSBjb3VudC5taW4gKGluZGV4ICsgbiAtIDEpXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfZmlsbGVkX2xpc3QgKGVuZF9wb3MgLSBpbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhX3YyLmNvcHlfZGF0YSAoYXJlYV92MiwgaW5kZXggLSAxLCAwLCBlbmRfcG9zIC0gaW5kZXggKyAxKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluYXBwbGljYWJsZVxuXG4gIG5ld19jaGFpbjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbnVzZWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmb3JjZV9pX3RoICh2OiBsaWtlIGlfdGg7IHBvczogSU5URUdFUilcbiAgICBkb1xuICAgICAgaWYgY291bnQgKyAxID4gY2FwYWNpdHkgdGhlblxuICAgICAgICBncm93IChjb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWFfdjIuZm9yY2UgKHYsIHBvcylcbiAgICBlbmRcblxuICBpbnNlcnQgKHY6IGxpa2UgaXRlbTsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQWRkIGB2JyBhdCBgcG9zJywgbW92aW5nIHN1YnNlcXVlbnQgaXRlbXNcbiAgICAgIC0tIHRvIHRoZSByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IHBvcyA8PSBjb3VudFxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBwb3MgPj0gMVxuICAgIGRvXG4gICAgICBpZiBjb3VudCArIDEgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGdyb3cgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgYXJlYV92Mi5tb3ZlX2RhdGEgKHBvcyAtIDEsIHBvcywgY291bnQgLSBwb3MgKyAxKVxuICAgICAgcHV0X2lfdGggKHYsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBpbmRleF91bmNoYW5nZWQ6IGluZGV4ID0gb2xkIGluZGV4XG4gICAgICBpbnNlcnRpb25fZG9uZTogaV90aCAocG9zKSA9IHZcbiAgICBlbmRcblxuICBuZXdfZmlsbGVkX2xpc3QgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBsaXN0IHdpdGggYG4nIGVsZW1lbnRzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49MFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBuZXdfZmlsbGVkX2xpc3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfZmlsbGVkX2xpc3RfY291bnRfc2V0OiBSZXN1bHQuY291bnQgPSAwXG4gICAgICBuZXdfZmlsbGVkX2xpc3RfYmVmb3JlOiBSZXN1bHQuYmVmb3JlXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBwcnVuYWJsZTogcHJ1bmFibGVcbiAgc3RhcnRzX2Zyb21fb25lOiBsb3dlciA9IDFcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGJhZywgYWNjZXNzO1xuICBhY2Nlc3M6IG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQkFHIFtHXSBpbmhlcml0XG5cbiAgQ09MTEVDVElPTiBbR11cbiAgICByZWRlZmluZVxuICAgICAgZXh0ZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBvY2N1cnJlbmNlcyAodjogRyk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycyBpbiBzdHJ1Y3R1cmVcbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9vY2N1cnJlbmNlczogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBhIG5ldyBvY2N1cnJlbmNlIG9mIGB2Jy5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICAgIC0tIENvbW1lbnRlZCBkdWUgdG8gdGhlIGV4cGVuc2l2ZSBuYXR1cmUgb2YgdGhlIGNoZWNrIHdoZW4gaW5zZXJ0aW5nIGEgbmV3IGl0ZW1cbiAgICAgICAgLS0gaW4gYSBjb250YWluZXJzIHdpdGggbWFueSBpdGVtcy5cbiAgICAgIC0tIG9uZV9tb3JlX29jY3VycmVuY2U6IG9jY3VycmVuY2VzICh2KSA9IG9sZCAob2NjdXJyZW5jZXMgKHYpKSArIDFcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZXMgdGhhdCBtYXkgYmUgdHJhdmVyc2VkIGZvcndhcmQgYW5kIGJhY2t3YXJkXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogYmlkaXJlY3Rpb25hbCwgdHJhdmVyc2luZztcbiAgYWNjZXNzOiBjdXJzb3IsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQklMSU5FQVIgW0ddIGluaGVyaXRcblxuICBMSU5FQVIgW0ddXG4gICAgcmVuYW1lXG4gICAgICBzZWFyY2ggYXMgc2VxdWVudGlhbF9zZWFyY2hcbiAgICBleHBvcnRcbiAgICAgIHtOT05FfVxuICAgICAgICBzZXF1ZW50aWFsX3NlYXJjaFxuICAgIHJlZGVmaW5lXG4gICAgICBvZmZcbiAgICBlbmRcblxuICBMSU5FQVIgW0ddXG4gICAgcmVkZWZpbmVcbiAgICAgIHNlYXJjaCwgb2ZmXG4gICAgc2VsZWN0XG4gICAgICBzZWFyY2hcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBvZmY6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIGN1cnJlbnQgaXRlbT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGJlZm9yZSBvciBhZnRlclxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEN1cnNvciBtb3ZlbWVudFxuXG4gIGJlZm9yZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gdmFsaWQgcG9zaXRpb24gdG8gdGhlIGxlZnQgb2YgY3VycmVudCBvbmU/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBiYWNrXG4gICAgICAtLSBNb3ZlIHRvIHByZXZpb3VzIHBvc2l0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9iZWZvcmU6IG5vdCBiZWZvcmVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICAtLSBtb3ZlZF9mb3J0aF9hZnRlcl9zdGFydDogKG5vdCBiZWZvcmUpIGltcGxpZXMgaW5kZXggPSBvbGQgaW5kZXggLSAxXG4gICAgZW5kXG5cbiAgc2VhcmNoICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBNb3ZlIHRvIGZpcnN0IHBvc2l0aW9uIChhdCBvciBhZnRlciBjdXJyZW50XG4gICAgICAtLSBwb3NpdGlvbikgd2hlcmUgYGl0ZW0nIGFuZCBgdicgYXJlIGVxdWFsLlxuICAgICAgLS0gSWYgc3RydWN0dXJlIGRvZXMgbm90IGluY2x1ZGUgYHYnIGVuc3VyZSB0aGF0XG4gICAgICAtLSBgZXhoYXVzdGVkJyB3aWxsIGJlIHRydWUuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGRvXG4gICAgICBpZiBiZWZvcmUgYW5kIG5vdCBpc19lbXB0eSB0aGVuXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcbiAgICAgIHNlcXVlbnRpYWxfc2VhcmNoICh2KVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBub3RfYm90aDogbm90IChhZnRlciBhbmQgYmVmb3JlKVxuICBiZWZvcmVfY29uc3RyYWludDogYmVmb3JlIGltcGxpZXMgb2ZmXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJUcnV0aCB2YWx1ZXMsIHdpdGggdGhlIGJvb2xlYW4gb3BlcmF0aW9uc1wiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLkJvb2xlYW5cIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBCT09MRUFOXG5cbmluaGVyaXRcbiAgQk9PTEVBTl9SRUZcbiAgICByZWRlZmluZVxuICAgICAgY29uanVuY3RlZCxcbiAgICAgIGNvbmp1bmN0ZWRfc2VtaXN0cmljdCxcbiAgICAgIGRpc2p1bmN0ZWQsXG4gICAgICBkaXNqdW5jdGVkX3NlbWlzdHJpY3QsXG4gICAgICBkaXNqdW5jdGVkX2V4Y2x1c2l2ZSxcbiAgICAgIGltcGxpY2F0aW9uLFxuICAgICAgbmVnYXRlZFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Qk9PTEVBTl9SRUZ9KVxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBjb25qdW5jdGVkIGFsaWFzIFwiYW5kXCIgKG90aGVyOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBjb25qdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgY29uanVuY3RlZF9zZW1pc3RyaWN0IGFsaWFzIFwiYW5kIHRoZW5cIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHNlbWktc3RyaWN0IGNvbmp1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbXBsaWNhdGlvbiBhbGlhcyBcImltcGxpZXNcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGltcGxpY2F0aW9uIG9mIGBvdGhlcidcbiAgICAgIC0tIChzZW1pLXN0cmljdClcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbmVnYXRlZCBhbGlhcyBcIm5vdFwiOiBCT09MRUFOXG4gICAgICAtLSBOZWdhdGlvblxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkIGFsaWFzIFwib3JcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkX3NlbWlzdHJpY3QgYWxpYXMgXCJvciBlbHNlXCIgKG90aGVyOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBzZW1pLXN0cmljdCBkaXNqdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZF9leGNsdXNpdmUgYWxpYXMgXCJ4b3JcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGV4Y2x1c2l2ZSBvciB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYSBib29sZWFuIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3MgQk9PTEVBTl9SRUYgaW5oZXJpdFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBCT09MRUFOX1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IEJPT0xFQU5fUkVGXG4gICAgICAtLSBBc3NvY2lhdGVkIHJlZmVyZW5jZSBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfaXRlbTogUmVzdWx0Lml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcjogSU5URUdFUlxuICAgICAgLS0gMSBpZiBgVHJ1ZSdcbiAgICAgIC0tIDAgaWYgYEZhbHNlJ1xuICAgIGRvXG4gICAgICBpZiBpdGVtIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbm90X2l0ZW1faW1wbGllc196ZXJvOiBub3QgaXRlbSBpbXBsaWVzIFJlc3VsdCA9IDBcbiAgICAgIGl0ZW1faW1wbGllc19vbmU6IGl0ZW0gaW1wbGllcyBSZXN1bHQgPSAxXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoYjogQk9PTEVBTilcbiAgICAgIC0tIE1ha2UgYGInIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBjb25qdW5jdGVkIGFsaWFzIFwiYW5kXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGNvbmp1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBhbmQgb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVfbW9yZ2FuOiBSZXN1bHQgPSBub3QgKG5vdCBDdXJyZW50IG9yIG5vdCBvdGhlcilcbiAgICAgIGNvbW11dGF0aXZlOiBSZXN1bHQgPSAob3RoZXIgYW5kIEN1cnJlbnQpXG4gICAgICBjb25zaXN0ZW50X3dpdGhfc2VtaV9zdHJpY3Q6IFJlc3VsdCBpbXBsaWVzIChDdXJyZW50IGFuZCB0aGVuIG90aGVyKVxuICAgIGVuZFxuXG4gIGNvbmp1bmN0ZWRfc2VtaXN0cmljdCBhbGlhcyBcImFuZCB0aGVuXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHNlbWktc3RyaWN0IGNvbmp1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBhbmQgdGhlbiBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZV9tb3JnYW46IFJlc3VsdCA9IG5vdCAobm90IEN1cnJlbnQgb3IgZWxzZSBub3Qgb3RoZXIpXG4gICAgZW5kXG5cbiAgaW1wbGljYXRpb24gYWxpYXMgXCJpbXBsaWVzXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGltcGxpY2F0aW9uIG9mIGBvdGhlcidcbiAgICAgIC0tIChzZW1pLXN0cmljdClcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gaW1wbGllcyBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAobm90IEN1cnJlbnQgb3IgZWxzZSBvdGhlcilcbiAgICBlbmRcblxuICBuZWdhdGVkIGFsaWFzIFwibm90XCI6IEJPT0xFQU5cbiAgICAgIC0tIE5lZ2F0aW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBub3QgaXRlbVxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWQgYWxpYXMgXCJvclwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBkaXNqdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gb3Igb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVfbW9yZ2FuOiBSZXN1bHQgPSBub3QgKG5vdCBDdXJyZW50IGFuZCBub3Qgb3RoZXIpXG4gICAgICBjb21tdXRhdGl2ZTogUmVzdWx0ID0gKG90aGVyIG9yIEN1cnJlbnQpXG4gICAgICBjb25zaXN0ZW50X3dpdGhfc2VtaV9zdHJpY3Q6IFJlc3VsdCBpbXBsaWVzIChDdXJyZW50IG9yIGVsc2Ugb3RoZXIpXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZF9zZW1pc3RyaWN0IGFsaWFzIFwib3IgZWxzZVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBzZW1pLXN0cmljdCBkaXNqdW5jdGlvbiB3aXRoIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gb3IgZWxzZSBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZV9tb3JnYW46IFJlc3VsdCA9IG5vdCAobm90IEN1cnJlbnQgYW5kIHRoZW4gbm90IG90aGVyKVxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWRfZXhjbHVzaXZlIGFsaWFzIFwieG9yXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGV4Y2x1c2l2ZSBvciB3aXRoIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0geG9yIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9ICgoQ3VycmVudCBvciBvdGhlcikgYW5kIG5vdCAoQ3VycmVudCBhbmQgb3RoZXIpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYm9vbGVhblxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gXCJGYWxzZVwiXG4gICAgICBpZiBpdGVtIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFwiVHJ1ZVwiXG4gICAgICBlbmRcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGludm9sdXRpdmVfbmVnYXRpb246IChub3QgKG5vdCBDdXJyZW50KSkuaXRlbSA9IGl0ZW1cbiAgbm9uX2NvbnRyYWRpY3Rpb246IG5vdCAoKG5vdCBDdXJyZW50KSBhbmQgQ3VycmVudClcbiAgY29tcGxldGVuZXNzOiAobm90IEN1cnJlbnQpIG9yIEN1cnJlbnRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQm91bmRlZCBkYXRhIHN0cnVjdHVyZXMsIHdpdGggYSBub3Rpb24gb2YgY2FwYWNpdHkuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogYm91bmRlZCwgc3RvcmFnZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEJPVU5ERUQgW0ddIGluaGVyaXRcblxuICBGSU5JVEUgW0ddXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGl0ZW1zIHRoYXQgbWF5IGJlIHN0b3JlZFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjYXBhY2l0eV9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGZ1bGw6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBmdWxsP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNvdW50ID0gY2FwYWNpdHkpXG4gICAgZW5kXG5cbiAgcmVzaXphYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgYGNhcGFjaXR5JyBiZSBjaGFuZ2VkP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIHZhbGlkX2NvdW50OiBjb3VudCA8PSBjYXBhY2l0eVxuICBmdWxsX2RlZmluaXRpb246IGZ1bGwgPSAoY291bnQgPSBjYXBhY2l0eSlcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHN0b3JhZ2U7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBCT1ggW0ddIGluaGVyaXRcblxuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGZ1bGw6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBmaWxsZWQgdG8gY2FwYWNpdHk/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDZWxscyBjb250YWluaW5nIGFuIGl0ZW1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBjZWxsO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmNsYXNzIENFTEwgW0ddXG5cbmNyZWF0ZVxuICBwdXRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBHXG4gICAgICAtLSBDb250ZW50IG9mIGNlbGwuXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQsIHJlcGxhY2UgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIE1ha2UgYHYnIHRoZSBjZWxsJ3MgYGl0ZW0nLlxuICAgIGRvXG4gICAgICBpdGVtIDo9IHZcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGl0ZW0gPSB2XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgUG9zc2libHkgY2lyY3VsYXIgc2VxdWVuY2VzIG9mIGl0ZW1zLFxuICAgIHdpdGhvdXQgY29tbWl0bWVudCB0byBhIHBhcnRpY3VsYXIgcmVwcmVzZW50YXRpb25cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogY2hhaW4sIHNlcXVlbmNlO1xuICBhY2Nlc3M6IGluZGV4LCBjdXJzb3IsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEzLTAxLTE1IDEzOjQxOjIyIC0wODAwIChUdWUsIDE1IEphbiAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjEyMiAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQ0hBSU4gW0ddIGluaGVyaXRcblxuICBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIHJlbmFtZVxuICAgICAgcHV0IGFzIHNlcXVlbmNlX3B1dFxuICAgIHVuZGVmaW5lXG4gICAgICBwcnVuZV9hbGxcbiAgICByZWRlZmluZVxuICAgICAgZmlsbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIGl0ZW0gYXMgaV90aCBhbGlhcyBcIltdXCIsXG4gICAgICBwdXQgYXMgcHV0X2lfdGgsXG4gICAgICBiYWdfcHV0IGFzIHNlcXVlbmNlX3B1dFxuICAgIHVuZGVmaW5lXG4gICAgICBwcnVuZV9hbGwsIHNlcXVlbmNlX3B1dFxuICAgIHJlZGVmaW5lXG4gICAgICBmaWxsXG4gICAgZW5kXG5cbiAgU0VRVUVOQ0UgW0ddXG4gICAgcmVuYW1lXG4gICAgICBwdXQgYXMgc2VxdWVuY2VfcHV0XG4gICAgZXhwb3J0XG4gICAgICB7Tk9ORX0gc2VxdWVuY2VfcHV0XG4gICAgcmVkZWZpbmVcbiAgICAgIGluZGV4X29mLCBoYXMsIG9mZiwgb2NjdXJyZW5jZXMsIGZpbGwsIGFwcGVuZFxuICAgIHNlbGVjdFxuICAgICAgaW5kZXhfb2YsIGhhcywgb2NjdXJyZW5jZXNcbiAgICBlbmRcblxuICBTRVFVRU5DRSBbR11cbiAgICByZW5hbWVcbiAgICAgIHB1dCBhcyBzZXF1ZW5jZV9wdXQsXG4gICAgICBpbmRleF9vZiBhcyBzZXF1ZW50aWFsX2luZGV4X29mLFxuICAgICAgaGFzIGFzIHNlcXVlbnRpYWxfaGFzLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgc2VxdWVudGlhbF9vY2N1cnJlbmNlc1xuICAgIGV4cG9ydFxuICAgICAge05PTkV9XG4gICAgICAgIHNlcXVlbnRpYWxfaW5kZXhfb2YsIHNlcXVlbnRpYWxfaGFzLFxuICAgICAgICBzZXF1ZW5jZV9wdXQsIHNlcXVlbnRpYWxfb2NjdXJyZW5jZXNcbiAgICByZWRlZmluZVxuICAgICAgb2ZmLCBmaWxsLCBhcHBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBmaXJzdDogbGlrZSBpdGVtXG4gICAgICAtLSBJdGVtIGF0IGZpcnN0IHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2VtcHR5OiBub3QgaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgcG9zOiBDVVJTT1JcbiAgICBkb1xuICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgc3RhcnRcbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgICBnb190byAocG9zKVxuICAgIGVuZFxuXG4gIGxhc3Q6IGxpa2UgaXRlbVxuICAgICAgLS0gSXRlbSBhdCBsYXN0IHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2VtcHR5OiBub3QgaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgcG9zOiBDVVJTT1JcbiAgICBkb1xuICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgZmluaXNoXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgICAgZ29fdG8gKHBvcylcbiAgICBlbmRcblxuICBoYXMgKHY6IGxpa2UgaXRlbSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY2hhaW4gaW5jbHVkZSBgdic/XG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuXG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIFJlc3VsdCA6PSBzZXF1ZW50aWFsX2hhcyAodilcbiAgICAgIGdvX3RvIChwb3MpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKHY6IGxpa2UgaXRlbTsgaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIEluZGV4IG9mIGBpJy10aCBvY2N1cnJlbmNlIG9mIGl0ZW0gaWRlbnRpY2FsIHRvIGB2Jy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgZG9cbiAgICAgIHBvcyA6PSBjdXJzb3JcbiAgICAgIFJlc3VsdCA6PSBzZXF1ZW50aWFsX2luZGV4X29mICh2LCBpKVxuICAgICAgZ29fdG8gKHBvcylcbiAgICBlbmRcblxuICBpX3RoIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBsaWtlIGl0ZW0gYXNzaWduIHB1dF9pX3RoXG4gICAgICAtLSBJdGVtIGF0IGBpJy10aCBwb3NpdGlvblxuICAgIGxvY2FsXG4gICAgICBwb3M6IENVUlNPUlxuICAgIGRvXG4gICAgICBwb3MgOj0gY3Vyc29yXG4gICAgICBnb19pX3RoIChpKVxuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGdvX3RvIChwb3MpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBvY2N1cnJlbmNlcyAodjogbGlrZSBpdGVtKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGB2JyBhcHBlYXJzLlxuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBsb2NhbFxuICAgICAgcG9zOiBDVVJTT1JcbiAgICBkb1xuICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgUmVzdWx0IDo9IHNlcXVlbnRpYWxfb2NjdXJyZW5jZXMgKHYpXG4gICAgICBnb190byAocG9zKVxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSwgY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNvdW50X2RlZmluaXRpb246IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgc3RhcnRcbiAgICAgIC0tIE1vdmUgY3Vyc29yIHRvIGZpcnN0IHBvc2l0aW9uLlxuICAgICAgLS0gKE5vIGVmZmVjdCBpZiBlbXB0eSlcbiAgICBkb1xuICAgICAgaWYgbm90IGlzX2VtcHR5IHRoZW5cbiAgICAgICAgZ29faV90aCAoMSlcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBhdF9maXJzdDogbm90IGlzX2VtcHR5IGltcGxpZXMgaXNmaXJzdFxuICAgIGVuZFxuXG4gIGZpbmlzaFxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gbGFzdCBwb3NpdGlvbi5cbiAgICAgIC0tIChObyBlZmZlY3QgaWYgZW1wdHkpXG4gICAgZG9cbiAgICAgIGlmIG5vdCBpc19lbXB0eSB0aGVuXG4gICAgICAgIGdvX2lfdGggKGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGF0X2xhc3Q6IG5vdCBpc19lbXB0eSBpbXBsaWVzIGlzbGFzdFxuICAgIGVuZFxuXG4gIG1vdmUgKGk6IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGN1cnNvciBgaScgcG9zaXRpb25zLiBUaGUgY3Vyc29yXG4gICAgICAtLSBtYXkgZW5kIHVwIGBvZmYnIGlmIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgaSdcbiAgICAgIC0tIGlzIHRvbyBiaWcuXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXIsIHBvcywgZmluYWw6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgaSA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgKGNvdW50ZXIgPSBpKSBvciBlbHNlIGFmdGVyXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBmb3J0aFxuICAgICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlaWYgaSA8IDAgdGhlblxuICAgICAgICBmaW5hbCA6PSBpbmRleCArIGlcbiAgICAgICAgaWYgZmluYWwgPD0gMCB0aGVuXG4gICAgICAgICAgc3RhcnRcbiAgICAgICAgICBiYWNrXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgcG9zIDo9IDFcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgcG9zID0gZmluYWxcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBmb3J0aFxuICAgICAgICAgICAgcG9zIDo9IHBvcyArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRvb19mYXJfcmlnaHQ6IChvbGQgaW5kZXggKyBpID4gY291bnQpIGltcGxpZXMgZXhoYXVzdGVkXG4gICAgICB0b29fZmFyX2xlZnQ6IChvbGQgaW5kZXggKyBpIDwgMSkgaW1wbGllcyBleGhhdXN0ZWRcbiAgICAgIGV4cGVjdGVkX2luZGV4OiAobm90IGV4aGF1c3RlZCkgaW1wbGllcyAoaW5kZXggPSBvbGQgaW5kZXggKyBpKVxuICAgIGVuZFxuXG4gIGdvX2lfdGggKGk6IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGN1cnNvciB0byBgaSctdGggcG9zaXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY3Vyc29yX2luZGV4OiB2YWxpZF9jdXJzb3JfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIG1vdmUgKGkgLSBpbmRleClcbiAgICBlbnN1cmVcbiAgICAgIHBvc2l0aW9uX2V4cGVjdGVkOiBpbmRleCA9IGlcbiAgICBlbmRcblxuIGZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiBhbGxvd2FibGUgYm91bmRzP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGkgPj0gMSkgYW5kIChpIDw9IGNvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWxpZF9pbmRleF9kZWZpbml0aW9uOiBSZXN1bHQgPSAoKGkgPj0gMSkgYW5kIChpIDw9IGNvdW50KSlcbiAgICBlbmRcblxuXG4gIGlzZmlyc3Q6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnNvciBhdCBmaXJzdCBwb3NpdGlvbj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBpc19lbXB0eSBhbmQgKGluZGV4ID0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBSZXN1bHQgaW1wbGllcyBub3QgaXNfZW1wdHlcbiAgICBlbmRcblxuICBpc2xhc3Q6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnNvciBhdCBsYXN0IHBvc2l0aW9uP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbm90IGlzX2VtcHR5IGFuZCAoaW5kZXggPSBjb3VudClcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBSZXN1bHQgaW1wbGllcyBub3QgaXNfZW1wdHlcbiAgICBlbmRcblxuICBvZmY6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIGN1cnJlbnQgaXRlbT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpbmRleCA9IDApIG9yIChpbmRleCA9IGNvdW50ICsgMSlcbiAgICBlbmRcblxuXG4gIHZhbGlkX2N1cnNvcl9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyBjb3JyZWN0bHkgYm91bmRlZCBmb3IgY3Vyc29yIG1vdmVtZW50P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGkgPj0gMCkgYW5kIChpIDw9IGNvdW50ICsgMSlcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2N1cnNvcl9pbmRleF9kZWZpbml0aW9uOiBSZXN1bHQgPSAoKGkgPj0gMCkgYW5kIChpIDw9IGNvdW50ICsgMSkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIFJlcGxhY2UgY3VycmVudCBpdGVtIGJ5IGB2Jy5cbiAgICAgIC0tIChTeW5vbnltIGZvciBgcmVwbGFjZScpXG4gICAgcmVxdWlyZVxuICAgICAgd3JpdGVhYmxlOiB3cml0YWJsZVxuICAgICAgcmVwbGFjZWFibGU6IHJlcGxhY2VhYmxlXG4gICAgZG9cbiAgICAgIHJlcGxhY2UgKHYpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgaXNfaW5zZXJ0ZWQ6IGlzX2luc2VydGVkICh2KVxuICAgIGVuZFxuXG4gIHB1dF9pX3RoICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IGBpJy10aCBwb3NpdGlvbi5cbiAgICBsb2NhbFxuICAgICAgcG9zOiBDVVJTT1JcbiAgICBkb1xuICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgZ29faV90aCAoaSlcbiAgICAgIHJlcGxhY2UgKHYpXG4gICAgICBnb190byAocG9zKVxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogU0VRVUVOQ0UgW0ddKVxuICAgICAgLS0gQXBwZW5kIGEgY29weSBvZiBgcycuXG4gICAgbG9jYWxcbiAgICAgIGw6IFNFUVVFTkNFIFtHXVxuICAgICAgbF9jdXJzb3I6IENVUlNPUlxuICAgIGRvXG4gICAgICBsIDo9IHNcbiAgICAgIGlmIHMgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgbCA6PSB0d2luXG4gICAgICBlbmRcbiAgICAgIGZyb21cbiAgICAgICAgbF9jdXJzb3IgOj0gY3Vyc29yXG4gICAgICAgIGwuc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGwuZXhoYXVzdGVkXG4gICAgICBsb29wXG4gICAgICAgIGV4dGVuZCAobC5pdGVtKVxuICAgICAgICBmaW5pc2hcbiAgICAgICAgbC5mb3J0aFxuICAgICAgZW5kXG4gICAgICBnb190byAobF9jdXJzb3IpXG4gICAgZW5kXG5cbiAgZmlsbCAob3RoZXI6IENPTlRBSU5FUiBbR10pXG4gICAgICAtLSBGaWxsIHdpdGggYXMgbWFueSBpdGVtcyBvZiBgb3RoZXInIGFzIHBvc3NpYmxlLlxuICAgICAgLS0gVGhlIHJlcHJlc2VudGF0aW9ucyBvZiBgb3RoZXInIGFuZCBjdXJyZW50IHN0cnVjdHVyZVxuICAgICAgLS0gbmVlZCBub3QgYmUgdGhlIHNhbWUuXG4gICAgbG9jYWxcbiAgICAgIGxpbl9yZXA6IExJTkVBUiBbR11cbiAgICAgIGxfY3Vyc29yOiBDVVJTT1JcbiAgICBkb1xuICAgICAgbGluX3JlcCA6PSBvdGhlci5saW5lYXJfcmVwcmVzZW50YXRpb25cbiAgICAgIGZyb21cbiAgICAgICAgbF9jdXJzb3IgOj0gY3Vyc29yXG4gICAgICAgIGxpbl9yZXAuc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIG5vdCBleHRlbmRpYmxlIG9yIGVsc2UgbGluX3JlcC5vZmZcbiAgICAgIGxvb3BcbiAgICAgICAgZXh0ZW5kIChsaW5fcmVwLml0ZW0pXG4gICAgICAgIGZpbmlzaFxuICAgICAgICBsaW5fcmVwLmZvcnRoXG4gICAgICBlbmRcbiAgICAgIGdvX3RvIChsX2N1cnNvcilcbiAgICBlbmRcbmZlYXR1cmUgLS0gVHJhbnNmb3JtYXRpb25cblxuICBzd2FwIChpOiBJTlRFR0VSKVxuICAgICAgLS0gRXhjaGFuZ2UgaXRlbSBhdCBgaSctdGggcG9zaXRpb24gd2l0aCBpdGVtXG4gICAgICAtLSBhdCBjdXJzb3IgcG9zaXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZjogbm90IG9mZlxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGxvY2FsXG4gICAgICBvbGRfaXRlbSwgbmV3X2l0ZW06IGxpa2UgaXRlbVxuICAgICAgcG9zOiBDVVJTT1JcbiAgICBkb1xuICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgb2xkX2l0ZW0gOj0gaXRlbVxuICAgICAgZ29faV90aCAoaSlcbiAgICAgIG5ld19pdGVtIDo9IGl0ZW1cbiAgICAgIHJlcGxhY2UgKG9sZF9pdGVtKVxuICAgICAgZ29fdG8gKHBvcylcbiAgICAgIHJlcGxhY2UgKG5ld19pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgc3dhcHBlZF90b19pdGVtOiBpdGVtID0gb2xkIGlfdGggKGkpXG4gICAgICBzd2FwcGVkX2Zyb21faXRlbTogaV90aCAoaSkgPSBvbGQgaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgZHVwbGljYXRlIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1Yi1jaGFpbiBiZWdpbm5pbmcgYXQgY3VycmVudCBwb3NpdGlvblxuICAgICAgLS0gYW5kIGhhdmluZyBtaW4gKGBuJywgYGZyb21faGVyZScpIGl0ZW1zLFxuICAgICAgLS0gd2hlcmUgYGZyb21faGVyZScgaXMgdGhlIG51bWJlciBvZiBpdGVtc1xuICAgICAgLS0gYXQgb3IgdG8gdGhlIHJpZ2h0IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZl91bmxlc3NfYWZ0ZXI6IG9mZiBpbXBsaWVzIGFmdGVyXG4gICAgICB2YWxpZF9zdWJjaGFpbjogbiA+PSAwXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5hcHBsaWNhYmxlXG5cbiAgcmVtb3ZlXG4gICAgICAtLSBSZW1vdmUgY3VycmVudCBpdGVtLlxuICAgIGRvXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIG5vbl9uZWdhdGl2ZV9pbmRleDogaW5kZXggPj0gMFxuICBpbmRleF9zbWFsbF9lbm91Z2g6IGluZGV4IDw9IGNvdW50ICsgMVxuICBvZmZfZGVmaW5pdGlvbjogb2ZmID0gKChpbmRleCA9IDApIG9yIChpbmRleCA9IGNvdW50ICsgMSkpXG4gIGlzZmlyc3RfZGVmaW5pdGlvbjogaXNmaXJzdCA9ICgobm90IGlzX2VtcHR5KSBhbmQgKGluZGV4ID0gMSkpXG4gIGlzbGFzdF9kZWZpbml0aW9uOiBpc2xhc3QgPSAoKG5vdCBpc19lbXB0eSkgYW5kIChpbmRleCA9IGNvdW50KSlcbiAgaXRlbV9jb3JyZXNwb25kc190b19pbmRleDogKG5vdCBvZmYpIGltcGxpZXMgKGl0ZW0gPSBpX3RoIChpbmRleCkpXG4gIGluZGV4X3NldF9oYXNfc2FtZV9jb3VudDogaW5kZXhfc2V0LmNvdW50ID0gY291bnRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlVuaWNvZGUgY2hhcmFjdGVycywgd2l0aCBjb21wYXJpc29uIG9wZXJhdGlvbnNcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlVJbnQzMlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzc1xuICBDSEFSQUNURVJfMzJcblxuaW5oZXJpdFxuICBDSEFSQUNURVJfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvZGUsXG4gICAgICBuYXR1cmFsXzMyX2NvZGUsXG4gICAgICB0b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Q0hBUkFDVEVSXzMyX1JFRn0pXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZTogSU5URUdFUlxuICAgICAgLS0gQXNzb2NpYXRlZCBpbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfOFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhIHVuaWNvZGUgY2hhcmFjdGVyIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgQ0hBUkFDVEVSXzMyX1JFRlxuXG5pbmhlcml0XG4gIENPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFVuaWNvZGUgY2hhcmFjdGVyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGNvZGU6IElOVEVHRVJcbiAgICAgIC0tIEFzc29jaWF0ZWQgaW50ZWdlciB2YWx1ZVxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbmF0dXJhbF8zMl9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgbmF0dXJhbF8zMl9jb2RlOiBOQVRVUkFMXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIG5hdHVyYWwgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0ubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5zdXJlXG4gICAgICBuYXR1cmFsXzMyX2NvZGVfaW5fcmFuZ2U6IFJlc3VsdCA+PSBtaW5fdmFsdWUgYW5kIFJlc3VsdCA8PSBtYXhfdmFsdWVcbiAgICBlbmRcblxuICBtaW5fdmFsdWU6IE5BVFVSQUxfMzIgPSAwXG4gIG1heF92YWx1ZTogTkFUVVJBTF8zMiA9IDQyOTQ5NjcyOTVcbiAgICAgIC0tIEJvdW5kcyBmb3IgaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBDSEFSQUNURVJfMzJcblxuICBtYXhfdW5pY29kZV92YWx1ZTogTkFUVVJBTF8zMiA9IDB4MTBGRkZEXG4gICAgICAtLSBNYXhpbXVtIFVuaWNvZGUgY2hhcmFjdGVycy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgZ3JlYXRlciB0aGFuIGN1cnJlbnQgY2hhcmFjdGVyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChuYXR1cmFsXzMyX2NvZGUgPCBvdGhlci5uYXR1cmFsXzMyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyByb3V0aW5lc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKGluY3I6IE5BVFVSQUxfMzIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFkZCBgaW5jcicgdG8gdGhlIGNvZGUgb2YgYGl0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luY3JlbWVudDogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgKyBpbmNyKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0ubmF0dXJhbF8zMl9jb2RlICsgaW5jcikudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IGluY3JcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAoZGVjcjogTkFUVVJBTF8zMik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gU3VidHJhY3QgYGRlY3InIGZyb20gdGhlIGNvZGUgb2YgYGl0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2RlY3JlbWVudDogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjQgLSBkZWNyKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0ubmF0dXJhbF8zMl9jb2RlIC0gZGVjcikudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IGl0ZW0gfC18IFJlc3VsdCA9IGRlY3JcbiAgICBlbmRcblxuICBkaWZmZXJlbmNlIGFsaWFzIFwifC18XCIgKG90aGVyOiBDSEFSQUNURVJfMzIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBEaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNvZGVzIG9mIGBpdGVtJyBhbmQgYG90aGVyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjQgLSBvdGhlci5uYXR1cmFsXzMyX2NvZGUudG9faW50ZWdlcl82NFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfbm9uX25lZ2F0aXZlX3Jlc3VsdDogUmVzdWx0ID49IDAgaW1wbGllcyAoKG90aGVyICsgUmVzdWx0LnRvX25hdHVyYWxfMzIpID0gaXRlbSlcbiAgICAgIHZhbGlkX25lZ2F0aXZlX3Jlc3VsdDogUmVzdWx0IDwgMCBpbXBsaWVzIChvdGhlciA9IChpdGVtICsgUmVzdWx0LnRvX25hdHVyYWxfMzIpKVxuICAgIGVuZFxuXG4gIG5leHQ6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gTmV4dCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5uYXR1cmFsXzMyX2NvZGUudG9fbmF0dXJhbF82NCArIDEpLmlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICsgMVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgfC18IGl0ZW0gPSAxXG4gICAgZW5kXG5cbiAgcHJldmlvdXM6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gUHJldmlvdXMgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgLSAxKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAtIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gLTFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBNYWtlIGBjJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHdpZGUgY2hhcmFjdGVyLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDYpXG4gICAgICBSZXN1bHQuYXBwZW5kX2NoYXJhY3RlciAoJ1UnKVxuICAgICAgUmVzdWx0LmFwcGVuZF9jaGFyYWN0ZXIgKCcrJylcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nIChuYXR1cmFsXzMyX2NvZGUudG9faGV4X3N0cmluZylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBDSEFSQUNURVJfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogQ0hBUkFDVEVSXzMyX1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQ29udmVydCBjdXJyZW50IHRvIENIQVJBQ1RFUl84LlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2NoYXJhY3Rlcl84X2NvbXBhdGlibGU6IGlzX2NoYXJhY3Rlcl84XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfMzIuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgYXNfdXBwZXIsIHVwcGVyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFVwcGVyY2FzZSB2YWx1ZSBvZiBgaXRlbScuXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX2xvd2VyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMudG9fdXBwZXIgKGl0ZW0pXG4gICAgZW5kXG5cbiAgYXNfbG93ZXIsIGxvd2VyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIExvd2VyY2FzZSB2YWx1ZSBvZiBgaXRlbScuXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX3VwcGVyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMudG9fbG93ZXIgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2NoYXJhY3Rlcl84OiBCT09MRUFOXG4gICAgICAtLSBDYW4gY3VycmVudCBiZSByZXByZXNlbnRlZCBvbiBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlIDw9IHtDSEFSQUNURVJfOH0ubWF4X3ZhbHVlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpc19hbHBoYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWM/XG4gICAgICAtLSBBbHBoYWJldGljIGlzIGBpc191cHBlcicgb3IgYGlzX2xvd2VyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfYWxwaGEgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfdXBwZXI6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyB1cHBlcmNhc2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3VwcGVyIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2xvd2VyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgbG93ZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc19sb3dlciAoaXRlbSlcbiAgICBlbmRcblxuICBpc19kaWdpdDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgZGVjaW1hbCBkaWdpdCBhcyBleHBlY3RlZCBmb3IgQVNDSUkgY2hhcmFjdGVycz9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODkuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAnMCcgPD0gaXRlbSBhbmQgaXRlbSA8PSAnOSdcbiAgICBlbmRcblxuICBpc191bmljb2RlX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBkZWNpbWFsIGRpZ2l0IGFzIGV4cGVjdGVkIGZvciBVbmljb2RlIGNoYXJhY3RlcnM/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2RpZ2l0IChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2hleGFfZGlnaXQ6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIGhleGFkZWNpbWFsIGRpZ2l0IGFzIGV4cGVjdGVkIGZvciBBU0NJSSBjaGFyYWN0ZXJzP1xuICAgICAgLS0gQSBkaWdpdCBpcyBvbmUgb2YgMDEyMzQ1Njc4OUFCQ0RFRmFiY2VkZi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfaGV4YV9kaWdpdCAoaXRlbSlcbiAgICBlbmRcblxuICBpc19zcGFjZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgd2hpdGUgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3NwYWNlIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX3B1bmN0dWF0aW9uOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBwdW5jdHVhdGlvbj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfcHVuY3R1YXRpb24gKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfYWxwaGFfbnVtZXJpYzogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWMgb3IgYSBkaWdpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfYWxwaGEgKGl0ZW0pIG9yIHByb3BlcnRpZXMuaXNfZGlnaXQgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfY29udHJvbDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgY29udHJvbCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2NvbnRyb2wgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgcHJvcGVydGllczogQ0hBUkFDVEVSX1BST1BFUlRZXG4gICAgICAtLSBQcm9wZXJ0eSBmb3IgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ2hhcmFjdGVycywgd2l0aCBjb21wYXJpc29uIG9wZXJhdGlvbnMgYW5kIGFuIEFTQ0lJIGNvZGVcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5DaGFyXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTAtMzAgMDg6MzI6NDYgLTA3MDAgKFR1ZSwgMzAgT2N0IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDIyICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3NcbiAgQ0hBUkFDVEVSXzhcblxuaW5oZXJpdFxuICBDSEFSQUNURVJfOF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgY29kZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Q0hBUkFDVEVSXzhfUkVGfSksXG4gIHRvX2NoYXJhY3Rlcl8zMjoge0NIQVJBQ1RFUl8zMn1cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvblxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGEgY2hhcmFjdGVyIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3MgQ0hBUkFDVEVSXzhfUkVGIGluaGVyaXRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG5hdHVyYWxfMzJfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5jb2RlXG4gICAgZW5zdXJlXG4gICAgICBjb2RlX25vbl9uZWdhdGlmOiBSZXN1bHQgPj0gMFxuICAgICAgY29kZV9pbl9yYW5nZTogUmVzdWx0ID49IG1pbl92YWx1ZSBhbmQgUmVzdWx0IDw9IG1heF92YWx1ZVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmNvZGUudG9fbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgbWluX3ZhbHVlOiBJTlRFR0VSID0gMFxuICBtYXhfdmFsdWU6IElOVEVHRVIgPSAyNTVcbiAgbWF4X2FzY2lpX3ZhbHVlOiBJTlRFR0VSID0gMTI3XG4gICAgICAtLSBCb3VuZHMgZm9yIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVycyAoQVNDSUkpXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGNoYXJhY3Rlcj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5hdHVyYWxfMzJfY29kZSA8IG90aGVyLm5hdHVyYWxfMzJfY29kZVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAobmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgcm91dGluZXNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChpbmNyOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFkZCBgaW5jcicgdG8gdGhlIGNvZGUgb2YgYGl0ZW0nXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5jcmVtZW50OiAoaXRlbS5jb2RlICsgaW5jcikuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0uY29kZSArIGluY3IpLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IGluY3JcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAoZGVjcjogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBTdWJ0cmFjdCBgZGVjcicgZnJvbSB0aGUgY29kZSBvZiBgaXRlbSdcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9kZWNyZW1lbnQ6IChpdGVtLmNvZGUgLSBkZWNyKS5pc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoaXRlbS5jb2RlIC0gZGVjcikudG9fY2hhcmFjdGVyXzhcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogaXRlbSB8LXwgUmVzdWx0ID0gZGVjclxuICAgIGVuZFxuXG4gIGRpZmZlcmVuY2UgYWxpYXMgXCJ8LXxcIiAob3RoZXI6IENIQVJBQ1RFUl84KTogSU5URUdFUlxuICAgICAgLS0gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb2RlcyBvZiBgaXRlbScgYW5kIGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uY29kZSAtIG90aGVyLmNvZGVcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogb3RoZXIgKyBSZXN1bHQgPSBpdGVtXG4gICAgZW5kXG5cbiAgbmV4dDogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIE5leHQgY2hhcmFjdGVyXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5jb2RlICsgMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSArIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gMVxuICAgIGVuZFxuXG4gIHByZXZpb3VzOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUHJldmlvdXMgY2hhcmFjdGVyXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5jb2RlIC0gMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAtIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gLTFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIE1ha2UgYGMnIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSlcbiAgICAgIFJlc3VsdC5hcHBlbmRfY2hhcmFjdGVyIChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IENIQVJBQ1RFUl84X1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IENIQVJBQ1RFUl84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG4gIGFzX3VwcGVyLCB1cHBlcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFVwcGVyY2FzZSB2YWx1ZSBvZiBgaXRlbSdcbiAgICAgIC0tIFJldHVybnMgYGl0ZW0nIGlmIG5vdCBgaXNfbG93ZXInXG4gICAgZG9cbiAgICAgIGlmIGlzX2xvd2VyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgLSAoJ2EnKS5jb2RlICsgKCdBJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFzX2xvd2VyLCBsb3dlcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIExvd2VyY2FzZSB2YWx1ZSBvZiBgaXRlbSdcbiAgICAgIC0tIFJldHVybnMgYGl0ZW0nIGlmIG5vdCBgaXNfdXBwZXInXG4gICAgZG9cbiAgICAgIGlmIGlzX3VwcGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgLSAoJ0EnKS5jb2RlICsgKCdhJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19hbHBoYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWM/XG4gICAgICAtLSBBbHBoYWJldGljIGlzIGBpc191cHBlcicgb3IgYGlzX2xvd2VyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX3VwcGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgdXBwZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3VwcGVyX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2xvd2VyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgbG93ZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX2xvd2VyX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBkaWdpdD9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiBpc19kaWdpdF9mbGFnKSA+IDBcbiAgICBlbmRcblxuICBpc19oZXhhX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYW4gaGV4YWRlY2ltYWwgZGlnaXQ/XG4gICAgICAtLSBBIGRpZ2l0IGlzIG9uZSBvZiAwMTIzNDU2Nzg5QUJDREVGYWJjZWRmXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgKGlzX2hleGFfZGlnaXRfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcpKSA+IDBcbiAgICBlbmRcblxuICBpc19zcGFjZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgd2hpdGUgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfd2hpdGVfc3BhY2VfZmxhZykgPiAwXG4gICAgZW5kXG5cbiAgaXNfcHVuY3R1YXRpb246IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHB1bmN0dWF0aW9uP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3B1bmN0dWF0aW9uX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2FscGhhX251bWVyaWM6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhbHBoYWJldGljIG9yIGEgZGlnaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgKGlzX3VwcGVyX2ZsYWcgfCBpc19sb3dlcl9mbGFnIHwgaXNfZGlnaXRfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX3ByaW50YWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBpbmNsdWRpbmcgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICZcbiAgICAgICAgKGlzX3VwcGVyX2ZsYWcgfCBpc19sb3dlcl9mbGFnIHwgaXNfZGlnaXRfZmxhZyB8IGlzX3B1bmN0dWF0aW9uX2ZsYWcgfCBpc19zcGFjZV9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfZ3JhcGg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHByaW50YWJsZSBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmXG4gICAgICAgIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcgfCBpc19wdW5jdHVhdGlvbl9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfY29udHJvbDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgY29udHJvbCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfY29udHJvbF9mbGFnKSA+IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBjaGFyYWN0ZXJfdHlwZXMgKGFfY29kZTogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gQXNzb2NpYXRlZCB0eXBlIGZvciBjaGFyYWN0ZXIgb2YgY29kZSBgYV9jb2RlJ1xuICAgIGRvXG4gICAgICAgIC0tIEZvciBjaGFyYWN0ZXIgd2hvc2UgY29kZSBpcyBhYm92ZSAyNTYsIGl0IGlzIGFzIGlmXG4gICAgICAgIC0tIHdlIGhhZCBubyBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAgICAgIGlmIGFfY29kZSA8IDI1NiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlcm5hbF9jaGFyYWN0ZXJfdHlwZXMuaXRlbSAoYV9jb2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfY2hhcmFjdGVyX3R5cGVzOiBTUEVDSUFMIFtOQVRVUkFMXzhdXG4gICAgICAtLSBBcnJheSB3aGljaCBzdG9yZXMgdGhlIHZhcmlvdXMgdHlwZSBmb3IgdGhlIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDI1NilcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgLS0gMCAgbnVsbFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxICBzdGFydCBvZiBoZWFkaW5nXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDIgIHN0YXJ0IG9mIHRleHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMyAgZW5kIG9mIHRleHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNCAgZW5kIG9mIHRyYW5zbWlzc2lvblxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1ICBlbnF1aXJ5XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDYgIGFja25vd2xlZGdlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDcgIGJlbGxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gOCAgYmFja3NwYWNlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDkgIGhvcml6b250YWwgdGFiXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEwIE5MIGxpbmUgZmVlZCwgbmV3IGxpbmVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZyB8IGlzX3doaXRlX3NwYWNlX2ZsYWcpICAgLS0gMTEgdmVydGljYWwgdGFiXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEyIE5QIGZvcm0gZmVlZCwgbmV3IHBhZ2VcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZyB8IGlzX3doaXRlX3NwYWNlX2ZsYWcpICAgLS0gMTMgY2FycmlhZ2UgcmV0dXJuPUNSXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDE0IHNoaWZ0IG91dFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNSBzaGlmdCBpblxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxN1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxOFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxOVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyM1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNyBFc2NhcGVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjggZmlsZSBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjkgZ3JvdXAgc2VwYXJhdG9yXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDMwIHJlY29yZCBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMzEgdW5pdCBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3doaXRlX3NwYWNlX2ZsYWcgfCBpc19zcGFjZV9mbGFnKSAgICAgLS0gMzIgU3BhY2VcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzMgIVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNCBcIlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNSAjXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM2ICRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzcgJVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzOCAmXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM5ICdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDAgKFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0MSApXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQyICpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDMgK1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NCAsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQ1IC1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDYgLlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NyAvXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDQ4IDBcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNDkgMVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MCAyXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDUxIDNcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTIgNFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MyA1XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU0IDZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTUgN1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1NiA4XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU3IDlcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNTggOlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA1OSA7XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYwIDxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjEgPVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA2MiA+XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYzID9cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjQgQFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2NSBBXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY2IEJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNjcgQ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2OCBEXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY5IEVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNzAgRlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3MSBHXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDcyIEhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzMgSVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NCBKXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc1IEtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzYgTFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NyBNXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc4IE5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzkgT1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MCBQXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDgxIFFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODIgUlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MyBTXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg0IFRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODUgVVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4NiBWXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg3IFdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODggWFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4OSBZXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDkwIFpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTEgW1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5MiBcXFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5MyBdXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDk0IF5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTUgX1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5NiBgXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDk3IGFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gOTggYlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA5OSBjXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDEwMCAgZFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSAxMDEgIGVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gMTAyICBmXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwMyAgZ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDQgIGhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA1ICBpXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwNiAgalxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDcgIGtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA4ICBsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwOSAgbVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTAgIG5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTExICBvXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExMiAgcFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTMgIHFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE0ICByXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExNSAgc1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTYgIHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE3ICB1XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExOCAgdlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTkgIHdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTIwICB4XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyMSAgeVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMjIgIHpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTIzICB7XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDEyNCAgfFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAxMjUgIH1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTI2ICB+XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyNyAgREVMXG4gICAgICBSZXN1bHQuZmlsbF93aXRoICgwLCAxMjgsIDI1NSkgICAgICAgICAgICAgIC0tIGV4dGVuZGVkIEFTQ0lJXG4gICAgZW5zdXJlXG4gICAgICBpbnRlcm5hbF9jaGFyYWN0ZXJfdHlwZXNfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgaXNfdXBwZXJfZmxhZzogTkFUVVJBTF84ID0gMHgwMVxuXG4gIGlzX2xvd2VyX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MDJcblxuICBpc19kaWdpdF9mbGFnOiBOQVRVUkFMXzggPSAweDA0XG5cbiAgaXNfd2hpdGVfc3BhY2VfZmxhZzogTkFUVVJBTF84ID0gMHgwOFxuXG4gIGlzX3B1bmN0dWF0aW9uX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MTBcblxuICBpc19jb250cm9sX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MjBcblxuICBpc19oZXhhX2RpZ2l0X2ZsYWc6IE5BVFVSQUxfOCA9IDB4NDBcblxuICBpc19zcGFjZV9mbGFnOiBOQVRVUkFMXzggPSAweDgwO1xuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGNvbGxlY3Rpb24sIGFjY2VzcztcbiAgYWNjZXNzOiBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIENPTExFQ1RJT04gW0ddIGluaGVyaXRcblxuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc19pbnNlcnRlZCAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIEhhcyBgdicgYmVlbiBpbnNlcnRlZCBieSB0aGUgbW9zdCByZWNlbnQgaW5zZXJ0aW9uP1xuICAgICAgLS0gKEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZSByZXR1cm5lZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmdcbiAgICAgIC0tIGBoYXMgKHYpJy4gSG93ZXZlciwgZGVzY2VuZGFudHMgbWlnaHQgYmUgYWJsZSB0byBwcm92aWRlIG1vcmVcbiAgICAgIC0tIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbnMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaGFzICh2KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0LCBleHRlbmQgKHY6IEcpXG4gICAgICAtLSBFbnN1cmUgdGhhdCBzdHJ1Y3R1cmUgaW5jbHVkZXMgYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9pbnNlcnRlZDogaXNfaW5zZXJ0ZWQgKHYpXG4gICAgZW5kXG5cbiAgZmlsbCAob3RoZXI6IENPTlRBSU5FUiBbR10pXG4gICAgICAtLSBGaWxsIHdpdGggYXMgbWFueSBpdGVtcyBvZiBgb3RoZXInIGFzIHBvc3NpYmxlLlxuICAgICAgLS0gVGhlIHJlcHJlc2VudGF0aW9ucyBvZiBgb3RoZXInIGFuZCBjdXJyZW50IHN0cnVjdHVyZVxuICAgICAgLS0gbmVlZCBub3QgYmUgdGhlIHNhbWUuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICBsb2NhbFxuICAgICAgbGluX3JlcDogTElORUFSIFtHXVxuICAgIGRvXG4gICAgICBsaW5fcmVwIDo9IG90aGVyLmxpbmVhcl9yZXByZXNlbnRhdGlvblxuICAgICAgZnJvbVxuICAgICAgICBsaW5fcmVwLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBub3QgZXh0ZW5kaWJsZSBvciBlbHNlIGxpbl9yZXAub2ZmXG4gICAgICBsb29wXG4gICAgICAgIGV4dGVuZCAobGluX3JlcC5pdGVtKVxuICAgICAgICBsaW5fcmVwLmZvcnRoXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcHJ1bmUgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgb25lIG9jY3VycmVuY2Ugb2YgYHYnIGlmIGFueS5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgcmVxdWlyZVxuICAgICAgcHJ1bmFibGU6IHBydW5hYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGB2Jy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgICAtLXxEZWZhdWx0IGltcGxlbWVudGF0aW9uLCB1c3VhbGx5IGluZWZmaWNpZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbCBub3QgaGFzICh2KSBsb29wXG4gICAgICAgIHBydW5lICh2KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub19tb3JlX29jY3VycmVuY2VzOiBub3QgaGFzICh2KVxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zLlxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB3aXBlZF9vdXQ6IGlzX2VtcHR5XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBDT01QQVJBQkxFIGluaGVyaXRcblxuICBQQVJUX0NPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcywgaXNfbGVzc19lcXVhbCxcbiAgICAgIGlzX2dyZWF0ZXIsIGlzX2dyZWF0ZXJfZXF1YWwsXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgYXN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgbm90IChvdGhlciA8IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfbGVzc19lcXVhbCBhbGlhcyBcIjw9XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCAob3RoZXIgPCBDdXJyZW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoKEN1cnJlbnQgPCBvdGhlcikgb3IgKEN1cnJlbnQgfiBvdGhlcikpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlciBhbGlhcyBcIj5cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgb2JqZWN0IGdyZWF0ZXIgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIgPCBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChvdGhlciA8IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlcl9lcXVhbCBhbGlhcyBcIj49XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCAoQ3VycmVudCA8IG90aGVyKVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAob3RoZXIgPD0gQ3VycmVudClcbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobm90IChDdXJyZW50IDwgb3RoZXIpIGFuZCBub3QgKG90aGVyIDwgQ3VycmVudCkpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHRyaWNob3RvbXk6IFJlc3VsdCA9IChub3QgKEN1cnJlbnQgPCBvdGhlcikgYW5kIG5vdCAob3RoZXIgPCBDdXJyZW50KSlcbiAgICBlbmRcblxuICB0aHJlZV93YXlfY29tcGFyaXNvbiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IElOVEVHRVJcbiAgICAgIC0tIElmIGN1cnJlbnQgb2JqZWN0IGVxdWFsIHRvIGBvdGhlcicsIDA7XG4gICAgICAtLSBpZiBzbWFsbGVyLCAtMTsgaWYgZ3JlYXRlciwgMVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50IDwgb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVsc2VpZiBvdGhlciA8IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBlcXVhbF96ZXJvOiAoUmVzdWx0ID0gMCkgPSAoQ3VycmVudCB+IG90aGVyKVxuICAgICAgc21hbGxlcl9uZWdhdGl2ZTogKFJlc3VsdCA9IC0xKSA9IChDdXJyZW50IDwgb3RoZXIpXG4gICAgICBncmVhdGVyX3Bvc2l0aXZlOiAoUmVzdWx0ID0gMSkgPSAoQ3VycmVudCA+IG90aGVyKVxuICAgIGVuZFxuXG4gIG1heCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVGhlIGdyZWF0ZXIgb2YgY3VycmVudCBvYmplY3QgYW5kIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA+PSBvdGhlciB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBvdGhlclxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjdXJyZW50X2lmX25vdF9zbWFsbGVyOiBDdXJyZW50ID49IG90aGVyIGltcGxpZXMgUmVzdWx0ID0gQ3VycmVudFxuICAgICAgb3RoZXJfaWZfc21hbGxlcjogQ3VycmVudCA8IG90aGVyIGltcGxpZXMgUmVzdWx0ID0gb3RoZXJcbiAgICBlbmRcblxuICBtaW4gKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRoZSBzbWFsbGVyIG9mIGN1cnJlbnQgb2JqZWN0IGFuZCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPD0gb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gb3RoZXJcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY3VycmVudF9pZl9ub3RfZ3JlYXRlcjogQ3VycmVudCA8PSBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IEN1cnJlbnRcbiAgICAgIG90aGVyX2lmX2dyZWF0ZXI6IEN1cnJlbnQgPiBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IG90aGVyXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGlycmVmbGV4aXZlX2NvbXBhcmlzb246IG5vdCAoQ3VycmVudCA8IEN1cnJlbnQpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBhY2Nlc3M7XG4gIGFjY2VzczogbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJ1Y3R1cmUgaW5jbHVkZSBgdic/XG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBub3RfZm91bmRfaW5fZW1wdHk6IFJlc3VsdCBpbXBsaWVzIG5vdCBpc19lbXB0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gZWxlbWVudD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGVtcHR5OiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyBlbGVtZW50P1xuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMDogVXNlIGBpc19lbXB0eScgaW5zdGVhZFwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc19lbXB0eVxuICAgIGVuZFxuXG4gIG9iamVjdF9jb21wYXJpc29uOiBCT09MRUFOXG4gICAgICAtLSBNdXN0IHNlYXJjaCBvcGVyYXRpb25zIHVzZSBgZXF1YWwnIHJhdGhlciB0aGFuIGA9J1xuICAgICAgLS0gZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzPyAoRGVmYXVsdDogbm8sIHVzZSBgPScuKVxuXG4gIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgb2JqZWN0X2NvbXBhcmlzb24nIGJlIGNoYW5nZWQ/XG4gICAgICAtLSAoQW5zd2VyOiB5ZXMgYnkgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHNldHRpbmdcblxuICBjb21wYXJlX29iamVjdHNcbiAgICAgIC0tIEVuc3VyZSB0aGF0IGZ1dHVyZSBzZWFyY2ggb3BlcmF0aW9ucyB3aWxsIHVzZSBgZXF1YWwnXG4gICAgICAtLSByYXRoZXIgdGhhbiBgPScgZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzLlxuICAgIHJlcXVpcmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBkb1xuICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gVHJ1ZVxuICAgIGVuc3VyZVxuICAgICAgb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuICBjb21wYXJlX3JlZmVyZW5jZXNcbiAgICAgIC0tIEVuc3VyZSB0aGF0IGZ1dHVyZSBzZWFyY2ggb3BlcmF0aW9ucyB3aWxsIHVzZSBgPSdcbiAgICAgIC0tIHJhdGhlciB0aGFuIGBlcXVhbCcgZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzLlxuICAgIHJlcXVpcmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBkb1xuICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIHJlZmVyZW5jZV9jb21wYXJpc29uOiBub3Qgb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0ddXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkN1cnNvcnMgZm9yIHJlbWVtYmVyaW5nIHBvc2l0aW9ucyBpbiBhcmJpdHJhcnkgZGF0YSBzdHJ1Y3R1cmVzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogY3Vyc29yO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuY2xhc3NcbiAgQ1VSU09SXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBjdXJzb3Jfc3RydWN0dXJlLCBhY2Nlc3M7XG4gIGFjY2VzczogY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIENVUlNPUl9TVFJVQ1RVUkUgW0ddIGluaGVyaXRcblxuICBBQ1RJVkUgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY3Vyc29yOiBDVVJTT1JcbiAgICAgIC0tIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGN1cnNvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgdmFsaWRfY3Vyc29yIChwOiBDVVJTT1IpOiBCT09MRUFOXG4gICAgICAtLSBDYW4gdGhlIGN1cnNvciBiZSBtb3ZlZCB0byBwb3NpdGlvbiBgcCc/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDdXJzb3IgbW92ZW1lbnRcblxuICBnb190byAocDogQ1VSU09SKVxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gcG9zaXRpb24gYHAnLlxuICAgIHJlcXVpcmVcbiAgICAgIGN1cnNvcl9wb3NpdGlvbl92YWxpZDogdmFsaWRfY3Vyc29yIChwKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJPYmplY3RzIHRoYXQgcHJvdmlkZSBhbiBvdXRwdXQgaW4gZGVidWdnZXJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDEtMTcgMTE6NDY6MTUgLTA4MDAgKFRodSwgMTcgSmFuIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTI0ICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBERUJVR19PVVRQVVRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGVidWdfb3V0cHV0OiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgICAgLS0gU3RyaW5nIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBkZWJ1Z2dlciB0byByZXByZXNlbnQgYEN1cnJlbnQnLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTItMjYgMTg6NTc6NTAgLTA4MDAgKFdlZCwgMjYgRGVjIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDk2ICRcIlxuXG5jbGFzc1xuICBERVZFTE9QRVJfRVhDRVBUSU9OXG5cbmluaGVyaXRcbiAgRVhDRVBUSU9OXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvZGUsXG4gICAgICB0YWdcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBmcm96ZW4gY29kZTogSU5URUdFUlxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHtFWENFUF9DT05TVH0uZGV2ZWxvcGVyX2V4Y2VwdGlvblxuICAgIGVuZFxuXG4gIHRhZzogSU1NVVRBQkxFX1NUUklOR18zMlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZ184IChcIkRldmVsb3BlciBleGNlcHRpb24uXCIpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJQZXJmb3JtIGNsZWFudXAgb3BlcmF0aW9ucyBiZWZvcmUgY3VycmVudCBpbnN0YW5jZSBpcyByZWNsYWltZWQgYnkgZ2FyYmFnZSBjb2xsZWN0aW9uLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIERJU1BPU0FCTEVcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgZGlzcG9zZVxuICAgICAgLS0gQWN0aW9uIHRvIGJlIGV4ZWN1dGVkIGp1c3QgYmVmb3JlIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgICAgLS0gcmVjbGFpbXMgYW4gb2JqZWN0LlxuICAgICAgLS0gRWZmZWN0IGl0IGluIGRlc2NlbmRhbnRzIHRvIHBlcmZvcm0gc3BlY2lmaWMgZGlzcG9zZVxuICAgICAgLS0gYWN0aW9ucy4gVGhvc2UgYWN0aW9ucyBzaG91bGQgb25seSB0YWtlIGNhcmUgb2YgZnJlZWluZ1xuICAgICAgLS0gZXh0ZXJuYWwgcmVzb3VyY2VzOyB0aGV5IHNob3VsZCBub3QgcGVyZm9ybSByZW1vdGUgY2FsbHNcbiAgICAgIC0tIG9uIG90aGVyIG9iamVjdHMgc2luY2UgdGhlc2UgbWF5IGFsc28gYmUgZGVhZCBhbmQgcmVjbGFpbWVkLlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19pbl9maW5hbF9jb2xsZWN0OiBCT09MRUFOXG4gICAgICAtLSBJcyBHQyBjdXJyZW50bHkgcGVyZm9ybWluZyBmaW5hbCBjb2xsZWN0aW9uXG4gICAgICAtLSBhZnRlciBleGVjdXRpb24gb2YgY3VycmVudCBwcm9ncmFtP1xuICAgICAgLS0gU2FmZSB0byB1c2UgaW4gYGRpc3Bvc2UnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgaW5saW5lIHVzZSAlXCJlaWZfbWVtb3J5LmglXCJcIlxuICAgIGFsaWFzXG4gICAgICBcInJldHVybiBlaWZfaXNfaW5fZmluYWxfY29sbGVjdDtcIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiRHluYW1pY2FsbHkgbW9kaWZpYWJsZSBjaGFpbnNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBkeW5hbWljX2NoYWluLCBzZXF1ZW5jZTtcbiAgYWNjZXNzOiBpbmRleCwgY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIERZTkFNSUNfQ0hBSU4gW0ddIGluaGVyaXRcblxuICBDSEFJTiBbR11cbiAgICBleHBvcnRcbiAgICAgIHtBTll9IHJlbW92ZSwgcHJ1bmVfYWxsLCBwcnVuZVxuICAgIHVuZGVmaW5lXG4gICAgICByZW1vdmUsIHBydW5lX2FsbCwgcHJ1bmVcbiAgICBlbmRcblxuICBVTkJPVU5ERUQgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiB5ZXMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0X2Zyb250ICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIGF0IGJlZ2lubmluZy5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICByZXF1aXJlXG4gICAgICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBpdGVtX2luc2VydGVkOiBmaXJzdCA9IHZcbiAgICBlbmRcblxuICBwdXRfbGVmdCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byB0aGUgbGVmdCBvZiBjdXJzb3IgcG9zaXRpb24uXG4gICAgICAtLSBEbyBub3QgbW92ZSBjdXJzb3IuXG4gICAgcmVxdWlyZVxuICAgICAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICAgICAgbm90X2JlZm9yZTogbm90IGJlZm9yZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgbmV3X2luZGV4OiBpbmRleCA9IG9sZCBpbmRleCArIDFcbiAgICBlbmRcblxuICBwdXRfcmlnaHQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIEFkZCBgdicgdG8gdGhlIHJpZ2h0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICByZXF1aXJlXG4gICAgICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gICAgICBub3RfYWZ0ZXI6IG5vdCBhZnRlclxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgc2FtZV9pbmRleDogaW5kZXggPSBvbGQgaW5kZXhcbiAgICBlbmRcblxuICBtZXJnZV9sZWZ0IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gTWVyZ2UgYG90aGVyJyBpbnRvIGN1cnJlbnQgc3RydWN0dXJlIGJlZm9yZSBjdXJzb3JcbiAgICAgIC0tIHBvc2l0aW9uLiBEbyBub3QgbW92ZSBjdXJzb3IuIEVtcHR5IGBvdGhlcicuXG4gICAgcmVxdWlyZVxuICAgICAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICAgICAgbm90X2JlZm9yZTogbm90IGJlZm9yZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBub3RfY3VycmVudDogb3RoZXIgLz0gQ3VycmVudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIG90aGVyLmNvdW50XG4gICAgICBuZXdfaW5kZXg6IGluZGV4ID0gb2xkIGluZGV4ICsgb2xkIG90aGVyLmNvdW50XG4gICAgICBvdGhlcl9pc19lbXB0eTogb3RoZXIuaXNfZW1wdHlcbiAgICBlbmRcblxuICBtZXJnZV9yaWdodCAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIE1lcmdlIGBvdGhlcicgaW50byBjdXJyZW50IHN0cnVjdHVyZSBhZnRlciBjdXJzb3JcbiAgICAgIC0tIHBvc2l0aW9uLiBEbyBub3QgbW92ZSBjdXJzb3IuIEVtcHR5IGBvdGhlcicuXG4gICAgcmVxdWlyZVxuICAgICAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICAgICAgbm90X2FmdGVyOiBub3QgYWZ0ZXJcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgbm90X2N1cnJlbnQ6IG90aGVyIC89IEN1cnJlbnRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBvdGhlci5jb3VudFxuICAgICAgc2FtZV9pbmRleDogaW5kZXggPSBvbGQgaW5kZXhcbiAgICAgIG90aGVyX2lzX2VtcHR5OiBvdGhlci5pc19lbXB0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICBwcnVuZSAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHYnLCBpZiBhbnksXG4gICAgICAtLSBhZnRlciBjdXJzb3IgcG9zaXRpb24uXG4gICAgICAtLSBJZiBmb3VuZCwgbW92ZSBjdXJzb3IgdG8gcmlnaHQgbmVpZ2hib3I7XG4gICAgICAtLSBpZiBub3QsIG1ha2Ugc3RydWN0dXJlIGBleGhhdXN0ZWQnLlxuICAgIGRvXG4gICAgICBzZWFyY2ggKHYpXG4gICAgICBpZiBub3QgZXhoYXVzdGVkIHRoZW5cbiAgICAgICAgcmVtb3ZlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZW1vdmVfbGVmdFxuICAgICAgLS0gUmVtb3ZlIGl0ZW0gdG8gdGhlIGxlZnQgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIHJlcXVpcmVcbiAgICAgIGxlZnRfZXhpc3RzOiBpbmRleCA+IDFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCAtIDFcbiAgICAgIG5ld19pbmRleDogaW5kZXggPSBvbGQgaW5kZXggLSAxXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3JpZ2h0XG4gICAgICAtLSBSZW1vdmUgaXRlbSB0byB0aGUgcmlnaHQgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIHJlcXVpcmVcbiAgICAgIHJpZ2h0X2V4aXN0czogaW5kZXggPCBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50IC0gMVxuICAgICAgc2FtZV9pbmRleDogaW5kZXggPSBvbGQgaW5kZXhcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIFJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgYHYnLlxuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICAgIC0tIExlYXZlIHN0cnVjdHVyZSBgZXhoYXVzdGVkJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBzdGFydFxuICAgICAgICBzZWFyY2ggKHYpXG4gICAgICB1bnRpbFxuICAgICAgICBleGhhdXN0ZWRcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlXG4gICAgICAgIHNlYXJjaCAodilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19leGhhdXN0ZWQ6IGV4aGF1c3RlZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIHN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eVxuICAgICAgbG9vcFxuICAgICAgICByZW1vdmVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgZHVwbGljYXRlIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1Yi1jaGFpbiBiZWdpbm5pbmcgYXQgY3VycmVudCBwb3NpdGlvblxuICAgICAgLS0gYW5kIGhhdmluZyBtaW4gKGBuJywgYGZyb21faGVyZScpIGl0ZW1zLFxuICAgICAgLS0gd2hlcmUgYGZyb21faGVyZScgaXMgdGhlIG51bWJlciBvZiBpdGVtc1xuICAgICAgLS0gYXQgb3IgdG8gdGhlIHJpZ2h0IG9mIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgbG9jYWxcbiAgICAgIHBvczogQ1VSU09SXG4gICAgICBjb3VudGVyOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgUmVzdWx0IDo9IG5ld19jaGFpblxuICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgUmVzdWx0LmNvbXBhcmVfb2JqZWN0c1xuICAgICAgICBlbmRcbiAgICAgICAgcG9zIDo9IGN1cnNvclxuICAgICAgdW50aWxcbiAgICAgICAgKGNvdW50ZXIgPSBuKSBvciBlbHNlIGV4aGF1c3RlZFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQuZXh0ZW5kIChpdGVtKVxuICAgICAgICBmb3J0aFxuICAgICAgICBjb3VudGVyIDo9IGNvdW50ZXIgKyAxXG4gICAgICBlbmRcbiAgICAgIGdvX3RvIChwb3MpXG4gICAgZW5kXG5cbmZlYXR1cmUge0RZTkFNSUNfQ0hBSU59IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgbmV3X2NoYWluOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEEgbmV3bHkgY3JlYXRlZCBpbnN0YW5jZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgICAgLS0gVGhpcyBmZWF0dXJlIG1heSBiZSByZWRlZmluZWQgaW4gZGVzY2VuZGFudHMgc28gYXMgdG9cbiAgICAgIC0tIHByb2R1Y2UgYW4gYWRlcXVhdGVseSBhbGxvY2F0ZWQgYW5kIGluaXRpYWxpemVkIG9iamVjdC5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBTZXF1ZW50aWFsLCBkeW5hbWljYWxseSBtb2RpZmlhYmxlIGxpc3RzLFxuICAgIHdpdGhvdXQgY29tbWl0bWVudCB0byBhIHBhcnRpY3VsYXIgcmVwcmVzZW50YXRpb25cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogZHluYW1pY19saXN0LCBzZXF1ZW5jZTtcbiAgYWNjZXNzOiBpbmRleCwgY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIERZTkFNSUNfTElTVCBbR10gaW5oZXJpdFxuXG4gIExJU1QgW0ddXG4gICAgdW5kZWZpbmVcbiAgICAgIHBydW5lLFxuICAgICAgc2VxdWVudGlhbF9pbmRleF9vZiwgc2VxdWVudGlhbF9oYXMsXG4gICAgICByZW1vdmUsIHBydW5lX2FsbFxuICAgIGVuZFxuXG4gIERZTkFNSUNfQ0hBSU4gW0ddXG4gICAgcmVuYW1lXG4gICAgICB3aXBlX291dCBhcyBjaGFpbl93aXBlX291dFxuICAgIGV4cG9ydFxuICAgICAge05PTkV9IGNoYWluX3dpcGVfb3V0XG4gICAgdW5kZWZpbmVcbiAgICAgIGlzX2VxdWFsXG4gICAgcmVkZWZpbmVcbiAgICAgIHB1dF9sZWZ0LCBwdXRfcmlnaHQsXG4gICAgICByZW1vdmVfbGVmdCwgcmVtb3ZlX3JpZ2h0XG4gICAgZW5kXG5cbiAgRFlOQU1JQ19DSEFJTiBbR11cbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICByZWRlZmluZVxuICAgICAgcHV0X2xlZnQsIHB1dF9yaWdodCxcbiAgICAgIHJlbW92ZV9sZWZ0LCByZW1vdmVfcmlnaHQsIHdpcGVfb3V0XG4gICAgc2VsZWN0XG4gICAgICB3aXBlX291dFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0X2xlZnQgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIEFkZCBgdicgdG8gdGhlIGxlZnQgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBsaWtlIGl0ZW1cbiAgICBkb1xuICAgICAgaWYgaXNfZW1wdHkgdGhlblxuICAgICAgICBwdXRfZnJvbnQgKHYpXG4gICAgICBlbHNlaWYgYWZ0ZXIgdGhlblxuICAgICAgICBiYWNrXG4gICAgICAgIHB1dF9yaWdodCAodilcbiAgICAgICAgbW92ZSAoMilcbiAgICAgIGVsc2VcbiAgICAgICAgdGVtcCA6PSBpdGVtXG4gICAgICAgIHJlcGxhY2UgKHYpXG4gICAgICAgIHB1dF9yaWdodCAodGVtcClcbiAgICAgICAgZm9ydGhcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHB1dF9yaWdodCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byB0aGUgcmlnaHQgb2YgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAgLS0gRG8gbm90IG1vdmUgY3Vyc29yLlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgbWVyZ2VfbGVmdCAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIE1lcmdlIGBvdGhlcicgaW50byBjdXJyZW50IHN0cnVjdHVyZSBiZWZvcmUgY3Vyc29yXG4gICAgICAtLSBwb3NpdGlvbi4gRG8gbm90IG1vdmUgY3Vyc29yLiBFbXB0eSBgb3RoZXInLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG90aGVyLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBvdGhlci5pc19lbXB0eVxuICAgICAgbG9vcFxuICAgICAgICBwdXRfbGVmdCAob3RoZXIuaXRlbSlcbiAgICAgICAgb3RoZXIucmVtb3ZlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtZXJnZV9yaWdodCAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIE1lcmdlIGBvdGhlcicgaW50byBjdXJyZW50IHN0cnVjdHVyZSBhZnRlciBjdXJzb3JcbiAgICAgIC0tIHBvc2l0aW9uLiBEbyBub3QgbW92ZSBjdXJzb3IuIEVtcHR5IGBvdGhlcicuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgb3RoZXIuZmluaXNoXG4gICAgICB1bnRpbFxuICAgICAgICBvdGhlci5pc19lbXB0eVxuICAgICAgbG9vcFxuICAgICAgICBwdXRfcmlnaHQgKG90aGVyLml0ZW0pXG4gICAgICAgIG90aGVyLmJhY2tcbiAgICAgICAgb3RoZXIucmVtb3ZlX3JpZ2h0XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlXG4gICAgICAtLSBSZW1vdmUgY3VycmVudCBpdGVtLlxuICAgICAgLS0gTW92ZSBjdXJzb3IgdG8gcmlnaHQgbmVpZ2hib3JcbiAgICAgIC0tIChvciBgYWZ0ZXInIGlmIG5vIHJpZ2h0IG5laWdoYm9yKS5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBhZnRlcl93aGVuX2VtcHR5OiBpc19lbXB0eSBpbXBsaWVzIGFmdGVyXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2xlZnRcbiAgICAgIC0tIFJlbW92ZSBpdGVtIHRvIHRoZSBsZWZ0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHJlbW92ZV9yaWdodFxuICAgICAgLS0gUmVtb3ZlIGl0ZW0gdG8gdGhlIHJpZ2h0IG9mIGN1cnNvciBwb3NpdGlvbi5cbiAgICAgIC0tIERvIG5vdCBtb3ZlIGN1cnNvci5cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zLlxuICAgIGRvXG4gICAgICBjaGFpbl93aXBlX291dFxuICAgICAgYmFja1xuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19iZWZvcmU6IGJlZm9yZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIENvbnN0YW50cyB1c2VkIGZvciBleGNlcHRpb24gaGFuZGxpbmcuXG4gICAgVGhpcyBjbGFzcyBtYXkgYmUgdXNlZCBhcyBhbmNlc3RvciBieSBjbGFzc2VzIG5lZWRpbmcgaXRzIGZhY2lsaXRpZXMuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIEVYQ0VQX0NPTlNUXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgVm9pZF9jYWxsX3RhcmdldDogSU5URUdFUiA9IDFcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBmZWF0dXJlIGFwcGxpZWQgdG8gdm9pZCByZWZlcmVuY2VcblxuICBOb19tb3JlX21lbW9yeTogSU5URUdFUiA9IDJcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBmYWlsZWQgbWVtb3J5IGFsbG9jYXRpb25cblxuICBQcmVjb25kaXRpb246IElOVEVHRVIgPSAzXG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgdmlvbGF0ZWQgcHJlY29uZGl0aW9uXG5cbiAgUG9zdGNvbmRpdGlvbjogSU5URUdFUiA9IDRcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciB2aW9sYXRlZCBwb3N0Y29uZGl0aW9uXG5cbiAgRmxvYXRpbmdfcG9pbnRfZXhjZXB0aW9uOiBJTlRFR0VSID0gNVxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIGZsb2F0aW5nIHBvaW50IGV4Y2VwdGlvblxuXG4gIENsYXNzX2ludmFyaWFudDogSU5URUdFUiA9IDZcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciB2aW9sYXRlZCBjbGFzcyBpbnZhcmlhbnRcblxuICBDaGVja19pbnN0cnVjdGlvbjogSU5URUdFUiA9IDdcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciB2aW9sYXRlZCBjaGVja1xuXG4gIFJvdXRpbmVfZmFpbHVyZTogSU5URUdFUiA9IDhcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBmYWlsZWQgcm91dGluZVxuXG4gIEluY29ycmVjdF9pbnNwZWN0X3ZhbHVlOiBJTlRFR0VSID0gIDlcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBpbnNwZWN0IHZhbHVlIHdoaWNoIGlzIG5vdCBvbmVcbiAgICAgIC0tIG9mIHRoZSBpbnNwZWN0IGNvbnN0YW50cywgaWYgdGhlcmUgaXMgbm8gRWxzZV9wYXJ0XG5cbiAgTG9vcF92YXJpYW50OiBJTlRFR0VSID0gMTBcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBub24tZGVjcmVhc2VkIGxvb3AgdmFyaWFudFxuXG4gIExvb3BfaW52YXJpYW50OiBJTlRFR0VSID0gMTFcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciB2aW9sYXRlZCBsb29wIGludmFyaWFudFxuXG4gIFNpZ25hbF9leGNlcHRpb246IElOVEVHRVIgPSAxMlxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIG9wZXJhdGluZyBzeXN0ZW0gc2lnbmFsXG5cbiAgRWlmZmVsX3J1bnRpbWVfcGFuaWM6IElOVEVHRVIgPSAxM1xuICAgICAgLS0gRWlmZmVsIHJ1bi10aW1lIHBhbmljXG5cbiAgUmVzY3VlX2V4Y2VwdGlvbjogSU5URUdFUiA9IDE0XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgZXhjZXB0aW9uIGluIHJlc2N1ZSBjbGF1c2VcblxuICBPdXRfb2ZfbWVtb3J5OiBJTlRFR0VSID0gMTVcbiAgICAgIC0tIE91dCBvZiBtZW1vcnkgKGNhbm5vdCBiZSBpZ25vcmVkKVxuXG4gIFJlc3VtcHRpb25fZmFpbGVkOiBJTlRFR0VSID0gMTZcbiAgICAgIC0tIFJlc3VtcHRpb24gZmFpbGVkIChyZXRyeSBkaWQgbm90IHN1Y2NlZWQpXG5cbiAgQ3JlYXRlX29uX2RlZmVycmVkOiBJTlRFR0VSID0gMTdcbiAgICAgIC0tIENyZWF0ZSBvbiBkZWZlcnJlZFxuXG4gIEV4dGVybmFsX2V4Y2VwdGlvbjogSU5URUdFUiA9IDE4XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3Igb3BlcmF0aW5nIHN5c3RlbSBlcnJvclxuICAgICAgLS0gd2hpY2ggZG9lcyBub3Qgc2V0IHRoZSBgZXJybm8nIHZhcmlhYmxlXG4gICAgICAtLSAoVW5peC1zcGVjaWZpYylcblxuICBWb2lkX2Fzc2lnbmVkX3RvX2V4cGFuZGVkOiBJTlRFR0VSID0gMTlcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBhc3NpZ25tZW50IG9mIHZvaWQgdmFsdWVcbiAgICAgIC0tIHRvIGV4cGFuZGVkIGVudGl0eVxuXG4gIEV4Y2VwdGlvbl9pbl9zaWduYWxfaGFuZGxlcjogSU5URUdFUiA9IDIwXG4gICAgICAtLSBFeGNlcHRpb24gaW4gc2lnbmFsIGhhbmRsZXJcblxuICBJb19leGNlcHRpb246IElOVEVHRVIgPSAyMVxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIEkvTyBlcnJvclxuXG4gIE9wZXJhdGluZ19zeXN0ZW1fZXhjZXB0aW9uOiBJTlRFR0VSID0gMjJcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBvcGVyYXRpbmcgc3lzdGVtIGVycm9yXG4gICAgICAtLSB3aGljaCBzZXRzIHRoZSBgZXJybm8nIHZhcmlhYmxlXG4gICAgICAtLSAoVW5peC1zcGVjaWZpYylcblxuICBSZXRyaWV2ZV9leGNlcHRpb246IElOVEVHRVIgPSAyM1xuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIHJldHJpZXZhbCBlcnJvclxuICAgICAgLS0gbWF5IGJlIHJhaXNlZCBieSBgcmV0cmlldmVkJyBpbiBgSU9fTUVESVVNJy5cblxuICBEZXZlbG9wZXJfZXhjZXB0aW9uOiBJTlRFR0VSID0gMjRcbiAgICAgIC0tIEV4Y2VwdGlvbiBjb2RlIGZvciBkZXZlbG9wZXIgZXhjZXB0aW9uXG5cbiAgRWlmZmVsX3J1bnRpbWVfZmF0YWxfZXJyb3I6IElOVEVHRVIgPSAyNVxuICAgICAgLS0gRWlmZmVsIHJ1bi10aW1lIGZhdGFsIGVycm9yXG5cbiAgRG9sbGFyX2FwcGxpZWRfdG9fbWVsdGVkX2ZlYXR1cmU6IElOVEVHRVIgPSAyNlxuICAgICAgLS0gJCBhcHBsaWVkIHRvIG1lbHRlZCBmZWF0dXJlXG5cbiAgUnVudGltZV9pb19leGNlcHRpb246IElOVEVHRVIgPSAyN1xuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIEkvTyBlcnJvciByYWlzZWQgYnkgcnVudGltZSBmdW5jdGlvbnNcbiAgICAgIC0tIHN1Y2ggYXMgc3RvcmUvcmV0cmlldmUsIGZpbGUgYWNjZXNzLi4uXG5cbiAgQ29tX2V4Y2VwdGlvbjogSU5URUdFUiA9IDI4XG4gICAgICAtLSBFeGNlcHRpb24gY29kZSBmb3IgYSBDT00gZXJyb3IuXG5cbiAgUnVudGltZV9jaGVja19leGNlcHRpb246IElOVEVHRVIgPSAyOVxuICAgICAgLS0gRXhjZXB0aW9uIGNvZGUgZm9yIHJ1bnRpbWUgY2hlY2sgYmVpbmcgdmlvbGF0ZWQuXG5cbiAgb2xkX2V4Y2VwdGlvbjogSU5URUdFUiA9IDMwXG4gICAgICAtLSBPbGQgZXhjZXB0aW9uIGNvZGUuXG5cbiAgc2VyaWFsaXphdGlvbl9leGNlcHRpb246IElOVEVHRVIgPSAzMVxuICAgICAgLS0gU2VyaWFsaXphdGlvbiBleGNlcHRpb24gY29kZS5cblxuICBudW1iZXJfb2ZfY29kZXM6IElOVEVHRVIgPSAzMVxuICAgICAgLS0gSG93IG1hbnkgY29kZXMgYXJlIHRoZXJlIHRvIHJlcHJlc2VudCBleGNlcHRpb25zP1xuXG4gIHZhbGlkX2NvZGUgKGM6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYycgYSB2YWxpZCBjb2RlIHRvIHJlcHJlc2VudCBzb21lIGtpbmQgb2YgZXhjZXB0aW9ucz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGMgPj0gMSBhbmQgYyA8PSBudW1iZXJfb2ZfY29kZXNcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBBbmNlc3RvciBvZiBhbGwgZXhjZXB0aW9uIGNsYXNzZXMuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMi0yOCAwNjowNzowMyAtMDgwMCAoRnJpLCAyOCBEZWMgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwOTggJFwiXG5cbmNsYXNzXG4gIEVYQ0VQVElPTlxuXG5pbmhlcml0XG4gIEVYQ0VQVElPTl9NQU5BR0VSX0ZBQ1RPUllcbiAgICB1bmRlZmluZVxuICAgICAgb3V0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV93aXRoX3RhZ19hbmRfdHJhY2VcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX3dpdGhfdGFnX2FuZF90cmFjZSAoYV90YWcsIGFfdHJhY2Vfc3RyaW5nOiBTVFJJTkcpXG4gICAgICAtLSBNYWtlIGBDdXJyZW50JyB3aXRoIGBkZXNjcmlwdGlvbicgc2V0IHRvIGBhX3RhZycuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBkZWZhdWx0X2NyZWF0ZScgYW5kIGBzZXRfZGVzY3JpcHRpb24nIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB0YWdfbm90X3ZvaWQ6IGFfdGFnIC89IFZvaWRcbiAgICAgIHRyYWNlX3N0cmluZ19ub3Rfdm9pZDogYV90cmFjZV9zdHJpbmcgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfZGVzY3JpcHRpb24gKGFfdGFnKVxuICAgIGVuc3VyZVxuICAgICAgZGVzY3JpcHRpb25fc2V0OiBhdHRhY2hlZCBkZXNjcmlwdGlvbiBhcyBsX2RlcyBhbmQgdGhlbiBhX3RhZy5zYW1lX3N0cmluZ19nZW5lcmFsIChsX2RlcylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSYWlzZVxuXG4gIHJhaXNlXG4gICAgICAtLSBSYWlzZSBjdXJyZW50IGV4Y2VwdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIGlzX3JhaXNhYmxlOiBpc19yYWlzYWJsZVxuICAgIGRvXG4gICAgICBleGNlcHRpb25fbWFuYWdlci5yYWlzZSAoQ3VycmVudClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBtZWFuaW5nOiBTVFJJTkdcbiAgICAgIC0tIEEgc2hvcnQgbWVzc2FnZSBkZXNjcmliaW5nIHdoYXQgY3VycmVudCBleGNlcHRpb24gaXNcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRhZycgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdGFnLmFzX3N0cmluZ184XG4gICAgZW5kXG5cbiAgdGFnOiBJTU1VVEFCTEVfU1RSSU5HXzMyXG4gICAgICAtLSBBIHNob3J0IG1lc3NhZ2UgZGVzY3JpYmluZyB3aGF0IGN1cnJlbnQgZXhjZXB0aW9uIGlzXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nXzggKFwiR2VuZXJhbCBleGNlcHRpb25cIilcbiAgICBlbmRcblxuICBtZXNzYWdlOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gTWVzc2FnZSBvZiBjdXJyZW50IGV4Y2VwdGlvblxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgZGVzY3JpcHRpb24nIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgY19kZXNjcmlwdGlvbiBhcyBsX20gdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9tLnN1YnN0cmluZyAoMSwgbF9tLmNvdW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZGVzY3JpcHRpb246IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HX0dFTkVSQUxcbiAgICAgIC0tIERldGFpbGVkIGRlc2NyaXB0aW9uIG9mIGN1cnJlbnQgZXhjZXB0aW9uXG4gICAgbG9jYWxcbiAgICAgIHU6IFVURl9DT05WRVJURVJcbiAgICAgIGxfcmVzOiBTVFJJTkdfMzJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgY19kZXNjcmlwdGlvbiBhcyBsX20gdGhlblxuICAgICAgICAgIC0tIERlc2NyaXB0aW9uIGlzIGVuY29kZWQgaW4gVVRGLTggYnkgdGhlIHJ1bnRpbWUuXG4gICAgICAgIGNyZWF0ZSBsX3Jlcy5tYWtlIChsX20uY291bnQpXG4gICAgICAgIHUudXRmXzhfMF9zdWJwb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKGxfbS5tYW5hZ2VkX2RhdGEsIDAsIGxfbS5jb3VudCAtIDEsIEZhbHNlLCBsX3JlcylcbiAgICAgICAgUmVzdWx0IDo9IGxfcmVzXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBleGNlcHRpb25fdHJhY2U6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgY3VycmVudCBleGNlcHRpb24gdHJhY2VcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRyYWNlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpbnRlcm5hbF90cmFjZVxuICAgIGVuZFxuXG4gIHRyYWNlOiBkZXRhY2hhYmxlIFNUUklOR18zMlxuICAgICAgLS0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGN1cnJlbnQgZXhjZXB0aW9uIHRyYWNlXG4gICAgbG9jYWxcbiAgICAgIHU6IFVURl9DT05WRVJURVJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgaW50ZXJuYWxfdHJhY2UgYXMgbF90cmFjZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB1LnV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAobF90cmFjZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNvZGU6IElOVEVHRVJcbiAgICAgIC0tIENvZGUgb2YgdGhlIGV4Y2VwdGlvbi5cbiAgICBkb1xuICAgIGVuZFxuXG4gIGZyb3plbiBvcmlnaW5hbDogRVhDRVBUSU9OXG4gICAgICAtLSBUaGUgb3JpZ2luYWwgZXhjZXB0aW9uIGRpcmVjdGx5IHRyaWdnZXJlZCBjdXJyZW50IGV4Y2VwdGlvblxuICAgIGxvY2FsXG4gICAgICB0OiBsaWtlIHRocm93aW5nX2V4Y2VwdGlvblxuICAgIGRvXG4gICAgICB0IDo9IHRocm93aW5nX2V4Y2VwdGlvblxuICAgICAgaWYgdCA9IEN1cnJlbnQgb3IgZWxzZSB0ID0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlaWYgKGF0dGFjaGVkIHtST1VUSU5FX0ZBSUxVUkV9IEN1cnJlbnQpIG9yIGVsc2UgKGF0dGFjaGVkIHtPTERfVklPTEFUSU9OfSBDdXJyZW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB0Lm9yaWdpbmFsXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG9yaWdpbmFsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBjYXVzZTogRVhDRVBUSU9OXG4gICAgICAtLSBUaGUgY2F1c2Ugb2YgY3VycmVudCBleGNlcHRpb24gcmFpc2VkIGR1cmluZyByZXNjdWUgcHJvY2Vzc2luZ1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBvcmlnaW5hbC50aHJvd2luZ19leGNlcHRpb24gYXMgZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBlXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNhdXNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiByZWNpcGllbnRfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgdGhlIHJvdXRpbmUgd2hvc2UgZXhlY3V0aW9uIHdhc1xuICAgICAgLS0gaW50ZXJydXB0ZWQgYnkgY3VycmVudCBleGNlcHRpb25cblxuICBmcm96ZW4gdHlwZV9uYW1lOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiB0aGUgY2xhc3MgdGhhdCBpbmNsdWRlcyB0aGUgcmVjaXBpZW50XG4gICAgICAtLSBvZiBvcmlnaW5hbCBmb3JtIG9mIGN1cnJlbnQgZXhjZXB0aW9uXG5cbiAgZnJvemVuIGxpbmVfbnVtYmVyOiBJTlRFR0VSXG4gICAgICAtLSBMaW5lIG51bWJlclxuXG5mZWF0dXJlIC0tIEFjY2VzcyBvYnNlbGV0ZVxuXG4gIHRyYWNlX2FzX3N0cmluZzogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIEV4Y2VwdGlvbiB0cmFjZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZ1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdHJhY2UnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGV4Y2VwdGlvbl90cmFjZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyBzZXR0aW5nc1xuXG4gIHNldF9tZXNzYWdlIChhX21lc3NhZ2U6IGxpa2UgbWVzc2FnZSlcbiAgICAgIC0tIFNldCBgbWVzc2FnZScgd2l0aCBgYV9tZXNzYWdlJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHNldF9kZXNjcmlwdGlvbicgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBzZXRfZGVzY3JpcHRpb24gKGFfbWVzc2FnZSlcbiAgICBlbnN1cmVcbiAgICAgIG1lc3NhZ2Vfc2V0OiBtZXNzYWdlIH4gYV9tZXNzYWdlXG4gICAgZW5kXG5cbiAgc2V0X2Rlc2NyaXB0aW9uIChhX2Rlc2NyaXB0aW9uOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gU2V0IGBkZXNjcmlwdGlvbicgd2l0aCBgYV9kZXNjcmlwdGlvbicuXG4gICAgbG9jYWxcbiAgICAgIHU6IFVURl9DT05WRVJURVJcbiAgICAgIGxfdXBwZXI6IENFTEwgW0lOVEVHRVJdXG4gICAgICBsX2M6IGxpa2UgY19kZXNjcmlwdGlvblxuICAgIGRvXG4gICAgICBpZiBhX2Rlc2NyaXB0aW9uIC89IFZvaWQgdGhlblxuICAgICAgICBjcmVhdGUgbF9jLm1ha2VfZW1wdHkgKGFfZGVzY3JpcHRpb24uY291bnQpXG4gICAgICAgIGNyZWF0ZSBsX3VwcGVyLnB1dCAoMClcbiAgICAgICAgdS51dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfMF9wb2ludGVyIChhX2Rlc2NyaXB0aW9uLCBsX2MubWFuYWdlZF9kYXRhLCAwLCBsX3VwcGVyKVxuICAgICAgICBsX2Muc2V0X2NvdW50IChsX3VwcGVyLml0ZW0pXG4gICAgICAgIGNfZGVzY3JpcHRpb24gOj0gbF9jXG4gICAgICBlbHNlXG4gICAgICAgIGNfZGVzY3JpcHRpb24gOj0gVm9pZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZXNjcmlwdGlvbl9zZXQ6IChhdHRhY2hlZCBhX2Rlc2NyaXB0aW9uIGFzIGFfZGVzIGFuZCB0aGVuIGF0dGFjaGVkIGRlc2NyaXB0aW9uIGFzIGxfZGVzIGFuZCB0aGVuIGxfZGVzLnNhbWVfc3RyaW5nIChsX2RlcykpIG9yIGVsc2VcbiAgICAgICAgICAgICAgKGFfZGVzY3JpcHRpb24gPSBWb2lkIGFuZCB0aGVuIGRlc2NyaXB0aW9uID0gVm9pZClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZnJvemVuIGlzX2lnbm9yYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBleGNlcHRpb24gaWdub3JhYmxlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZXhjZXB0aW9uX21hbmFnZXIuaXNfaWdub3JhYmxlIChnZW5lcmF0aW5nX3R5cGUpXG4gICAgZW5kXG5cbiAgZnJvemVuIGlzX3JhaXNhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGV4Y2VwdGlvbiByYWlzYWJsZSBieSBgcmFpc2UnP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZXhjZXB0aW9uX21hbmFnZXIuaXNfcmFpc2FibGUgKGdlbmVyYXRpbmdfdHlwZSlcbiAgICBlbmRcblxuICBmcm96ZW4gaXNfaWdub3JlZDogQk9PTEVBTlxuICAgICAgLS0gSWYgc2V0LCBjdXJyZW50IGV4Y2VwdGlvbiBpcyBub3QgcmFpc2VkLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZXhjZXB0aW9uX21hbmFnZXIuaXNfaWdub3JlZCAoZ2VuZXJhdGluZ190eXBlKVxuICAgIGVuc3VyZVxuICAgICAgaXNfaWdub3JlZF9pbXBsaWVzX2lzX2lnbm9yYWJsZTogUmVzdWx0IGltcGxpZXMgaXNfaWdub3JhYmxlXG4gICAgICBub3RfaXNfY2F1Z2h0OiBSZXN1bHQgPSBub3QgaXNfY2F1Z2h0XG4gICAgZW5kXG5cbiAgZnJvemVuIGlzX2NhdWdodDogQk9PTEVBTlxuICAgICAgLS0gSWYgc2V0LCBjdXJyZW50IGV4Y2VwdGlvbiBpcyByYWlzZWQuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBub3QgaXNfaWdub3JlZFxuICAgIGVuc3VyZVxuICAgICAgbm90X2lzX2NhdWdodF9pbXBsaWVzX2lzX2lnbm9yYWJsZTogbm90IFJlc3VsdCBpbXBsaWVzIGlzX2lnbm9yYWJsZVxuICAgICAgbm90X2lzX2lnbm9yZWQ6IFJlc3VsdCA9IG5vdCBpc19pZ25vcmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIE5ldyBzdHJpbmcgY29udGFpbmluZyB0ZXJzZSBwcmludGFibGUgcmVwcmVzZW50YXRpb25cbiAgICAgIC0tIG9mIGN1cnJlbnQgb2JqZWN0XG4gICAgbG9jYWxcbiAgICAgIHQ6IGRldGFjaGFibGUgU1RSSU5HXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBnZW5lcmF0aW5nX3R5cGVcbiAgICAgIHQgOj0gdHJhY2VcbiAgICAgIGlmIHQgLz0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdC5hcHBlbmRfY2hhcmFjdGVyICgnJU4nKVxuICAgICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZyAodC5hc19zdHJpbmdfOClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtFWENFUFRJT059IC0tIEFjY2Vzc1xuXG4gIGZyb3plbiB0aHJvd2luZ19leGNlcHRpb246IGRldGFjaGFibGUgRVhDRVBUSU9OXG4gICAgICAtLSBUaGUgZXhjZXB0aW9uIHRocm93aW5nIGN1cnJlbnQgZXhjZXB0aW9uXG5cbmZlYXR1cmUge0VYQ0VQVElPTl9NQU5BR0VSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfdGhyb3dpbmdfZXhjZXB0aW9uIChhX2V4Y2VwdGlvbjogZGV0YWNoYWJsZSBFWENFUFRJT04pXG4gICAgICAtLSBTZXQgYHRocm93aW5nX2V4Y2VwdGlvbicgd2l0aCBgYV9leGNlcHRpb24nLlxuICAgIGRvXG4gICAgICB0aHJvd2luZ19leGNlcHRpb24gOj0gYV9leGNlcHRpb25cbiAgICBlbnN1cmVcbiAgICAgIHRocm93aW5nX2V4Y2VwdGlvbl9zZXQ6IHRocm93aW5nX2V4Y2VwdGlvbiA9IGFfZXhjZXB0aW9uXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9yZWNpcGllbnRfbmFtZSAoYV9uYW1lOiBsaWtlIHJlY2lwaWVudF9uYW1lKVxuICAgICAgLS0gU2V0IGByZWNpcGllbnRfbmFtZScgd2l0aCBgYV9uYW1lJ1xuICAgIGRvXG4gICAgICByZWNpcGllbnRfbmFtZSA6PSBhX25hbWVcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2xpbmVfbnVtYmVyIChhX251bWJlcjogbGlrZSBsaW5lX251bWJlcilcbiAgICAgIC0tIFNldCBgbGluZV9udW1iZXInIHdpdGggYGFfbnVtYmVyJy5cbiAgICBkb1xuICAgICAgbGluZV9udW1iZXIgOj0gYV9udW1iZXJcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2NfZGVzY3JpcHRpb24gKGFfZGVzOiBkZXRhY2hhYmxlIFNUUklOR184KVxuICAgICAgLS0gU2V0IGBjX2Rlc2NyaXB0aW9uJyB3aXRoIGBhX2RlcycuIGBhX2RlcycgaXMgaW4gVVRGLTguXG4gICAgZG9cbiAgICAgIGlmIGFfZGVzIC89IFZvaWQgdGhlblxuICAgICAgICBjcmVhdGUgY19kZXNjcmlwdGlvbi5tYWtlIChhX2RlcylcbiAgICAgIGVsc2VcbiAgICAgICAgY19kZXNjcmlwdGlvbiA6PSBWb2lkXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjX2Rlc2NyaXB0aW9uOiBkZXRhY2hhYmxlIENfU1RSSU5HXG4gICAgICAtLSBNZXNzYWdlLCBzdG9yZWQgYXMgQyBzdHJpbmcgdG8ga2VlcCBpdCBhbGl2ZSBhbmQgdXNhYmxlIGJ5IHRoZSBydW50aW1lIHRyYWNlIHByaW50aW5nLlxuXG4gIGZyb3plbiBzZXRfdHlwZV9uYW1lIChhX3R5cGU6IGxpa2UgdHlwZV9uYW1lKVxuICAgICAgLS0gU2V0IGB0eXBlX25hbWUnIHdpdGggYGFfdHlwZSdcbiAgICBkb1xuICAgICAgdHlwZV9uYW1lIDo9IGFfdHlwZVxuICAgIGVuZFxuXG4gIGZyb3plbiBpbnRlcm5hbF9pc19pZ25vcmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIEludGVybmFsIGBpc19pZ25vcmFibGUnXG5cbiAgZnJvemVuIHNldF9leGNlcHRpb25fdHJhY2UgKGFfdHJhY2U6IGxpa2UgZXhjZXB0aW9uX3RyYWNlKVxuICAgICAgLS0gU2V0IGBleGNlcHRpb25fdHJhY2UnIHdpdGggYGFfdHJhY2UnLlxuICAgIGRvXG4gICAgICBpbnRlcm5hbF90cmFjZSA6PSBhX3RyYWNlXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfdHJhY2U6IGRldGFjaGFibGUgU1RSSU5HO1xuICAgICAgLS0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBleGNlcHRpb24gdHJhY2Vcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBDb21tb24gZXhjZXB0aW9uIG9wZXJhdGlvbnMgYW5kIG1hbmFnZW1lbnQuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIEVYQ0VQVElPTl9NQU5BR0VSXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbGFzdF9leGNlcHRpb246IGRldGFjaGFibGUgRVhDRVBUSU9OXG4gICAgICAtLSBMYXN0IGV4Y2VwdGlvblxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSYWlzZVxuXG4gIHJhaXNlIChhX2V4Y2VwdGlvbjogRVhDRVBUSU9OKVxuICAgICAgLS0gUmFpc2UgYGFfZXhjZXB0aW9uJy5cbiAgICByZXF1aXJlXG4gICAgICBhX2V4Y2VwdGlvbl9ub3Rfdm9pZDogYV9leGNlcHRpb24gLz0gVm9pZFxuICAgICAgYV9leGNlcHRpb25faXNfcmFpc2FibGU6IGFfZXhjZXB0aW9uLmlzX3JhaXNhYmxlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyBzZXR0aW5nXG5cbiAgaWdub3JlIChhX2V4Y2VwdGlvbjogVFlQRSBbZGV0YWNoYWJsZSBFWENFUFRJT05dKVxuICAgICAgLS0gSWdub3JlIHR5cGUgb2YgYGFfZXhjZXB0aW9uJy5cbiAgICByZXF1aXJlXG4gICAgICBhX2V4Y2VwdGlvbl9ub3Rfdm9pZDogYV9leGNlcHRpb24gLz0gVm9pZFxuICAgICAgaXNfaWdub3JhYmxlOiBpc19pZ25vcmFibGUgKGFfZXhjZXB0aW9uKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGlzX2NhdWdodDogaXNfaWdub3JlZCAoYV9leGNlcHRpb24pXG4gICAgZW5kXG5cbiAgY2F0Y2ggKGFfZXhjZXB0aW9uOiBUWVBFIFtkZXRhY2hhYmxlIEVYQ0VQVElPTl0pXG4gICAgICAtLSBTZXQgdHlwZSBvZiBgYV9leGNlcHRpb24nIGBpc19jYXVnaHQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfZXhjZXB0aW9uX25vdF92b2lkOiBhX2V4Y2VwdGlvbiAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXNfaWdub3JlZDogbm90IGlzX2lnbm9yZWQgKGFfZXhjZXB0aW9uKVxuICAgIGVuZFxuXG4gIHNldF9pc19pZ25vcmVkIChhX2V4Y2VwdGlvbjogVFlQRSBbZGV0YWNoYWJsZSBFWENFUFRJT05dOyBhX2lnbm9yZWQ6IEJPT0xFQU4pXG4gICAgICAtLSBTZXQgdHlwZSBvZiBgYV9leGNlcHRpb24nIHRvIGJlIGBhX2lnbm9yZWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfZXhjZXB0aW9uX25vdF92b2lkOiBhX2V4Y2VwdGlvbiAvPSBWb2lkXG4gICAgICBhX2lnbm9yZWRfaW1wbGllc19pc19pZ25vcmFibGU6IGFfaWdub3JlZCBpbXBsaWVzIGlzX2lnbm9yYWJsZSAoYV9leGNlcHRpb24pXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXNfaWdub3JlZF9zZXQ6IGlzX2lnbm9yZWQgKGFfZXhjZXB0aW9uKSA9IGFfaWdub3JlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19pZ25vcmFibGUgKGFfZXhjZXB0aW9uOiBUWVBFIFtkZXRhY2hhYmxlIEVYQ0VQVElPTl0pOiBCT09MRUFOXG4gICAgICAtLSBJZiBzZXQsIHR5cGUgb2YgYGFfZXhjZXB0aW9uJyBpcyBpZ25vcmFibGUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlzX3JhaXNhYmxlIChhX2V4Y2VwdGlvbjogVFlQRSBbZGV0YWNoYWJsZSBFWENFUFRJT05dKTogQk9PTEVBTlxuICAgICAgLS0gSWYgc2V0LCB0eXBlIG9mIGBhX2V4Y2VwdGlvbicgaXMgcmFpc2FibGUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlzX2lnbm9yZWQgKGFfZXhjZXB0aW9uOiBUWVBFIFtkZXRhY2hhYmxlIEVYQ0VQVElPTl0pOiBCT09MRUFOXG4gICAgICAtLSBJZiBzZXQsIHR5cGUgb2YgYGFfZXhjZXB0aW9uJyBpcyBub3QgcmFpc2VkLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9pc19jYXVnaHQ6IFJlc3VsdCA9IG5vdCBpc19jYXVnaHQgKGFfZXhjZXB0aW9uKVxuICAgIGVuZFxuXG4gIGlzX2NhdWdodCAoYV9leGNlcHRpb246IFRZUEUgW2RldGFjaGFibGUgRVhDRVBUSU9OXSk6IEJPT0xFQU5cbiAgICAgIC0tIElmIHNldCwgdHlwZSBvZiBgYV9leGNlcHRpb24nIGlzIHJhaXNlZC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBub3RfaXNfaWdub3JlZDogUmVzdWx0ID0gbm90IGlzX2lnbm9yZWQgKGFfZXhjZXB0aW9uKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtFWENFUFRJT05TfSAtLSBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IHN1cHBvcnRcblxuICB0eXBlX29mX2NvZGUgKGFfY29kZTogSU5URUdFUik6IGRldGFjaGFibGUgVFlQRSBbRVhDRVBUSU9OXVxuICAgICAgLS0gRXhjZXB0aW9uIHR5cGUgb2YgYGFfY29kZSdcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgZXhjZXB0aW9uX2Zyb21fY29kZSAoYV9jb2RlOiBJTlRFR0VSKTogZGV0YWNoYWJsZSBFWENFUFRJT05cbiAgICAgIC0tIENyZWF0ZSBleGNlcHRpb24gb2JqZWN0IGZyb20gYGFfY29kZSdcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgRXhjZXB0aW9uIG1hbmFnZXIgZmFjdG9yeS5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3NcbiAgRVhDRVBUSU9OX01BTkFHRVJfRkFDVE9SWVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGV4Y2VwdGlvbl9tYW5hZ2VyOiBFWENFUFRJT05fTUFOQUdFUlxuICAgICAgLS0gRXhjZXB0aW9uIG1hbmFnZXJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBleGNlcHRpb25fbWFuYWdlcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMS0xOCAxMTo1MDozMSAtMDgwMCAoRnJpLCAxOCBKYW4gMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxMjYgJFwiXG5cbmNsYXNzIEVYQ0VQVElPTlNcblxuaW5oZXJpdFxuICBFWENFUF9DT05TVFxuXG4gIEVYQ0VQVElPTl9NQU5BR0VSX0ZBQ1RPUllcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgbWVhbmluZyAoZXhjZXB0OiBJTlRFR0VSKTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIEEgbWVzc2FnZSBpbiBFbmdsaXNoIGRlc2NyaWJpbmcgd2hhdCBgZXhjZXB0JyBpc1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5leGNlcHRpb25fZnJvbV9jb2RlIChleGNlcHQpIGFzIGxfZXhjZXB0aW9uIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZXhjZXB0aW9uLnRhZy5hc19zdHJpbmdfOFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXNzZXJ0aW9uX3Zpb2xhdGlvbjogQk9PTEVBTlxuICAgICAgLS0gSXMgbGFzdCBleGNlcHRpb24gb3JpZ2luYWxseSBkdWUgdG8gYSB2aW9sYXRlZFxuICAgICAgLS0gYXNzZXJ0aW9uIG9yIG5vbi1kZWNyZWFzaW5nIHZhcmlhbnQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiBhbmQgdGhlblxuICAgICAgICAgICAgYXR0YWNoZWQge0FTU0VSVElPTl9WSU9MQVRJT059IGxfZXhjZXB0aW9uLm9yaWdpbmFsXG4gICAgZW5kXG5cbiAgaXNfZGV2ZWxvcGVyX2V4Y2VwdGlvbjogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlIGxhc3QgZXhjZXB0aW9uIG9yaWdpbmFsbHkgZHVlIHRvXG4gICAgICAtLSBhIGRldmVsb3BlciBleGNlcHRpb24/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiBhbmQgdGhlblxuICAgICAgICAgICAgYXR0YWNoZWQge0RFVkVMT1BFUl9FWENFUFRJT059IGxfZXhjZXB0aW9uLm9yaWdpbmFsXG4gICAgZW5kXG5cbiAgaXNfZGV2ZWxvcGVyX2V4Y2VwdGlvbl9vZl9uYW1lIChuYW1lOiBkZXRhY2hhYmxlIFNUUklORyk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZSBsYXN0IGV4Y2VwdGlvbiBvcmlnaW5hbGx5IGR1ZSB0byBhIGRldmVsb3BlclxuICAgICAgLS0gZXhjZXB0aW9uIG9mIG5hbWUgYG5hbWUnP1xuICAgIGRvXG4gICAgICBpZiBpc19kZXZlbG9wZXJfZXhjZXB0aW9uIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRldmVsb3Blcl9leGNlcHRpb25fbmFtZSB+IG5hbWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRldmVsb3Blcl9leGNlcHRpb25fbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgbGFzdCBkZXZlbG9wZXItcmFpc2VkIGV4Y2VwdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIGFwcGxpY2FibGU6IGlzX2RldmVsb3Blcl9leGNlcHRpb25cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gYW5kIHRoZW4gYXR0YWNoZWQgbF9leGNlcHRpb24ub3JpZ2luYWwuZGVzY3JpcHRpb24gYXMgbF9kZXMgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9kZXMuYXNfc3RyaW5nXzhcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGlzX3NpZ25hbDogQk9PTEVBTlxuICAgICAgLS0gSXMgbGFzdCBleGNlcHRpb24gb3JpZ2luYWxseSBkdWUgdG8gYW4gZXh0ZXJuYWxcbiAgICAgIC0tIGV2ZW50IChvcGVyYXRpbmcgc3lzdGVtIHNpZ25hbCk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiBhbmQgdGhlblxuICAgICAgICAgICAgYXR0YWNoZWQge09QRVJBVElOR19TWVNURU1fU0lHTkFMX0ZBSUxVUkV9IGxfZXhjZXB0aW9uLm9yaWdpbmFsXG4gICAgZW5kXG5cbiAgaXNfc3lzdGVtX2V4Y2VwdGlvbjogQk9PTEVBTlxuICAgICAgLS0gSXMgbGFzdCBleGNlcHRpb24gb3JpZ2luYWxseSBkdWUgdG8gYW5cbiAgICAgIC0tIGV4dGVybmFsIGV2ZW50IChvcGVyYXRpbmcgc3lzdGVtIGVycm9yKT9cbiAgICBkb1xuICAgICAgaWZcbiAgICAgICAgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gYW5kXG4gICAgICAgIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmV4Y2VwdGlvbl9mcm9tX2NvZGUgKGV4dGVybmFsX2V4Y2VwdGlvbikgYXMgbF9leHRlcm5hbFxuICAgICAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9leGNlcHRpb24ub3JpZ2luYWwuY29uZm9ybXNfdG8gKGxfZXh0ZXJuYWwpIG9yIGVsc2VcbiAgICAgICAgICAgIGF0dGFjaGVkIHtPUEVSQVRJTkdfU1lTVEVNX0ZBSUxVUkV9IGxfZXhjZXB0aW9uLm9yaWdpbmFsXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0YWdfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIFRhZyBvZiBsYXN0IHZpb2xhdGVkIGFzc2VydGlvbiBjbGF1c2VcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgZXhjZXB0aW9uX21hbmFnZXIubGFzdF9leGNlcHRpb24gYXMgbF9leGNlcHRpb24gYW5kIHRoZW4gYXR0YWNoZWQgbF9leGNlcHRpb24uZGVzY3JpcHRpb24gYXMgbF9kZXMgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9kZXMuYXNfc3RyaW5nXzhcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlY2lwaWVudF9uYW1lOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiB0aGUgcm91dGluZSB3aG9zZSBleGVjdXRpb24gd2FzXG4gICAgICAtLSBpbnRlcnJ1cHRlZCBieSBsYXN0IGV4Y2VwdGlvblxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi5yZWNpcGllbnRfbmFtZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY2xhc3NfbmFtZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgdGhlIGNsYXNzIHRoYXQgaW5jbHVkZXMgdGhlIHJlY2lwaWVudFxuICAgICAgLS0gb2Ygb3JpZ2luYWwgZm9ybSBvZiBsYXN0IGV4Y2VwdGlvblxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci5sYXN0X2V4Y2VwdGlvbiBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX2V4Y2VwdGlvbi50eXBlX25hbWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGV4Y2VwdGlvbjogSU5URUdFUlxuICAgICAgLS0gQ29kZSBvZiBsYXN0IGV4Y2VwdGlvbiB0aGF0IG9jY3VycmVkXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZXhjZXB0aW9uLmNvZGVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGV4Y2VwdGlvbl90cmFjZTogZGV0YWNoYWJsZSBTVFJJTkdcbiAgICAgIC0tIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXhjZXB0aW9uIHRyYWNlXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIGFuZCB0aGVuIGF0dGFjaGVkIGxfZXhjZXB0aW9uLm9yaWdpbmFsLnRyYWNlIGFzIGxfdHJhY2UgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF90cmFjZS5hc19zdHJpbmdfOFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgb3JpZ2luYWxfdGFnX25hbWU6IGRldGFjaGFibGUgU1RSSU5HXG4gICAgICAtLSBBc3NlcnRpb24gdGFnIGZvciBvcmlnaW5hbCBmb3JtIG9mIGxhc3RcbiAgICAgIC0tIGFzc2VydGlvbiB2aW9sYXRpb24uXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIGFuZCB0aGVuIGF0dGFjaGVkIGxfZXhjZXB0aW9uLmNhdXNlLm9yaWdpbmFsLmRlc2NyaXB0aW9uIGFzIGxfZGVzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZGVzLmFzX3N0cmluZ184XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBvcmlnaW5hbF9leGNlcHRpb246IElOVEVHRVJcbiAgICAgIC0tIE9yaWdpbmFsIGNvZGUgb2YgbGFzdCBleGNlcHRpb24gdGhhdCB0cmlnZ2VyZWRcbiAgICAgIC0tIGN1cnJlbnQgZXhjZXB0aW9uXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZXhjZXB0aW9uLmNhdXNlLm9yaWdpbmFsLmNvZGVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG9yaWdpbmFsX3JlY2lwaWVudF9uYW1lOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiB0aGUgcm91dGluZSB3aG9zZSBleGVjdXRpb24gd2FzXG4gICAgICAtLSBpbnRlcnJ1cHRlZCBieSBvcmlnaW5hbCBmb3JtIG9mIGxhc3QgZXhjZXB0aW9uXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZXhjZXB0aW9uLmNhdXNlLm9yaWdpbmFsLnJlY2lwaWVudF9uYW1lXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBvcmlnaW5hbF9jbGFzc19uYW1lOiBkZXRhY2hhYmxlIFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiB0aGUgY2xhc3MgdGhhdCBpbmNsdWRlcyB0aGUgcmVjaXBpZW50XG4gICAgICAtLSBvZiBvcmlnaW5hbCBmb3JtIG9mIGxhc3QgZXhjZXB0aW9uXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmxhc3RfZXhjZXB0aW9uIGFzIGxfZXhjZXB0aW9uIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZXhjZXB0aW9uLmNhdXNlLm9yaWdpbmFsLnR5cGVfbmFtZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHNldHRpbmdcblxuICBjYXRjaCAoY29kZTogSU5URUdFUilcbiAgICAgIC0tIE1ha2Ugc3VyZSB0aGF0IGFueSBleGNlcHRpb24gb2YgY29kZSBgY29kZScgd2lsbCBiZVxuICAgICAgLS0gY2F1Z2h0LiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci50eXBlX29mX2NvZGUgKGNvZGUpIGFzIGxfdHlwZSB0aGVuXG4gICAgICAgIGV4Y2VwdGlvbl9tYW5hZ2VyLmNhdGNoIChsX3R5cGUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpZ25vcmUgKGNvZGU6IElOVEVHRVIpXG4gICAgICAtLSBNYWtlIHN1cmUgdGhhdCBhbnkgZXhjZXB0aW9uIG9mIGNvZGUgYGNvZGUnIHdpbGwgYmVcbiAgICAgIC0tIGlnbm9yZWQuIFRoaXMgaXMgbm90IHRoZSBkZWZhdWx0LlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCBleGNlcHRpb25fbWFuYWdlci50eXBlX29mX2NvZGUgKGNvZGUpIGFzIGxfdHlwZSB0aGVuXG4gICAgICAgIGV4Y2VwdGlvbl9tYW5hZ2VyLmlnbm9yZSAobF90eXBlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmFpc2UgKG5hbWU6IGRldGFjaGFibGUgU1RSSU5HKVxuICAgICAgLS0gUmFpc2UgYSBkZXZlbG9wZXIgZXhjZXB0aW9uIG9mIG5hbWUgYG5hbWUnLlxuICAgIGxvY2FsXG4gICAgICBsX2V4Y2VwdGlvbjogREVWRUxPUEVSX0VYQ0VQVElPTlxuICAgIGRvXG4gICAgICBjcmVhdGUgbF9leGNlcHRpb25cbiAgICAgIGxfZXhjZXB0aW9uLnNldF9kZXNjcmlwdGlvbiAobmFtZSlcbiAgICAgIGxfZXhjZXB0aW9uLnJhaXNlXG4gICAgZW5kXG5cbiAgcmFpc2VfcmV0cmlldmFsX2V4Y2VwdGlvbiAobmFtZTogZGV0YWNoYWJsZSBTVFJJTkcpXG4gICAgICAtLSBSYWlzZSBhIHJldHJpZXZhbCBleGNlcHRpb24gb2YgbmFtZSBgbmFtZScuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIGV4Y2VwdGlvbl9tYW5hZ2VyLmV4Y2VwdGlvbl9mcm9tX2NvZGUgKHNlcmlhbGl6YXRpb25fZXhjZXB0aW9uKSBhcyBsX2V4Y2VwdGlvbiB0aGVuXG4gICAgICAgIGxfZXhjZXB0aW9uLnNldF9kZXNjcmlwdGlvbiAobmFtZSlcbiAgICAgICAgbF9leGNlcHRpb24ucmFpc2VcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRpZSAoY29kZTogSU5URUdFUilcbiAgICAgIC0tIFRlcm1pbmF0ZSBleGVjdXRpb24gd2l0aCBleGl0IHN0YXR1cyBgY29kZScsXG4gICAgICAtLSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXhjZXB0aW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgdXNlICVcImVpZl9leGNlcHQuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZXNkaWVcIlxuICAgIGVuc3VyZVxuICAgICAgRmFsc2VcbiAgICBlbmRcblxuICBuZXdfZGllIChjb2RlOiBJTlRFR0VSKSBvYnNvbGV0ZSBcIlVzZSBgYGRpZScnXCJcbiAgICAgIC0tIFRlcm1pbmF0ZSBleGVjdXRpb24gd2l0aCBleGl0IHN0YXR1cyBgY29kZScsXG4gICAgICAtLSB3aXRob3V0IHRyaWdnZXJpbmcgYW4gZXhjZXB0aW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgdXNlICVcImVpZl9leGNlcHQuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZXNkaWVcIlxuICAgIGVuc3VyZVxuICAgICAgRmFsc2VcbiAgICBlbmRcblxuICBtZXNzYWdlX29uX2ZhaWx1cmVcbiAgICAgIC0tIFByaW50IGFuIGV4Y2VwdGlvbiBoaXN0b3J5IHRhYmxlXG4gICAgICAtLSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAgICAtLSBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgIGRvXG4gICAgICBjX3RyYWNlX2V4Y2VwdGlvbiAoVHJ1ZSlcbiAgICBlbmRcblxuICBub19tZXNzYWdlX29uX2ZhaWx1cmVcbiAgICAgIC0tIERvIG5vdCBwcmludCBhbiBleGNlcHRpb24gaGlzdG9yeSB0YWJsZVxuICAgICAgLS0gaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgIGRvXG4gICAgICBjX3RyYWNlX2V4Y2VwdGlvbiAoRmFsc2UpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgY190cmFjZV9leGNlcHRpb24gKGI6IEJPT0xFQU4pXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyB1c2UgJVwiZWlmX2V4Y2VwdC5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJlZXRyYWNlXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZXMgd2l0aCBhIGZpbml0ZSBpdGVtIGNvdW50XCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogZmluaXRlLCBzdG9yYWdlO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgRklOSVRFIFtHXSBpbmhlcml0XG5cbiAgQk9YIFtHXVxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBpdGVtc1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2VtcHR5OiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZW1wdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY291bnQgPSAwKVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZW1wdHlfZGVmaW5pdGlvbjogaXNfZW1wdHkgPSAoY291bnQgPSAwKVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIE9iamVjdHMgcmVwcmVzZW50aW5nIGRlbGF5ZWQgY2FsbHMgdG8gYSBmdW5jdGlvbixcbiAgICB3aXRoIHNvbWUgYXJndW1lbnRzIHBvc3NpYmx5IHN0aWxsIG9wZW4uXG5cbiAgICBOb3RlOiBGZWF0dXJlcyBhcmUgdGhlIHNhbWUgYXMgdGhvc2Ugb2YgUk9VVElORSxcbiAgICAgIHdpdGggYGFwcGx5JyBtYWRlIGVmZmVjdGl2ZSwgYW5kIHRoZSBhZGRpdGlvblxuICAgICAgb2YgYGxhc3RfcmVzdWx0JyBhbmQgYGl0ZW0nLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDEtMjggMTQ6MzU6MjMgLTA4MDAgKFR1ZSwgMjggSmFuIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0MTA5ICRcIlxuXG5jbGFzc1xuICBGVU5DVElPTiBbQkFTRV9UWVBFIC0+IGRldGFjaGFibGUgQU5ZLCBPUEVOX0FSR1MgLT4gZGV0YWNoYWJsZSBUVVBMRSBjcmVhdGUgZGVmYXVsdF9jcmVhdGUgZW5kLCBSRVNVTFRfVFlQRV1cblxuaW5oZXJpdFxuICBST1VUSU5FIFtCQVNFX1RZUEUsIE9QRU5fQVJHU11cbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIGNvcHlcbiAgICBlbmRcblxuY3JlYXRlIHtOT05FfVxuICBzZXRfcm91dF9kaXNwXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbGFzdF9yZXN1bHQ6IGRldGFjaGFibGUgUkVTVUxUX1RZUEVcbiAgICAgIC0tIFJlc3VsdCBvZiBsYXN0IGNhbGwsIGlmIGFueVxuXG4gIGNhbGwgKGFyZ3M6IGRldGFjaGFibGUgc2VwYXJhdGUgT1BFTl9BUkdTKVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgbGFzdF9yZXN1bHQgOj0gaXRlbSAoYXJncylcbiAgICBlbmRcblxuICBpdGVtIGFsaWFzIFwiKClcIiAoYXJnczogZGV0YWNoYWJsZSBzZXBhcmF0ZSBPUEVOX0FSR1MpOiBSRVNVTFRfVFlQRVxuICAgICAgLS0gUmVzdWx0IG9mIGNhbGxpbmcgZnVuY3Rpb24gd2l0aCBgYXJncycgYXMgb3BlcmFuZHMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfb3BlcmFuZHM6IHZhbGlkX29wZXJhbmRzIChhcmdzKVxuICAgIGxvY2FsXG4gICAgICBsX2Nsb3NlZF9jb3VudDogSU5URUdFUlxuICAgICAgYzogbGlrZSBjbG9zZWRfb3BlcmFuZHNcbiAgICBkb1xuICAgICAgYyA6PSBjbG9zZWRfb3BlcmFuZHNcbiAgICAgIGlmIGMvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jbG9zZWRfY291bnQgOj0gIGMuY291bnRcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IGZhc3RfaXRlbSAoZW5jYXBzX3JvdXRfZGlzcCwgY2FsY19yb3V0X2FkZHIsICRjbG9zZWRfb3BlcmFuZHMsICRhcmdzLCByb3V0aW5lX2lkLFxuICAgICAgICBpc19iYXNpYywgd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudCwgbF9jbG9zZWRfY291bnQsIG9wZW5fY291bnQsICRvcGVuX21hcClcbiAgICBlbmRcblxuICBhcHBseVxuICAgICAgLS0gQ2FsbCBmdW5jdGlvbiB3aXRoIGBvcGVyYW5kcycgYXMgbGFzdCBzZXQuXG4gICAgZG9cbiAgICAgIGxhc3RfcmVzdWx0IDo9IGl0ZW0gKG9wZXJhbmRzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGFzc29jaWF0ZWQgZnVuY3Rpb24gdGhlIHNhbWUgYXMgdGhlIG9uZVxuICAgICAgLS0gYXNzb2NpYXRlZCB3aXRoIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBQcmVjdXJzb3IgKG90aGVyKSBhbmQgdGhlbiAobGFzdF9yZXN1bHQgfiBvdGhlci5sYXN0X3Jlc3VsdClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBVc2Ugc2FtZSBmdW5jdGlvbiBhcyBgb3RoZXInLlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUHJlY3Vyc29yIChvdGhlcilcbiAgICAgICAgbGFzdF9yZXN1bHQgOj0gb3RoZXIubGFzdF9yZXN1bHRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE9ic29sZXRlXG5cbiAgZXZhbCAoYXJnczogZGV0YWNoYWJsZSBPUEVOX0FSR1MpOiBSRVNVTFRfVFlQRVxuICAgICAgLS0gUmVzdWx0IG9mIGV2YWx1YXRpbmcgZnVuY3Rpb24gZm9yIGBhcmdzJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJQbGVhc2UgdXNlIGBpdGVtJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIChhcmdzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICBjbGVhcl9sYXN0X3Jlc3VsdFxuICAgICAgLS0gUmVzZXQgY29udGVudCBvZiBgbGFzdF9yZXN1bHQnIHRvIGl0cyBkZWZhdWx0IHZhbHVlLlxuICAgIGxvY2FsXG4gICAgICBsX3Jlc3VsdDogZGV0YWNoYWJsZSBSRVNVTFRfVFlQRVxuICAgIGRvXG4gICAgICBsYXN0X3Jlc3VsdCA6PSBsX3Jlc3VsdFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEV4dGVuZGVkIG9wZXJhdGlvbnNcblxuICBmbGV4aWJsZV9pdGVtIChhOiBkZXRhY2hhYmxlIHNlcGFyYXRlIFRVUExFKTogUkVTVUxUX1RZUEVcbiAgICAgIC0tIFJlc3VsdCBvZiBjYWxsaW5nIGZ1bmN0aW9uIHdpdGggYGEnIGFzIGFyZ3VtZW50cy5cbiAgICAgIC0tIENvbXBhcmVkIHRvIGBpdGVtJyB0aGUgdHlwZSBvZiBgYScgbWF5IGJlIGRpZmZlcmVudCBmcm9tIGB7T1BFTl9BUkdTfScuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfb3BlcmFuZHM6IHZhbGlkX29wZXJhbmRzIChhKVxuICAgIGxvY2FsXG4gICAgICBkZWZhdWx0X2FyZ3VtZW50czogZGV0YWNoYWJsZSBPUEVOX0FSR1NcbiAgICBkb1xuICAgICAgaWYgbm90IGF0dGFjaGVkIGEgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAoZGVmYXVsdF9hcmd1bWVudHMpXG4gICAgICBlbHNlXG4gICAgICAgIC0tIFRPRE86IEltcGxlbWVudCBpbiBKYXZhU2NyaXB0XG4gICAgICAgIC0tIGNoZWNrXG4gICAgICAgIC0tICAgZnJvbV9wcmVjb25kaXRpb246IGF0dGFjaGVkIHtPUEVOX0FSR1N9IG5ld190dXBsZV9mcm9tX3R1cGxlICgoe09QRU5fQVJHU30pLnR5cGVfaWQsIGEpIGFzIHhcbiAgICAgICAgLS0gdGhlblxuICAgICAgICAtLSAgIFJlc3VsdCA6PSBpdGVtICh4KVxuICAgICAgICAtLSBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZhc3RfaXRlbSAoYV9yb3V0X2Rpc3AsIGFfY2FsY19yb3V0X2FkZHI6IFBPSU5URVJcbiAgICAgICAgICAgYV9jbG9zZWRfb3BlcmFuZHM6IFBPSU5URVI7IGFfb3BlcmFuZHM6IFBPSU5URVJcbiAgICAgICAgIGFfcm91dGluZV9pZDogSU5URUdFUjsgYV9pc19iYXNpYzogQk9PTEVBTjsgYV9jbGFzc19pZF9pbmxpbmVfYWdlbnQ6IElOVEVHRVI7XG4gICAgICAgICBhX2Nsb3NlZF9jb3VudCwgYV9vcGVuX2NvdW50OiBJTlRFR0VSOyBhX29wZW5fbWFwOiBQT0lOVEVSKTogUkVTVUxUX1RZUEVcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIGlubGluZSB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGFsaWFzXG4gICAgICBcIltcbiAgICAgICNpZmRlZiBXT1JLQkVOQ0hcbiAgICAgICAgJCRfcmVzdWx0X3R5cGUgcmVzdWx0O1xuICAgICAgICBpZiAoJGFfcm91dF9kaXNwICE9IDApIHtcbiAgICAgICAgICByZXR1cm4gKEZVTkNUSU9OX0NBU1QoRUlGX1RZUEVEX1ZBTFVFLCAoRUlGX1BPSU5URVIsIEVJRl9SRUZFUkVOQ0UsIEVJRl9SRUZFUkVOQ0UpKSAkYV9yb3V0X2Rpc3ApKFxuICAgICAgICAgICAgJGFfY2FsY19yb3V0X2FkZHIsICRhX2Nsb3NlZF9vcGVyYW5kcywgJGFfb3BlcmFuZHMpLiQkX3Jlc3VsdF92YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0X29ial9jYWxsX2Z1bmN0aW9uX2R5bmFtaWMgKFxuICAgICAgICAgICAgJGFfcm91dGluZV9pZCxcbiAgICAgICAgICAgICRhX2lzX2Jhc2ljLFxuICAgICAgICAgICAgJGFfY2xhc3NfaWRfaW5saW5lX2FnZW50LFxuICAgICAgICAgICAgJGFfY2xvc2VkX29wZXJhbmRzLFxuICAgICAgICAgICAgJGFfY2xvc2VkX2NvdW50LFxuICAgICAgICAgICAgJGFfb3BlcmFuZHMsXG4gICAgICAgICAgICAkYV9vcGVuX2NvdW50LFxuICAgICAgICAgICAgJGFfb3Blbl9tYXAsXG4gICAgICAgICAgICAmcmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAjZWxzZVxuICAgICAgICByZXR1cm4gKEZVTkNUSU9OX0NBU1QoJCRfcmVzdWx0X3R5cGUsIChFSUZfUE9JTlRFUiwgRUlGX1JFRkVSRU5DRSwgRUlGX1JFRkVSRU5DRSkpICRhX3JvdXRfZGlzcCkoXG4gICAgICAgICAgJGFfY2FsY19yb3V0X2FkZHIsICRhX2Nsb3NlZF9vcGVyYW5kcywgJGFfb3BlcmFuZHMpO1xuICAgICAgI2VuZGlmXG4gICAgICBdXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIEhBU0hBQkxFXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgZ29vZF9oYXNoX3ZhbHVlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGJ5IGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIFNlcXVlbmNlcyBvZiBpbW11dGFibGUgOC1iaXQgY2hhcmFjdGVycywgYWNjZXNzaWJsZSB0aHJvdWdoIGludGVnZXIgaW5kaWNlc1xuICAgIGluIGEgY29udGlndW91cyByYW5nZS5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTAzIDE0OjI2OjIwIC0wODAwIChGcmksIDAzIEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5Mzg4OCAkXCJcblxuZnJvemVuIGNsYXNzXG4gIElNTVVUQUJMRV9TVFJJTkdfOFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR184XG4gICAgdW5kZWZpbmVcbiAgICAgIGlzX2ltbXV0YWJsZVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBhcmVhX2xvd2VyXG4gICAgZW5kXG5cbiAgSU1NVVRBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVuYW1lXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsLFxuICAgICAgaXRlbSBhcyBjaGFyYWN0ZXJfMzJfaXRlbSxcbiAgICAgIGhhcyBhcyBjaGFyYWN0ZXJfMzJfaGFzLFxuICAgICAgaW5kZXhfb2YgYXMgY2hhcmFjdGVyXzMyX2luZGV4X29mLFxuICAgICAgbGFzdF9pbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfbGFzdF9pbmRleF9vZixcbiAgICAgIG9jY3VycmVuY2VzIGFzIGNoYXJhY3Rlcl8zMl9vY2N1cnJlbmNlc1xuICAgIHVuZGVmaW5lXG4gICAgICBpc19lcXVhbCwgb3V0LCBjb3B5XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBtYWtlLFxuICBtYWtlX2VtcHR5LFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX3N0cmluZyxcbiAgbWFrZV9mcm9tX2MsXG4gIG1ha2VfZnJvbV9jaWwsXG4gIG1ha2VfZnJvbV9zZXBhcmF0ZVxuXG5jcmVhdGUge0lNTVVUQUJMRV9TVFJJTkdfOH1cbiAgbWFrZV9mcm9tX2FyZWFfYW5kX2JvdW5kc1xuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9zdHJpbmcgKHtSRUFEQUJMRV9TVFJJTkdfOCwgU1RSSU5HXzh9KSxcbiAgbWFrZV9mcm9tX2NpbCAoe1NZU1RFTV9TVFJJTkd9KSxcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIGFzX3N0cmluZ18zMjoge1NUUklOR18zMn0sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX2FyZWFfYW5kX2JvdW5kcyAoYTogbGlrZSBhcmVhOyBsb3csIG46IGxpa2UgY291bnQpXG4gICAgICAtLSBJbml0aWFsaXplIGN1cnJlbnQgd2l0aCBhcmVhIGBhJyB3aXRoIGxvd2VyIGJvdW5kcyBgbG93JyBhbmQgY291bnQgYG4nLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgYV92YWxpZF9jb3VudDogKGEuY291bnQgLSBsb3cpID49IGNvdW50ICsgMVxuICAgICAgbG93X25vbl9uZWdhdGl2ZTogbG93ID49IDBcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgYXJlYSA6PSBhXG4gICAgICBhcmVhX2xvd2VyIDo9IGxvd1xuICAgICAgY291bnQgOj0gblxuICAgIGVuc3VyZVxuICAgICAgYXJlYV9zZXQ6IGFyZWEgPSBhXG4gICAgICBhcmVhX2xvd2VyX3NldDogYXJlYV9sb3dlciA9IGxvd1xuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBhX3N5c3RlbV9zdHJpbmcubGVuZ3RoICsgZG90bmV0X2NvbnZlcnRvci5lc2NhcGVfY291bnQgKGFfc3lzdGVtX3N0cmluZylcbiAgICAgIGVuZFxuICAgICAgbWFrZSAobF9jb3VudClcbiAgICAgIGlmIGxfY291bnQgPiAwIHRoZW5cbiAgICAgICAgZG90bmV0X2NvbnZlcnRvci5yZWFkX3N5c3RlbV9zdHJpbmdfaW50b19hcmVhXzggKGFfc3lzdGVtX3N0cmluZywgYXJlYSlcbiAgICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge0lNTVVUQUJMRV9TVFJJTkdfOH0gLS0gRHVwbGljYXRpb25cblxuICBjb3B5IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgICAgLS0gQmVjYXVzZSBpdCBpcyBpbW11dGFibGUgd2UgY2FuIHNpbXBseSBzaGFyZSB0aGUgYGFyZWEnIGZyb20gYG90aGVyJy5cbiAgICAgICAgc3RhbmRhcmRfY29weSAob3RoZXIpXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X3Jlc3VsdF9jb3VudDogY291bnQgPSBvdGhlci5jb3VudFxuICAgICAgLS0gc2FtZV9jaGFyYWN0ZXJzOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IGBvdGhlcicuYGl0ZW0nIChgaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgKyBhcmVhX2xvd2VyIC0gMSlcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfMzJfaXRlbSAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSArIGFyZWFfbG93ZXIgLSAxKS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgKyBhcmVhX2xvd2VyIC0gMSkubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgICAtLSBVc2UgYGNvZGUnIGluc3RlYWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggVW5pY29kZSBoYW5kbGluZy5cbiAgICAgIC0tfCBOb3Qgb2Jzb2xldGUgYmVjYXVzZSBvbGQgY29kZSB1c2luZyBqdXN0IEFTQ0lJIGlzIHNhZmUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgKyBhcmVhX2xvd2VyIC0gMSkuY29kZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGEsIGFfODogbGlrZSBhcmVhXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9zMzJfYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgIGRvXG4gICAgICBjcmVhdGUgYS5tYWtlX2VtcHR5IChjb3VudCArIHMuY291bnQgKyAxKVxuICAgICAgYS5jb3B5X2RhdGEgKGFyZWEsIGFyZWFfbG93ZXIsIDAsIGNvdW50KVxuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR184fSBzIGFzIGxfczggdGhlblxuICAgICAgICBhLmNvcHlfZGF0YSAobF9zOC5hcmVhLCBsX3M4LmFyZWFfbG93ZXIsIGNvdW50LCBsX3M4LmNvdW50ICsgMSlcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgY3JlYXRlIGFfOC5tYWtlX2VtcHR5IChsX3MzMi5jb3VudCArIDEpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDBcbiAgICAgICAgICBqIDo9IGxfczMyLmFyZWFfbG93ZXJcbiAgICAgICAgICBsX3MzMl9hcmVhIDo9IGxfczMyLmFyZWFcbiAgICAgICAgICBuYiA6PSBsX3MzMi5jb3VudCAtIDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFfOC5leHRlbmQgKGxfczMyX2FyZWEgW2pdLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBhXzguZXh0ZW5kICgnJS8wMDAvJylcbiAgICAgICAgYS5jb3B5X2RhdGEgKGFfOCwgMCwgY291bnQsIG5iICsgMilcbiAgICAgIGVuZFxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fYXJlYV9hbmRfYm91bmRzIChhLCAwLCBjb3VudCArIHMuY291bnQpXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhLm1ha2VfZW1wdHkgKGNvdW50ICsgMSlcbiAgICAgIGEuY29weV9kYXRhIChhcmVhLCBhcmVhX2xvd2VyLCAwLCBjb3VudCArIDEpXG4gICAgICBtaXJyb3JfYXJlYSAoYSwgMCwgY291bnQgLSAxKVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fYXJlYV9hbmRfYm91bmRzIChhLCAwLCBjb3VudClcbiAgICBlbmRcblxuICBhc19sb3dlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgY3JlYXRlIGEubWFrZV9lbXB0eSAoY291bnQgKyAxKVxuICAgICAgYS5jb3B5X2RhdGEgKGFyZWEsIGFyZWFfbG93ZXIsIDAsIGNvdW50ICsgMSlcbiAgICAgIHRvX2xvd2VyX2FyZWEgKGEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX2FyZWFfYW5kX2JvdW5kcyAoYSwgMCwgY291bnQpXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhLm1ha2VfZW1wdHkgKGNvdW50ICsgMSlcbiAgICAgIGEuY29weV9kYXRhIChhcmVhLCBhcmVhX2xvd2VyLCAwLCBjb3VudCArIDEpXG4gICAgICB0b191cHBlcl9hcmVhIChhLCAwLCBjb3VudCAtIDEpXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9hcmVhX2FuZF9ib3VuZHMgKGEsIDAsIGNvdW50KVxuICAgIGVuZFxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUl8zMik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIG5iIDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgICBjcmVhdGUgYS5tYWtlX2VtcHR5IChuYiArIDEpXG4gICAgICAgIGEuY29weV9kYXRhIChhcmVhLCBhcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCAwLCBuYilcbiAgICAgICAgYS5leHRlbmQgKCclLzAwMC8nKVxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9hcmVhX2FuZF9ib3VuZHMgKGEsIDAsIG5iKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gZW1wdHlfc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzaGFyZWRfc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSXzMyKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX2FyZWFfYW5kX2JvdW5kcyAoYXJlYSwgYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gZW1wdHlfc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGVtcHR5P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY291bnQgPSAwXG4gICAgZW5kXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0NIQVJBQ1RFUl84XVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbQ0hBUkFDVEVSXzhdXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSB0ZW1wLm1ha2UgKGNhcGFjaXR5KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjb3VudFxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSXzMyKTogSU1NVVRBQkxFX1NUUklOR184XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG4pXG4gICAgZW5kXG5cbiAgZW1wdHlfc3RyaW5nOiBJTU1VVEFCTEVfU1RSSU5HXzhcbiAgICAgIC0tIFNoYXJlZCBlbXB0eSBpbW11dGFibGUgc3RyaW5nXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgwKVxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgZW1wdHlfc3RyaW5nX2VtcHR5OiBSZXN1bHQuaXNfZW1wdHlcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhX2xvd2VyOiBJTlRFR0VSO1xuICAgICAgLS0gSW5kZXggd2hlcmUgY3VycmVudCBzdHJpbmcgc3RhcnRzIGluIGBhcmVhJ1xuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ29tbW9uIGFuY2VzdG9ycyB0byBhbGwgaW1tdXRhYmxlIFNUUklORyBjbGFzc2VzLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIElNTVVUQUJMRV9TVFJJTkdfR0VORVJBTFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2ltbXV0YWJsZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19pbW11dGFibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG5pbnZhcmlhbnRcbiAgaW1tdXRhYmxlOiBpc19pbW11dGFibGVcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlRhYmxlcyB3aG9zZSBrZXlzIGFyZSBpbnRlZ2VycyBpbiBhIGNvbnRpZ3VvdXMgaW50ZXJ2YWxcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBpbmRleGFibGUsIGFjY2VzcztcbiAgYWNjZXNzOiBpbmRleCwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBJTkRFWEFCTEUgW0csIEggLT4gSU5URUdFUl0gaW5oZXJpdFxuXG4gIFRBQkxFIFtHLCBJTlRFR0VSXVxuICAgIHJlbmFtZVxuICAgICAgdmFsaWRfa2V5IGFzIHZhbGlkX2luZGV4LFxuICAgICAgZm9yY2UgYXMgcHV0XG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtHXVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuXG5cblxuIiwiZXhwYW5kZWQgY2xhc3MgSU5URUdFUl8zMiBpbmhlcml0XG5cbiAgSU5URUdFUl8zMl9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgb3Bwb3NpdGUsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzYV9uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsLFxuICAgICAgdG9fZG91YmxlLFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuLS0gY29udmVydFxuLS0gICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7SU5URUdFUl8zMl9SRUZ9KSxcbi0tICAgdG9fcmVhbDoge1JFQUxfMzJ9LFxuLS0gICB0b19kb3VibGU6IHtSRUFMXzY0fSxcbi0tICAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzMyXG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJJbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiAxNiBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uSW50MTZcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBJTlRFR0VSXzE2IGluaGVyaXRcblxuICBJTlRFR0VSXzE2X1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBvcHBvc2l0ZSxcbiAgICAgIGlkZW50aXR5LFxuICAgICAgYXNfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbCxcbiAgICAgIHRvX2RvdWJsZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0lOVEVHRVJfMTZfUkVGfSksXG4gIHRvX3JlYWw6IHtSRUFMXzMyfSxcbiAgdG9fZG91YmxlOiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfMzI6IHtJTlRFR0VSXzMyfSxcbiAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzE2KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfMTYpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzE2KTogSU5URUdFUl8xNlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl8xNik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfMTZcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfMTZcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfMTYpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl8xNik6IElOVEVHRVJfMTZcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzE2KTogSU5URUdFUl8xNlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzE2XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDE2IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBJTlRFR0VSXzE2X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IElOVEVHRVJfMTZcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9faW50ZWdlci5oYXNoX2NvZGVcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXzE2XG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgdG9fY2hhcmFjdGVyXzggaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IElOVEVHRVJfMTYgPSAtMzI3NjhcbiAgTWF4X3ZhbHVlOiBJTlRFR0VSXzE2ID0gMzI3NjdcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogSU5URUdFUl8xNilcbiAgICAgIC0tIE1ha2UgYGknIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBkaXZpZGVkIGJ5IGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtIC89IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsdWU6IFJlc3VsdCA9IChvdGhlci5pdGVtIC89IDApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF8zMl9SRUZ9IG90aGVyIGFzIHJlYWxfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhbF92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IG90aGVyIGFzIGRvdWJsZV92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkb3VibGVfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDApIG9yXG4gICAgICAgIChvdGhlci5jb25mb3Jtc190byAoMC4wKSBhbmQgaXRlbSA+IDApKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgaWYgaXQgaXMgbm90IGl0cyB0eXBlJ3MgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtID49IDBcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0gMCBhbmRcbiAgICAgICAgaXRlbS50b19uYXR1cmFsXzMyID49IHtDSEFSQUNURVJfMzJ9Lk1pbl92YWx1ZSBhbmRcbiAgICAgICAgaXRlbS50b19uYXR1cmFsXzMyIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgYWJzOiBJTlRFR0VSXzE2XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0ID0gaXRlbSkgb3IgKFJlc3VsdCA9IC1pdGVtKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKC0gaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBJTlRFR0VSXzE2X1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IElOVEVHRVJfMTZfUkVGXG4gICAgICAtLSBBc3NvY2lhdGVkIHJlZmVyZW5jZSBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gVHJ1ZSBpZiBub3QgYHplcm8nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzhcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfMTZcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfOH0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfOH0uTWluX3ZhbHVlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBSZXR1cm4gYGl0ZW0nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZTogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fZG91YmxlXG4gICAgZW5kXG5cbiAgdG9faGV4X3N0cmluZzogU1RSSU5HXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICBsb2NhbFxuICAgICAgaSwgdmFsOiBJTlRFR0VSXG4gICAgICBhX2RpZ2l0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAoY3JlYXRlIHtQTEFURk9STX0pLkludGVnZXJfMTZfYml0cyAvLyA0XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaSlcbiAgICAgICAgUmVzdWx0LmZpbGxfYmxhbmtcbiAgICAgICAgdmFsIDo9IGl0ZW1cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAwXG4gICAgICBsb29wXG4gICAgICAgIGFfZGlnaXQgOj0gKHZhbCAmIDB4RilcbiAgICAgICAgUmVzdWx0LnB1dCAoYV9kaWdpdC50b19oZXhfY2hhcmFjdGVyLCBpKVxuICAgICAgICB2YWwgOj0gdmFsIHw+PiA0XG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgUmVzdWx0X3ZhbGlkX2NvdW50OiBSZXN1bHQuY291bnQgPSAoY3JlYXRlIHtQTEFURk9STX0pLkludGVnZXJfMTZfYml0cyAvLyA0XG4gICAgZW5kXG5cbiAgdG9faGV4X2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBpbl9ib3VuZHM6IDAgPD0gaXRlbSBhbmQgaXRlbSA8PSAxNVxuICAgIGxvY2FsXG4gICAgICB0bXA6IElOVEVHRVJcbiAgICBkb1xuICAgICAgdG1wIDo9IGl0ZW1cbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQgaWYgYG4nIHBvc2l0aXZlLFxuICAgICAgLS0gdG8gbGVmdCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzE2OiBuIDw9IDE2XG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfMTY6IG4gPj0gLTE2XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzE2OiBuIDw9IDE2XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfbGVmdCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfbGVmdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18xNjogbiA8PSAxNlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMTY6IG4gPCAxNlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9faW50ZWdlcl8xNiB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMTY6IG4gPCAxNlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX2ludGVnZXJfMTYgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19pbnRlZ2VyXzE2IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IElOVEVHRVJfMTYpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBhbGwgMSBiaXRzIG9mIG0gc2V0IHRvIDFcbiAgICAgIC0tIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8IG1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiBtLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgaW50ZWdlciB2YWx1ZVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDYpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXJfMTYgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYWJzX3JlZjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtID49IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIHNpZ25fdGltZXNfYWJzOiBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiAzMiBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgSU5URUdFUl8zMl9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIlxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgICAgLS0gQ2xlYXIgc2lnbiBiaXQuXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmIDB4N0ZGRkZGRkZcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgdG9fY2hhcmFjdGVyXzggaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IElOVEVHRVJfMzIgPSAtMjE0NzQ4MzY0OFxuICBNYXhfdmFsdWU6IElOVEVHRVJfMzIgPSAyMTQ3NDgzNjQ3XG4gICAgICAtLSBNaW5pbXVtIGFuZCBNYXhpbXVtIHZhbHVlIGhvbGQgaW4gYGl0ZW0nLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGk6IElOVEVHRVJfMzIpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSAwXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IDAgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGFiczogSU5URUdFUl8zMlxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFic19yZWYuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCA9IGl0ZW0pIG9yIChSZXN1bHQgPSAtaXRlbSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgtIGl0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSBcXFxcIG90aGVyLml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpbnRlcnZhbCBhbGlhcyBcInwuLnxcIiAob3RoZXI6IElOVEVHRVIpOiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBJbnRlcnZhbCBmcm9tIGN1cnJlbnQgZWxlbWVudCB0byBgb3RoZXInXG4gICAgICAtLSAoZW1wdHkgaWYgYG90aGVyJyBsZXNzIHRoYW4gY3VycmVudCBpbnRlZ2VyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGl0ZW0sIG90aGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IElOVEVHRVJfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogSU5URUdFUl8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19zbWFsbDogaXRlbSA+PSB7SU5URUdFUl84fS5NaW5fdmFsdWVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX3NtYWxsOiBpdGVtID49IHtJTlRFR0VSXzE2fS5NaW5fdmFsdWVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzE2fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlciwgZnJvemVuIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJldHVybiBgaXRlbScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19kb3VibGVcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8zMl9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHhGKVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8zMl9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbVxuICAgICAgaWYgdG1wIDw9IDkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gKHRtcCArICgnMCcpLmNvZGUpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAoKCdBJykuY29kZSArICh0bXAgLSAxMCkpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X2FuZCAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfYW5kX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9vciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2Vfb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfeG9yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV94b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X25vdDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfbm90KVxuICAgIGVuc3VyZVxuICAgICAgYml0X25vdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3NoaWZ0IChuOiBJTlRFR0VSXzMyKTogSU5URUdFUlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodCBpZiBgbicgcG9zaXRpdmUsXG4gICAgICAtLSB0byBsZWZ0IG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICAgIG5fZ3JlYXRlcl9vcl9lcXVhbF90b19taW51c18zMjogbiA+PSAtMzJcbiAgICBkb1xuICAgICAgaWYgbiA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X3JpZ2h0IChuKS5pdGVtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfbGVmdCAoLSBuKS5pdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9sZWZ0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9sZWZ0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzMyOiBuIDw9IDMyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfcmlnaHQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X3JpZ2h0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfdGVzdCAobjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRlc3QgYG4nLXRoIHBvc2l0aW9uIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl8zMjogbiA8IDMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICYgKDEgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKDEgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKDEgfDw8IG4pLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0X3dpdGhfbWFzayAoYjogQk9PTEVBTjsgbTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGFsbCAxIGJpdHMgb2YgbSBzZXQgdG8gMVxuICAgICAgLS0gaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmIG0uYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMTEpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXIgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgYWJzX3JlZjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtID49IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIHNpZ25fdGltZXNfYWJzOiBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJJbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiA2NCBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uSW50NjRcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBJTlRFR0VSXzY0XG5cbmluaGVyaXRcbiAgSU5URUdFUl82NF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgb3Bwb3NpdGUsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWwsXG4gICAgICB0b19kb3VibGUsXG4gICAgICB0b19jaGFyYWN0ZXJfOCxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMixcbiAgICAgIGJpdF9hbmQsXG4gICAgICBiaXRfb3IsXG4gICAgICBiaXRfeG9yLFxuICAgICAgYml0X25vdCxcbiAgICAgIGJpdF9zaGlmdF9sZWZ0LFxuICAgICAgYml0X3NoaWZ0X3JpZ2h0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtJTlRFR0VSXzY0X1JFRn0pLFxuICB0b19yZWFsOiB7UkVBTF8zMn0sXG4gIHRvX2RvdWJsZToge1JFQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzY0KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfNjQpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzY0KTogSU5URUdFUl82NFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl82NCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfNjRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfNjRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfNjQpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl82NCk6IElOVEVHRVJfNjRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzY0KTogSU5URUdFUl82NFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzY0XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl82NFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDY0IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBJTlRFR0VSXzY0X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgICAtLSBHZXQgdGhlIHBvc2l0aXZlIHZhbHVlIG9mIGBpdGVtJyBhbmQgdGhlbiBkb1xuICAgICAgICAtLSBhIG1vZHVsbyBvbiB0aGUgbWF4aW11bSBJTlRFR0VSXzMyIHZhbHVlLlxuICAgICAgUmVzdWx0IDo9IChpdGVtICYgMHgwMDAwMDAwMDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBJTlRFR0VSXzY0ID0gLTkyMjMzNzIwMzY4NTQ3NzU4MDhcbiAgTWF4X3ZhbHVlOiBJTlRFR0VSXzY0ID0gOTIyMzM3MjAzNjg1NDc3NTgwN1xuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBJTlRFR0VSXzY0KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0gMCBhbmQgaXRlbS50b19uYXR1cmFsXzY0IDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSAwIGFuZFxuICAgICAgICBpdGVtLnRvX25hdHVyYWxfNjQgPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZFxuICAgICAgICBpdGVtLnRvX25hdHVyYWxfNjQgPD0ge0NIQVJBQ1RFUl8zMn0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBhYnM6IElOVEVHRVJfNjRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhYnNfcmVmLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgPSBpdGVtKSBvciAoUmVzdWx0ID0gLWl0ZW0pXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoLSBpdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLy8gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gXFxcXCBvdGhlci5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBeIG90aGVyXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogSU5URUdFUl82NF9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBJTlRFR0VSXzY0X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtOQVRVUkFMXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF8xNn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF8zMn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX3NtYWxsOiBpdGVtID49IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMzJ9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMzJ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBSZXR1cm4gYGl0ZW0nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIHRvX3JlYWw6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2RvdWJsZVxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIHZhbDogSU5URUdFUl82NFxuICAgICAgYV9kaWdpdDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzY0X2JpdHMgLy8gNFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAweDBGKS50b19pbnRlZ2VyXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzY0X2JpdHMgLy8gNFxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtLnRvX2ludGVnZXJcbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQgaWYgYG4nIHBvc2l0aXZlLFxuICAgICAgLS0gdG8gbGVmdCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzY0OiBuIDw9IDY0XG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfNjQ6IG4gPj0gLTY0XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzY0OiBuIDw9IDY0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfbGVmdCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfbGVmdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b182NDogbiA8PSA2NFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fNjQ6IG4gPCA2NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9faW50ZWdlcl82NCB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl82NFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fNjQ6IG4gPCA2NFxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX2ludGVnZXJfNjQgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19pbnRlZ2VyXzY0IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IElOVEVHRVJfNjQpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBhbGwgMSBiaXRzIG9mIG0gc2V0IHRvIDFcbiAgICAgIC0tIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8IG1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiBtLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgaW50ZWdlciB2YWx1ZVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDIwKVxuICAgICAgUmVzdWx0LmFwcGVuZF9pbnRlZ2VyXzY0IChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFic19yZWY6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+PSAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IC1DdXJyZW50XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0IH4gQ3VycmVudCkgb3IgKFJlc3VsdCB+IC1DdXJyZW50KVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBzaWduX3RpbWVzX2Ficzogc2lnbiAqIGFicyA9IGl0ZW1cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDggYml0c1wiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlNCeXRlXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgSU5URUdFUl84IGluaGVyaXRcblxuICBJTlRFR0VSXzhfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsLFxuICAgICAgdG9fZG91YmxlLFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7SU5URUdFUl84X1JFRn0pLFxuICB0b19yZWFsOiB7UkVBTF8zMn0sXG4gIHRvX2RvdWJsZToge1JFQUxfNjR9LFxuICB0b19pbnRlZ2VyXzE2OiB7SU5URUdFUl8xNn0sXG4gIHRvX2ludGVnZXJfMzI6IHtJTlRFR0VSXzMyfSxcbiAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBJTlRFR0VSXzgpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBJTlRFR0VSXzhcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfOFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl84KTogSU5URUdFUl84XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogSU5URUdFUl84XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDggYml0c1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xOSAxNDoyNjoxNCAtMDcwMCAoTW9uLCAxOSBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUxMTcgJFwiXG5cbmNsYXNzXG4gIElOVEVHRVJfOF9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIlxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBJTlRFR0VSXzhcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9faW50ZWdlci5oYXNoX2NvZGVcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXzhcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVsc2VpZiBpdGVtIDwgMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDEpXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDApXG4gICAgZW5kXG5cbiAgYXNjaWlfY2hhcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0b19jaGFyYWN0ZXJfOCBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXJfY29kZTogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIE1pbl92YWx1ZTogSU5URUdFUl84ID0gLTEyOFxuICBNYXhfdmFsdWU6IElOVEVHRVJfOCA9IDEyN1xuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSAwXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IDAgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kXG4gICAgICAgIGl0ZW0udG9fbmF0dXJhbF8zMiA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGFiczogSU5URUdFUl84XG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0ID0gaXRlbSkgb3IgKFJlc3VsdCA9IC1pdGVtKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKC0gaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBJTlRFR0VSXzhfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiBWIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogSU5URUdFUl84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXRlbV9ub25fbmVnYXRpdmU6IGl0ZW0gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gUmV0dXJuIGBpdGVtJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZTogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fZG91YmxlXG4gICAgZW5kXG5cbiAgdG9faGV4X3N0cmluZzogU1RSSU5HXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICBsb2NhbFxuICAgICAgaSwgdmFsOiBJTlRFR0VSXG4gICAgICBhX2RpZ2l0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAyXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaSlcbiAgICAgICAgUmVzdWx0LmZpbGxfYmxhbmtcbiAgICAgICAgdmFsIDo9IGl0ZW1cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAwXG4gICAgICBsb29wXG4gICAgICAgIGFfZGlnaXQgOj0gKHZhbCAmIDE1KVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICByZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IDJcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbVxuICAgICAgUmVzdWx0IDo9IHRtcC50b19oZXhfY2hhcmFjdGVyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IElOVEVHRVJfOFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodCBpZiBgbicgcG9zaXRpdmUsXG4gICAgICAtLSB0byBsZWZ0IG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fODogbiA8PSA4XG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfODogbiA+PSAtOFxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b184OiBuIDw9IDhcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9sZWZ0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9sZWZ0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzg6IG4gPD0gOFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fODogbiA8IDhcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX2ludGVnZXJfOCB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBgbictdGggcG9zaXRpb25cbiAgICAgIC0tIHNldCB0byAxIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl84OiBuIDwgOFxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX2ludGVnZXJfOCB8PDwgbilcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX2ludGVnZXJfOCB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBJTlRFR0VSXzgpOiBJTlRFR0VSXzhcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGFsbCAxIGJpdHMgb2YgbSBzZXQgdG8gMVxuICAgICAgLS0gaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmIG0uYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBpbnRlZ2VyIHZhbHVlXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoNClcbiAgICAgIFJlc3VsdC5hcHBlbmRfaW50ZWdlcl84IChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFic19yZWY6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+PSAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IC1DdXJyZW50XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0IH4gQ3VycmVudCkgb3IgKFJlc3VsdCB+IC1DdXJyZW50KVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuICBzaWduX3RpbWVzX2Ficzogc2lnbiAqIGFicyA9IGl0ZW1cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZSB0aGF0IGNhbiBiZSBpdGVyYXRlZCBvdmVyIHVzaW5nIGBhY3Jvc3MuLi5sb29wLi4uZW5kJy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBJVEVSQUJMRSBbR11cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBuZXdfY3Vyc29yOiBJVEVSQVRJT05fQ1VSU09SIFtHXVxuICAgICAgLS0gRnJlc2ggY3Vyc29yIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHN0cnVjdHVyZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfYXR0YWNoZWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJTdHJ1Y3R1cmVzIHdob3NlIGl0ZW1zIG1heSBiZSBhY2Nlc3NlZCBzZXF1ZW50aWFsbHksIG9uZS13YXlcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBzZXF1ZW50aWFsLCB0cmF2ZXJzaW5nO1xuICBhY2Nlc3M6IG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgTElORUFSIFtHXSBpbmhlcml0XG5cbiAgVFJBVkVSU0FCTEUgW0ddXG4gICAgcmVkZWZpbmVcbiAgICAgIGRvX2FsbCwgZG9faWYsIHRoZXJlX2V4aXN0cywgZm9yX2FsbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGhhcyAodjogbGlrZSBpdGVtKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJ1Y3R1cmUgaW5jbHVkZSBhbiBvY2N1cnJlbmNlIG9mIGB2Jz9cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZG9cbiAgICAgIHN0YXJ0XG4gICAgICBpZiBub3Qgb2ZmIHRoZW5cbiAgICAgICAgc2VhcmNoICh2KVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gbm90IGV4aGF1c3RlZFxuICAgIGVuZFxuXG4gIGluZGV4X29mICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBgaSctdGggb2NjdXJyZW5jZSBvZiBgdicuXG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIHJlcXVpcmVcbiAgICAgIHBvc2l0aXZlX29jY3VycmVuY2VzOiBpID4gMFxuICAgIGxvY2FsXG4gICAgICBvY2N1ciwgcG9zOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIGFuZCB2IC89IFZvaWQgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgc3RhcnRcbiAgICAgICAgICBwb3MgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGV4aGF1c3RlZCBvciAob2NjdXIgPSBpKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaWYgaXRlbSB+IHYgdGhlblxuICAgICAgICAgICAgb2NjdXIgOj0gb2NjdXIgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgICBwb3MgOj0gcG9zICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgcG9zIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBleGhhdXN0ZWQgb3IgKG9jY3VyID0gaSlcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gPSB2IHRoZW5cbiAgICAgICAgICAgIG9jY3VyIDo9IG9jY3VyICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGZvcnRoXG4gICAgICAgICAgcG9zIDo9IHBvcyArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIG9jY3VyID0gaSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBwb3MgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9yZXN1bHQ6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgc2VhcmNoICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBNb3ZlIHRvIGZpcnN0IHBvc2l0aW9uIChhdCBvciBhZnRlciBjdXJyZW50XG4gICAgICAtLSBwb3NpdGlvbikgd2hlcmUgYGl0ZW0nIGFuZCBgdicgYXJlIGVxdWFsLlxuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICAgIC0tIElmIG5vIHN1Y2ggcG9zaXRpb24gZW5zdXJlIHRoYXQgYGV4aGF1c3RlZCcgd2lsbCBiZSB0cnVlLlxuICAgIGRvXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBleGhhdXN0ZWQgb3IgZWxzZSB2IH4gaXRlbVxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBleGhhdXN0ZWQgb3IgZWxzZSB2ID0gaXRlbVxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9ydGhcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG9iamVjdF9mb3VuZDogKG5vdCBleGhhdXN0ZWQgYW5kIG9iamVjdF9jb21wYXJpc29uKVxuICAgICAgICAgaW1wbGllcyB2IH4gaXRlbVxuICAgICAgaXRlbV9mb3VuZDogKG5vdCBleGhhdXN0ZWQgYW5kIG5vdCBvYmplY3RfY29tcGFyaXNvbilcbiAgICAgICAgIGltcGxpZXMgdiA9IGl0ZW1cbiAgICBlbmRcblxuICBpbmRleDogSU5URUdFUlxuICAgICAgLS0gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvblxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgb2NjdXJyZW5jZXMgKHY6IGxpa2UgaXRlbSk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgICAgc2VhcmNoICh2KVxuICAgICAgdW50aWxcbiAgICAgICAgZXhoYXVzdGVkXG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgIGZvcnRoXG4gICAgICAgIHNlYXJjaCAodilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGl0ZW1fZm9yX2l0ZXJhdGlvbjogR1xuICAgICAgLS0gSXRlbSBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZjogbm90IG9mZlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleGhhdXN0ZWQ6IEJPT0xFQU5cbiAgICAgIC0tIEhhcyBzdHJ1Y3R1cmUgYmVlbiBjb21wbGV0ZWx5IGV4cGxvcmVkP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb2ZmXG4gICAgZW5zdXJlXG4gICAgICBleGhhdXN0ZWRfd2hlbl9vZmY6IG9mZiBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGFmdGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyB2YWxpZCBwb3NpdGlvbiB0byB0aGUgcmlnaHQgb2YgY3VycmVudCBvbmU/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBvZmY6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIGN1cnJlbnQgaXRlbT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX2VtcHR5IG9yIGFmdGVyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgZmluaXNoXG4gICAgICAtLSBNb3ZlIHRvIGxhc3QgcG9zaXRpb24uXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBmb3J0aFxuICAgICAgLS0gTW92ZSB0byBuZXh0IHBvc2l0aW9uOyBpZiBubyBuZXh0IHBvc2l0aW9uLFxuICAgICAgLS0gZW5zdXJlIHRoYXQgYGV4aGF1c3RlZCcgd2lsbCBiZSB0cnVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9hZnRlcjogbm90IGFmdGVyXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIC0tIG1vdmVkX2ZvcnRoX2JlZm9yZV9lbmQ6IChub3QgYWZ0ZXIpIGltcGxpZXMgaW5kZXggPSBvbGQgaW5kZXggKyAxXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbS5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGM6IGRldGFjaGFibGUgQ1VSU09SXG4gICAgICBjczogZGV0YWNoYWJsZSBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7Q1VSU09SX1NUUlVDVFVSRSBbR119IEN1cnJlbnQgYXMgYWNzIHRoZW5cbiAgICAgICAgY3MgOj0gYWNzXG4gICAgICAgIGMgOj0gYWNzLmN1cnNvclxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGFmdGVyXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbV0pXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcblxuICAgICAgaWYgY3MgLz0gVm9pZCBhbmQgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgY3MuZ29fdG8gKGMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZiAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0ddXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGM6IGRldGFjaGFibGUgQ1VSU09SXG4gICAgICBjczogZGV0YWNoYWJsZSBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7Q1VSU09SX1NUUlVDVFVSRSBbR119IEN1cnJlbnQgYXMgYWNzIHRoZW5cbiAgICAgICAgY3MgOj0gYWNzXG4gICAgICAgIGMgOj0gYWNzLmN1cnNvclxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGFmdGVyXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2l0ZW1dKSB0aGVuXG4gICAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcblxuICAgICAgaWYgY3MgLz0gVm9pZCBhbmQgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgY3MuZ29fdG8gKGMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICBsb2NhbFxuICAgICAgYzogZGV0YWNoYWJsZSBDVVJTT1JcbiAgICAgIGNzOiBkZXRhY2hhYmxlICBDVVJTT1JfU1RSVUNUVVJFIFtHXVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7Q1VSU09SX1NUUlVDVFVSRSBbR119IEN1cnJlbnQgYXMgYWNzIHRoZW5cbiAgICAgICAgY3MgOj0gYWNzXG4gICAgICAgIGMgOj0gYWNzLmN1cnNvclxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGFmdGVyIG9yIFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gdGVzdC5pdGVtIChbaXRlbV0pXG4gICAgICAgIGZvcnRoXG4gICAgICBlbmRcblxuICAgICAgaWYgY3MgLz0gVm9pZCBhbmQgYyAvPVZvaWQgdGhlblxuICAgICAgICBjcy5nb190byAoYylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZvcl9hbGwgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYWxsIGl0ZW1zP1xuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGM6IGRldGFjaGFibGUgQ1VSU09SXG4gICAgICBjczogZGV0YWNoYWJsZSAgQ1VSU09SX1NUUlVDVFVSRSBbR11cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0NVUlNPUl9TVFJVQ1RVUkUgW0ddfSBDdXJyZW50IGFzIGFjcyB0aGVuXG4gICAgICAgIGNzIDo9IGFjc1xuICAgICAgICBjIDo9IGFjcy5jdXJzb3JcbiAgICAgIGVuZFxuXG4gICAgICBmcm9tXG4gICAgICAgIHN0YXJ0XG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICB1bnRpbFxuICAgICAgICBhZnRlciBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSB0ZXN0Lml0ZW0gKFtpdGVtXSlcbiAgICAgICAgZm9ydGhcbiAgICAgIGVuZFxuXG4gICAgICBpZiBjcyAvPSBWb2lkIGFuZCBjIC89IFZvaWQgdGhlblxuICAgICAgICBjcy5nb190byAoYylcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBlbXB0eTogaXNfZW1wdHkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0ddXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgYWZ0ZXJfY29uc3RyYWludDogYWZ0ZXIgaW1wbGllcyBvZmZcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlNlcXVlbnRpYWwgbGlzdHMsIHdpdGhvdXQgY29tbWl0bWVudCB0byBhIHBhcnRpY3VsYXIgcmVwcmVzZW50YXRpb25cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBsaXN0LCBzZXF1ZW5jZTtcbiAgYWNjZXNzOiBpbmRleCwgY3Vyc29yLCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIExJU1QgW0ddIGluaGVyaXRcblxuICBDSEFJTiBbR11cbiAgICBleHBvcnRcbiAgICAgIHtBTll9IHJlbW92ZVxuICAgIHJlZGVmaW5lXG4gICAgICBmb3J0aCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBvdGhlcicgY29udGFpbiB0aGUgc2FtZSBlbGVtZW50cz9cbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA9IG90aGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IChpc19lbXB0eSA9IG90aGVyLmlzX2VtcHR5KSBhbmRcbiAgICAgICAgICAgIChvYmplY3RfY29tcGFyaXNvbiA9IG90aGVyLm9iamVjdF9jb21wYXJpc29uKSBhbmRcbiAgICAgICAgICAgIChjb3VudCA9IG90aGVyLmNvdW50KVxuICAgICAgICBpZiBSZXN1bHQgYW5kIG5vdCBpc19lbXB0eSB0aGVuXG4gICAgICAgICAgaWZcbiAgICAgICAgICAgIGF0dGFjaGVkIHtDVVJTT1J9IGN1cnNvciBhcyBjMSBhbmQgdGhlblxuICAgICAgICAgICAgYXR0YWNoZWQge0NVUlNPUn0gb3RoZXIuY3Vyc29yIGFzIGMyXG4gICAgICAgICAgdGhlblxuICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgICBvdGhlci5zdGFydFxuICAgICAgICAgICAgdW50aWxcbiAgICAgICAgICAgICAgYWZ0ZXIgb3Igbm90IFJlc3VsdFxuICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiB0aGVuXG4gICAgICAgICAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfiBvdGhlci5pdGVtXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBSZXN1bHQgOj0gaXRlbSA9IG90aGVyLml0ZW1cbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGZvcnRoXG4gICAgICAgICAgICAgIG90aGVyLmZvcnRoXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGdvX3RvIChjMSlcbiAgICAgICAgICAgIG90aGVyLmdvX3RvIChjMilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgICBjdXJzb3JzX2V4aXN0OiBGYWxzZVxuICAgICAgICAgICAgICAgIC0tIEJlY2F1c2UgZXZlcnkgbGlzdCBjb250YWlucyBhIGN1cnNvciBvYmplY3RcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgaXNfZW1wdHkgYW5kIG90aGVyLmlzX2VtcHR5IGFuZFxuICAgICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGluZGljZXNfdW5jaGFuZ2VkOlxuICAgICAgICBpbmRleCA9IG9sZCBpbmRleCBhbmQgb3RoZXIuaW5kZXggPSBvbGQgb3RoZXIuaW5kZXhcbiAgICAgIHRydWVfaW1wbGllc19zYW1lX3NpemU6IFJlc3VsdCBpbXBsaWVzIGNvdW50ID0gb3RoZXIuY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgYWZ0ZXI6IEJPT0xFQU5cbiAgICAgIC0tIElzIHRoZXJlIG5vIHZhbGlkIGN1cnNvciBwb3NpdGlvbiB0byB0aGUgcmlnaHQgb2YgY3Vyc29yP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGluZGV4ID0gY291bnQgKyAxKVxuICAgIGVuZFxuXG4gIGJlZm9yZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gdmFsaWQgY3Vyc29yIHBvc2l0aW9uIHRvIHRoZSBsZWZ0IG9mIGN1cnNvcj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpbmRleCA9IDApXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgZm9ydGhcbiAgICAgIC0tIE1vdmUgdG8gbmV4dCBwb3NpdGlvbjsgaWYgbm8gbmV4dCBwb3NpdGlvbixcbiAgICAgIC0tIGVuc3VyZSB0aGF0IGBleGhhdXN0ZWQnIHdpbGwgYmUgdHJ1ZS5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBtb3ZlZF9mb3J0aDogaW5kZXggPSBvbGQgaW5kZXggKyAxXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGJlZm9yZV9kZWZpbml0aW9uOiBiZWZvcmUgPSAoaW5kZXggPSAwKVxuICBhZnRlcl9kZWZpbml0aW9uOiBhZnRlciA9IChpbmRleCA9IGNvdW50ICsgMSlcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBUbyBlYXNpbHkgbWFuYWdlIGFsbG9jYXRpb24gYW5kIHJlbGVhc2Ugb2YgYWxsb2NhdGVkIEMgbWVtb3J5LCBhbmRcbiAgICB0byBwZXJmb3JtIGluc2VydGlvbiBvZiBiYXNpYyBlbGVtZW50cy4gQnl0ZSBvcmRlciBpcyBieSBkZWZhdWx0XG4gICAgcGxhdGZvcm0gc3BlY2lmaWMuXG4gICAgQWx0aG91Z2ggbWVtb3J5IGFsbG9jYXRpb24gcm91dGluZXMgZG8gbm90IGFjY2VwdCBhIHplcm8gc2l6ZWQgcG9pbnRlclxuICAgIE1BTkFHRURfUE9JTlRFUiBkb2VzIGJ5IGFsbG9jYXRpbmcgaW4gZmFjdCBhIDEgYnl0ZSBzaXplZCBwb2ludGVyIGZvclxuICAgIHRoaXMgcGFydGljdWxhciBjYXNlLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTAtMjkgMTc6MTI6MDAgLTA3MDAgKE1vbiwgMjkgT2N0IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDE1ICRcIlxuXG5jbGFzc1xuICBNQU5BR0VEX1BPSU5URVJcblxuaW5oZXJpdFxuICBESVNQT1NBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBjb3B5XG4gICAgZW5kXG5cbiAgUExBVEZPUk1cbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIGNvcHlcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsIG1ha2VfZnJvbV9hcnJheSwgbWFrZV9mcm9tX3BvaW50ZXIsIHNoYXJlX2Zyb21fcG9pbnRlciwgb3duX2Zyb21fcG9pbnRlclxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBgaXRlbScgd2l0aCBgbicgYnl0ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpbmNyZW1lbnRfY291bnRlclxuICAgICAgaXRlbSA6PSBpdGVtLm1lbW9yeV9jYWxsb2MgKG4ubWF4ICgxKSwgMSlcbiAgICAgIGlmIGl0ZW0gPSBkZWZhdWx0X3BvaW50ZXIgdGhlblxuICAgICAgICAoY3JlYXRlIHtFWENFUFRJT05TfSkucmFpc2UgKFwiTm8gbW9yZSBtZW1vcnlcIilcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0gblxuICAgICAgaXNfc2hhcmVkIDo9IEZhbHNlXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBpc19zaGFyZWRfc2V0OiBub3QgaXNfc2hhcmVkXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2FycmF5IChkYXRhOiBBUlJBWSBbTkFUVVJBTF84XSlcbiAgICAgIC0tIEFsbG9jYXRlIGBpdGVtJyB3aXRoIGBkYXRhLmNvdW50JyBieXRlcyBhbmQgY29weVxuICAgICAgLS0gY29udGVudCBvZiBgZGF0YScgaW50byBgaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgZGF0YV9ub3Rfdm9pZDogZGF0YSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluY3JlbWVudF9jb3VudGVyXG4gICAgICBjb3VudCA6PSBkYXRhLmNvdW50XG4gICAgICBpdGVtIDo9IGl0ZW0ubWVtb3J5X2FsbG9jIChjb3VudC5tYXggKDEpKVxuICAgICAgaWYgaXRlbSA9IGRlZmF1bHRfcG9pbnRlciB0aGVuXG4gICAgICAgIChjcmVhdGUge0VYQ0VQVElPTlN9KS5yYWlzZSAoXCJObyBtb3JlIG1lbW9yeVwiKVxuICAgICAgZW5kXG4gICAgICBwdXRfYXJyYXkgKGRhdGEsIDApXG4gICAgICBpc19zaGFyZWQgOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IGRhdGEuY291bnRcbiAgICAgIGlzX3NoYXJlZF9zZXQ6IG5vdCBpc19zaGFyZWRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fcG9pbnRlciAoYV9wdHI6IFBPSU5URVI7IG46IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGBhX2NvdW50JyBieXRlcyBmcm9tIGBhX3B0cicgaW50byBjdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIGFfcHRyX25vdF9udWxsOiBhX3B0ciAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaW5jcmVtZW50X2NvdW50ZXJcbiAgICAgIGl0ZW0gOj0gaXRlbS5tZW1vcnlfYWxsb2MgKG4ubWF4ICgxKSlcbiAgICAgIGlmIGl0ZW0gPSBkZWZhdWx0X3BvaW50ZXIgdGhlblxuICAgICAgICAoY3JlYXRlIHtFWENFUFRJT05TfSkucmFpc2UgKFwiTm8gbW9yZSBtZW1vcnlcIilcbiAgICAgIGVuZFxuICAgICAgaXRlbS5tZW1vcnlfY29weSAoYV9wdHIsIG4pXG4gICAgICBjb3VudCA6PSBuXG4gICAgICBpc19zaGFyZWQgOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGlzX3NoYXJlZF9zZXQ6IG5vdCBpc19zaGFyZWRcbiAgICBlbmRcblxuICBzaGFyZV9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSOyBuOiBJTlRFR0VSKVxuICAgICAgLS0gVXNlIGRpcmVjdGx5IGBhX3B0cicgd2l0aCBjb3VudCBgbicgdG8gaG9sZCBjdXJyZW50IGRhdGEuXG4gICAgcmVxdWlyZVxuICAgICAgYV9wdHJfdmFsaWQ6IGFfcHRyID0gZGVmYXVsdF9wb2ludGVyIGltcGxpZXMgbiA9IDBcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaW5jcmVtZW50X2NvdW50ZXJcbiAgICAgIGl0ZW0gOj0gYV9wdHJcbiAgICAgIGNvdW50IDo9IG5cbiAgICAgIGlzX3NoYXJlZCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGFfcHRyXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgaXNfc2hhcmVkX3NldDogaXNfc2hhcmVkXG4gICAgZW5kXG5cbiAgb3duX2Zyb21fcG9pbnRlciAoYV9wdHI6IFBPSU5URVI7IG46IElOVEVHRVIpXG4gICAgICAtLSBVc2UgZGlyZWN0bHkgYGFfcHRyJyB3aXRoIGNvdW50IGBuJyB0byBob2xkIGN1cnJlbnQgZGF0YSBhbmQgZnJlZVxuICAgICAgLS0gaXRzIGFzc29jaWF0ZWQgQyBtZW1vcnkgd2hlbiBDdXJyZW50IGlzIGNvbGxlY3RlZC5cbiAgICAgIC0tIEl0IGFzc3VtZXMgdGhhdCBgYV9wdHInIHdhcyBhbGxvY2F0ZWQgdXNpbmcgdGhlIEMtYG1hbGxvYycgcm91dGluZSBhbmQgdGh1c1xuICAgICAgLS0gd2lsbCBiZSBmcmVlZCBieSBjYWxsaW5nIHRoZSBDLWBmcmVlJyByb3V0aW5lLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfcHRyX3ZhbGlkOiBhX3B0ciAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaW5jcmVtZW50X2NvdW50ZXJcbiAgICAgIGl0ZW0gOj0gYV9wdHJcbiAgICAgIGNvdW50IDo9IG5cbiAgICAgIGlzX3NoYXJlZCA6PSBGYWxzZVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBhX3B0clxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGlzX3NoYXJlZF9zZXQ6IG5vdCBpc19zaGFyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTZXR0aW5nc1xuXG4gIHNldF9mcm9tX3BvaW50ZXIgKGFfcHRyOiBQT0lOVEVSOyBuOiBJTlRFR0VSKVxuICAgICAgLS0gVXNlIGRpcmVjdGx5IGBhX3B0cicgd2l0aCBjb3VudCBgbicgdG8gaG9sZCBjdXJyZW50IGRhdGEuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfc2hhcmVkOiBpc19zaGFyZWRcbiAgICAgIGFfcHRyX25vdF9udWxsOiBhX3B0ciA9IGRlZmF1bHRfcG9pbnRlciBpbXBsaWVzIG4gPSAwXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGl0ZW0gOj0gYV9wdHJcbiAgICAgIGNvdW50IDo9IG5cbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gYV9wdHJcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBpc19zaGFyZWRfdW5jaGFuZ2VkOiBpc19zaGFyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBQT0lOVEVSIG5vdGUgb3B0aW9uOiB0cmFuc2llbnQgYXR0cmlidXRlIGVuZFxuICAgICAgLS0gQWNjZXNzIHRvIGFsbG9jYXRlZCBtZW1vcnkuXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBlbGVtZW50cyB0aGF0IEN1cnJlbnQgY2FuIGhvbGQuXG5cbiAgaXNfc2hhcmVkOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgc2hhcmVkIHdpdGggYW5vdGhlciBtZW1vcnkgYXJlYT9cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkIGVxdWFsIHRvIGN1cnJlbnQgb2JqZWN0P1xuICAgIGRvXG4gICAgICBpZiBjb3VudCA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtID0gb3RoZXIuaXRlbSkgb3IgZWxzZSBpdGVtLm1lbW9yeV9jb21wYXJlIChvdGhlci5pdGVtLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFVwZGF0ZSBjdXJyZW50IG9iamVjdCB1c2luZyBmaWVsZHMgb2Ygb2JqZWN0IGF0dGFjaGVkXG4gICAgICAtLSB0byBgb3RoZXInLCBzbyBhcyB0byB5aWVsZCBlcXVhbCBvYmplY3RzLiBJZiBgaXNfc2hhcmVkJ1xuICAgICAgLS0gYW5kIGN1cnJlbnQgaXMgbm90IGxhcmdlIGVub3VnaCB0byBob2xkIGBvdGhlcicgY3JlYXRlXG4gICAgICAtLSBhIG5ldyBwb2ludGVyIGFyZWEgYW5kIGBpc19zaGFyZWQnIGlzIHNldCB0byBgRmFsc2UnLlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgaWYgaXRlbSA9IG90aGVyLml0ZW0gb3IgaXNfc2hhcmVkIHRoZW5cbiAgICAgICAgICAgIC0tIENvcHkgd2FzIG1vc3QgbGlrZWx5IGNhbGxlZCB2aWEgYHR3aW4nIGJ1dCBldmVuXG4gICAgICAgICAgICAtLSBpZiBpdCBpcyBub3QsIGl0IG1ha2VzIHNlbnNlIHRvIGR1cGxpY2F0ZSB0aGUgbWVtb3J5LlxuICAgICAgICAgICAgLS0gT3IgYmVmb3JlIGBpdGVtJyB3YXMgc2hhcmVkLCBzbyB3ZSBzaW1wbHkgYWxsb2NhdGVcbiAgICAgICAgICAgIC0tIGEgbmV3IG1lbW9yeSBhcmVhIGZyb20gYG90aGVyJyBhbmQgcmVzZXRcbiAgICAgICAgICAgIC0tIHRoZSBgaXNfc2hhcmVkJyBmbGFnLlxuICAgICAgICAgIG1ha2VfZnJvbV9wb2ludGVyIChvdGhlci5pdGVtLCBvdGhlci5jb3VudClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHJlc2l6ZSBDdXJyZW50IGFuZCBjb3B5IGRhdGEuXG4gICAgICAgICAgcmVzaXplIChvdGhlci5jb3VudClcbiAgICAgICAgICBpdGVtLm1lbW9yeV9jb3B5IChvdGhlci5pdGVtLCBvdGhlci5jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2hhcmluZ19zdGF0dXNfbm90X3ByZXNlcnZlZDogKG90aGVyIC89IEN1cnJlbnQpIGltcGxpZXMgKG9sZCBpc19zaGFyZWQgaW1wbGllcyBub3QgaXNfc2hhcmVkKVxuICAgICAgY291bnRfcHJlc2VydmVkOiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzOiBQbGF0Zm9ybSBzcGVjaWZpY1xuXG4gIHJlYWRfbmF0dXJhbF84IChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF84IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoJFJlc3VsdCkubWVtb3J5X2NvcHkgKGl0ZW0gKyBwb3MsIG5hdHVyYWxfOF9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfMTYgKHBvczogSU5URUdFUik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF8xNiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF8xNl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfMzIgKHBvczogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF8zMiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfNjQgKHBvczogSU5URUdFUik6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF82NF9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfOCAocG9zOiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBSZWFkIElOVEVHRVJfOCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfOF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF84IChwb3MpLmFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl8xNiAocG9zOiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gUmVhZCBJTlRFR0VSXzE2IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8xNiAocG9zKS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzMyIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBSZWFkIElOVEVHRVIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzMyIChwb3MpLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfNjQgKHBvczogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIFJlYWQgSU5URUdFUl82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfNjQgKHBvcykuYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIHJlYWRfcG9pbnRlciAocG9zOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gUmVhZCBQT0lOVEVSIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgUG9pbnRlcl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBQb2ludGVyX2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfYm9vbGVhbiAocG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gUmVhZCBCT09MRUFOIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgQm9vbGVhbl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBCb29sZWFuX2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfY2hhcmFjdGVyIChwb3M6IElOVEVHRVIpOiBDSEFSQUNURVJcbiAgICAgIC0tIFJlYWQgQ0hBUkFDVEVSIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgQ2hhcmFjdGVyXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgQ2hhcmFjdGVyXzhfYnl0ZXMpXG4gICAgZW5kXG5cbiAgcmVhZF9yZWFsIChwb3M6IElOVEVHRVIpOiBSRUFMXG4gICAgICAtLSBSZWFkIFJFQUxfMzIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgb2Jzb2xldGUgXCJVc2UgcmVhZF9yZWFsXzMyIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgUmVhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX3JlYWxfMzIgKHBvczogSU5URUdFUik6IFJFQUxcbiAgICAgIC0tIFJlYWQgUkVBTF8zMiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgUmVhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX2RvdWJsZSAocG9zOiBJTlRFR0VSKTogRE9VQkxFXG4gICAgICAtLSBSZWFkIFJFQUxfNjQgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgb2Jzb2xldGUgXCJVc2UgcmVhZF9yZWFsXzY0IGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgUmVhbF82NF9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX3JlYWxfNjQgKHBvczogSU5URUdFUik6IERPVUJMRVxuICAgICAgLS0gUmVhZCBSRUFMXzY0IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgUmVhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBSZWFsXzY0X2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfYXJyYXkgKHBvcywgYV9jb3VudDogSU5URUdFUik6IEFSUkFZIFtOQVRVUkFMXzhdXG4gICAgICAtLSBSZWFkIGBjb3VudCcgYnl0ZXMgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgY291bnRfcG9zaXRpdmU6IGFfY291bnQgPiAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGFfY291bnQpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGNyZWF0ZSBsX2FyZWEubWFrZV9lbXB0eSAoYV9jb3VudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gYV9jb3VudFxuICAgICAgbG9vcFxuICAgICAgICBsX2FyZWEuZXh0ZW5kIChyZWFkX25hdHVyYWxfOCAocG9zICsgaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3BlY2lhbCAobF9hcmVhKVxuICAgIGVuc3VyZVxuICAgICAgcmVhZF9hcnJheV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHJlYWRfYXJyYXlfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IGFfY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZTogUGxhdGZvcm0gc3BlY2lmaWNcblxuICBwdXRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzg7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGksIG5hdHVyYWxfOF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzggKHBvcylcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGksIG5hdHVyYWxfMTZfYnl0ZXMpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfbmF0dXJhbF8xNiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzMyIChpOiBOQVRVUkFMXzMyOyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKGl0ZW0gKyBwb3MpLm1lbW9yeV9jb3B5ICgkaSwgbmF0dXJhbF8zMl9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzMyIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X25hdHVyYWxfNjQgKGk6IE5BVFVSQUxfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRpLCBuYXR1cmFsXzY0X2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX25hdHVyYWxfNjQgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzg7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzggKGkuYXNfbmF0dXJhbF84LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl84IChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTY7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzE2X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF8xNiAoaS5hc19uYXR1cmFsXzE2LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl8xNiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzMyIChpOiBJTlRFR0VSOyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8zMl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgcHV0X25hdHVyYWxfMzIgKGkuYXNfbmF0dXJhbF8zMiwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfMzIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NDsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzY0IChpLmFzX25hdHVyYWxfNjQsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9pbnRlZ2VyXzY0IChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X3BvaW50ZXIgKHA6IFBPSU5URVI7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcCcgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBQb2ludGVyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRwLCBQb2ludGVyX2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IHAgPSByZWFkX3BvaW50ZXIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfYm9vbGVhbiAoYjogQk9PTEVBTjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBiJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIEJvb2xlYW5fYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGIsIEJvb2xlYW5fYnl0ZXMpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogYiA9IHJlYWRfYm9vbGVhbiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBjJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIENoYXJhY3Rlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRjLCBDaGFyYWN0ZXJfOF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBjID0gcmVhZF9jaGFyYWN0ZXIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfcmVhbCAocjogUkVBTDsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGByJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICBvYnNvbGV0ZSBcIlVzZSBwdXRfcmVhbF8zMiBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBSZWFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRyLCBSZWFsXzMyX2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IHIgPSByZWFkX3JlYWxfMzIgKHBvcylcbiAgICBlbmRcblxuICBwdXRfcmVhbF8zMiAocjogUkVBTDsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGByJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIFJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJHIsIFJlYWxfMzJfYnl0ZXMpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogciA9IHJlYWRfcmVhbF8zMiAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9kb3VibGUgKGQ6IERPVUJMRTsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBkJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICBvYnNvbGV0ZSBcIlVzZSBwdXRfcmVhbF82NCBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBSZWFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICAoaXRlbSArIHBvcykubWVtb3J5X2NvcHkgKCRkLCBSZWFsXzY0X2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGQgPSByZWFkX3JlYWxfNjQgKHBvcylcbiAgICBlbmRcblxuICBwdXRfcmVhbF82NCAoZDogRE9VQkxFOyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGQnIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgUmVhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKGl0ZW0gKyBwb3MpLm1lbW9yeV9jb3B5ICgkZCwgUmVhbF82NF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBkID0gcmVhZF9yZWFsXzY0IChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2FycmF5IChkYXRhOiBBUlJBWSBbTkFUVVJBTF84XTsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjb250ZW50IG9mIGBkYXRhJyBpbnRvIGBpdGVtJyBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBkYXRhX25vdF92b2lkOiBkYXRhIC89IFZvaWRcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgZGF0YS5jb3VudCkgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9zcDogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgIGRvXG4gICAgICBsX3NwIDo9IGRhdGEuYXJlYTtcbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGxfc3AsIGRhdGEuY291bnQpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogcmVhZF9hcnJheSAocG9zLCBkYXRhLmNvdW50KSB+IGRhdGFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3M6IExpdHRsZS1lbmRpYW4gZm9ybWF0XG5cbiAgcmVhZF9uYXR1cmFsXzhfbGUgKHBvczogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gUmVhZCBOQVRVUkFMXzggYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoaXRlbSArIHBvcywgbmF0dXJhbF84X2J5dGVzKVxuICAgIGVuZFxuXG4gIHJlYWRfbmF0dXJhbF8xNl9sZSAocG9zOiBJTlRFR0VSKTogTkFUVVJBTF8xNlxuICAgICAgLS0gUmVhZCBOQVRVUkFMXzE2IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8xNl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9oaWdoLCBsX2xvdzogTkFUVVJBTF8xNlxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8xNiAocG9zKVxuICAgICAgZWxzZVxuICAgICAgICBsX2xvdyA6PSB7TkFUVVJBTF8xNn0gMHgwMEZGICYgcmVhZF9uYXR1cmFsXzggKHBvcylcbiAgICAgICAgbF9oaWdoIDo9IHJlYWRfbmF0dXJhbF84IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgICAgIFJlc3VsdCA6PSAobF9oaWdoLnRvX25hdHVyYWxfMTYgfDw8IDgpIHwgbF9sb3dcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlYWRfbmF0dXJhbF8zMl9sZSAocG9zOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUmVhZCBOQVRVUkFMXzMyIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9oaWdoLCBsX2xvdzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8zMiAocG9zKVxuICAgICAgZWxzZVxuICAgICAgICBsX2xvdyA6PSB7TkFUVVJBTF8zMn0gMHgwMDAwRkZGRiAmIHJlYWRfbmF0dXJhbF8xNl9sZSAocG9zKVxuICAgICAgICBsX2hpZ2ggOj0gcmVhZF9uYXR1cmFsXzE2X2xlIChwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKVxuICAgICAgICBSZXN1bHQgOj0gKGxfaGlnaC50b19uYXR1cmFsXzMyIHw8PCAxNikgfCBsX2xvd1xuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVhZF9uYXR1cmFsXzY0X2xlIChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBSZWFkIE5BVFVSQUxfNjQgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2hpZ2gsIGxfbG93OiBOQVRVUkFMXzY0XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzY0IChwb3MpXG4gICAgICBlbHNlXG4gICAgICAgIGxfbG93IDo9IHtOQVRVUkFMXzY0fSAweDAwMDAwMDAwRkZGRkZGRkYgJiByZWFkX25hdHVyYWxfMzJfbGUgKHBvcylcbiAgICAgICAgbF9oaWdoIDo9IHJlYWRfbmF0dXJhbF8zMl9sZSAocG9zICsgbmF0dXJhbF8zMl9ieXRlcylcbiAgICAgICAgUmVzdWx0IDo9IChsX2hpZ2gudG9fbmF0dXJhbF82NCB8PDwgMzIpIHwgbF9sb3dcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl84X2xlIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzhcbiAgICAgIC0tIFJlYWQgSU5URUdFUl84IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzhfbGUgKHBvcykuYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzE2X2xlIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBSZWFkIElOVEVHRVJfMTYgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzE2X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzE2X2xlIChwb3MpLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfMzJfbGUgKHBvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFJlYWQgSU5URUdFUiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfMzJfbGUgKHBvcykuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl82NF9sZSAocG9zOiBJTlRFR0VSKTogSU5URUdFUl82NFxuICAgICAgLS0gUmVhZCBJTlRFR0VSXzY0IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF82NF9sZSAocG9zKS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgcmVhZF9yZWFsXzMyX2xlIChwb3M6IElOVEVHRVIpOiBSRUFMXG4gICAgICAtLSBSZWFkIFJFQUxfMzIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyByZWFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX25hdDMyOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGNoZWNrXG4gICAgICAgIGNvcnJlY3Rfc2l6ZTogcmVhbF8zMl9ieXRlcyA9IG5hdHVyYWxfMzJfYnl0ZXNcbiAgICAgIGVuZFxuICAgICAgbF9uYXQzMiA6PSByZWFkX25hdHVyYWxfMzJfbGUgKHBvcylcbiAgICAgICgkUmVzdWx0KS5tZW1vcnlfY29weSAoJGxfbmF0MzIsIG5hdHVyYWxfMzJfYnl0ZXMpXG4gICAgZW5kXG5cbiAgcmVhZF9yZWFsXzY0X2xlIChwb3M6IElOVEVHRVIpOiBET1VCTEVcbiAgICAgIC0tIFJlYWQgUkVBTF82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0NjQ6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzY0X2J5dGVzID0gbmF0dXJhbF82NF9ieXRlc1xuICAgICAgZW5kXG4gICAgICBsX25hdDY0IDo9IHJlYWRfbmF0dXJhbF82NF9sZSAocG9zKVxuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5ICgkbF9uYXQ2NCwgbmF0dXJhbF82NF9ieXRlcylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZTogTGl0dGxlLWVuZGlhbiBmb3JtYXRcblxuICBwdXRfbmF0dXJhbF84X2xlIChpOiBOQVRVUkFMXzg7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIChpdGVtICsgcG9zKS5tZW1vcnlfY29weSAoJGksIG5hdHVyYWxfOF9ieXRlcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzhfbGUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF8xNl9sZSAoaTogTkFUVVJBTF8xNjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBwdXRfbmF0dXJhbF8xNiAoaSwgcG9zKVxuICAgICAgZWxzZVxuICAgICAgICBwdXRfbmF0dXJhbF84ICgoaSAmIDB4MDBGRikudG9fbmF0dXJhbF84LCBwb3MpXG4gICAgICAgIHB1dF9uYXR1cmFsXzggKCgoKGkgJiAweEZGMDApIHw+PiA4KSAmIDB4MDBGRikudG9fbmF0dXJhbF84LCBwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzE2X2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X25hdHVyYWxfMzJfbGUgKGk6IE5BVFVSQUxfMzI7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgcHV0X25hdHVyYWxfMzIgKGksIHBvcylcbiAgICAgIGVsc2VcbiAgICAgICAgcHV0X25hdHVyYWxfMTZfbGUgKChpICYgMHgwMDAwRkZGRikudG9fbmF0dXJhbF8xNiwgcG9zKVxuICAgICAgICBwdXRfbmF0dXJhbF8xNl9sZSAoKCgoaSAmIDB4RkZGRjAwMDApIHw+PiAxNikgJiAweDAwMDBGRkZGKS50b19uYXR1cmFsXzE2LCBwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfbmF0dXJhbF8zMl9sZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzY0X2xlIChpOiBOQVRVUkFMXzY0OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgaWYgaXNfbGl0dGxlX2VuZGlhbiB0aGVuXG4gICAgICAgIHB1dF9uYXR1cmFsXzY0IChpLCBwb3MpXG4gICAgICBlbHNlXG4gICAgICAgIHB1dF9uYXR1cmFsXzMyX2xlICgoaSAmIDB4MDAwMDAwMDBGRkZGRkZGRikudG9fbmF0dXJhbF8zMiwgcG9zKVxuICAgICAgICBwdXRfbmF0dXJhbF8zMl9sZSAoXG4gICAgICAgICAgKCgoaSAmIDB4RkZGRkZGRkYwMDAwMDAwMCkgfD4+IDMyKSAmIDB4MDAwMDAwMDBGRkZGRkZGRikudG9fbmF0dXJhbF8zMixcbiAgICAgICAgICBwb3MrIG5hdHVyYWxfMzJfYnl0ZXMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzY0X2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfOF9sZSAoaTogSU5URUdFUl84OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF84X2xlIChpLmFzX25hdHVyYWxfOCwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfOF9sZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzE2X2xlIChpOiBJTlRFR0VSXzE2OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgcHV0X25hdHVyYWxfMTZfbGUgKGkuYXNfbmF0dXJhbF8xNiwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfMTZfbGUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl8zMl9sZSAoaTogSU5URUdFUjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzMyX2xlIChpLmFzX25hdHVyYWxfMzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9pbnRlZ2VyXzMyX2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfNjRfbGUgKGk6IElOVEVHRVJfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF82NF9sZSAoaS5hc19uYXR1cmFsXzY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl82NF9sZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9yZWFsXzMyX2xlICh2OiBSRUFMOyBwb3M6IElOVEVHRVJfMzIpXG4gICAgICAtLSBJbnNlcnQgYHYnIGF0IHBvc2l0aW9uIGBwb3MnIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgcmVhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9uYXQzMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBjaGVja1xuICAgICAgICBjb3JyZWN0X3NpemU6IHJlYWxfMzJfYnl0ZXMgPSBuYXR1cmFsXzMyX2J5dGVzXG4gICAgICBlbmRcbiAgICAgICgkbF9uYXQzMikubWVtb3J5X2NvcHkgKCR2LCBuYXR1cmFsXzMyX2J5dGVzKVxuICAgICAgcHV0X25hdHVyYWxfMzJfbGUgKGxfbmF0MzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiB2ID0gcmVhZF9yZWFsXzMyX2xlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X3JlYWxfNjRfbGUgKHY6IERPVUJMRTsgcG9zOiBJTlRFR0VSXzMyKVxuICAgICAgLS0gSW5zZXJ0IGB2JyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0NjQ6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzY0X2J5dGVzID0gbmF0dXJhbF82NF9ieXRlc1xuICAgICAgZW5kXG4gICAgICAoJGxfbmF0NjQpLm1lbW9yeV9jb3B5ICgkdiwgbmF0dXJhbF82NF9ieXRlcylcbiAgICAgIHB1dF9uYXR1cmFsXzY0X2xlIChsX25hdDY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogdiA9IHJlYWRfcmVhbF82NF9sZSAocG9zKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2VzczogQmlnLWVuZGlhbiBmb3JtYXRcblxuICByZWFkX25hdHVyYWxfOF9iZSAocG9zOiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBSZWFkIE5BVFVSQUxfOCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfOF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5IChpdGVtICsgcG9zLCBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgZW5kXG5cbiAgcmVhZF9uYXR1cmFsXzE2X2JlIChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBSZWFkIE5BVFVSQUxfMTYgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2hpZ2gsIGxfbG93OiBOQVRVUkFMXzE2XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBsX2hpZ2ggOj0gcmVhZF9uYXR1cmFsXzggKHBvcylcbiAgICAgICAgbF9sb3cgOj0gKDB4MDBGRikudG9fbmF0dXJhbF8xNiAmIHJlYWRfbmF0dXJhbF84IChwb3MgKyBuYXR1cmFsXzhfYnl0ZXMpXG4gICAgICAgIFJlc3VsdCA6PSAobF9oaWdoLnRvX25hdHVyYWxfMTYgfDw8IDgpIHwgbF9sb3dcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8xNiAocG9zKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVhZF9uYXR1cmFsXzMyX2JlIChwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBSZWFkIE5BVFVSQUxfMzIgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzMyX2J5dGVzKSA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBsX2hpZ2gsIGxfbG93OiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBsX2hpZ2ggOj0gcmVhZF9uYXR1cmFsXzE2X2JlIChwb3MpXG4gICAgICAgIGxfbG93IDo9ICgweDAwMDBGRkZGKS50b19uYXR1cmFsXzMyICYgcmVhZF9uYXR1cmFsXzE2X2JlIChwb3MgKyBuYXR1cmFsXzE2X2J5dGVzKVxuICAgICAgICBSZXN1bHQgOj0gKGxfaGlnaC50b19uYXR1cmFsXzMyIHw8PCAxNikgfCBsX2xvd1xuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzMyIChwb3MpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWFkX25hdHVyYWxfNjRfYmUgKHBvczogSU5URUdFUik6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFJlYWQgTkFUVVJBTF82NCBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfaGlnaCwgbF9sb3c6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgaWYgaXNfbGl0dGxlX2VuZGlhbiB0aGVuXG4gICAgICAgIGxfaGlnaCA6PSByZWFkX25hdHVyYWxfMzJfYmUgKHBvcylcbiAgICAgICAgbF9sb3cgOj0ge05BVFVSQUxfNjR9IDB4MDAwMDAwMDBGRkZGRkZGRiAmIHJlYWRfbmF0dXJhbF8zMl9iZSAocG9zICsgbmF0dXJhbF8zMl9ieXRlcylcbiAgICAgICAgUmVzdWx0IDo9IChsX2hpZ2gudG9fbmF0dXJhbF82NCB8PDwgMzIpIHwgbF9sb3dcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF82NCAocG9zKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzhfYmUgKHBvczogSU5URUdFUik6IElOVEVHRVJfOFxuICAgICAgLS0gUmVhZCBJTlRFR0VSXzggYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzhfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfOF9iZSAocG9zKS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICByZWFkX2ludGVnZXJfMTZfYmUgKHBvczogSU5URUdFUik6IElOVEVHRVJfMTZcbiAgICAgIC0tIFJlYWQgSU5URUdFUl8xNiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMTZfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByZWFkX25hdHVyYWxfMTZfYmUgKHBvcykuYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIHJlYWRfaW50ZWdlcl8zMl9iZSAocG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUmVhZCBJTlRFR0VSIGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8zMl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHJlYWRfbmF0dXJhbF8zMl9iZSAocG9zKS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgcmVhZF9pbnRlZ2VyXzY0X2JlIChwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBSZWFkIElOVEVHRVJfNjQgYXQgcG9zaXRpb24gYHBvcycuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcmVhZF9uYXR1cmFsXzY0X2JlIChwb3MpLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICByZWFkX3JlYWxfMzJfYmUgKHBvczogSU5URUdFUik6IFJFQUxcbiAgICAgIC0tIFJlYWQgUkVBTF8zMiBhdCBwb3NpdGlvbiBgcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0MzI6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzMyX2J5dGVzID0gbmF0dXJhbF8zMl9ieXRlc1xuICAgICAgZW5kXG4gICAgICBsX25hdDMyIDo9IHJlYWRfbmF0dXJhbF8zMl9iZSAocG9zKVxuICAgICAgKCRSZXN1bHQpLm1lbW9yeV9jb3B5ICgkbF9uYXQzMiwgbmF0dXJhbF8zMl9ieXRlcylcbiAgICBlbmRcblxuICByZWFkX3JlYWxfNjRfYmUgKHBvczogSU5URUdFUik6IERPVUJMRVxuICAgICAgLS0gUmVhZCBSRUFMXzY0IGF0IHBvc2l0aW9uIGBwb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgcmVhbF82NF9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9uYXQ2NDogTkFUVVJBTF82NFxuICAgIGRvXG4gICAgICBjaGVja1xuICAgICAgICBjb3JyZWN0X3NpemU6IHJlYWxfNjRfYnl0ZXMgPSBuYXR1cmFsXzY0X2J5dGVzXG4gICAgICBlbmRcbiAgICAgIGxfbmF0NjQgOj0gcmVhZF9uYXR1cmFsXzY0X2JlIChwb3MpXG4gICAgICAoJFJlc3VsdCkubWVtb3J5X2NvcHkgKCRsX25hdDY0LCBuYXR1cmFsXzY0X2J5dGVzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlOiBCaWctZW5kaWFuIGZvcm1hdFxuXG4gIHB1dF9uYXR1cmFsXzhfYmUgKGk6IE5BVFVSQUxfODsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfOF9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgKGl0ZW0gKyBwb3MpLm1lbW9yeV9jb3B5ICgkaSwgbmF0dXJhbF84X2J5dGVzKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX25hdHVyYWxfOF9iZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzE2X2JlIChpOiBOQVRVUkFMXzE2OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgbmF0dXJhbF8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgaWYgaXNfbGl0dGxlX2VuZGlhbiB0aGVuXG4gICAgICAgIHB1dF9uYXR1cmFsXzggKCgoKGkgJiAweEZGMDApIHw+PiA4KSAmIDB4MDBGRikudG9fbmF0dXJhbF84LCBwb3MpXG4gICAgICAgIHB1dF9uYXR1cmFsXzggKChpICYgMHgwMEZGKS50b19uYXR1cmFsXzgsIHBvcyArIG5hdHVyYWxfOF9ieXRlcylcbiAgICAgIGVsc2VcbiAgICAgICAgcHV0X25hdHVyYWxfMTYgKGksIHBvcylcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX25hdHVyYWxfMTZfYmUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF8zMl9iZSAoaTogTkFUVVJBTF8zMjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIG5hdHVyYWxfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGlmIGlzX2xpdHRsZV9lbmRpYW4gdGhlblxuICAgICAgICBwdXRfbmF0dXJhbF8xNl9iZSAoKCgoaSAmIDB4RkZGRjAwMDApIHw+PiAxNikgJiAweDAwMDBGRkZGKS50b19uYXR1cmFsXzE2LCBwb3MpXG4gICAgICAgIHB1dF9uYXR1cmFsXzE2X2JlICgoaSAmIDB4MDAwMEZGRkYpLnRvX25hdHVyYWxfMTYsIHBvcyArIG5hdHVyYWxfMTZfYnl0ZXMpXG4gICAgICBlbHNlXG4gICAgICAgIHB1dF9uYXR1cmFsXzMyIChpLCBwb3MpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzMyX2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X25hdHVyYWxfNjRfYmUgKGk6IE5BVFVSQUxfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBuYXR1cmFsXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBpZiBpc19saXR0bGVfZW5kaWFuIHRoZW5cbiAgICAgICAgcHV0X25hdHVyYWxfMzJfYmUgKFxuICAgICAgICAgICgoKGkgJiAweEZGRkZGRkZGMDAwMDAwMDApIHw+PiAzMikgJiAweDAwMDAwMDAwRkZGRkZGRkYpLnRvX25hdHVyYWxfMzIsIHBvcylcbiAgICAgICAgcHV0X25hdHVyYWxfMzJfYmUgKChpICYgMHgwMDAwMDAwMEZGRkZGRkZGKS50b19uYXR1cmFsXzMyLFxuICAgICAgICAgIHBvcyArIG5hdHVyYWxfMzJfYnl0ZXMpXG4gICAgICBlbHNlXG4gICAgICAgIHB1dF9uYXR1cmFsXzY0IChpLCBwb3MpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9uYXR1cmFsXzY0X2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfOF9iZSAoaTogSU5URUdFUl84OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl84X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF84X2JlIChpLmFzX25hdHVyYWxfOCwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfOF9iZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzE2X2JlIChpOiBJTlRFR0VSXzE2OyBwb3M6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGknIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgaW50ZWdlcl8xNl9ieXRlcykgPD0gY291bnRcbiAgICBkb1xuICAgICAgcHV0X25hdHVyYWxfMTZfYmUgKGkuYXNfbmF0dXJhbF8xNiwgcG9zKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGkgPSByZWFkX2ludGVnZXJfMTZfYmUgKHBvcylcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl8zMl9iZSAoaTogSU5URUdFUjsgcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBpJyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIGludGVnZXJfMzJfYnl0ZXMpIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIHB1dF9uYXR1cmFsXzMyX2JlIChpLmFzX25hdHVyYWxfMzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpID0gcmVhZF9pbnRlZ2VyXzMyX2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X2ludGVnZXJfNjRfYmUgKGk6IElOVEVHRVJfNjQ7IHBvczogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgaScgYXQgcG9zaXRpb24gYHBvcycgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zX25vbm5lZ2F0aXZlOiBwb3MgPj0gMFxuICAgICAgdmFsaWRfcG9zaXRpb246IChwb3MgKyBpbnRlZ2VyXzY0X2J5dGVzKSA8PSBjb3VudFxuICAgIGRvXG4gICAgICBwdXRfbmF0dXJhbF82NF9iZSAoaS5hc19uYXR1cmFsXzY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaSA9IHJlYWRfaW50ZWdlcl82NF9iZSAocG9zKVxuICAgIGVuZFxuXG4gIHB1dF9yZWFsXzMyX2JlICh2OiBSRUFMOyBwb3M6IElOVEVHRVJfMzIpXG4gICAgICAtLSBJbnNlcnQgYHYnIGF0IHBvc2l0aW9uIGBwb3MnIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICAgIHJlcXVpcmVcbiAgICAgIHBvc19ub25uZWdhdGl2ZTogcG9zID49IDBcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiAocG9zICsgcmVhbF8zMl9ieXRlcykgPD0gY291bnRcbiAgICBsb2NhbFxuICAgICAgbF9uYXQzMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBjaGVja1xuICAgICAgICBjb3JyZWN0X3NpemU6IHJlYWxfMzJfYnl0ZXMgPSBuYXR1cmFsXzMyX2J5dGVzXG4gICAgICBlbmRcbiAgICAgICgkbF9uYXQzMikubWVtb3J5X2NvcHkgKCR2LCBuYXR1cmFsXzMyX2J5dGVzKVxuICAgICAgcHV0X25hdHVyYWxfMzJfYmUgKGxfbmF0MzIsIHBvcylcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiB2ID0gcmVhZF9yZWFsXzMyX2JlIChwb3MpXG4gICAgZW5kXG5cbiAgcHV0X3JlYWxfNjRfYmUgKHY6IERPVUJMRTsgcG9zOiBJTlRFR0VSXzMyKVxuICAgICAgLS0gSW5zZXJ0IGB2JyBhdCBwb3NpdGlvbiBgcG9zJyBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAgICByZXF1aXJlXG4gICAgICBwb3Nfbm9ubmVnYXRpdmU6IHBvcyA+PSAwXG4gICAgICB2YWxpZF9wb3NpdGlvbjogKHBvcyArIHJlYWxfNjRfYnl0ZXMpIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0NjQ6IE5BVFVSQUxfNjRcbiAgICBkb1xuICAgICAgY2hlY2tcbiAgICAgICAgY29ycmVjdF9zaXplOiByZWFsXzY0X2J5dGVzID0gbmF0dXJhbF82NF9ieXRlc1xuICAgICAgZW5kXG4gICAgICAoJGxfbmF0NjQpLm1lbW9yeV9jb3B5ICgkdiwgbmF0dXJhbF82NF9ieXRlcylcbiAgICAgIHB1dF9uYXR1cmFsXzY0X2JlIChsX25hdDY0LCBwb3MpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogdiA9IHJlYWRfcmVhbF82NF9iZSAocG9zKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbmNhdGVuYXRpb25cblxuICBhcHBlbmQgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBBcHBlbmQgYG90aGVyJyBhdCB0aGUgZW5kIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3NoYXJlZDogbm90IGlzX3NoYXJlZFxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmV3X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5ld19jb3VudCA6PSBjb3VudCArIG90aGVyLmNvdW50XG4gICAgICBpdGVtIDo9IGl0ZW0ubWVtb3J5X3JlYWxsb2MgKG5ld19jb3VudC5tYXggKDEpKVxuICAgICAgaWYgaXRlbSA9IGRlZmF1bHRfcG9pbnRlciB0aGVuXG4gICAgICAgIChjcmVhdGUge0VYQ0VQVElPTlN9KS5yYWlzZSAoXCJObyBtb3JlIG1lbW9yeVwiKVxuICAgICAgZW5kXG4gICAgICAoaXRlbSArIGNvdW50KS5tZW1vcnlfY29weSAob3RoZXIuaXRlbSwgb3RoZXIuY291bnQpXG4gICAgICBjb3VudCA6PSBuZXdfY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIHJlc2l6ZSAobjogSU5URUdFUilcbiAgICAgIC0tIFJlYWxsb2NhdGUgYGl0ZW0nIHRvIGhvbGQgYG4nIGJ5dGVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5vdF9zaGFyZWQ6IG5vdCBpc19zaGFyZWRcbiAgICBkb1xuICAgICAgICAtLSBSZWFsbG9jYXRlLlxuICAgICAgaWYgbiAvPSBjb3VudCB0aGVuXG4gICAgICAgIGl0ZW0gOj0gaXRlbS5tZW1vcnlfcmVhbGxvYyAobi5tYXggKDEpKVxuICAgICAgICBpZiBpdGVtID0gZGVmYXVsdF9wb2ludGVyIHRoZW5cbiAgICAgICAgICAoY3JlYXRlIHtFWENFUFRJT05TfSkucmFpc2UgKFwiTm8gbW9yZSBtZW1vcnlcIilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgICAtLSBSZXNldCBuZXdseSBhbGxvY2F0ZWQgbWVtb3J5IHRvIGAwJy5cbiAgICAgICAgKGl0ZW0gKyBjb3VudCkubWVtb3J5X3NldCAoMCwgbiAtIGNvdW50KVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBuXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIERpc3Bvc2FsXG5cbiAgZGlzcG9zZVxuICAgICAgLS0gUmVsZWFzZSBtZW1vcnkgcG9pbnRlZCBieSBgaXRlbScuXG4gICAgbG9jYWxcbiAgICAgIG51bGw6IFBPSU5URVJcbiAgICBkb1xuICAgICAgaWYgbm90IGlzX3NoYXJlZCB0aGVuXG4gICAgICAgIGl0ZW0ubWVtb3J5X2ZyZWVcbiAgICAgIGVuZFxuICAgICAgaXRlbSA6PSBudWxsXG4gICAgICBpc19zaGFyZWQgOj0gRmFsc2VcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2hhcmVkX3Jlc2V0OiBub3QgaXNfc2hhcmVkXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIERlYnVnZ2luZ1xuXG4gIGFsbG9jYXRpb25fY291bnRlcjogQ0VMTCBbTkFUVVJBTF82NF1cbiAgICAgIC0tIFN0b3JlIGN1cnJlbnQgbnVtYmVyIG9mIGFsbG9jYXRpb24gYmVpbmcgbWFkZS5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0LnB1dCAoMClcbiAgICBlbmRcblxuICBjb3VudGVyOiBOQVRVUkFMXzY0IG5vdGUgb3B0aW9uOiB0cmFuc2llbnQgYXR0cmlidXRlIGVuZFxuICAgICAgLS0gQWxsb2NhdGlvbiBudW1iZXIgYXNzb2NpYXRlZCB0byBDdXJyZW50LlxuXG4gIGluY3JlbWVudF9jb3VudGVyXG4gICAgICAtLSBTZXQgYGNvdW50ZXInIHdpdGggYSBuZXcgYWxsb2NhdGlvbiBudW1iZXIuXG4gICAgZG9cbiAgICAgIGRlYnVnIChcIk1BTkFHRURfUE9JTlRFUl9hbGxvY2F0aW9uXCIpXG4gICAgICAgIGNvdW50ZXIgOj0gYWxsb2NhdGlvbl9jb3VudGVyLml0ZW0gKyAxXG4gICAgICAgIGFsbG9jYXRpb25fY291bnRlci5wdXQgKGNvdW50ZXIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuXG5pbnZhcmlhbnRcbiAgaXRlbV9ub3RfbnVsbDogaXRlbSA9IGRlZmF1bHRfcG9pbnRlciBpbXBsaWVzIChjb3VudCA9IDAgYW5kIGlzX3NoYXJlZClcbiAgdmFsaWRfY291bnQ6IGNvdW50ID49IDBcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuXG5mZWF0dXJlIC0tIENvcnJlY3Rpb25cblxuICBjb3JyZWN0X21pc21hdGNoXG4gICAgICAtLSBBdHRlbXB0IHRvIGNvcnJlY3Qgb2JqZWN0IG1pc21hdGNoIHVzaW5nIGBtaXNtYXRjaF9pbmZvcm1hdGlvbicuXG4gICAgbG9jYWxcbiAgICAgIGxfbXNnOiBTVFJJTkdcbiAgICAgIGxfZXhjOiBFWENFUFRJT05TXG4gICAgZG9cbiAgICAgICAgLS0gSWYgaXQgaXMgbm90IHJlZGVmaW5lZCB0aGVuIHdlIHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgIGNyZWF0ZSBsX21zZy5tYWtlX2Zyb21fc3RyaW5nIChcIk1pc21hdGNoOiBcIilcbiAgICAgIGNyZWF0ZSBsX2V4Y1xuICAgICAgbF9tc2cuYXBwZW5kIChnZW5lcmF0aW5nX3R5cGUpXG4gICAgICBsX2V4Yy5yYWlzZV9yZXRyaWV2YWxfZXhjZXB0aW9uIChsX21zZylcbiAgICBlbmRcblxuICBtaXNtYXRjaF9pbmZvcm1hdGlvbjogTUlTTUFUQ0hfSU5GT1JNQVRJT05cbiAgICAgIC0tIE9yaWdpbmFsIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgbWlzbWF0Y2hlZCBvYmplY3RcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkZha2UgYWJzdHJhY3Rpb24gb2YgYSAuTkVUIE5BVElWRV9BUlJBWSBpbiBhIG5vbi0uTkVUIHN5c3RlbVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wNC0yMyAxNDo0OTowMiAtMDcwMCAoVHVlLCAyMyBBcHIgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI0NzAgJFwiXG5cbmZyb3plbiBjbGFzc1xuICBOQVRJVkVfQVJSQVkgW0ddXG5cbmludmFyaWFudFxuICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJVbnNpZ25lZCBpbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiAxNiBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uVUludDE2XCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgTkFUVVJBTF8xNlxuXG5pbmhlcml0XG4gIE5BVFVSQUxfMTZfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIGlkZW50aXR5LFxuICAgICAgYXNfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbF8zMixcbiAgICAgIHRvX3JlYWxfNjQsXG4gICAgICB0b19jaGFyYWN0ZXJfOCxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMixcbiAgICAgIGJpdF9hbmQsXG4gICAgICBiaXRfb3IsXG4gICAgICBiaXRfeG9yLFxuICAgICAgYml0X25vdCxcbiAgICAgIGJpdF9zaGlmdF9sZWZ0LFxuICAgICAgYml0X3NoaWZ0X3JpZ2h0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtOQVRVUkFMXzE2X1JFRn0pLFxuICB0b19yZWFsXzMyOiB7UkVBTF8zMn0sXG4gIHRvX3JlYWxfNjQ6IHtSRUFMXzY0fSxcbiAgdG9faW50ZWdlcl8zMjoge0lOVEVHRVJfMzJ9LFxuICB0b19pbnRlZ2VyXzY0OiB7SU5URUdFUl82NH0sXG4gIHRvX25hdHVyYWxfMzI6IHtOQVRVUkFMXzMyfSxcbiAgdG9fbmF0dXJhbF82NDoge05BVFVSQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzE2KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfMTYpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF8xNik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF8xNik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfMTZcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IE5BVFVSQUxfMTYpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogTkFUVVJBTF8xNik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBOQVRVUkFMXzE2XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF8xNlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDE2IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBOQVRVUkFMXzE2X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfMTZcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXJfY29kZTogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIE1pbl92YWx1ZTogTkFUVVJBTF8xNiA9IDBcbiAgTWF4X3ZhbHVlOiBOQVRVUkFMXzE2ID0gNjU1MzVcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIE1ha2UgYGknIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBkaXZpZGVkIGJ5IGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtIC89IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsdWU6IFJlc3VsdCA9IChvdGhlci5pdGVtIC89IDApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF8zMl9SRUZ9IG90aGVyIGFzIHJlYWxfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhbF92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IG90aGVyIGFzIGRvdWJsZV92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkb3VibGVfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDApIG9yXG4gICAgICAgIChvdGhlci5jb25mb3Jtc190byAoMC4wKSBhbmQgaXRlbSA+IDApKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgaWYgaXQgaXMgbm90IGl0cyB0eXBlJ3MgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfMzJ9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzMyfS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICB1bmFwcGxpY2FibGVfb3Bwb3NpdGU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEN1cnJlbnRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbm90X2FwcGxpY2FibGU6IEZhbHNlXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSBcXFxcIG90aGVyLml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpbnRlcnZhbCBhbGlhcyBcInwuLnxcIiAob3RoZXI6IElOVEVHRVIpOiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBJbnRlcnZhbCBmcm9tIGN1cnJlbnQgZWxlbWVudCB0byBgb3RoZXInXG4gICAgICAtLSAoZW1wdHkgaWYgYG90aGVyJyBsZXNzIHRoYW4gY3VycmVudCBpbnRlZ2VyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGl0ZW0sIG90aGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBDb252ZXJzaW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogTkFUVVJBTF8xNl9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBOQVRVUkFMXzE2X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtOQVRVUkFMXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8xNlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8xNn0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfMTZcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8xNl9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHhGKVxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl8xNl9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbS50b19pbnRlZ2VyXzMyXG4gICAgICBpZiB0bXAgPD0gOSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodG1wICsgKCcwJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9ICgoJ0EnKS5jb2RlICsgKHRtcCAtIDEwKSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLmhhcyAoUmVzdWx0KVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzE2XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18xNjogbiA8PSAxNlxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzE2OiBuID49IC0xNlxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18xNjogbiA8PSAxNlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMTY6IG4gPD0gMTZcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzE2OiBuIDwgMTZcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfMTYgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzE2OiBuIDwgMTZcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzE2IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF8xNiB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzE2KTogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICg1KVxuICAgICAgUmVzdWx0LmFwcGVuZF9uYXR1cmFsXzE2IChpdGVtKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiVW5zaWduZWQgaW50ZWdlciB2YWx1ZXMgY29kZWQgb24gMzIgYml0cy5cIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5VSW50MzJcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzMyIGluaGVyaXRcblxuICBOQVRVUkFMXzMyX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWxfMzIsXG4gICAgICB0b19yZWFsXzY0LFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7TkFUVVJBTF8zMl9SRUZ9KSxcbiAgdG9fcmVhbF8zMjoge1JFQUxfMzJ9LFxuICB0b19yZWFsXzY0OiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfNjQ6IHtJTlRFR0VSXzY0fSxcbiAgdG9fbmF0dXJhbF82NDoge05BVFVSQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQ0hBUkFDVEVSXzMyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogTkFUVVJBTF8zMlxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiAzMiBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgTkFUVVJBTF8zMl9SRUZcblxuaW5oZXJpdFxuICBOVU1FUklDXG4gICAgcmVuYW1lXG4gICAgICBxdW90aWVudCBhcyBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIixcbiAgICAgIG9wcG9zaXRlIGFzIHVuYXBwbGljYWJsZV9vcHBvc2l0ZVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgQ09NUEFSQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfaGFzaGFibGUsIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBOQVRVUkFMXzMyXG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgICAgLS0gQ2xlYXIgc2lnbiBiaXQuXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0gJiAweDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBOQVRVUkFMXzMyID0gMFxuICBNYXhfdmFsdWU6IE5BVFVSQUxfMzIgPSA0Mjk0OTY3Mjk1XG4gICAgICAtLSBNaW5pbXVtIGFuZCBNYXhpbXVtIHZhbHVlIGhvbGQgaW4gYGl0ZW0nLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoXG4gICAgICAgIGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUudG9fbmF0dXJhbF8zMiBhbmRcbiAgICAgICAgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIHVuYXBwbGljYWJsZV9vcHBvc2l0ZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBub3RfYXBwbGljYWJsZTogRmFsc2VcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IE5BVFVSQUxfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF8zMl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzE2fS5NYXhfdmFsdWUudG9fbmF0dXJhbF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMzJ9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXzMyXG4gICAgZW5kXG5cbiAgdG9fcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF82NFxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQsIHZhbDogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAweEYpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtLnRvX2ludGVnZXJfMzJcbiAgICAgIGlmIHRtcCA8PSA5IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh0bXAgKyAoJzAnKS5jb2RlKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gKCgnQScpLmNvZGUgKyAodG1wIC0gMTApKS50b19jaGFyYWN0ZXJfOFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IChcIjAxMjM0NTY3ODlBQkNERUZcIikuaGFzIChSZXN1bHQpXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgdG9fY2hhcmFjdGVyXzgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQ0hBUkFDVEVSXzMyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzMyOiBuID49IC0zMlxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfMzIgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzMyIHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF8zMiB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgyMClcbiAgICAgIFJlc3VsdC5hcHBlbmRfbmF0dXJhbF8zMiAoaXRlbSlcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlVuc2lnbmVkIGludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDY0IGJpdHNcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5VSW50NjRcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzY0XG5cbmluaGVyaXRcbiAgTkFUVVJBTF82NF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsXzMyLFxuICAgICAgdG9fcmVhbF82NCxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe05BVFVSQUxfNjRfUkVGfSksXG4gIHRvX3JlYWxfMzI6IHtSRUFMXzMyfSxcbiAgdG9fcmVhbF82NDoge1JFQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBOQVRVUkFMXzY0KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfNjQpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogTkFUVVJBTF82NCk6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfNjRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IE5BVFVSQUxfNjQpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogTkFUVVJBTF82NCk6IE5BVFVSQUxfNjRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBOQVRVUkFMXzY0XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF82NFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDY0IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBOQVRVUkFMXzY0X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfNjRcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgICAtLSBHZXQgdGhlIHBvc2l0aXZlIHZhbHVlIG9mIGBpdGVtJyBhbmQgdGhlbiBkb1xuICAgICAgICAtLSBhIG1vZHVsbyBvbiB0aGUgbWF4aW11bSBJTlRFR0VSXzMyIHZhbHVlLlxuICAgICAgUmVzdWx0IDo9IChpdGVtICYgMHgwMDAwMDAwMDdGRkZGRkZGKS50b19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgTWluX3ZhbHVlOiBOQVRVUkFMXzY0ID0gMFxuICBNYXhfdmFsdWU6IE5BVFVSQUxfNjQgPSAxODQ0Njc0NDA3MzcwOTU1MTYxNVxuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfNjRcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKFxuICAgICAgICBpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlLnRvX25hdHVyYWxfNjQgYW5kXG4gICAgICAgIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF82NClcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl8zMn0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgdW5hcHBsaWNhYmxlX29wcG9zaXRlOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5vdF9hcHBsaWNhYmxlOiBGYWxzZVxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLy8gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gXFxcXCBvdGhlci5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBeIG90aGVyICsgMFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IE5BVFVSQUxfNjRfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF82NF9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19ib29sZWFuOiBCT09MRUFOXG4gICAgICAtLSBUcnVlIGlmIG5vdCBgemVybycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF84fS5NYXhfdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge05BVFVSQUxfMzJ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8xNn0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtJTlRFR0VSXzMyfS5NYXhfdmFsdWUudG9fbmF0dXJhbF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfNjR9Lk1heF92YWx1ZS50b19uYXR1cmFsXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICB2YWw6IE5BVFVSQUxfNjRcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl82NF9iaXRzIC8vIDRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMHgwRikudG9faW50ZWdlcl8zMlxuICAgICAgICBSZXN1bHQucHV0IChhX2RpZ2l0LnRvX2hleF9jaGFyYWN0ZXIsIGkpXG4gICAgICAgIHZhbCA6PSB2YWwgfD4+IDRcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfdmFsaWRfY291bnQ6IFJlc3VsdC5jb3VudCA9IChjcmVhdGUge1BMQVRGT1JNfSkuSW50ZWdlcl82NF9iaXRzIC8vIDRcbiAgICBlbmRcblxuICB0b19oZXhfY2hhcmFjdGVyOiBDSEFSQUNURVJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIGluX2JvdW5kczogMCA8PSBpdGVtIGFuZCBpdGVtIDw9IDE1XG4gICAgbG9jYWxcbiAgICAgIHRtcDogSU5URUdFUlxuICAgIGRvXG4gICAgICB0bXAgOj0gaXRlbS50b19pbnRlZ2VyXzMyXG4gICAgICBpZiB0bXAgPD0gOSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodG1wICsgKCcwJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9ICgoJ0EnKS5jb2RlICsgKHRtcCAtIDEwKSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLmhhcyAoUmVzdWx0KVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzY0XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b182NDogbiA8PSA2NFxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzY0OiBuID49IC02NFxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b182NDogbiA8PSA2NFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fNjQ6IG4gPD0gNjRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzY0OiBuIDwgNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoKDEpLnRvX25hdHVyYWxfNjQgfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzY0OiBuIDwgNjRcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzY0IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF82NCB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBOQVRVUkFMXzY0KTogTkFUVVJBTF82NFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgyMClcbiAgICAgIFJlc3VsdC5hcHBlbmRfbmF0dXJhbF82NCAoaXRlbSlcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkludGVnZXIgdmFsdWVzIGNvZGVkIG9uIDggYml0c1wiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLkJ5dGVcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzcyBOQVRVUkFMXzggaW5oZXJpdFxuXG4gIE5BVFVSQUxfOF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc19uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsXzMyLFxuICAgICAgdG9fcmVhbF82NCxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe05BVFVSQUxfOF9SRUZ9KSxcbiAgdG9fcmVhbF8zMjoge1JFQUxfMzJ9LFxuICB0b19yZWFsXzY0OiB7UkVBTF82NH0sXG4gIHRvX2ludGVnZXJfMTY6IHtJTlRFR0VSXzE2fSxcbiAgdG9faW50ZWdlcl8zMjoge0lOVEVHRVJfMzJ9LFxuICB0b19pbnRlZ2VyXzY0OiB7SU5URUdFUl82NH0sXG4gIHRvX25hdHVyYWxfMTY6IHtOQVRVUkFMXzE2fSxcbiAgdG9fbmF0dXJhbF8zMjoge05BVFVSQUxfMzJ9LFxuICB0b19uYXR1cmFsXzY0OiB7TkFUVVJBTF82NH1cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IE5BVFVSQUxfOCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IE5BVFVSQUxfOCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IE5BVFVSQUxfOFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzgpOiBOQVRVUkFMXzhcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogTkFUVVJBTF84XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGFuIGludGVnZXIgdmFsdWUgY29kZWQgb24gOCBiaXRzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgTkFUVVJBTF84X1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfOFxuICAgICAgLS0gSW50ZWdlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIHNpZ246IElOVEVHRVJcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVsc2VpZiBpdGVtIDwgMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDEpXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDApXG4gICAgZW5kXG5cbiAgYXNjaWlfY2hhcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0b19jaGFyYWN0ZXJfOCBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IE5BVFVSQUxfOCA9IDBcbiAgTWF4X3ZhbHVlOiBOQVRVUkFMXzggPSAyNTVcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogTkFUVVJBTF84KVxuICAgICAgLS0gTWFrZSBgaScgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IGlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB2YWx1ZTogUmVzdWx0ID0gKG90aGVyLml0ZW0gLz0gMClcbiAgICBlbmRcblxuICBleHBvbmVudGlhYmxlIChvdGhlcjogTlVNRVJJQyk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBlbGV2YXRlZCB0byB0aGUgcG93ZXIgYG90aGVyJz9cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSBvdGhlciBhcyBpbnRlZ2VyX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGludGVnZXJfdmFsdWUuaXRlbSA+PSAwIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzY0X1JFRn0gb3RoZXIgYXMgZG91YmxlX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGRvdWJsZV92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYWZlX3ZhbHVlczogKChvdGhlci5jb25mb3Jtc190byAoMCkgYW5kIGl0ZW0gLz0gMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMCkpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChpdGVtID49IHtDSEFSQUNURVJfOH0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG4gIGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl8zMn0uTWluX3ZhbHVlIGFuZCBpdGVtIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvIG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIHVuYXBwbGljYWJsZV9vcHBvc2l0ZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBub3RfYXBwbGljYWJsZTogRmFsc2VcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIENvbnZlcnNpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBOQVRVUkFMXzhfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiBWIC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogTkFUVVJBTF84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbVxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF8zMlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfNjRcbiAgICBlbmRcblxuICB0b19oZXhfc3RyaW5nOiBTVFJJTkdcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gaGV4YWRlY2ltYWwgc3RyaW5nLlxuICAgIGxvY2FsXG4gICAgICBpLCB2YWw6IElOVEVHRVJcbiAgICAgIGFfZGlnaXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDJcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpKVxuICAgICAgICBSZXN1bHQuZmlsbF9ibGFua1xuICAgICAgICB2YWwgOj0gaXRlbVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYV9kaWdpdCA6PSAodmFsICYgMTUpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gMlxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtXG4gICAgICBSZXN1bHQgOj0gdG1wLnRvX2hleF9jaGFyYWN0ZXJcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X2FuZCAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfYW5kX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9vciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2Vfb3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfeG9yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV94b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X25vdDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfbm90KVxuICAgIGVuc3VyZVxuICAgICAgYml0X25vdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3NoaWZ0IChuOiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b184OiBuIDw9IDhcbiAgICAgIG5fZ3JlYXRlcl9vcl9lcXVhbF90b19taW51c184OiBuID49IC04XG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzg6IG4gPD0gOFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fODogbiA8PSA4XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfcmlnaHQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X3JpZ2h0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfdGVzdCAobjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRlc3QgYG4nLXRoIHBvc2l0aW9uIG9mIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3NfdGhhbl84OiBuIDwgOFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKSAvPSAwXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXQgKGI6IEJPT0xFQU47IG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIENvcHkgb2YgY3VycmVudCB3aXRoIGBuJy10aCBwb3NpdGlvblxuICAgICAgLS0gc2V0IHRvIDEgaWYgYGInLCAwIG90aGVyd2lzZS5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzg6IG4gPCA4XG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8ICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF84IHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgzKVxuICAgICAgUmVzdWx0LmFwcGVuZF9uYXR1cmFsXzggKGl0ZW0pXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG5cbiAgTlVNRVJJQ1xuXG5pbmhlcml0XG4gIERFQlVHX09VVFBVVFxuICAgIHJlbmFtZVxuICAgICAgZGVidWdfb3V0cHV0IGFzIG91dFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIG9ic29sZXRlXG4gICAgICBcIlsyMDA4XzA0XzAxXSBXaWxsIGJlIHJlbW92ZWQgc2luY2Ugbm90IHVzZWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInIChjb21tdXRhdGl2ZSkuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBjb21tdXRhdGl2ZTogUmVzdWx0IH4gKG90aGVyICsgQ3VycmVudClcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcblxuLS0gIG5ldXRyYWxfYWRkaXRpb246IGVxdWFsIChDdXJyZW50ICsgemVybywgQ3VycmVudCk7XG4tLSAgc2VsZl9zdWJ0cmFjdGlvbjogZXF1YWwgKEN1cnJlbnQgLSBDdXJyZW50LCB6ZXJvKTtcbi0tICBuZXV0cmFsX211bHRpcGxpY2F0aW9uOiBlcXVhbCAoQ3VycmVudCAqIG9uZSwgQ3VycmVudCk7XG4tLSAgc2VsZl9kaXZpc2lvbjogZGl2aXNpYmxlIChDdXJyZW50KSBpbXBsaWVzIGVxdWFsIChDdXJyZW50IC8gQ3VycmVudCwgb25lKVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiT2JqZWN0cyB0aGF0IG1heSBiZSBjb21wYXJlZCBhY2NvcmRpbmcgdG8gYSBwYXJ0aWFsIG9yZGVyIHJlbGF0aW9uXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgUEFSVF9DT01QQVJBQkxFXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX2xlc3NfZXF1YWwgYWxpYXMgXCI8PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoQ3VycmVudCA8IG90aGVyKSBvciAoQ3VycmVudCB+IG90aGVyKVxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXIgYWxpYXMgXCI+XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyIDwgQ3VycmVudFxuICAgIGVuZFxuXG4gIGlzX2dyZWF0ZXJfZXF1YWwgYWxpYXMgXCI+PVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcic/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAob3RoZXIgPCBDdXJyZW50KSBvciAoQ3VycmVudCB+IG90aGVyKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUGxhdGZvcm0tZGVwZW5kZW50IHByb3BlcnRpZXMuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA2LTE1IDEyOjM0OjMyIC0wNzAwIChGcmksIDE1IEp1biAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4NCAkXCJcblxuY2xhc3MgUExBVEZPUk1cblxuZmVhdHVyZSAtLSBQbGF0Zm9ybVxuXG4gIGlzX3RocmVhZF9jYXBhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHBsYXRmb3JtIGNhcGFibGUgb2YgbXVsdGktdGhyZWFkaW5nP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfc2Nvb3BfY2FwYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBwbGF0Zm9ybSBjYXBhYmxlIG9mIFNDT09QP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfZG90bmV0OiBCT09MRUFOXG4gICAgICAtLSBBcmUgd2UgdGFyZ2V0dGluZyAuTkVUP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfd2luZG93czogQk9PTEVBTlxuICAgICAgLS0gQXJlIHdlIHJ1bm5pbmcgb24gV2luZG93cyBwbGF0Zm9ybT9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIGlzX3VuaXg6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBydW5uaW5nIG9uIGEgVW5peCBsaWtlIHBsYXRmb3JtP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaXNfdm1zOiBCT09MRUFOXG4gICAgICAtLSBBcmUgd2UgcnVubmluZyBvbiBWTVM/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBpc19tYWM6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBydW5uaW5nIG9uIE1hYyBPUz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIGlzX3Z4d29ya3M6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBydW5uaW5nIG9uIFZ4V29ya3M/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBpc19saXR0bGVfZW5kaWFuOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHBsYXRmb3JtIGEgbGl0dGxlIGVuZGlhbiBvbmU/XG4gICAgbG9jYWxcbiAgICAgIGxfbmF0MTY6IE5BVFVSQUxfMTZcbiAgICAgIGxfbmF0ODogTkFUVVJBTF84XG4gICAgICBsX2ZpcnN0OiBOQVRVUkFMXzhcbiAgICBvbmNlXG4gICAgICBsX25hdDE2IDo9IDB4NDMyMVxuICAgICAgbF9uYXQ4IDo9IDB4MjFcbiAgICAgICgkbF9maXJzdCkubWVtb3J5X2NvcHkgKCRsX25hdDE2LCAxKVxuICAgICAgUmVzdWx0IDo9IGxfZmlyc3QgPSBsX25hdDhcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3MgYnl0ZXMgc2l6ZVxuXG4gIGJvb2xlYW5fYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYEJPT0xFQU4nXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfOF9ieXRlczogSU5URUdFUiA9IDFcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl84J1xuXG4gIGNoYXJhY3Rlcl8zMl9ieXRlczogSU5URUdFUiA9IDRcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl8zMidcblxuICBuYXR1cmFsXzhfYnl0ZXM6IElOVEVHRVIgPSAxXG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBOQVRVUkFMXzgnXG5cbiAgbmF0dXJhbF8xNl9ieXRlczogSU5URUdFUiA9IDJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfMTYnXG5cbiAgbmF0dXJhbF8zMl9ieXRlczogSU5URUdFUiA9IDRcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfMzInXG5cbiAgbmF0dXJhbF82NF9ieXRlczogSU5URUdFUiA9IDhcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfNjQnXG5cbiAgaW50ZWdlcl84X2J5dGVzOiBJTlRFR0VSID0gMVxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl84J1xuXG4gIGludGVnZXJfMTZfYnl0ZXM6IElOVEVHRVIgPSAyXG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzE2J1xuXG4gIGludGVnZXJfMzJfYnl0ZXM6IElOVEVHRVIgPSA0XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzMyJ1xuXG4gIGludGVnZXJfNjRfYnl0ZXM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzY0J1xuXG4gIHJlYWxfMzJfYnl0ZXM6IElOVEVHRVIgPSA0XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzMyJ1xuXG4gIHJlYWxfNjRfYnl0ZXM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYnl0ZXMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzY0J1xuXG4gIHBvaW50ZXJfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYFBPSU5URVInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3MgYml0cyBzaXplXG5cbiAgYm9vbGVhbl9iaXRzOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYEJPT0xFQU4nXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBib29sZWFuX2J5dGVzICogOFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl84X2JpdHM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl84J1xuXG4gIGNoYXJhY3Rlcl8zMl9iaXRzOiBJTlRFR0VSID0gMzJcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgQ0hBUkFDVEVSXzMyJ1xuXG4gIG5hdHVyYWxfOF9iaXRzOiBJTlRFR0VSID0gOFxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBOQVRVUkFMXzgnXG5cbiAgbmF0dXJhbF8xNl9iaXRzOiBJTlRFR0VSID0gMTZcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgTkFUVVJBTF8xNidcblxuICBuYXR1cmFsXzMyX2JpdHM6IElOVEVHRVIgPSAzMlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBOQVRVUkFMXzMyJ1xuXG4gIG5hdHVyYWxfNjRfYml0czogSU5URUdFUiA9IDY0XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYE5BVFVSQUxfNjQnXG5cbiAgaW50ZWdlcl84X2JpdHM6IElOVEVHRVIgPSA4XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYElOVEVHRVJfOCdcblxuICBpbnRlZ2VyXzE2X2JpdHM6IElOVEVHRVIgPSAxNlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBJTlRFR0VSXzE2J1xuXG4gIGludGVnZXJfMzJfYml0czogSU5URUdFUiA9IDMyXG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYElOVEVHRVJfMzInXG5cbiAgaW50ZWdlcl82NF9iaXRzOiBJTlRFR0VSID0gNjRcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl82NCdcblxuICByZWFsXzMyX2JpdHM6IElOVEVHRVIgPSAzMlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzMyJ1xuXG4gIHJlYWxfNjRfYml0czogSU5URUdFUiA9IDY0XG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYFJFQUxfNjQnXG5cbiAgcG9pbnRlcl9iaXRzOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgYml0cyBpbiBhIHZhbHVlIG9mIHR5cGUgYFBPSU5URVInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwb2ludGVyX2J5dGVzICogOFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE9ic29sZXRlc1xuXG4gIGNoYXJhY3Rlcl9ieXRlczogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIGluIGEgdmFsdWUgb2YgdHlwZSBgQ0hBUkFDVEVSXzgnXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBjaGFyYWN0ZXJfOF9ieXRlcycgaW5zdGVhZC5cIlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgd2lkZV9jaGFyYWN0ZXJfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYENIQVJBQ1RFUl8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGNoYXJhY3Rlcl8zMl9ieXRlcycgaW5zdGVhZC5cIlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9ieXRlczogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGludGVnZXJfMzJfYnl0ZXMnIGluc3RlYWQuXCJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIHJlYWxfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYFJFQUxfMzInXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGByZWFsXzMyX2J5dGVzJyBpbnN0ZWFkLlwiXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBkb3VibGVfYnl0ZXM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBpbiBhIHZhbHVlIG9mIHR5cGUgYFJFQUxfNjQnXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGByZWFsXzY0X2J5dGVzJyBpbnN0ZWFkLlwiXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfYml0czogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBDSEFSQUNURVJfOCdcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGNoYXJhY3Rlcl84X2JpdHMnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IDhcbiAgICBlbmRcblxuICBpbnRlZ2VyX2JpdHM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgSU5URUdFUl8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGludGVnZXJfMzJfYml0cycgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gMzJcbiAgICBlbmRcblxuICByZWFsX2JpdHM6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBiaXRzIGluIGEgdmFsdWUgb2YgdHlwZSBgUkVBTF8zMidcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHJlYWxfMzJfYml0cycgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gMzJcbiAgICBlbmRcblxuICBkb3VibGVfYml0czogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJpdHMgaW4gYSB2YWx1ZSBvZiB0eXBlIGBSRUFMXzY0J1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgcmVhbF82NF9iaXRzJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSA2NFxuICAgIGVuZFxuXG4gIG1heGltdW1fY2hhcmFjdGVyX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIExhcmdlc3Qgc3VwcG9ydGVkIGNvZGUgZm9yIENIQVJBQ1RFUl84IHZhbHVlc1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBge0NIQVJBQ1RFUn0ubWF4X3ZhbHVlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB7Q0hBUkFDVEVSfS5tYXhfdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIG1lYW5pbmdmdWw6IFJlc3VsdCA+PSAxMjdcbiAgICBlbmRcblxuICBtYXhpbXVtX2ludGVnZXI6IElOVEVHRVJcbiAgICAgIC0tIExhcmdlc3Qgc3VwcG9ydGVkIHZhbHVlIG9mIHR5cGUgSU5URUdFUl8zMlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBge0lOVEVHRVJ9Lm1heF92YWx1ZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0ge0lOVEVHRVJ9Lm1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgbWVhbmluZ2Z1bDogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBtaW5pbXVtX2NoYXJhY3Rlcl9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBTbWFsbGVzdCBzdXBwb3J0ZWQgY29kZSBmb3IgQ0hBUkFDVEVSXzggdmFsdWVzXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB7Q0hBUkFDVEVSfS5taW5fdmFsdWUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHtDSEFSQUNURVJ9Lm1pbl92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgbWVhbmluZ2Z1bDogUmVzdWx0IDw9IDBcbiAgICBlbmRcblxuICBtaW5pbXVtX2ludGVnZXI6IElOVEVHRVJcbiAgICAgIC0tIFNtYWxsZXN0IHN1cHBvcnRlZCB2YWx1ZSBvZiB0eXBlIElOVEVHRVJfMzJcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHtJTlRFR0VSfS5taW5fdmFsdWUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHtJTlRFR0VSfS5taW5fdmFsdWVcbiAgICBlbnN1cmVcbiAgICAgIG1lYW5pbmdmdWw6IFJlc3VsdCA8PSAwXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgbWVhbnQgdG8gYmUgZXhjaGFuZ2VkIHdpdGggbm9uLUVpZmZlbCBzb2Z0d2FyZS5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgUE9JTlRFUiBpbmhlcml0XG5cbiAgUE9JTlRFUl9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaGFzaF9jb2RlLFxuICAgICAgcGx1cyxcbiAgICAgIHRvX2ludGVnZXJfMzIsXG4gICAgICBpc19kZWZhdWx0X3BvaW50ZXIsXG4gICAgICBvdXRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe1BPSU5URVJfUkVGfSlcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfZGVmYXVsdF9wb2ludGVyOiBCT09MRUFOXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob2Zmc2V0OiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gUG9pbnRlciBtb3ZlZCBieSBhbiBvZmZzZXQgb2YgYG9mZnNldCcgYnl0ZXMuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcG9pbnRlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyByZWZlcmVuY2UgdG8gb2JqZWN0XG4gICAgbWVhbnQgdG8gYmUgZXhjaGFuZ2VkIHdpdGggbm9uLUVpZmZlbCBzb2Z0d2FyZS5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3MgUE9JTlRFUl9SRUZcbmluaGVyaXRcbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbCwgaXNfaGFzaGFibGVcbiAgICBlbmRcblxuICBSRUZBQ1RPUklOR19IRUxQRVJcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IFBPSU5URVJcbiAgICAgIC0tIFBvaW50ZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaGFzaF9jb2RlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmcm96ZW4gc2V0X2l0ZW0gKHA6IFBPSU5URVIpXG4gICAgICAtLSBNYWtlIGBwJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBpZiBpdCBpcyBub3QgaXRzIHR5cGUncyBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZW5kXG5cbiAgaXNfZGVmYXVsdF9wb2ludGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGBkZWZhdWx0X3BvaW50ZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA9IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGl0ZW0gPSBkZWZhdWx0X3BvaW50ZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG9mZnNldDogSU5URUdFUik6IFBPSU5URVJcbiAgICAgIC0tIFBvaW50ZXIgbW92ZWQgYnkgYW4gb2Zmc2V0IG9mIGBvZmZzZXQnIGJ5dGVzLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSArIG9mZnNldFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IFBPSU5URVJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogUE9JTlRFUl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICByZXF1aXJlXG4tLSAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMzJ9Lk1pbl92YWx1ZVxuLS0gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8zMn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIC0tIFRPRE86IEZpeCBPTkNFIGFyZ3VtZW50c1xuICAgICAgLS1maXhtZSAob25jZSBcIkRvIG5vdCBmb3JnZXQgdG8gYWRkIHByb3BlciBwcmVjb25kaXRpb24gdG8gZW5zdXJlIHdlIGNhbiBjb252ZXJ0IHBvaW50ZXIgJVxuICAgICAgLS0gICV2YWx1ZSBpbnRvIGFuIElOVEVHRVJfMzJcIilcbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2ludGVnZXJfMzJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZW1vcnkgY29weVxuXG4gIG1lbW9yeV9jb3B5IChhX3NvdXJjZTogUE9JTlRFUjsgYV9zaXplOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBgYV9zaXplJyBieXRlcyBmcm9tIGBhX3NvdXJjZScgdG8gYEN1cnJlbnQnLlxuICAgICAgLS0gYGFfc291cmNlJyBhbmQgYEN1cnJlbnQnIHNob3VsZCBub3Qgb3ZlcmxhcC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zaXplOiBhX3NpemUgPj0gMFxuICAgICAgdmFsaWRfc291cmNlOiBhX3NvdXJjZSAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBkb1xuICAgICAgY19tZW1jcHkgKGl0ZW0sIGFfc291cmNlLCBhX3NpemUpXG4gICAgZW5kXG5cbiAgbWVtb3J5X21vdmUgKGFfc291cmNlOiBQT0lOVEVSOyBhX3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGBhX3NpemUnIGJ5dGVzIGZyb20gYGFfc291cmNlJyB0byBgQ3VycmVudCcuXG4gICAgICAtLSBgYV9zb3VyY2UnIGFuZCBgQ3VycmVudCcgY2FuIG92ZXJsYXAuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc2l6ZTogYV9zaXplID49IDBcbiAgICAgIHZhbGlkX3NvdXJjZTogYV9zb3VyY2UgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIGNfbWVtbW92ZSAoaXRlbSwgYV9zb3VyY2UsIGFfc2l6ZSlcbiAgICBlbmRcblxuICBtZW1vcnlfc2V0ICh2YWwsIG46IElOVEVHRVIpXG4gICAgICAtLSBGaWxsIGZpcnN0IGBuJyBieXRlcyBvZiB0aGUgbWVtb3J5IHBvaW50ZWQgYnkgYEN1cnJlbnQnXG4gICAgICAtLSB3aXRoIGNvbnN0YW50IGB2YWwnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3ZhbDogdmFsID49IDBcbiAgICAgIHZhbGlkX246IG4gPj0gMFxuICAgIGRvXG4gICAgICBjX21lbXNldCAoaXRlbSwgdmFsLCBuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFsbG9jYXRpb24vZnJlZVxuXG4gIG1lbW9yeV9hbGxvYyAoYV9zaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQWxsb2NhdGVkIGBzaXplJyBieXRlcyB1c2luZyBgbWFsbG9jJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zaXplOiBhX3NpemUgPiAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjX21hbGxvYyAoYV9zaXplKVxuICAgIGVuZFxuXG4gIG1lbW9yeV9jYWxsb2MgKGFfY291bnQsIGFfZWxlbWVudF9zaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQWxsb2NhdGUgYGFfY291bnQnIGVsZW1lbnRzIG9mIHNpemUgYGFfZWxlbWVudF9zaXplJyBieXRlcyB1c2luZyBgY2FsbG9jLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2VsZW1lbnRfY291bnQ6IGFfY291bnQgPiAwXG4gICAgICB2YWxpZF9lbGVtZW50X3NpemU6IGFfZWxlbWVudF9zaXplID4gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19jYWxsb2MgKGFfY291bnQsIGFfZWxlbWVudF9zaXplKVxuICAgIGVuZFxuXG4gIG1lbW9yeV9yZWFsbG9jIChhX3NpemU6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBSZWFsbG9jIGBDdXJyZW50Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zaXplOiBhX3NpemUgPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19yZWFsbG9jIChpdGVtLCBhX3NpemUpXG4gICAgZW5kXG5cbiAgbWVtb3J5X2ZyZWVcbiAgICAgIC0tIEZyZWUgYWxsb2NhdGVkIG1lbW9yeSB3aXRoIGBtYWxsb2MnLlxuICAgIGRvXG4gICAgICBjX2ZyZWUgKGl0ZW0pXG4gICAgICBzZXRfaXRlbSAoZGVmYXVsdF9wb2ludGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBtZW1vcnlfY29tcGFyZSAob3RoZXI6IFBPSU5URVI7IGFfc2l6ZTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgYEN1cnJlbnQnIGFuZCBgb3RoZXInIGFyZSBpZGVudGljYWwgb24gYGFfc2l6ZScgYnl0ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc2l6ZTogYV9zaXplID4gMFxuICAgICAgdmFsaWRfb3RoZXI6IG90aGVyIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19tZW1jbXAgKGl0ZW0sIG90aGVyLCBhX3NpemUpID0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcG9pbnRlciB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5vdXRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBjX21lbWNweSAoZGVzdGluYXRpb24sIHNvdXJjZTogUE9JTlRFUjsgY291bnQ6IElOVEVHRVIpXG4gICAgICAtLSBDIG1lbWNweVxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlICh2b2lkICosIGNvbnN0IHZvaWQgKiwgc2l6ZV90KSB1c2UgPHN0cmluZy5oPlwiXG4gICAgYWxpYXNcbiAgICAgIFwibWVtY3B5XCJcbiAgICBlbmRcblxuICBjX21lbW1vdmUgKGRlc3RpbmF0aW9uLCBzb3VyY2U6IFBPSU5URVI7IGNvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gQyBtZW1tb3ZlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBzaWduYXR1cmUgKHZvaWQgKiwgY29uc3Qgdm9pZCAqLCBzaXplX3QpIHVzZSA8c3RyaW5nLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJtZW1tb3ZlXCJcbiAgICBlbmRcblxuICBjX21lbXNldCAoc291cmNlOiBQT0lOVEVSOyB2YWw6IElOVEVHRVI7IGNvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gQyBtZW1zZXRcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAodm9pZCAqLCBpbnQsIHNpemVfdCkgdXNlIDxzdHJpbmcuaD5cIlxuICAgIGFsaWFzXG4gICAgICBcIm1lbXNldFwiXG4gICAgZW5kXG5cbiAgY19tZW1jbXAgKHNvdXJjZSwgb3RoZXI6IFBPSU5URVI7IGNvdW50OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQyBtZW1jbXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAodm9pZCAqLCB2b2lkICosIHNpemVfdCk6IEVJRl9JTlRFR0VSIHVzZSA8c3RyaW5nLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJtZW1jbXBcIlxuICAgIGVuZFxuXG4gIGNfbWFsbG9jIChzaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQyBtYWxsb2NcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAoc2l6ZV90KTogRUlGX1BPSU5URVIgdXNlIDxzdGRsaWIuaD5cIlxuICAgIGFsaWFzXG4gICAgICBcIm1hbGxvY1wiXG4gICAgZW5kXG5cbiAgY19jYWxsb2MgKG5tZW1iLCBzaXplOiBJTlRFR0VSKTogUE9JTlRFUlxuICAgICAgLS0gQyBjYWxsb2NcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAoc2l6ZV90LCBzaXplX3QpOiBFSUZfUE9JTlRFUiB1c2UgPHN0ZGxpYi5oPlwiXG4gICAgYWxpYXNcbiAgICAgIFwiY2FsbG9jXCJcbiAgICBlbmRcblxuICBjX3JlYWxsb2MgKHNvdXJjZTogUE9JTlRFUjsgc2l6ZTogSU5URUdFUik6IFBPSU5URVJcbiAgICAgIC0tIEMgcmVhbGxvY1xuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlICh2b2lkICosIHNpemVfdCk6IEVJRl9QT0lOVEVSIHVzZSA8c3RkbGliLmg+XCJcbiAgICBhbGlhc1xuICAgICAgXCJyZWFsbG9jXCJcbiAgICBlbmRcblxuICBjX2ZyZWUgKHA6IFBPSU5URVIpXG4gICAgICAtLSBDIGZyZWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJDIHNpZ25hdHVyZSAodm9pZCAqKSB1c2UgPHN0ZGxpYi5oPlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZnJlZVwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgT2JqZWN0cyByZXByZXNlbnRpbmcgZGVsYXllZCBjYWxscyB0byBhIHByb2NlZHVyZS5cbiAgICB3aXRoIHNvbWUgb3BlcmFuZHMgcG9zc2libHkgc3RpbGwgb3Blbi5cblxuICAgIE5vdGU6IEZlYXR1cmVzIGFyZSB0aGUgc2FtZSBhcyB0aG9zZSBvZiBST1VUSU5FLFxuICAgICAgd2l0aCBgYXBwbHknIG1hZGUgZWZmZWN0aXZlLCBhbmQgbm8gZnVydGhlclxuICAgICAgcmVkZWZpbml0aW9uIG9mIGBpc19lcXVhbCcgYW5kIGBjb3B5Jy5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTI4IDE0OjM1OjIzIC0wODAwIChUdWUsIDI4IEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDEwOSAkXCJcblxuY2xhc3NcbiAgUFJPQ0VEVVJFIFtCQVNFX1RZUEUgLT4gZGV0YWNoYWJsZSBBTlksIE9QRU5fQVJHUyAtPiBkZXRhY2hhYmxlIFRVUExFIGNyZWF0ZSBkZWZhdWx0X2NyZWF0ZSBlbmRdXG5cbmluaGVyaXRcbiAgUk9VVElORSBbQkFTRV9UWVBFLCBPUEVOX0FSR1NdXG4gICAgcmVuYW1lXG4gICAgICBjYWxsIGFzIGNhbGwgYWxpYXMgXCIoKVwiXG4gICAgZW5kXG5cbmNyZWF0ZSB7Tk9ORX1cbiAgc2V0X3JvdXRfZGlzcFxuXG5mZWF0dXJlIC0tIENhbGxzXG5cbiAgYXBwbHlcbiAgICAgIC0tIENhbGwgcHJvY2VkdXJlIHdpdGggYGFyZ3MnIGFzIGxhc3Qgc2V0LlxuICAgIGRvXG4gICAgICBjYWxsIChvcGVyYW5kcylcbiAgICBlbmRcblxuICBjYWxsIGFsaWFzIFwiKClcIiAoYXJnczogZGV0YWNoYWJsZSBzZXBhcmF0ZSBPUEVOX0FSR1MpXG4gICAgbG9jYWxcbiAgICAgIGM6IGxpa2UgY2xvc2VkX29wZXJhbmRzXG4gICAgICBsX2Nsb3NlZF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjIDo9IGNsb3NlZF9vcGVyYW5kc1xuICAgICAgaWYgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jbG9zZWRfY291bnQgOj0gIGMuY291bnRcbiAgICAgIGVuZFxuICAgICAgZmFzdF9jYWxsIChlbmNhcHNfcm91dF9kaXNwLCBjYWxjX3JvdXRfYWRkciwgJGNsb3NlZF9vcGVyYW5kcywgJGFyZ3MsIHJvdXRpbmVfaWQsXG4gICAgICAgICAgICAgICBpc19iYXNpYywgd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudCwgbF9jbG9zZWRfY291bnQsIG9wZW5fY291bnQsICRvcGVuX21hcClcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmYXN0X2NhbGwgKGFfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSO1xuICAgICAgICAgICBhX2Nsb3NlZF9vcGVyYW5kczogUE9JTlRFUjsgYV9vcGVyYW5kczogUE9JTlRFUjtcbiAgICAgICAgIGFfcm91dGluZV9pZDogSU5URUdFUjsgYV9pc19iYXNpYzogQk9PTEVBTjsgYV9jbGFzc19pZF9pbmxpbmVfYWdlbnQ6IElOVEVHRVI7XG4gICAgICAgICBhX2Nsb3NlZF9jb3VudCwgYV9vcGVuX2NvdW50OiBJTlRFR0VSOyBhX29wZW5fbWFwOiBQT0lOVEVSKVxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgaW5saW5lIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiW1xuICAgICAgI2lmZGVmIFdPUktCRU5DSFxuICAgICAgICBpZiAoJGFfcm91dF9kaXNwICE9IDApIHtcbiAgICAgICAgICAoRlVOQ1RJT05fQ0FTVCh2b2lkLCAoRUlGX1BPSU5URVIsIEVJRl9SRUZFUkVOQ0UsIEVJRl9SRUZFUkVOQ0UpKSAkYV9yb3V0X2Rpc3ApKFxuICAgICAgICAgICAgJGFfY2FsY19yb3V0X2FkZHIsICRhX2Nsb3NlZF9vcGVyYW5kcywgJGFfb3BlcmFuZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRfb2JqX2NhbGxfcHJvY2VkdXJlX2R5bmFtaWMgKFxuICAgICAgICAgICAgJGFfcm91dGluZV9pZCxcbiAgICAgICAgICAgICRhX2lzX2Jhc2ljLFxuICAgICAgICAgICAgJGFfY2xhc3NfaWRfaW5saW5lX2FnZW50LFxuICAgICAgICAgICAgJGFfY2xvc2VkX29wZXJhbmRzLFxuICAgICAgICAgICAgJGFfY2xvc2VkX2NvdW50LFxuICAgICAgICAgICAgJGFfb3BlcmFuZHMsXG4gICAgICAgICAgICAkYV9vcGVuX2NvdW50LFxuICAgICAgICAgICAgJGFfb3Blbl9tYXApO1xuICAgICAgICB9XG4gICAgICAjZWxzZVxuICAgICAgICAoRlVOQ1RJT05fQ0FTVCh2b2lkLCAoRUlGX1BPSU5URVIsIEVJRl9SRUZFUkVOQ0UsIEVJRl9SRUZFUkVOQ0UpKSAkYV9yb3V0X2Rpc3ApKFxuICAgICAgICAgICRhX2NhbGNfcm91dF9hZGRyLCAkYV9jbG9zZWRfb3BlcmFuZHMsICRhX29wZXJhbmRzKTtcbiAgICAgICNlbmRpZlxuICAgICAgXVwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJUYWJsZXMgd2hvc2Uga2V5cyBhcmUgaW50ZWdlcnMgaW4gYSBjb250aWd1b3VzIGludGVydmFsXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogaW5kZXhhYmxlLCBhY2Nlc3M7XG4gIGFjY2VzczogaW5kZXgsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgUkVBREFCTEVfSU5ERVhBQkxFIFtHXVxuXG5pbmhlcml0XG4gIElURVJBQkxFIFtHXVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiIChpOiBJTlRFR0VSKTogR1xuICAgICAgLS0gRW50cnkgYXQgcG9zaXRpb24gYGknXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgbmV3X2N1cnNvcjogSU5ERVhBQkxFX0lURVJBVElPTl9DVVJTT1IgW0ddXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuc3RhcnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyBhIHZhbGlkIGluZGV4P1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBvbmx5X2lmX2luX2luZGV4X3NldDpcbiAgICAgICAgUmVzdWx0IGltcGxpZXMgKChpID49IGluZGV4X3NldC5sb3dlcikgYW5kIChpIDw9IGluZGV4X3NldC51cHBlcikpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG5cblxuXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xNCAyMjoyMToxOSAtMDcwMCAoV2VkLCAxNCBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUwNjAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR18zMlxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVuYW1lXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGhhcywgaW5kZXhfb2YsIGxhc3RfaW5kZXhfb2YsIG9jY3VycmVuY2VzXG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgYXNfcmVhZGFibGVfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOH0sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbiArIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGM6IENIQVJBQ1RFUl8zMjsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBzdHJpbmcgb2YgbGVuZ3RoIGBuJyBmaWxsZWQgd2l0aCBgYycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgICAgZmlsbF9jaGFyYWN0ZXIgKGMpXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICAgIGZpbGxlZDogb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGlmIEN1cnJlbnQgLz0gcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZW1wdHkgKGNvdW50ICsgMSlcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCAwLCBjb3VudCArIDEpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9zaGFyZWRfaW1wbGVtZW50YXRpb246IEN1cnJlbnQgLz0gcyBpbXBsaWVzIG5vdCBzaGFyZWRfd2l0aCAocylcbiAgICAgIGluaXRpYWxpemVkOiBzYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbm90X3NoYXJlZF9pbXBsZW1lbnRhdGlvbjogQ3VycmVudCAvPSBzXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoJyUvMDAwLycsIGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG9fY2hhcmFjdGVyXzMyX2FyZWEgKGFyZWEsIDEsIGxfY291bnQpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NfcG9pbnRlciAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBDcmVhdGUgbmV3IGluc3RhbmNlIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX2Zyb21fYycuXCJcbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBtYWtlX2Zyb21fYyAoY19zdHJpbmcpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHNoYXJlZF93aXRoIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChvdGhlciAvPSBWb2lkKSBhbmQgdGhlbiAoYXJlYSA9IG90aGVyLmFyZWEpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IENIQVJBQ1RFUl8zMjsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGksIG5iLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfbG93ZXJfYXJlYSA6PSBhcmVhX2xvd2VyXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleCAtIDEgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgICBuYiA6PSBuYiArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIGEuaXRlbSAoaSkgPSBjXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMVxuICAgICAgICAgICAgLS0gYW5kIHN1YnN0cmFjdCBgYXJlYV9sb3dlcidcbiAgICAgICAgICBSZXN1bHQgOj0gaSArIDEgLSBsX2xvd2VyX2FyZWFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsYXN0X2luZGV4X29mIChjOiBDSEFSQUNURVJfMzI7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJyxcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kIC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCBsX2xvd2VyX2FyZWEgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMS5cbiAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleF9pbl9ib3VuZHMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9wb3MsIGVuZF9wb3MpXG4gICAgZW5kXG5cbiAgc3RyaW5nOiBTVFJJTkdfMzJcbiAgICAgIC0tIE5ldyBTVFJJTkdfMzIgaGF2aW5nIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3RyaW5nX3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN0cmluZ19yZXByZXNlbnRhdGlvbjogU1RSSU5HXzMyXG4gICAgICAtLSBTaW1pbGFyIHRvIGBzdHJpbmcnIGJ1dCBvbmx5IGNyZWF0ZSBhIG5ldyBvYmplY3QgaWYgYEN1cnJlbnQnIGlzIG5vdCBvZiBkeW5hbWljIHR5cGUge1NUUklOR18zMn1cbiAgICBkb1xuICAgICAgaWYgc2FtZV90eXBlIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIHRoZW4gYXR0YWNoZWQge1NUUklOR18zMn0gQ3VycmVudCBhcyBsX3MzMiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3MzMlxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGNvcnJlY3RfdHlwZTogUmVzdWx0LnNhbWVfdHlwZSAoY3JlYXRlIHtTVFJJTkdfMzJ9Lm1ha2VfZW1wdHkpXG4gICAgICBmaXJzdF9pdGVtOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKVxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuc3RyaW5nXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9pbmRleCwgY291bnQpXG4gICAgZW5kXG5cbiAgZnV6enlfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnQ6IElOVEVHRVI7IGZ1eno6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLmZ1enp5X2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnQsIGNvdW50LCBmdXp6KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIEFsbG9jYXRlZCBzcGFjZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5jb3VudCAtIDFcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gQWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1ha2luZyB1cCB0aGUgc3RyaW5nXG5cbiAgb2NjdXJyZW5jZXMgKGM6IENIQVJBQ1RFUl8zMik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50ICsgaVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiBhLml0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB6ZXJvX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBSZXN1bHQgPSAwXG4gICAgICByZWN1cnNlX2lmX25vdF9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSAvPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgICByZWN1cnNlX2lmX2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpID0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IDEgKyBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEsIGNvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpbmRleF9zZXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpbmRleF9zZXRfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIGxvY2FsXG4gICAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2hhc2gsIGxfb3RoZXJfaGFzaDogbGlrZSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgIGRvXG4gICAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBMZXQncyBjb21wYXJlIHRoZSBjb250ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBoYXNoX2NvZGUgYXJlIHRoZSBzYW1lIG9yIG5vdCB5ZXQgY29tcHV0ZWQuXG4gICAgICAgICAgbF9oYXNoIDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgICAgIGxfb3RoZXJfaGFzaCA6PSBvdGhlci5pbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBpZiBsX2hhc2ggPSAwIG9yIGVsc2UgbF9vdGhlcl9oYXNoID0gMCBvciBlbHNlIGxfaGFzaCA9IGxfb3RoZXJfaGFzaCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBuYilcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICBlbmRcblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJyByZWdhcmRsZXNzIG9mIGNhc2luZ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBuYiA9IDAgb3IgZWxzZSBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyLCAxLCBuYiwgMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAoQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnQ6IGF0dGFjaGVkIHtsaWtlIEN1cnJlbnR9IG90aGVyIGFzIGxfb3RoZXIgaW1wbGllcyAoc3RhbmRhcmRfaXNfZXF1YWwgKGxfb3RoZXIpIGltcGxpZXMgUmVzdWx0KVxuICAgICAgdmFsaWRfcmVzdWx0OiBhc19sb3dlciB+IG90aGVyLmFzX2xvd2VyIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBjYXNlbGVzcyBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICBsX2FyZWEsIGxfb3RoZXJfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjMSxjMjogQ0hBUkFDVEVSXzMyXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgaW5kZXhfcG9zIC0gMVxuICAgICAgICAgIGogOj0gb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgICBuYiA6PSBuYiArIGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMxIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGMyIDo9IGxfb3RoZXJfYXJlYS5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGxfcHJvcC50b19sb3dlciAoYzEpIC89IGxfcHJvcC50b19sb3dlciAoYzIpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbmIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG8gYEN1cnJlbnQnIGFuZCBgb3RoZXInIGhhdmUgc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2U/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKHN0cmluZyB+IG90aGVyLnN0cmluZylcbiAgICBlbmRcblxuICBzYW1lX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyICsgc3RhcnRfcG9zIC0gMSwgYXJlYV9sb3dlciArIGluZGV4X3BvcyAtIDEsIG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NoYXJhY3RlcnM6IFJlc3VsdCA9IHN1YnN0cmluZyAoaW5kZXhfcG9zLCBpbmRleF9wb3MgKyBlbmRfcG9zIC0gc3RhcnRfcG9zKS5zYW1lX3N0cmluZyAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbGV4aWNvZ3JhcGhpY2FsbHkgbG93ZXIgdGhhbiBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBvdGhlcl9jb3VudDogSU5URUdFUlxuICAgICAgY3VycmVudF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb3RoZXJfY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgICBpZiBvdGhlcl9jb3VudCA9IGN1cnJlbnRfY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgb3RoZXJfY291bnQpID4gMFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgY3VycmVudF9jb3VudCA8IG90aGVyX2NvdW50IHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgY3VycmVudF9jb3VudCkgPj0gMFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgb3RoZXJfY291bnQpID4gMFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19zdHJpbmdfODogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG5cbiAgaXNfdmFsaWRfYXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBuYiA6PSBjb3VudCArIGlcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkuY29kZSA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDFcbiAgICAgICAgbiA6PSBhcmVhX2xvd2VyICsgZW5kX2luZGV4IC0gMVxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuIG9yIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gaSA+IG5cbiAgICBlbmRcblxuICBoYXMgKGM6IENIQVJBQ1RFUl8zMik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIChsX2FyZWEuaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDwgbmIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzdGFydHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICBsX3NfYXJlYSA6PSBzLmFyZWFcbiAgICAgICAgICAgIGogOj0gYXJlYV9sb3dlciArIGlcbiAgICAgICAgICAgIGkgOj0gcy5hcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgbmIgOj0gcy5hcmVhX2xvd2VyXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgICBpZiBsX2FyZWEuaXRlbSAoaikgLz0gbF9zX2FyZWEuaXRlbSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSBuYiAtLSBKdW1wIG91dCBvZiBsb29wXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHMuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoMSwgcy5jb3VudCkpXG4gICAgZW5kXG5cbiAgZW5kc193aXRoIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBmaW5pc2ggd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGogOj0gY291bnRcbiAgICAgICAgaWYgaSA8PSBqIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgICAgbF9zX2FyZWEgOj0gcy5hcmVhXG4gICAgICAgICAgICBqIDo9IGFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBpIDo9IHMuYXJlYV91cHBlciArIDFcbiAgICAgICAgICAgIG5iIDo9IHMuYXJlYV9sb3dlclxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgaSA9IG5iXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgICAgaiA6PSBqIC0gMVxuICAgICAgICAgICAgaWYgbF9hcmVhLml0ZW0gKGopIC89IGxfc19hcmVhLml0ZW0gKGkpIHRoZW5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICAgIGkgOj0gbmIgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKGNvdW50IC0gcy5jb3VudCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICB2YWxpZF9jb2RlICh2OiBOQVRVUkFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHYnIGEgdmFsaWQgY29kZSBmb3IgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID0gNCB0aGVuXG4gICAgICAgICAgLS0gQ2hlY2sgaWYgdGhpcyBpcyBgdHJ1ZV9jb25zdGFudCdcbiAgICAgICAgUmVzdWx0IDo9IGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbCAodHJ1ZV9jb25zdGFudClcbiAgICAgIGVsc2VpZiBuYiA9IDUgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYGZhbHNlX2NvbnN0YW50J1xuICAgICAgICBSZXN1bHQgOj0gaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsIChmYWxzZV9jb25zdGFudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYHR3aW4nLilcbiAgICBsb2NhbFxuICAgICAgb2xkX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb2xkX2FyZWEgOj0gYXJlYVxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgICAtLSBOb3RlOiA8PSBpcyBuZWVkZWQgYXMgYWxsIEVpZmZlbCBzdHJpbmcgc2hvdWxkIGhhdmUgYW5cbiAgICAgICAgICAtLSBleHRyYSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IG51bGwgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmIG9sZF9hcmVhID0gVm9pZCBvciBlbHNlIG9sZF9hcmVhID0gb3RoZXIuYXJlYSBvciBlbHNlIG9sZF9hcmVhLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgICAgIC0tIFByZXZlbnQgY29weWluZyBvZiBsYXJnZSBgYXJlYScgaWYgb25seSBhIGZldyBjaGFyYWN0ZXJzIGFyZSBhY3R1YWxseSB1c2VkLlxuICAgICAgICAgIGFyZWEgOj0gYXJlYS5yZXNpemVkX2FyZWEgKGNvdW50ICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9sZF9hcmVhLmNvcHlfZGF0YSAoYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgICAgYXJlYSA6PSBvbGRfYXJlYVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBuZXdfcmVzdWx0X2NvdW50OiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgICAtLSBzYW1lX2NoYXJhY3RlcnM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYG90aGVyJy5gaXRlbScgKGBpJylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmaWxsX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgY2hhcmFjdGVycyBhbGwgZXF1YWwgdG8gYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NhcDogbGlrZSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBsX2NhcCA6PSBjYXBhY2l0eVxuICAgICAgaWYgbF9jYXAgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NhcCAtIDEpXG4gICAgICAgIGNvdW50IDo9IGxfY2FwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogY291bnQgPSBjYXBhY2l0eVxuICAgICAgc2FtZV9zaXplOiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgLS0gYWxsX2NoYXI6IEZvciBldmVyeSBgaScgaW4gMS4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYGMnXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgUmVzdWx0Jy5gaXRlbScgKGBpJykgPSBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoYXNfc3RyaW5nXzgpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfaXRlbXM6IHNhbWVfdHlwZSAoXCJcIikgaW1wbGllcyBzYW1lX3N0cmluZ19nZW5lcmFsIChSZXN1bHQpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgc3RyaW5nX3NlYXJjaGVyOiBTVFJJTkdfMzJfU0VBUkNIRVJcbiAgICAgIC0tIFN0cmluZyBzZWFyY2hlciBzcGVjaWFsaXplZCBmb3IgUkVBREFCTEVfU1RSSU5HXzMyIGluc3RhbmNlc1xuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cl9zdHJpY3RfY21wICh0aGlzLCBvdGhlcjogbGlrZSBhcmVhOyB0aGlzX2luZGV4LCBvdGhlcl9pbmRleCwgbjogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENvbXBhcmUgYG4nIGNoYXJhY3RlcnMgZnJvbSBgdGhpcycgc3RhcnRpbmcgYXQgYHRoaXNfaW5kZXgnIHdpdGhcbiAgICAgIC0tIGBuJyBjaGFyYWN0ZXJzIGZyb20gYW5kIGBvdGhlcicgc3RhcnRpbmcgYXQgYG90aGVyX2luZGV4Jy5cbiAgICAgIC0tIDAgaWYgZXF1YWwsIDwgMCBpZiBgdGhpcycgPCBgb3RoZXInLFxuICAgICAgLS0gPiAwIGlmIGB0aGlzJyA+IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICB0aGlzX25vdF92b2lkOiB0aGlzIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX3ZhbGlkOiBuIDw9ICh0aGlzLnVwcGVyIC0gdGhpc19pbmRleCArIDEpIGFuZCBuIDw9IChvdGhlci51cHBlciAtIG90aGVyX2luZGV4ICsgMSlcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmIsIGxfY3VycmVudF9jb2RlLCBsX290aGVyX2NvZGU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHRoaXNfaW5kZXhcbiAgICAgICAgbmIgOj0gaSArIG5cbiAgICAgICAgaiA6PSBvdGhlcl9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY3VycmVudF9jb2RlIDo9IHRoaXMuaXRlbSAoaSkuY29kZVxuICAgICAgICBsX290aGVyX2NvZGUgOj0gb3RoZXIuaXRlbSAoaikuY29kZVxuICAgICAgICBpZiBsX2N1cnJlbnRfY29kZSAvPSBsX290aGVyX2NvZGUgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBsX2N1cnJlbnRfY29kZSAtIGxfb3RoZXJfY29kZVxuICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgICAgLS0gd2l0aCB0aGVpciBsb3dlciB2ZXJzaW9uIHdoZW4gYXZhaWxhYmxlLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogQ0hBUkFDVEVSXzMyXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgbG9vcFxuICAgICAgICBjMSA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGMyIDo9IGxfcHJvcC50b19sb3dlciAoYzEpXG4gICAgICAgICAgLS0gTGV0J3MgYXZvaWQgYSB3cml0ZSBhY2Nlc3MgaWYgbm90IG5lZWRlZC5cbiAgICAgICAgaWYgYzEgLz0gYzIgdGhlblxuICAgICAgICAgIGEucHV0IChjMiwgaSlcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX3VwcGVyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgdXBwZXIgdmVyc2lvbiB3aGVuIGF2YWlsYWJsZS5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBjMSwgYzI6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYzEgOj0gYS5pdGVtIChpKVxuICAgICAgICBjMiA6PSBsX3Byb3AudG9fdXBwZXIgKGMxKVxuICAgICAgICAgIC0tIExldCdzIGF2b2lkIGEgd3JpdGUgYWNjZXNzIGlmIG5vdCBuZWVkZWQuXG4gICAgICAgIGlmIGMxIC89IGMyIHRoZW5cbiAgICAgICAgICBhLnB1dCAoYzIsIGkpXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtaXJyb3JfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gTWlycm9yIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpIDw9IGpcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZVxuICB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMixcbiAgU1RSSU5HXzhfU0VBUkNIRVIsIFNUUklOR18zMl9TRUFSQ0hFUixcbiAgSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSLFxuICBTVFJJTkdfVE9fSU5URUdFUl9DT05WRVJUT1IsXG4gIFNUUklOR19UT19SRUFMX0NPTlZFUlRPUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzXG5cbiAgYXJlYV9sb3dlcjogSU5URUdFUlxuICAgICAgLS0gTWluaW11bSBpbmRleFxuICAgIGRvXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX2xvd2VyX25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICAgIGFyZWFfbG93ZXJfdmFsaWQ6IFJlc3VsdCA8PSBhcmVhLnVwcGVyXG4gICAgZW5kXG5cbiAgYXJlYV91cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV9sb3dlciArIGNvdW50IC0gMVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV91cHBlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICAgIGFyZWFfdXBwZXJfaW5fYm91bmQ6IGFyZWFfbG93ZXIgPD0gUmVzdWx0ICsgMVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgYXJlYV9ub3Rfdm9pZDogYXJlYSAvPSBWb2lkXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xNCAyMjoyMjowMiAtMDcwMCAoV2VkLCAxNCBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUwNjEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR184XG5cbmluaGVyaXRcbiAgUkVBREFCTEVfU1RSSU5HX0dFTkVSQUxcbiAgICByZW5hbWVcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwsXG4gICAgICBpdGVtIGFzIGNoYXJhY3Rlcl8zMl9pdGVtLFxuICAgICAgaGFzIGFzIGNoYXJhY3Rlcl8zMl9oYXMsXG4gICAgICBpbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfaW5kZXhfb2YsXG4gICAgICBsYXN0X2luZGV4X29mIGFzIGNoYXJhY3Rlcl8zMl9sYXN0X2luZGV4X29mLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgY2hhcmFjdGVyXzMyX29jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuICBSRUFEQUJMRV9JTkRFWEFCTEUgW0NIQVJBQ1RFUl84XVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9LFxuICBhc19yZWFkYWJsZV9zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzJ9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbiArIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGM6IENIQVJBQ1RFUl84OyBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlIHN0cmluZyBvZiBsZW5ndGggYG4nIGZpbGxlZCB3aXRoIGBjJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb3VudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgICBmaWxsX2NoYXJhY3RlciAoYylcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgICAgZmlsbGVkOiBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBpZiBDdXJyZW50IC89IHMgdGhlblxuICAgICAgICBjcmVhdGUgYXJlYS5tYWtlX2VtcHR5IChjb3VudCArIDEpXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgMCwgY291bnQgKyAxKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3Rfc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBDdXJyZW50IC89IHMgaW1wbGllcyBub3Qgc2hhcmVkX3dpdGggKHMpXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKCclLzAwMC8nLCBsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvX2NoYXJhY3Rlcl84X2FyZWEgKGFyZWEsIDEsIGxfY291bnQpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NfcG9pbnRlciAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBDcmVhdGUgbmV3IGluc3RhbmNlIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX2Zyb21fYycgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG1ha2VfZnJvbV9jIChjX3N0cmluZylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IGRldGFjaGFibGUgU1lTVEVNX1NUUklORylcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCB3aXRoIGBhX3N5c3RlbV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRm9yIGNvbnNpc3RlbmN5IHdpdGggVW5pY29kZSBzdHJpbmcgaGFuZGxpbmcsIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHNoYXJlZF93aXRoIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBzaGFyZSB0aGUgdGV4dCBvZiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKG90aGVyIC89IFZvaWQpIGFuZCB0aGVuIChhcmVhID0gb3RoZXIuYXJlYSlcbiAgICBlbmRcblxuICBpbmRleF9vZiAoYzogQ0hBUkFDVEVSXzg7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycgYXQgb3IgYWZ0ZXIgYHN0YXJ0X2luZGV4JztcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnRfaW5kZXggPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgaSwgbmIsIGxfbG93ZXJfYXJlYTogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgc3RhcnRfaW5kZXggPD0gbmIgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9sb3dlcl9hcmVhIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4IC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgbF9sb3dlcl9hcmVhXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iIG9yIGVsc2UgYS5pdGVtIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBhZGQgKzEgZHVlIHRvIHRoZSBhcmVhIHN0YXJ0aW5nIGF0IDAgYW5kIG5vdCBhdCAxXG4gICAgICAgICAgICAtLSBhbmQgc3Vic3RyYWN0IGBhcmVhX2xvd2VyJ1xuICAgICAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIChzdGFydF9pbmRleCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBjb3VudClcbiAgICAgIHplcm9faWZfYWJzZW50OiAoUmVzdWx0ID0gMCkgPSBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXMgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYmVmb3JlOiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBSZXN1bHQgLSAxKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZiAoYzogQ0hBUkFDVEVSXzg7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJyxcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kIC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCBsX2xvd2VyX2FyZWEgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMS5cbiAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9hZnRlcjogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4X2luX2JvdW5kcyAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICBlbmRcblxuICBzdHJpbmc6IFNUUklOR184XG4gICAgICAtLSBOZXcgU1RSSU5HXzggaGF2aW5nIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3RyaW5nX3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzh9Lm1ha2VfZW1wdHkpXG4gICAgICBmaXJzdF9pdGVtOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKVxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuc3RyaW5nXG4gICAgZW5kXG5cbiAgc3RyaW5nX3JlcHJlc2VudGF0aW9uOiBTVFJJTkdfOFxuICAgICAgLS0gU2ltaWxhciB0byBgc3RyaW5nJyBidXQgb25seSBjcmVhdGUgYSBuZXcgb2JqZWN0IGlmIGBDdXJyZW50JyBpcyBub3Qgb2YgZHluYW1pYyB0eXBlIHtTVFJJTkdfOH1cbiAgICBkb1xuICAgICAgaWYgc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KSBhbmQgdGhlbiBhdHRhY2hlZCB7U1RSSU5HXzh9IEN1cnJlbnQgYXMgbF9zOCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3M4XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdHJpbmdcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgY29ycmVjdF90eXBlOiBSZXN1bHQuc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnRfaW5kZXgsIGNvdW50KVxuICAgIGVuZFxuXG4gIGZ1enp5X2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0OiBJTlRFR0VSOyBmdXp6OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5mdXp6eV9pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0LCBjb3VudCwgZnV6eilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBBbGxvY2F0ZWQgc3BhY2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuY291bnQgLSAxXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIEFjdHVhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBtYWtpbmcgdXAgdGhlIHN0cmluZ1xuXG4gIG9jY3VycmVuY2VzIChjOiBDSEFSQUNURVJfOCk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgKyBpXG4gICAgICAgIGEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIGEuaXRlbSAoaSkgPSBjIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHplcm9faWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIFJlc3VsdCA9IDBcbiAgICAgIHJlY3Vyc2VfaWZfbm90X2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICAgIHJlY3Vyc2VfaWZfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gMSArIHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSwgY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGluZGV4X3NldF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGluZGV4X3NldF9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2hhc2gsIGxfb3RoZXJfaGFzaDogbGlrZSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBMZXQncyBjb21wYXJlIHRoZSBjb250ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBoYXNoX2NvZGUgYXJlIHRoZSBzYW1lIG9yIG5vdCB5ZXQgY29tcHV0ZWQuXG4gICAgICAgICAgbF9oYXNoIDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgICAgIGxfb3RoZXJfaGFzaCA6PSBvdGhlci5pbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBpZiBsX2hhc2ggPSAwIG9yIGVsc2UgbF9vdGhlcl9oYXNoID0gMCBvciBlbHNlIGxfaGFzaCA9IGxfb3RoZXJfaGFzaCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBuYilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInIHJlZ2FyZGxlc3Mgb2YgY2FzaW5nXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChDdXJyZW50KVxuICAgICAgY29uc2lzdGVudDogYXR0YWNoZWQge2xpa2UgQ3VycmVudH0gb3RoZXIgYXMgbF9vdGhlciBpbXBsaWVzIChzdGFuZGFyZF9pc19lcXVhbCAobF9vdGhlcikgaW1wbGllcyBSZXN1bHQpXG4gICAgICB2YWxpZF9yZXN1bHQ6IGFzX2xvd2VyIH4gb3RoZXIuYXNfbG93ZXIgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9vdGhlcl9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGMxLGMyOiBDSEFSQUNURVJcbiAgICBkb1xuICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGlmIG5iIDw9IGNvdW50IC0gaW5kZXhfcG9zICsgMSB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfb3RoZXJfYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxXG4gICAgICAgICAgaiA6PSBvdGhlci5hcmVhX2xvd2VyICsgc3RhcnRfcG9zIC0gMVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgYzEgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgYzIgOj0gbF9vdGhlcl9hcmVhLml0ZW0gKGopXG4gICAgICAgICAgaWYgYzEgLz0gYzIgYW5kIHRoZW4gYzEuYXNfbG93ZXIgLz0gYzIuYXNfbG93ZXIgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBpIDo9IG5iIC0gMSAtLSBKdW1wIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpbmNyZWFzaW5nX2luZGV4OiBsX2FyZWEudXBwZXIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEbyBgQ3VycmVudCcgYW5kIGBvdGhlcicgaGF2ZSBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZT9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoc3RyaW5nIH4gb3RoZXIuc3RyaW5nKVxuICAgIGVuZFxuXG4gIHNhbWVfY2hhcmFjdGVycyAob3RoZXI6IFJFQURBQkxFX1NUUklOR184OyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDEsIGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxLCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3Bvcykuc2FtZV9zdHJpbmcgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIGxleGljb2dyYXBoaWNhbGx5IGxvd2VyIHRoYW4gYG90aGVyJz9cbiAgICBsb2NhbFxuICAgICAgb3RoZXJfY291bnQ6IElOVEVHRVJcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIG90aGVyX2NvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgICAgaWYgb3RoZXJfY291bnQgPSBjdXJyZW50X2NvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGN1cnJlbnRfY291bnQgPCBvdGhlcl9jb3VudCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIGN1cnJlbnRfY291bnQpID49IDBcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3ZhbGlkX2FzX3N0cmluZ184OiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICAgIG4gOj0gYXJlYV9sb3dlciArIGVuZF9pbmRleCAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuIG9yIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gaSA+IG5cbiAgICBlbmRcblxuICBoYXMgKGM6IENIQVJBQ1RFUl84KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgaW5jbHVkZSBgYyc/XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iIG9yIGVsc2UgKGxfYXJlYS5pdGVtIChpKSA9IGMpXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gKGkgPCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmFsc2VfaWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIG5vdCBSZXN1bHRcbiAgICAgIHRydWVfaWZfZmlyc3Q6IGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzIChjKSlcbiAgICBlbmRcblxuICBzdGFydHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBiZWdpbiB3aXRoIGBzJz9cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfc19hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA9IHMgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBpIDo9IHMuY291bnRcbiAgICAgICAgaWYgaSA8PSBjb3VudCB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX2xvd2VyICsgaVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBzLmNvdW50KSlcbiAgICBlbmRcblxuICBlbmRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgZmluaXNoIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9zX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBqIDo9IGNvdW50XG4gICAgICAgIGlmIGkgPD0gaiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChjb3VudCAtIHMuY291bnQgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgdmFsaWRfY29kZSAodjogTkFUVVJBTF8zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB2JyBhIHZhbGlkIGNvZGUgZm9yIGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdiA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA9IDQgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYHRydWVfY29uc3RhbnQnXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpLmxvd2VyID0gJ3QnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAxKS5sb3dlciA9ICdyJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMikubG93ZXIgPSAndScgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDMpLmxvd2VyID0gJ2UnXG4gICAgICBlbHNlaWYgbmIgPSA1IHRoZW5cbiAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIGlzIGBmYWxzZV9jb25zdGFudCdcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkubG93ZXIgPSAnZicgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDEpLmxvd2VyID0gJ2EnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAyKS5sb3dlciA9ICdsJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMykubG93ZXIgPSAncycgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDQpLmxvd2VyID0gJ2UnXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HXzh9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYHR3aW4nLilcbiAgICBsb2NhbFxuICAgICAgb2xkX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb2xkX2FyZWEgOj0gYXJlYVxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgICAtLSBOb3RlOiA8PSBpcyBuZWVkZWQgYXMgYWxsIEVpZmZlbCBzdHJpbmcgc2hvdWxkIGhhdmUgYW5cbiAgICAgICAgICAtLSBleHRyYSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IG51bGwgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmIG9sZF9hcmVhID0gVm9pZCBvciBlbHNlIG9sZF9hcmVhID0gb3RoZXIuYXJlYSBvciBlbHNlIG9sZF9hcmVhLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgICAgIC0tIFByZXZlbnQgY29weWluZyBvZiBsYXJnZSBgYXJlYScgaWYgb25seSBhIGZldyBjaGFyYWN0ZXJzIGFyZSBhY3R1YWxseSB1c2VkLlxuICAgICAgICAgIGFyZWEgOj0gYXJlYS5yZXNpemVkX2FyZWEgKGNvdW50ICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9sZF9hcmVhLmNvcHlfZGF0YSAoYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgICAgYXJlYSA6PSBvbGRfYXJlYVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBuZXdfcmVzdWx0X2NvdW50OiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgICAtLSBzYW1lX2NoYXJhY3RlcnM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYG90aGVyJy5gaXRlbScgKGBpJylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmaWxsX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBGaWxsIHdpdGggYGNhcGFjaXR5JyBjaGFyYWN0ZXJzIGFsbCBlcXVhbCB0byBgYycuXG4gICAgbG9jYWxcbiAgICAgIGxfY2FwOiBsaWtlIGNhcGFjaXR5XG4gICAgZG9cbiAgICAgIGxfY2FwIDo9IGNhcGFjaXR5XG4gICAgICBpZiBsX2NhcCAvPSAwIHRoZW5cbiAgICAgICAgYXJlYS5maWxsX3dpdGggKGMsIDAsIGxfY2FwIC0gMSlcbiAgICAgICAgY291bnQgOj0gbF9jYXBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmlsbGVkOiBjb3VudCA9IGNhcGFjaXR5XG4gICAgICBzYW1lX3NpemU6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICAtLSBhbGxfY2hhcjogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgYydcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBSZXN1bHQnLmBpdGVtJyAoYGknKSA9IGBpdGVtJyAoYGNvdW50JysxLWBpJylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBvdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2l0ZW1zOiBzYW1lX3R5cGUgKFwiXCIpIGltcGxpZXMgUmVzdWx0LnNhbWVfc3RyaW5nIChDdXJyZW50KVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cmluZ19zZWFyY2hlcjogU1RSSU5HXzhfU0VBUkNIRVJcbiAgICAgIC0tIFN0cmluZyBzZWFyY2hlciBzcGVjaWFsaXplZCBmb3IgUkVBREFCTEVfU1RSSU5HXzggaW5zdGFuY2VzXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlXG4gICAgZW5kXG5cbiAgc3RyX3N0cmljdF9jbXAgKHRoaXMsIG90aGVyOiBsaWtlIGFyZWE7IHRoaXNfaW5kZXgsIG90aGVyX2luZGV4LCBuOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQ29tcGFyZSBgbicgY2hhcmFjdGVycyBmcm9tIGB0aGlzJyBzdGFydGluZyBhdCBgdGhpc19pbmRleCcgd2l0aFxuICAgICAgLS0gYG4nIGNoYXJhY3RlcnMgZnJvbSBhbmQgYG90aGVyJyBzdGFydGluZyBhdCBgb3RoZXJfaW5kZXgnLlxuICAgICAgLS0gMCBpZiBlcXVhbCwgPCAwIGlmIGB0aGlzJyA8IGBvdGhlcicsXG4gICAgICAtLSA+IDAgaWYgYHRoaXMnID4gYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIHRoaXNfbm90X3ZvaWQ6IHRoaXMgLz0gVm9pZFxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fdmFsaWQ6IG4gPD0gKHRoaXMudXBwZXIgLSB0aGlzX2luZGV4ICsgMSkgYW5kIG4gPD0gKG90aGVyLnVwcGVyIC0gb3RoZXJfaW5kZXggKyAxKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYiwgbF9jdXJyZW50X2NvZGUsIGxfb3RoZXJfY29kZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gdGhpc19pbmRleFxuICAgICAgICBuYiA6PSBpICsgblxuICAgICAgICBqIDo9IG90aGVyX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgbF9jdXJyZW50X2NvZGUgOj0gdGhpcy5pdGVtIChpKS5jb2RlXG4gICAgICAgIGxfb3RoZXJfY29kZSA6PSBvdGhlci5pdGVtIChqKS5jb2RlXG4gICAgICAgIGlmIGxfY3VycmVudF9jb2RlIC89IGxfb3RoZXJfY29kZSB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IGxfY3VycmVudF9jb2RlIC0gbF9vdGhlcl9jb2RlXG4gICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlcl9hcmVhIChhOiBsaWtlIGFyZWE7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgICAtLSB3aXRoIHRoZWlyIGxvd2VyIHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgYV9ub3Rfdm9pZDogYSAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGEuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYS5wdXQgKGEuaXRlbSAoaSkubG93ZXIsIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX3VwcGVyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgdXBwZXIgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgbG9vcFxuICAgICAgICBhLnB1dCAoYS5pdGVtIChpKS51cHBlciwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIE1pcnJvciBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBjOiBDSEFSQUNURVJfOFxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpIDw9IGpcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZVxuICB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMixcbiAgU1RSSU5HXzhfU0VBUkNIRVIsIFNUUklOR18zMl9TRUFSQ0hFUixcbiAgSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSLFxuICBTVFJJTkdfVE9fSU5URUdFUl9DT05WRVJUT1IsXG4gIFNUUklOR19UT19SRUFMX0NPTlZFUlRPUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnNcblxuICBhcmVhX2xvd2VyOiBJTlRFR0VSXG4gICAgICAtLSBNaW5pbXVtIGluZGV4XG4gICAgZG9cbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfbG93ZXJfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgICAgYXJlYV9sb3dlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICBlbmRcblxuICBhcmVhX3VwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBNYXhpbXVtIGluZGV4XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX2xvd2VyICsgY291bnQgLSAxXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX3VwcGVyX3ZhbGlkOiBSZXN1bHQgPD0gYXJlYS51cHBlclxuICAgICAgYXJlYV91cHBlcl9pbl9ib3VuZDogYXJlYV9sb3dlciA8PSBSZXN1bHQgKyAxXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBhcmVhX25vdF92b2lkOiBhcmVhIC89IFZvaWRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkNvbW1vbiBhbmNlc3RvcnMgdG8gYWxsIFNUUklORyBjbGFzc2VzLiBSZWFkLW9ubHkgaW50ZXJmYWNlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wMy0xOSAwNjoyNzowMSAtMDcwMCAoV2VkLCAxOSBNYXIgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTQ2MzAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG5cbmluaGVyaXRcbiAgQ09NUEFSQUJMRVxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuICBTVFJJTkdfSEFORExFUlxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlIChuOiBJTlRFR0VSKVxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nOiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbiAgbWFrZV9lbXB0eVxuICAgICAgLS0gQ3JlYXRlIGVtcHR5IHN0cmluZy5cbiAgICBkb1xuICAgICAgbWFrZSAoMClcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5OiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvZGUgYXQgcG9zaXRpb24gYGknXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IGxpa2UgaXRlbTsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X2xhcmdlX2Vub3VnaDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgc3RhcnRfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSBpdGVtIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPD0gbmIgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCA9IDAgb3IgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50KVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKVxuICAgICAgZm91bmRfaWZfcHJlc2VudDogc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9iZWZvcmU6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXNcbiAgICAgICAgbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIFJlc3VsdCAtIDEpLmhhcyAoYylcbiAgICBlbmRcblxuICBsYXN0X2luZGV4X29mIChjOiBsaWtlIGl0ZW07IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfaW5kZXhfZnJvbV9lbmRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2UgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9hZnRlcjogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2ZfY29kZSAoYzogbGlrZSBjb2RlOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnIGF0IG9yIGFmdGVyIGBzdGFydF9pbmRleCc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBzdGFydF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4IDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgc3RhcnRfaW5kZXggPD0gbmIgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBlbHNlIGNvZGUgKGkpID0gY1xuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgaSA8PSBuYiB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IGlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0ID0gMCBvciAoc3RhcnRfaW5kZXggPD0gUmVzdWx0IGFuZCBSZXN1bHQgPD0gY291bnQpXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYykgaW1wbGllcyBjb2RlIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9iZWZvcmU6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0IC0gMSkuaGFzX2NvZGUgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZl9jb2RlIChjOiBsaWtlIGNvZGU7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfaW5kZXhfZnJvbV9lbmRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2UgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKVxuICAgICAgZm91bmRfaWZfcHJlc2VudDogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzX2NvZGUgKGMpIGltcGxpZXMgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYWZ0ZXI6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXNfY29kZSAoYylcbiAgICBlbmRcblxuICBmYWxzZV9jb25zdGFudDogU1RSSU5HXzggPSBcImZhbHNlXCJcbiAgICAgIC0tIENvbnN0YW50IHN0cmluZyBcImZhbHNlXCJcblxuICB0cnVlX2NvbnN0YW50OiBTVFJJTkdfOCA9IFwidHJ1ZVwiXG4gICAgICAtLSBDb25zdGFudCBzdHJpbmcgXCJ0cnVlXCJcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgICBpZiBSZXN1bHQgPSAwIHRoZW5cbiAgICAgICAgICAtLSBUaGUgbWFnaWMgbnVtYmVyIGA4Mzg4NTkzJyBiZWxvdyBpcyB0aGUgZ3JlYXRlc3QgcHJpbWUgbG93ZXIgdGhhblxuICAgICAgICAgIC0tIDJeMjMgc28gdGhhdCB0aGlzIG1hZ2ljIG51bWJlciBzaGlmdGVkIHRvIHRoZSBsZWZ0IGRvZXMgbm90IGV4Y2VlZCAyXjMxLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSAoKFJlc3VsdCBcXFxcIDgzODg1OTMpIHw8PCA4KSArIGl0ZW0gKGkpLmNvZGVcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gUmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjYXNlX2luc2Vuc2l0aXZlX2hhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlIG9mIHRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYEN1cnJlbnQnLlxuICAgIGxvY2FsXG4gICAgICBsX3Byb3BzOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGVcbiAgICAgIGlmIFJlc3VsdCA9IDAgdGhlblxuICAgICAgICAgIC0tIFRoZSBtYWdpYyBudW1iZXIgYDgzODg1OTMnIGJlbG93IGlzIHRoZSBncmVhdGVzdCBwcmltZSBsb3dlciB0aGFuXG4gICAgICAgICAgLS0gMl4yMyBzbyB0aGF0IHRoaXMgbWFnaWMgbnVtYmVyIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgZG9lcyBub3QgZXhjZWVkIDJeMzEuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICAgIGxfcHJvcHMgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSAoKFJlc3VsdCBcXFxcIDgzODg1OTMpIHw8PCA4KSArIGxfcHJvcHMudG9fbG93ZXIgKGl0ZW0gKGkpKS5jb2RlXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGUgOj0gUmVzdWx0XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvbnNpc3RlbnQ6IFJlc3VsdCA9IGFzX2xvd2VyLmhhc2hfY29kZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19pbW11dGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIENhbiB0aGUgY2hhcmFjdGVyIHNlcXVlbmNlIG9mIGBDdXJyZW50JyBiZSBub3QgY2hhbmdlZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHN0cmluZz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpID4gMCkgYW5kIChpIDw9IGNvdW50KVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKDEgPD0gaSBhbmQgaSA8PSBjb3VudClcbiAgICBlbmRcblxuICB2YWxpZF9jb2RlICh2OiBsaWtlIGNvZGUpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdicgYSB2YWxpZCBjb2RlIGZvciBDdXJyZW50P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhIHNlcXVlbmNlIG9mIENIQVJBQ1RFUl84P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfc3RyaW5nXzMyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgQ3VycmVudCcgYSBzZXF1ZW5jZSBvZiBDSEFSQUNURVJfMzI/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc192YWxpZF9hc19zdHJpbmdfODogQk9PTEVBTlxuICAgICAgLS0gSXMgYEN1cnJlbnQnIGNvbnZlcnRpYmxlIHRvIGEgc2VxdWVuY2Ugb2YgQ0hBUkFDVEVSXzggd2l0aG91dCBpbmZvcm1hdGlvbiBsb3NzP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfZW1wdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBlbXB0eT9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX3doaXRlc3BhY2U6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIGNvdW50KVxuICAgIGVuZFxuXG4gIGlzX3N1YnN0cmluZ193aGl0ZXNwYWNlIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3Vic3RyaW5nIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycz9cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9iaWdfZW5vdWdoOiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICBlbmRfaW5kZXhfc21hbGxfZW5vdWdoOiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIGNvbnNpc3RlbnRfaW5kZXhlczogc3RhcnRfaW5kZXggLSAxIDw9IGVuZF9pbmRleFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaGFzIChjOiBsaWtlIGl0ZW0pOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBpbmNsdWRlIGBjJz9cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSAoaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDw9IG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGZhbHNlX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2ZpcnN0OiBjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjIGltcGxpZXMgUmVzdWx0XG4gICAgICByZWN1cnNlOiAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgKFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLmhhcyAoYykpXG4gICAgZW5kXG5cbiAgaGFzX2NvZGUgKGM6IGxpa2UgY29kZSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBlbHNlIChjb2RlIChpKSA9IGMpXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gKGkgPD0gbmIpXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZmFsc2VfaWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIG5vdCBSZXN1bHRcbiAgICAgIHRydWVfaWZfZmlyc3Q6IGNvdW50ID4gMCBhbmQgdGhlbiBjb2RlICgxKSA9IGMgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+IDAgYW5kIHRoZW4gY29kZSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzX2NvZGUgKGMpKVxuICAgIGVuZFxuXG4gIGlzX251bWJlcl9zZXF1ZW5jZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgbnVtYmVyIHNlcXVlbmNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgIGVuc3VyZVxuICAgICAgc3ludGF4X2FuZF9yYW5nZTpcbiAgICAgICAgLS0gUmVzdWx0IGlzIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gIEN1cnJlbnQgY2FuIGJlIHByb2R1Y2VkIGJ5IFwiSW50ZWdlcl9saXRlcmFsXCI6XG4gICAgICAgIC0tXG4gICAgICAgIC0tIEludGVnZXJfbGl0ZXJhbCA9IFtTcGFjZV0gW1NpZ25dIEludGVnZXIgW1NwYWNlXVxuICAgICAgICAtLSBTcGFjZSAgPSBcIiBcIiB8IFwiIFwiIFNwYWNlXG4gICAgICAgIC0tIFNpZ24gICA9IFwiK1wiIHwgXCItXCJcbiAgICAgICAgLS0gSW50ZWdlciAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgID0gXCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJcbiAgICBlbmRcblxuICBpc19yZWFsX3NlcXVlbmNlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSByZWFsIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9yX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9yX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9kb3VibGVcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgIGVuZFxuXG4gIGlzX3JlYWwsIGlzX3JlYWxfMzI6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIFJFQUxfMzI/XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b3JfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b3JfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9yZWFsKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLmlzX2ludGVncmFsX3JlYWxcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSAxLiBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgICAgICAtLSAyLiBUaGUgbnVtZXJpY2FsIHZhbHVlIHJlcHJlc2VudGVkIGJ5ICdDdXJyZW50J1xuICAgICAgICAtLSAgaXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZFxuICAgICAgICAtLSAgYnkgYW4gaW5zdGFuY2Ugb2YgdHlwZSBSRUFMLlxuICAgIGVuZFxuXG4gIGlzX2RvdWJsZSwgaXNfcmVhbF82NDogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgUkVBTF82ND9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2RvdWJsZSlcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9kb3VibGVcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSAxLiBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgICAgICAtLSAyLiBUaGUgbnVtZXJpY2FsIHZhbHVlIHJlcHJlc2VudGVkIGJ5ICdDdXJyZW50J1xuICAgICAgICAtLSAgaXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZFxuICAgICAgICAtLSAgYnkgYW4gaW5zdGFuY2Ugb2YgdHlwZSBET1VCTEUuXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaXNfYm9vbGVhbjogUmVzdWx0ID0gKHRydWVfY29uc3RhbnQuc2FtZV9zdHJpbmdfZ2VuZXJhbCAoYXNfbG93ZXIpIG9yXG4gICAgICAgIGZhbHNlX2NvbnN0YW50LnNhbWVfc3RyaW5nX2dlbmVyYWwgKGFzX2xvd2VyKSlcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzg6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhbiBJTlRFR0VSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2ludGVnZXJfOClcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzE2OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl8xNj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl8xNilcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyLCBpc19pbnRlZ2VyXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl8zMilcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzY0OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl82ND9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl82NClcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzg6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF84KVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfMTY6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfMTY/XG5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF8xNilcbiAgICBlbmRcblxuICBpc19uYXR1cmFsLCBpc19uYXR1cmFsXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBOQVRVUkFMXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9uYXR1cmFsXzMyKVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfNjQ6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfNjQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gQ3VycmVudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBjaGFyYWN0ZXJzIGFsbG9jYXRlZCBpbiBDdXJyZW50XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBvY2N1cnJlbmNlcyAoYzogQ0hBUkFDVEVSXzMyKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGBjJyBhcHBlYXJzIGluIHRoZSBzdHJpbmdcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgemVyb19pZl9lbXB0eTogY291bnQgPSAwIGltcGxpZXMgUmVzdWx0ID0gMFxuICAgICAgcmVjdXJzZV9pZl9ub3RfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgICAgcmVjdXJzZV9pZl9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSAxICsgc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cmluZyBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcicgcmVnYXJkbGVzcyBvZiBjYXNpbmdcbiAgICAgIC0tIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChDdXJyZW50KVxuICAgICAgY29uc2lzdGVudDogYXR0YWNoZWQge2xpa2UgQ3VycmVudH0gb3RoZXIgYXMgbF9vdGhlciBpbXBsaWVzIChzdGFuZGFyZF9pc19lcXVhbCAobF9vdGhlcikgaW1wbGllcyBSZXN1bHQpXG4gICAgICB2YWxpZF9yZXN1bHQ6IGFzX2xvd2VyIH4gb3RoZXIuYXNfbG93ZXIgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgYzEsYzI6IGxpa2UgaXRlbVxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBpbmRleF9wb3NcbiAgICAgICAgICBqIDo9IHN0YXJ0X3Bvc1xuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgYzEgOj0gaXRlbSAoaSlcbiAgICAgICAgICBjMiA6PSBvdGhlci5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGxfcHJvcC50b19sb3dlciAoYzEpIC89IGxfcHJvcC50b19sb3dlciAoYzIpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbmIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGhhc19zdWJzdHJpbmcgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIGNvbnRhaW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZWlmIG90aGVyLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHN1YnN0cmluZ19pbmRleCAob3RoZXIsIDEpID4gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBmYWxzZV9pZl90b29fc21hbGw6IGNvdW50IDwgb3RoZXIuY291bnQgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2luaXRpYWw6IChjb3VudCA+PSBvdGhlci5jb3VudCBhbmQgdGhlblxuICAgICAgICBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBvdGhlci5jb3VudCkpKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgcmVjdXJzZTogKGNvdW50ID49IG90aGVyLmNvdW50IGFuZCB0aGVuXG4gICAgICAgIG5vdCBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBvdGhlci5jb3VudCkpKSBpbXBsaWVzXG4gICAgICAgIChSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5oYXNfc3Vic3RyaW5nIChvdGhlcikpXG4gICAgZW5kXG5cbiAgc2FtZV9zdHJpbmcgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYG90aGVyJyByZXByZXNlbnQgdGhlIHNhbWUgc3RyaW5nIGFzIGBDdXJyZW50Jz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2FtZV9jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICBpIDo9IGluZGV4X3Bvc1xuICAgICAgICAgIGogOj0gc3RhcnRfcG9zXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSAvPSBvdGhlci5pdGVtIChqKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGluY3JlYXNpbmdfaW5kZXg6IG5iIC0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLnNhbWVfc3RyaW5nIChvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykpXG4gICAgZW5kXG5cbiAgc3RhcnRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSAwXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaWYgY29kZSAoaSkgLz0gcy5jb2RlIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKDEsIHMuY291bnQpKVxuICAgIGVuZFxuXG4gIGVuZHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBmaW5pc2ggd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGogOj0gY291bnRcbiAgICAgICAgaWYgaSA8PSBqIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGlmIGNvZGUoaikgLz0gcy5jb2RlIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKGNvdW50IC0gcy5jb3VudCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXhfaW5fYm91bmRzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYG90aGVyJyBhdCBvciBhZnRlciBgc3RhcnRfcG9zJ1xuICAgICAgLS0gYW5kIHRvIG9yIGJlZm9yZSBgZW5kX3Bvcyc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm9udm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgb3RoZXJfbm90ZW1wdHk6IG5vdCBvdGhlci5pc19lbXB0eVxuICAgICAgc3RhcnRfcG9zX2xhcmdlX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIHN0YXJ0X3Bvc19zbWFsbF9lbm91Z2g6IHN0YXJ0X3BvcyA8PSBjb3VudFxuICAgICAgZW5kX3Bvc19sYXJnZV9lbm91Z2g6IGVuZF9wb3MgPj0gc3RhcnRfcG9zXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3JyZWN0X3BsYWNlOiBSZXN1bHQgPiAwIGltcGxpZXMgb3RoZXIuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoUmVzdWx0LCBSZXN1bHQgKyBvdGhlci5jb3VudCAtIDEpKVxuICAgICAgLS0gZm9yYWxsIHggOiBzdGFydF9wb3MuLlJlc3VsdFxuICAgICAgLS0gIG5vdCBzdWJzdHJpbmcgKHgsIHgrb3RoZXIuY291bnQgLTEpLmlzX2VxdWFsIChvdGhlcilcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIG90aGVyIGF0IG9yIGFmdGVyIHN0YXJ0X2luZGV4O1xuICAgICAgLS0gMCBpZiBub25lXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiBzdGFydF9pbmRleCA+PSAxIGFuZCBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIGVsc2VcbiAgICAgICAgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50IC0gb3RoZXIuY291bnQgKyAxKVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9XG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzX3N1YnN0cmluZyAob3RoZXIpXG4gICAgICBhdF90aGlzX2luZGV4OiBSZXN1bHQgPj0gc3RhcnRfaW5kZXggaW1wbGllc1xuICAgICAgICBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChSZXN1bHQsIFJlc3VsdCArIG90aGVyLmNvdW50IC0gMSkpXG4gICAgICBub25lX2JlZm9yZTogUmVzdWx0ID4gc3RhcnRfaW5kZXggaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0ICsgb3RoZXIuY291bnQgLSAyKS5oYXNfc3Vic3RyaW5nIChvdGhlcilcbiAgICBlbmRcblxuICBmdXp6eV9pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydDogSU5URUdFUjsgZnV6ejogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYG90aGVyJyBhdCBvciBhZnRlciBgc3RhcnQnXG4gICAgICAtLSB3aXRoIDAuLmBmdXp6JyBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIHN0cmluZyBhbmQgYG90aGVyJy5cbiAgICAgIC0tIDAgaWYgdGhlcmUgYXJlIG5vIGZ1enp5IG1hdGNoZXNcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF9lbXB0eTogbm90IG90aGVyLmlzX2VtcHR5XG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnQgPD0gY291bnRcbiAgICAgIGFjY2VwdGFibGVfZnV6enk6IGZ1enogPD0gb3RoZXIuY291bnRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBmcm96ZW4gdG9fY2lsOiBTWVNURU1fU1RSSU5HXG4gICAgICAtLSBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgU1lTVEVNX1NUUklORyB1c2luZyBjaGFyYWN0ZXJzXG4gICAgICAtLSBvZiBDdXJyZW50IGJldHdlZW4gaW5kaWNlcyBgMScgYW5kIGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZG90bmV0X2NvbnZlcnRvci5mcm9tX3N0cmluZ190b19zeXN0ZW1fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3N0cmluZ184OiBTVFJJTkdfOFxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfOC5cbiAgICByZXF1aXJlXG4gICAgICBpc192YWxpZF9hc19zdHJpbmdfODogaXNfdmFsaWRfYXNfc3RyaW5nXzhcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX3N0cmluZ184XG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfOF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGlkZW50aXR5OiAoY29uZm9ybXNfdG8gKFwiXCIpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzhfY29udmVyc2lvbjogU1RSSU5HXzhcbiAgICAgIC0tIEVxdWl2YWxlbnQgdG8gYGFzX3N0cmluZ184JyB3aXRoIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAtLSBUbyBiZSB1c2VkIGZvciBtaWdyYXRpbmcgZXhpc3RpbmcgY29kZSB0byBVbmljb2RlXG4gICAgICAtLSB3aGVuIHlvdSBnZXQgYSBjb21waWxlciBlcnJvciBidXQgY2Fubm90IG9yIGRvIG5vdCBoYXZlXG4gICAgICAtLSB0aGUgdGltZSB5ZXQgdG8gYWRkcmVzcyB0aGUgdGFyZ2V0IHJlY2lwaWVudCBvZiB0aGUgc3RyaW5nIHRvIGJlXG4gICAgICAtLSBhIFJFQURBQkxFX1NUUklOR18zMiBvciBkZXNjZW5kYW50cy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVcGRhdGUgcmVjaXBpZW50IG9mIGNhbGwgdG8gdXNlIFJFQURBQkxFX1NUUklOR18zMiBhbmQgZGVzY2VuZGFudHMgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfc3RyaW5nXzhcbiAgICBlbmRcblxuICBhc19yZWFkYWJsZV9zdHJpbmdfODogUkVBREFCTEVfU1RSSU5HXzhcbiAgICAgIC0tXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGV4cGxpY2l0IGNvbnZlcnNpb24gYHRvX3N0cmluZ184JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfOFxuICAgIGVuZFxuXG4gIGFzX3N0cmluZ184OiBTVFJJTkdfOFxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfOC4gSWYgYSBjb2RlIG9mIGBDdXJyZW50JyBpc1xuICAgICAgLS0gbm90IGEgdmFsaWQgY29kZSBmb3IgYSBTVFJJTkdfOCBpdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBudWxsXG4gICAgICAtLSBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvZGU6IGxpa2UgY29kZVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7U1RSSU5HXzh9IEN1cnJlbnQgYXMgbF9yZXN1bHQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9yZXN1bHRcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuYilcbiAgICAgICAgUmVzdWx0LnNldF9jb3VudCAobmIpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfY29kZSA6PSBjb2RlIChpKVxuICAgICAgICAgIGlmIFJlc3VsdC52YWxpZF9jb2RlIChsX2NvZGUpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAobF9jb2RlLCBpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAoMCwgaSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfOF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGlkZW50aXR5OiAoY29uZm9ybXNfdG8gKFwiXCIpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzMyX2NvbnZlcnNpb246IFNUUklOR18zMlxuICAgICAgLS0gRXF1aXZhbGVudCB0byBgYXNfc3RyaW5nXzMyJyB3aXRoIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAtLSBUbyBiZSB1c2VkIGZvciBtaWdyYXRpbmcgZXhpc3RpbmcgY29kZSB0byBVbmljb2RlXG4gICAgICAtLSB3aGVuIHlvdSBnZXQgYSBjb21waWxlciBlcnJvciBidXQgY2Fubm90IG9yIGRvIG5vdCBoYXZlXG4gICAgICAtLSB0aGUgdGltZSB5ZXQgdG8gYWRkcmVzcyB0aGUgc291cmNlIG9mIHRoZSBzdHJpbmcgdG8gYmVcbiAgICAgIC0tIGEgUkVBREFCTEVfU1RSSU5HXzMyIG9yIGRlc2NlbmRhbnRzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVwZGF0ZSB0YXJnZXQgb2YgY2FsbCB0byB1c2UgUkVBREFCTEVfU1RSSU5HXzMyIGFuZCBkZXNjZW5kYW50cyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfMzJcbiAgICBlbmRcblxuICBhc19yZWFkYWJsZV9zdHJpbmdfMzI6IFJFQURBQkxFX1NUUklOR18zMlxuICAgICAgLS1cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgZXhwbGljaXQgY29udmVyc2lvbiBgdG9fc3RyaW5nXzMyJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfMzJcbiAgICBlbmRcblxuICBhc19zdHJpbmdfMzIsIHRvX3N0cmluZ18zMjogU1RSSU5HXzMyXG4gICAgICAtLSBDb252ZXJ0IGBDdXJyZW50JyBhcyBhIFNUUklOR18zMi5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1NUUklOR18zMn0gQ3VycmVudCBhcyBsX3Jlc3VsdCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3Jlc3VsdFxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG5iKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChuYilcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgUmVzdWx0LnB1dF9jb2RlIChjb2RlIChpKSwgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfMzJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpZGVudGl0eTogKGNvbmZvcm1zX3RvIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIFJlc3VsdCA9IEN1cnJlbnQpIG9yIChub3QgY29uZm9ybXNfdG8gKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGFzX2xvd2VyX2F0dGFjaGVkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbGVuZ3RoOiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgYW5jaG9yOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKS5hc19sb3dlclxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuYXNfbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBhc191cHBlcl9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGxlbmd0aDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIGFuY2hvcjogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSkuYXNfdXBwZXJcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLmFzX3VwcGVyXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIDgtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzg6IGlzX2ludGVnZXJfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gMTYtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzE2OiBpc19pbnRlZ2VyXzE2XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgdG9faW50ZWdlciwgdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gMzItYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzMyXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gNjQtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzY0OiBpc19pbnRlZ2VyXzY0XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIDgtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzg6IGlzX25hdHVyYWxfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gMTYtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzE2OiBpc19uYXR1cmFsXzE2XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbCwgdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gMzItYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsOiBpc19uYXR1cmFsXzMyXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gNjQtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzY0OiBpc19uYXR1cmFsXzY0XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbCwgdG9fcmVhbF8zMjogUkVBTFxuICAgICAgLS0gUmVhbCB2YWx1ZTtcbiAgICAgIC0tIGZvciBleGFtcGxlLCB3aGVuIGFwcGxpZWQgdG8gXCIxMjMuMFwiLCB3aWxsIHlpZWxkIDEyMy4wXG4gICAgcmVxdWlyZVxuICAgICAgcmVwcmVzZW50c19hX3JlYWw6IGlzX3JlYWxcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRvX2RvdWJsZS50cnVuY2F0ZWRfdG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZSwgdG9fcmVhbF82NDogRE9VQkxFXG4gICAgICAtLSBcIkRvdWJsZVwiIHZhbHVlO1xuICAgICAgLS0gZm9yIGV4YW1wbGUsIHdoZW4gYXBwbGllZCB0byBcIjEyMy4wXCIsIHdpbGwgeWllbGQgMTIzLjAgKGRvdWJsZSlcbiAgICByZXF1aXJlXG4gICAgICByZXByZXNlbnRzX2FfZG91YmxlOiBpc19kb3VibGVcbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX2RvdWJsZVxuICAgIGVuZFxuXG4gIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gdmFsdWU7XG4gICAgICAtLSBcIlRydWVcIiB5aWVsZHMgYFRydWUnLCBcIkZhbHNlXCIgeWllbGRzIGBGYWxzZSdcbiAgICAgIC0tIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2Jvb2xlYW46IGlzX2Jvb2xlYW5cbiAgICBkb1xuICAgICAgY2hlY2sgdHJ1ZV9jb25zdGFudC5jb3VudCA9IDQgZW5kXG4gICAgICBpZiBjb3VudCA9IDQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0b19ib29sZWFuOiAoUmVzdWx0ID0gYXNfbG93ZXIuc2FtZV9zdHJpbmcgKHRydWVfY29uc3RhbnQpKSBvclxuICAgICAgICAobm90IFJlc3VsdCA9IGFzX2xvd2VyLnNhbWVfc3RyaW5nIChmYWxzZV9jb25zdGFudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHNwbGl0IChhX3NlcGFyYXRvcjogQ0hBUkFDVEVSXzMyKTogTElTVCBbbGlrZSBDdXJyZW50XVxuICAgICAgLS0gU3BsaXQgb24gYGFfc2VwYXJhdG9yJy5cbiAgICBsb2NhbFxuICAgICAgbF9saXN0OiBBUlJBWUVEX0xJU1QgW2xpa2UgQ3VycmVudF1cbiAgICAgIHBhcnQ6IGxpa2UgQ3VycmVudFxuICAgICAgaSwgaiwgYzogSU5URUdFUlxuICAgIGRvXG4gICAgICBjIDo9IGNvdW50XG4gICAgICAgIC0tIFdvcnNlIGNhc2UgYWxsb2NhdGlvbjogZXZlcnkgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yXG4gICAgICBjcmVhdGUgbF9saXN0Lm1ha2UgKGMgKyAxKVxuICAgICAgaWYgYyA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGogOj0gaW5kZXhfb2YgKGFfc2VwYXJhdG9yLCBpKVxuICAgICAgICAgIGlmIGogPSAwIHRoZW5cbiAgICAgICAgICAgICAgLS0gTm8gc2VwYXJhdG9yIHdhcyBmb3VuZCwgd2Ugd2lsbFxuICAgICAgICAgICAgICAtLSBzaW1wbHkgY3JlYXRlIGEgbGlzdCB3aXRoIGEgY29weSBvZlxuICAgICAgICAgICAgICAtLSBDdXJyZW50IGluIGl0LlxuICAgICAgICAgICAgaiA6PSBjICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHBhcnQgOj0gc3Vic3RyaW5nIChpLCBqIC0gMSlcbiAgICAgICAgICBsX2xpc3QuZXh0ZW5kIChwYXJ0KVxuICAgICAgICAgIGkgOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGogPSBjIHRoZW5cbiAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgbGFzdF9jaGFyYWN0ZXJfaXNfYV9zZXBhcmF0b3I6IGl0ZW0gKGopID0gYV9zZXBhcmF0b3JcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEEgc2VwYXJhdG9yIHdhcyBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgICBsX2xpc3QuZXh0ZW5kIChuZXdfc3RyaW5nICgwKSlcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0ZW5kIGVtcHR5IHN0cmluZywgc2luY2UgQ3VycmVudCBpcyBlbXB0eS5cbiAgICAgICAgbF9saXN0LmV4dGVuZCAobmV3X3N0cmluZyAoMCkpXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSBsX2xpc3RcbiAgICAgIGNoZWNrXG4gICAgICAgIGxfbGlzdC5jb3VudCA9IG9jY3VycmVuY2VzIChhX3NlcGFyYXRvcikgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHBsdXNfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50ICsgcy5jb3VudFxuICAgICAgaW5pdGlhbDogZWxrc19jaGVja2luZyBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDEsIGNvdW50KSB+IEN1cnJlbnRcbiAgICAgIGZpbmFsOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoY291bnQgKyAxLCBjb3VudCArIHMuY291bnQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc3Vic3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3Vic3RyaW5nX2NvdW50OiBSZXN1bHQuY291bnQgPSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEgb3IgUmVzdWx0LmNvdW50ID0gMFxuICAgICAgZmlyc3RfY29kZTogUmVzdWx0LmNvdW50ID4gMCBpbXBsaWVzIFJlc3VsdC5pdGVtICgxKSA9IGl0ZW0gKHN0YXJ0X2luZGV4KVxuICAgICAgcmVjdXJzZTogUmVzdWx0LmNvdW50ID4gMCBpbXBsaWVzXG4gICAgICAgIFJlc3VsdC5zdWJzdHJpbmcgKDIsIFJlc3VsdC5jb3VudCkgfiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4ICsgMSwgZW5kX2luZGV4KVxuICAgIGVuZFxuXG4gIGhlYWQgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByZWZpeCwgcmV0YWluaW5nIGZpcnN0IGBuJyBjaGFyYWN0ZXJzIChvciBhcyBtYW55IGFzIGF2YWlsYWJsZSkuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHN1YnN0cmluZyAoMSwgbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgKGNvdW50KVxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAoY291bnQpXG4gICAgZW5kXG5cbiAgdGFpbCAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VmZml4LCByZXRhaW5pbmcgbGFzdCBgbicgY2hhcmFjdGVycyAob3IgYXMgbWFueSBhcyBhdmFpbGFibGUpLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdWJzdHJpbmcgKGNvdW50IC0gbiArIDEsIGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQpXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG4ubWluIChjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gQXNzZXJ0aW9uIGhlbHBlclxuXG4gIGVsa3NfY2hlY2tpbmc6IEJPT0xFQU4gPSBGYWxzZVxuICAgICAgLS0gQXJlIEVMS1MgY2hlY2tpbmdzIHZlcmlmaWVkPyBNdXN0IGJlIFRydWUgd2hlbiBjaGFuZ2luZyBpbXBsZW1lbnRhdGlvbiBvZiBTVFJJTkdfR0VORVJBTCBvciBkZXNjZW5kYW50LlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIG5ld19zdHJpbmcgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBjdXJyZW50IHdpdGggc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X3N0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIG5ld19zdHJpbmdfZW1wdHk6IFJlc3VsdC5pc19lbXB0eVxuICAgICAgbmV3X3N0cmluZ19hcmVhX2JpZ19lbm91Z2g6IFJlc3VsdC5jYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh0eXBlOiBJTlRFR0VSKSA6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhIHZhbGlkIG51bWJlciBhY2NvcmRpbmcgdG8gZ2l2ZW4gYHR5cGUnP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucmVzZXQgKHR5cGUpXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB0eXBlKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLmlzX2ludGVncmFsX2ludGVnZXJcbiAgICBlbmRcblxuICBzdHJpbmdfc2VhcmNoZXI6IFNUUklOR19TRUFSQ0hFUlxuICAgICAgLS0gRmFjaWxpdGllcyB0byBzZWFyY2ggc3RyaW5nIGluIGFub3RoZXIgc3RyaW5nLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzdHJpbmdfc2VhcmNoZXJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY19zdHJpbmdfcHJvdmlkZXI6IENfU1RSSU5HXG4gICAgICAtLSBUbyBjcmVhdGUgRWlmZmVsIHN0cmluZ3MgZnJvbSBDIHN0cmluZy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDApXG4gICAgZW5zdXJlXG4gICAgICBjX3N0cmluZ19wcm92aWRlcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBjdG9pX2NvbnZlcnRvcjogU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVE9SXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byBpbnRlZ2VyIG9yIG5hdHVyYWxcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfdHJhaWxpbmdfc2VwYXJhdG9ycyAoXCIgXCIpXG4gICAgICBSZXN1bHQuc2V0X2xlYWRpbmdfc2VwYXJhdG9yc19hY2NlcHRhYmxlIChUcnVlKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgZW5zdXJlXG4gICAgICBjdG9pX2NvbnZlcnRvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBjdG9yX2NvbnZlcnRvcjogU1RSSU5HX1RPX1JFQUxfQ09OVkVSVE9SXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byByZWFsIG9yIGRvdWJsZVxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgICAgUmVzdWx0LnNldF9sZWFkaW5nX3NlcGFyYXRvcnMgKFwiIFwiKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgICBSZXN1bHQuc2V0X3RyYWlsaW5nX3NlcGFyYXRvcnNfYWNjZXB0YWJsZSAoVHJ1ZSlcbiAgICBlbnN1cmVcbiAgICAgIGN0b3JfY29udmVydG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGRvdG5ldF9jb252ZXJ0b3I6IFNZU1RFTV9TVFJJTkdfRkFDVE9SWVxuICAgICAgLS0gQ29udmVydG9yIHVzZWQgdG8gY29udmVydCBmcm9tIGFuZCB0byBTWVNURU1fU1RSSU5HLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgIGRvdG5ldF9jb252ZXJ0b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX3Byb3BlcnRpZXM6IENIQVJBQ1RFUl9QUk9QRVJUWVxuICAgICAgLS0gQWNjZXNzIHRvIFVuaWNvZGUgY2hhcmFjdGVyIHByb3BlcnRpZXNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HX0dFTkVSQUx9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgaW50ZXJuYWxfaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBDYWNoZSBmb3IgYGhhc2hfY29kZScuXG5cbiAgaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGU6IElOVEVHRVI7XG4gICAgICAtLSBDYXNoIGZvciBgY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGUnLlxuXG5cbmZlYXR1cmUgLS0gQWNjZXNzOiBDdXJzb3JcblxuICBuZXdfY2hhcmFjdGVyXzMyX2N1cnNvcjogU1RSSU5HX0lURVJBVElPTl9DVVJTT1JcbiAgICAgIC0tIEZyZXNoIGN1cnNvciBmb3IgdGhpcyBzdHJpbmcgdGhhdCBpdGVyYXRlcyBvdmVyIGNvZGUgcG9pbnRzIChzZWUgYGNvZGUnKVxuICAgICAgLS0gZXhwb3NlZCBhcyB7Q0hBUkFDVEVSXzMyfS5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChDdXJyZW50KVxuICAgICAgUmVzdWx0LnN0YXJ0XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWFsIHZhbHVlcywgc2luZ2xlIHByZWNpc2lvblwiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlNpbmdsZVwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIFJFQUxfMzIgaW5oZXJpdFxuXG4gIFJFQUxfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBpc19uYW4sXG4gICAgICBpc19uZWdhdGl2ZV9pbmZpbml0eSxcbiAgICAgIGlzX3Bvc2l0aXZlX2luZmluaXR5LFxuICAgICAgdHJ1bmNhdGVkX3RvX2ludGVnZXIsXG4gICAgICB0cnVuY2F0ZWRfdG9faW50ZWdlcl82NCxcbiAgICAgIHRvX2RvdWJsZSxcbiAgICAgIGNlaWxpbmdfcmVhbF8zMixcbiAgICAgIGZsb29yX3JlYWxfMzIsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBvdXRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbmNvbnZlcnRcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe1JFQUxfMzJfUkVGfSksXG4gIHRvX2RvdWJsZToge1JFQUxfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBSRUFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCByZWFsP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgUmVwb3J0XG5cbiAgaXNfbmFuOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHRoZSByZXByZXNlbnRhdGlvbiBvZiBgbmFuJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaXNfbmVnYXRpdmVfaW5maW5pdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuZWdhdGl2ZV9pbmZpbml0eSc/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlzX3Bvc2l0aXZlX2luZmluaXR5OiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHRoZSByZXByZXNlbnRhdGlvbiBvZiBgcG9zaXRpdmVfaW5maW5pdHknP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdHJ1bmNhdGVkX3RvX2ludGVnZXI6IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgcGFydCAoc2FtZSBzaWduLCBsYXJnZXN0IGFic29sdXRlXG4gICAgICAtLSB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3QncylcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdHJ1bmNhdGVkX3RvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgcGFydCAoc2FtZSBzaWduLCBsYXJnZXN0IGFic29sdXRlXG4gICAgICAtLSB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3QncylcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDdXJyZW50IHNlZW4gYXMgYSBkb3VibGVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgY2VpbGluZ19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBTbWFsbGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBzbWFsbGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgZmxvb3JfcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gR3JlYXRlc3QgaW50ZWdyYWwgdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogUkVBTF8zMik6IFJFQUxfMzJcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBSRUFMXzMyKTogUkVBTF8zMlxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IFJFQUxfMzIpOiBSRUFMXzMyXG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBSRUFMXzMyKTogUkVBTF8zMlxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBDdXJyZW50IHJlYWwgdG8gdGhlIHBvd2VyIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IFJFQUxfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IFJFQUxfMzJcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcmVhbCB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGEgcmVhbCB2YWx1ZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0xMi0zMCAxNjo1NDo0OSAtMDgwMCAoTW9uLCAzMCBEZWMgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTM4NTUgJFwiXG5cbmNsYXNzIFJFQUxfMzJfUkVGIGluaGVyaXRcblxuICBOVU1FUklDXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IFJFQUxfMzJcbiAgICAgIC0tIE51bWVyaWMgcmVhbCB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHJ1bmNhdGVkX3RvX2ludGVnZXIuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAuMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAuMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKHtSRUFMXzMyfSAxLjApXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKHtSRUFMXzMyfSAwLjApXG4gICAgZW5kXG5cbiAgbmFuOiBSRUFMXzMyXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBvZiBub3QgYSBudW1iZXIgKE5hTilcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIG5lZ2F0aXZlX2luZmluaXR5OiBSRUFMXzMyXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBvZiBuZWdhdGl2ZSBpbmZpbml0eVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgcG9zaXRpdmVfaW5maW5pdHk6IFJFQUxfMzJcbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIG9mIHBvc2l0aXZlIGluZmluaXR5XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBtaW5fdmFsdWU6IFJFQUxfMzIgPSAtMy40MDI4MjM0NjYzODUyODg1OTgxMTcwZSswMzhcbiAgbWF4X3ZhbHVlOiBSRUFMXzMyID0gMy40MDI4MjM0NjYzODUyODg1OTgxMTcwZSswMzhcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbiAgbWFjaGluZV9lcHNpbG9uOiBSRUFMXzMyID0gMS4xOTIwOTI4OTU1MDc4MTI1MDAwMDAwZS0wMDdcbiAgICAgIC0tIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMSBhbmQgdGhlIGxlYXN0IHZhbHVlIGdyZWF0ZXIgdGhhblxuICAgICAgLS0gMSB0aGF0IGlzIHJlcHJlc2VudGFibGUgaW4gdGhlIGdpdmVuIGZsb2F0aW5nIHBvaW50IHR5cGUuXG5cbiAgZXBzaWxvbjogUkVBTF8zMiA9IDEuMTc1NDk0MzUwODIyMjg3NTA3OTY4OGUtMDM4XG4gICAgICAtLSBNaW5pbXVtIG5vcm1hbGl6ZWQgcG9zaXRpdmUgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCByZWFsP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8IG90aGVyLml0ZW1cbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtID0gaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0X2l0ZW0gKHI6IFJFQUxfMzIpXG4gICAgICAtLSBNYWtlIGByJyB0aGUgdmFsdWUgb2YgYGl0ZW0nLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZGl2aXNpYmxlIChvdGhlcjogUkVBTF8zMl9SRUYpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwLjBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgcmVmX25vdF9leGFjdF96ZXJvOiBSZXN1bHQgaW1wbGllcyAob3RoZXIuaXRlbSAvPSAwLjApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDAuMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDAuMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMC4wKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwLjBcbiAgICBlbmRcblxuICBpc19uYW46IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuYW4nP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5pc19uYW5cbiAgICBlbmRcblxuICBpc19uZWdhdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYG5lZ2F0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfbmVnYXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuICBpc19wb3NpdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYHBvc2l0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfcG9zaXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBSRUFMXzMyX1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IFJFQUxfMzJfUkVGXG4gICAgICAtLSBBc3NvY2lhdGVkIHJlZmVyZW5jZSBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9faW50ZWdlcjogSU5URUdFUl8zMlxuICAgICAgLS0gSW50ZWdlciBwYXJ0IChzYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50cnVuY2F0ZWRfdG9faW50ZWdlclxuICAgIGVuZFxuXG4gIHRydW5jYXRlZF90b19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBhcnQgKHNhbWUgc2lnbiwgbGFyZ2VzdCBhYnNvbHV0ZVxuICAgICAgLS0gdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0J3MpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRydW5jYXRlZF90b19pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDdXJyZW50IHNlZW4gYXMgYSBkb3VibGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fZG91YmxlXG4gICAgZW5kXG5cbiAgY2VpbGluZzogSU5URUdFUl8zMlxuICAgICAgLS0gU21hbGxlc3QgaW50ZWdyYWwgdmFsdWUgbm8gc21hbGxlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjZWlsaW5nX3JlYWxfMzIudHJ1bmNhdGVkX3RvX2ludGVnZXJcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub19zbWFsbGVyOiBSZXN1bHQgPj0gaXRlbVxuICAgICAgY2xvc2VfZW5vdWdoOiBSZXN1bHQgLSBpdGVtIDwgaXRlbS5vbmVcbiAgICBlbmRcblxuICBmbG9vcjogSU5URUdFUl8zMlxuICAgICAgLS0gR3JlYXRlc3QgaW50ZWdyYWwgdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBmbG9vcl9yZWFsXzMyLnRydW5jYXRlZF90b19pbnRlZ2VyXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm9fZ3JlYXRlcjogUmVzdWx0IDw9IGl0ZW1cbiAgICAgIGNsb3NlX2Vub3VnaDogaXRlbSAtIFJlc3VsdCA8IFJlc3VsdC5vbmVcbiAgICBlbmRcblxuICByb3VuZGVkOiBJTlRFR0VSXzMyXG4gICAgICAtLSBSb3VuZGVkIGludGVncmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzaWduICogKChhYnMgKyAwLjUpLmZsb29yKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcilcbiAgICBlbmRcblxuICBjZWlsaW5nX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIFNtYWxsZXN0IGludGVncmFsIHZhbHVlIG5vIHNtYWxsZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5jZWlsaW5nX3JlYWxfMzJcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub19zbWFsbGVyOiBSZXN1bHQgPj0gaXRlbVxuICAgICAgY2xvc2VfZW5vdWdoOiBSZXN1bHQgLSBpdGVtIDwgaXRlbS5vbmVcbiAgICBlbmRcblxuICBmbG9vcl9yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBHcmVhdGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uZmxvb3JfcmVhbF8zMlxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vX2dyZWF0ZXI6IFJlc3VsdCA8PSBpdGVtXG4gICAgICBjbG9zZV9lbm91Z2g6IGl0ZW0gLSBSZXN1bHQgPCBSZXN1bHQub25lXG4gICAgZW5kXG5cbiAgcm91bmRlZF9yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBSb3VuZGVkIGludGVncmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzaWduICogKChhYnMgKyB7UkVBTF8zMn0gMC41KS5mbG9vcl9yZWFsXzMyKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gc2lnbiAqICgoYWJzICsge1JFQUxfMzJ9IDAuNSkuZmxvb3JfcmVhbF8zMilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgYWJzOiBSRUFMXzMyXG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwLjBcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgPSBpdGVtKSBvciAoUmVzdWx0ID0gLWl0ZW0pXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLSBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gKiBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAvIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gQ3VycmVudCByZWFsIHRvIHRoZSBwb3dlciBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoLSBpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgcmVhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5vdXRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhYnNfcmVmOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPSAwLjAgdGhlblxuICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSB3aGVuIGBpdGVtJyBpcyBgLTAnLlxuICAgICAgICBSZXN1bHQgOj0gemVyb1xuICAgICAgZWxzZWlmIGl0ZW0gPiAwLjAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gLUN1cnJlbnRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfYWJzb2x1dGVfdmFsdWU6IChSZXN1bHQgfiBDdXJyZW50KSBvciAoUmVzdWx0IH4gLUN1cnJlbnQpXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBzaWduX3RpbWVzX2Ficzogbm90IGl0ZW0uaXNfbmFuIGltcGxpZXMgc2lnbiAqIGFicyA9IGl0ZW1cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlYWwgdmFsdWVzLCBkb3VibGUgcHJlY2lzaW9uXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uRG91YmxlXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3MgUkVBTF82NCBpbmhlcml0XG5cbiAgUkVBTF82NF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIGlzX25hbixcbiAgICAgIGlzX25lZ2F0aXZlX2luZmluaXR5LFxuICAgICAgaXNfcG9zaXRpdmVfaW5maW5pdHksXG4gICAgICB0cnVuY2F0ZWRfdG9faW50ZWdlcixcbiAgICAgIHRydW5jYXRlZF90b19pbnRlZ2VyXzY0LFxuICAgICAgdHJ1bmNhdGVkX3RvX3JlYWwsXG4gICAgICBjZWlsaW5nX3JlYWxfNjQsXG4gICAgICBmbG9vcl9yZWFsXzY0LFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBvcHBvc2l0ZSxcbiAgICAgIGlkZW50aXR5LFxuICAgICAgb3V0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtSRUFMXzY0X1JFRn0pXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBSRUFMXzY0KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBncmVhdGVyIHRoYW4gY3VycmVudCBkb3VibGU/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyBSZXBvcnRcblxuICBpc19uYW46IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuYW4nP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpc19uZWdhdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYG5lZ2F0aXZlX2luZmluaXR5Jz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaXNfcG9zaXRpdmVfaW5maW5pdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBwb3NpdGl2ZV9pbmZpbml0eSc/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0cnVuY2F0ZWRfdG9faW50ZWdlcjogSU5URUdFUl8zMlxuICAgICAgLS0gSW50ZWdlciBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gSW50ZWdlciBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gUmVhbCBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjZWlsaW5nX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIFNtYWxsZXN0IGludGVncmFsIHZhbHVlIG5vIHNtYWxsZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBmbG9vcl9yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBHcmVhdGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIFByb2R1Y3Qgd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gQ3VycmVudCBkb3VibGUgdG8gdGhlIHBvd2VyIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IFJFQUxfNjRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IFJFQUxfNjRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgZG91YmxlIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYSBkb3VibGUtcHJlY2lzaW9uIHJlYWwgbnVtYmVyXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTEyLTMwIDE2OjQ5OjM0IC0wODAwIChNb24sIDMwIERlYyAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5Mzg1NCAkXCJcblxuY2xhc3MgUkVBTF82NF9SRUYgaW5oZXJpdFxuXG4gIE5VTUVSSUNcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIENPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2hhc2hhYmxlLCBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogUkVBTF82NFxuICAgICAgLS0gTnVtZXJpYyBkb3VibGUgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRydW5jYXRlZF90b19pbnRlZ2VyLmhhc2hfY29kZVxuICAgIGVuZFxuXG4gIHNpZ246IElOVEVHRVJcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwLjAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwLjAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxLjApXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDAuMClcbiAgICBlbmRcblxuICBuYW46IFJFQUxfNjRcbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIG9mIG5vdCBhIG51bWJlciAoTmFOKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbiAgbmVnYXRpdmVfaW5maW5pdHk6IFJFQUxfNjRcbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIG9mIG5lZ2F0aXZlIGluZmluaXR5XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW4gc3RhdGljXCJcbiAgICBlbmRcblxuICBwb3NpdGl2ZV9pbmZpbml0eTogUkVBTF82NFxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gb2YgcG9zaXRpdmUgaW5maW5pdHlcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pbiBzdGF0aWNcIlxuICAgIGVuZFxuXG4gIG1pbl92YWx1ZTogUkVBTF82NCA9IC0xLjc5NzY5MzEzNDg2MjMxNTcwODE0NTJlKzMwOFxuICBtYXhfdmFsdWU6IFJFQUxfNjQgPSAxLjc5NzY5MzEzNDg2MjMxNTcwODE0NTJlKzMwOFxuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuICBtYWNoaW5lX2Vwc2lsb246IFJFQUxfNjQgPSAyLjIyMDQ0NjA0OTI1MDMxMzA4MDg0NzNlLTAxNlxuICAgICAgLS0gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiAxIGFuZCB0aGUgbGVhc3QgdmFsdWUgZ3JlYXRlciB0aGFuXG4gICAgICAtLSAxIHRoYXQgaXMgcmVwcmVzZW50YWJsZSBpbiB0aGUgZ2l2ZW4gZmxvYXRpbmcgcG9pbnQgdHlwZS5cblxuICBlcHNpbG9uOiBSRUFMXzY0ID0gMi4yMjUwNzM4NTg1MDcyMDEzODMwOTAzZS0zMDhcbiAgICAgIC0tIE1pbmltdW0gbm9ybWFsaXplZCBwb3NpdGl2ZSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGRvdWJsZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChkOiBSRUFMXzY0KVxuICAgICAgLS0gTWFrZSBgZCcgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IFJFQUxfNjRfUkVGKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGRpdmlkZWQgYnkgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gLz0gMC4wXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5vdF9leGFjdF96ZXJvOiBSZXN1bHQgaW1wbGllcyAob3RoZXIuaXRlbSAvPSAwLjApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDAuMFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gb3RoZXIgYXMgcmVhbF92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSByZWFsX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMC4wXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDAuMCkgb3JcbiAgICAgICAgKG90aGVyLmNvbmZvcm1zX3RvICgwLjApIGFuZCBpdGVtID4gMC4wKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwLjBcbiAgICBlbmRcblxuICBpc19uYW46IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGBuYW4nP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5pc19uYW5cbiAgICBlbmRcblxuICBpc19uZWdhdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYG5lZ2F0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfbmVnYXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuICBpc19wb3NpdGl2ZV9pbmZpbml0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0aGUgcmVwcmVzZW50YXRpb24gb2YgYHBvc2l0aXZlX2luZmluaXR5Jz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uaXNfcG9zaXRpdmVfaW5maW5pdHlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gQ29udmVyc2lvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IFJFQUxfNjRfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogUkVBTF82NF9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRydW5jYXRlZF90b19pbnRlZ2VyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIHBhcnQgKFNhbWUgc2lnbiwgbGFyZ2VzdCBhYnNvbHV0ZVxuICAgICAgLS0gdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0J3MpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRydW5jYXRlZF90b19pbnRlZ2VyXG4gICAgZW5kXG5cbiAgdHJ1bmNhdGVkX3RvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIEludGVnZXIgcGFydCAoU2FtZSBzaWduLCBsYXJnZXN0IGFic29sdXRlXG4gICAgICAtLSB2YWx1ZSBubyBncmVhdGVyIHRoYW4gY3VycmVudCBvYmplY3QncylcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udHJ1bmNhdGVkX3RvX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0cnVuY2F0ZWRfdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gUmVhbCBwYXJ0IChTYW1lIHNpZ24sIGxhcmdlc3QgYWJzb2x1dGVcbiAgICAgIC0tIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdCdzKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50cnVuY2F0ZWRfdG9fcmVhbFxuICAgIGVuZFxuXG4gIGNlaWxpbmc6IElOVEVHRVJfMzJcbiAgICAgIC0tIFNtYWxsZXN0IGludGVncmFsIHZhbHVlIG5vIHNtYWxsZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY2VpbGluZ19yZWFsXzY0LnRydW5jYXRlZF90b19pbnRlZ2VyXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm9fc21hbGxlcjogUmVzdWx0ID49IGl0ZW1cbiAgICAgIGNsb3NlX2Vub3VnaDogUmVzdWx0IC0gaXRlbSA8IGl0ZW0ub25lXG4gICAgZW5kXG5cbiAgZmxvb3I6IElOVEVHRVJfMzJcbiAgICAgIC0tIEdyZWF0ZXN0IGludGVncmFsIHZhbHVlIG5vIGdyZWF0ZXIgdGhhbiBjdXJyZW50IG9iamVjdFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZmxvb3JfcmVhbF82NC50cnVuY2F0ZWRfdG9faW50ZWdlclxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vX2dyZWF0ZXI6IFJlc3VsdCA8PSBpdGVtXG4gICAgICBjbG9zZV9lbm91Z2g6IGl0ZW0gLSBSZXN1bHQgPCBSZXN1bHQub25lXG4gICAgZW5kXG5cbiAgcm91bmRlZDogSU5URUdFUl8zMlxuICAgICAgLS0gUm91bmRlZCBpbnRlZ3JhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHNpZ24gKiAoKGFicyArIDAuNSkuZmxvb3IpXG4gICAgZW5kXG5cbiAgY2VpbGluZ19yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBTbWFsbGVzdCBpbnRlZ3JhbCB2YWx1ZSBubyBzbWFsbGVyIHRoYW4gY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uY2VpbGluZ19yZWFsXzY0XG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfbm9fc21hbGxlcjogUmVzdWx0ID49IGl0ZW1cbiAgICAgIGNsb3NlX2Vub3VnaDogUmVzdWx0IC0gaXRlbSA8IGl0ZW0ub25lXG4gICAgZW5kXG5cbiAgZmxvb3JfcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gR3JlYXRlc3QgaW50ZWdyYWwgdmFsdWUgbm8gZ3JlYXRlciB0aGFuIGN1cnJlbnQgb2JqZWN0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmZsb29yX3JlYWxfNjRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9ub19ncmVhdGVyOiBSZXN1bHQgPD0gaXRlbVxuICAgICAgY2xvc2VfZW5vdWdoOiBpdGVtIC0gUmVzdWx0IDwgUmVzdWx0Lm9uZVxuICAgIGVuZFxuXG4gIHJvdW5kZWRfcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gUm91bmRlZCBpbnRlZ3JhbCB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcl9yZWFsXzY0KVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gc2lnbiAqICgoYWJzICsgMC41KS5mbG9vcl9yZWFsXzY0KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBhYnM6IFJFQUxfNjRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhYnNfcmVmLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDAuMFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCA9IGl0ZW0pIG9yIChSZXN1bHQgPSAtaXRlbSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLyBvdGhlci5pdGVtKVxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEN1cnJlbnQgZG91YmxlIHRvIHRoZSBwb3dlciBgb3RoZXInXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIF4gb3RoZXJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoKyBpdGVtKVxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoLSBpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgZG91YmxlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLm91dFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFic19yZWY6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQWJzb2x1dGUgdmFsdWVcbiAgICBkb1xuICAgICAgaWYgaXRlbSA9IDAuMCB0aGVuXG4gICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIHdoZW4gYGl0ZW0nIGlzIGAtMCcuXG4gICAgICAgIFJlc3VsdCA6PSB6ZXJvXG4gICAgICBlbHNlaWYgaXRlbSA+IDAuMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAtQ3VycmVudFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCB+IEN1cnJlbnQpIG9yIChSZXN1bHQgfiAtQ3VycmVudClcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIHNpZ25fdGltZXNfYWJzOiBub3QgaXRlbS5pc19uYW4gaW1wbGllcyBzaWduICogYWJzID0gaXRlbVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgIENvbGxlY3Rpb24gb2YgZmVhdHVyZXMgdGhhdCBhcmUgdXNlZCB0byBtYXJrXG4gICAgcGxhY2VzIGluIGNvZGUgdGhhdCBuZWVkcyByZWZhY3RvcmluZy5cbiAgICBdXCJcblxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBSRUZBQ1RPUklOR19IRUxQRVJcblxuZmVhdHVyZSAtLSBNYXJrZXJzXG5cbiAgZml4bWUgKGNvbW1lbnQ6IFNUUklORylcbiAgICAgIC0tIE1hcmsgY29kZSB0aGF0IGhhcyB0byBiZSBcImZpeGVkXCIgd2l0aCBgY29tbWVudCcuXG4gICAgcmVxdWlyZVxuICAgICAgY29tbWVudF9ub3Rfdm9pZDogY29tbWVudCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIC0tIGRlYnVnIChcInJlZmFjdG9yX2ZpeG1lXCIpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9zdHJpbmcgKFwiRklYTUU6IFwiKVxuICAgICAgLS0gICBpby5lcnJvci5wdXRfc3RyaW5nIChjb21tZW50KVxuICAgICAgLS0gICBpby5lcnJvci5wdXRfbmV3X2xpbmVcbiAgICAgIC0tIGVuZFxuICAgIGVuZFxuXG4gIHRvX2ltcGxlbWVudCAoY29tbWVudDogU1RSSU5HKVxuICAgICAgLS0gTWFyayBjb2RlIHRoYXQgaGFzIHRvIGJlIFwiaW1wbGVtZW50ZWRcIiB3aXRoIGBjb21tZW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBjb21tZW50X25vdF92b2lkOiBjb21tZW50IC89IFZvaWRcbiAgICBkb1xuICAgICAgLS0gZGVidWcgKFwicmVmYWN0b3JfZml4bWVcIilcbiAgICAgIC0tICAgaW8uZXJyb3IucHV0X3N0cmluZyAoXCJUT19CRV9JTVBMRU1FTlRFRDogXCIpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9zdHJpbmcgKGNvbW1lbnQpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9uZXdfbGluZVxuICAgICAgLS0gZW5kXG4gICAgZW5kXG5cbiAgdG9faW1wbGVtZW50X2Fzc2VydGlvbiAoY29tbWVudDogU1RSSU5HKTogQk9PTEVBTlxuICAgICAgLS0gTWFyayBhc3NlcnRpb24gdGhhdCBoYXMgdG8gYmUgXCJpbXBsZW1lbnRlZFwiIHdpdGggYGNvbW1lbnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNvbW1lbnRfbm90X3ZvaWQ6IGNvbW1lbnQgLz0gVm9pZFxuICAgIGRvXG4gICAgICAtLSBUT0RPIGltcGxlbWVudCBkZWJ1ZyBzdGF0ZW1lbnRcbiAgICAgIC0tIGRlYnVnIChcInJlZmFjdG9yX2ZpeG1lXCIpXG4gICAgICAtLSAgIGlvLmVycm9yLnB1dF9zdHJpbmcgKFwiQVNTRVJUSU9OX1RPX0JFX0lNUExFTUVOVEVEOiBcIilcbiAgICAgIC0tICAgaW8uZXJyb3IucHV0X3N0cmluZyAoY29tbWVudClcbiAgICAgIC0tICAgaW8uZXJyb3IucHV0X25ld19saW5lXG4gICAgICAtLSBlbmRcbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgICBBY2Nlc3MgdG8gaW50ZXJuYWwgb2JqZWN0IHByb3BlcnRpZXMuXG4gICAgICBUaGlzIGNsYXNzIG1heSBiZSB1c2VkIGFzIGFuY2VzdG9yIGJ5IGNsYXNzZXMgbmVlZGluZyBpdHMgZmFjaWxpdGllcy5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA5LTA2IDIxOjQ1OjQ3IC0wNzAwIChGcmksIDA2IFNlcCAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjkxNyAkXCJcblxuY2xhc3NcbiAgUkVGTEVDVE9SXG5cbmluaGVyaXRcbiAgUkVGTEVDVE9SX0hFTFBFUlxuXG4gIFJFRkxFQ1RPUl9DT05TVEFOVFNcblxuZmVhdHVyZSAtLSBDb25mb3JtYW5jZVxuXG4gIHR5cGVfY29uZm9ybXNfdG8gKHR5cGUxLCB0eXBlMjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYHR5cGUxJyBjb25mb3JtIHRvIGB0eXBlMic/XG4gICAgcmVxdWlyZVxuICAgICAgdHlwZTFfbm9ubmVnYXRpdmU6IHR5cGUxID49IDBcbiAgICAgIHR5cGUyX25vbm5lZ2F0aXZlOiB0eXBlMiA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0udHlwZV9jb25mb3Jtc190byAodHlwZTEsIHR5cGUyKVxuICAgIGVuZFxuXG4gIGZpZWxkX2NvbmZvcm1zX3RvIChhX3NvdXJjZV90eXBlLCBhX2ZpZWxkX3R5cGU6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBhX3NvdXJjZV90eXBlJyBjb25mb3JtIHRvIGBhX2ZpZWxkX3R5cGUnP1xuICAgICAgLS18IERpZmZlcmVudCBmcm9tIGB0eXBlX2NvbmZvcm1zX3RvJyBzaW5jZSBwb3NzaWJsZSBhdHRhY2htZW50IG1hcmsgb2YgYGFfZmllbGRfdHlwZSdcbiAgICAgIC0tfCBpcyBkaXNjYXJkZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV9zb3VyY2VfdHlwZV9ub25fbmVnYXRpdmU6IGFfc291cmNlX3R5cGUgPj0gMFxuICAgICAgYV9maWVsZF90eXBlX25vbl9uZWdhdGl2ZTogYV9maWVsZF90eXBlID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS50eXBlX2NvbmZvcm1zX3RvIChhX3NvdXJjZV90eXBlLCB7SVNFX1JVTlRJTUV9LmRldGFjaGFibGVfdHlwZSAoYV9maWVsZF90eXBlKSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDcmVhdGlvblxuXG4gIGR5bmFtaWNfdHlwZV9mcm9tX3N0cmluZyAoY2xhc3NfdHlwZTogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBJTlRFR0VSXG4gICAgICAtLSBEeW5hbWljIHR5cGUgY29ycmVzcG9uZGluZyB0byBgY2xhc3NfdHlwZScuXG4gICAgICAtLSBJZiBubyBkeW5hbWljIHR5cGUgYXZhaWxhYmxlLCByZXR1cm5zIC0xLlxuICAgIHJlcXVpcmVcbiAgICAgIGNsYXNzX3R5cGVfbm90X3ZvaWQ6IGNsYXNzX3R5cGUgLz0gVm9pZFxuICAgICAgY2xhc3NfdHlwZV9ub3RfZW1wdHk6IG5vdCBjbGFzc190eXBlLmlzX2VtcHR5XG4gICAgICBpc192YWxpZF90eXBlX3N0cmluZzogaXNfdmFsaWRfdHlwZV9zdHJpbmcgKGNsYXNzX3R5cGUpXG4gICAgbG9jYWxcbiAgICAgIGxfY3N0cjogQ19TVFJJTkdcbiAgICAgIGxfdGFibGU6IGxpa2UgaW50ZXJuYWxfZHluYW1pY190eXBlX3N0cmluZ190YWJsZVxuICAgICAgbF9wcmVfZWNtYV9zdGF0dXM6IEJPT0xFQU5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBsX3RhYmxlIDo9IGludGVybmFsX2R5bmFtaWNfdHlwZV9zdHJpbmdfdGFibGVcbiAgICAgIC0tIGxfdGFibGUuc2VhcmNoIChjbGFzc190eXBlKVxuICAgICAgLS0gaWYgbF90YWJsZS5mb3VuZCB0aGVuXG4gICAgICAtLSAgIFJlc3VsdCA6PSBsX3RhYmxlLmZvdW5kX2l0ZW1cbiAgICAgIC0tIGVsc2VcbiAgICAgIC0tICAgY3JlYXRlIGxfY3N0ci5tYWtlIChjbGFzc190eXBlKVxuICAgICAgLS0gICAgIC0tIFRha2UgaW50byBjb25zaWRlcmF0aW9uIHBvc3NpYmxlIHByZS1FQ01BIG1hcHBpbmcuXG4gICAgICAtLSAgIGxfcHJlX2VjbWFfc3RhdHVzIDo9IHtJU0VfUlVOVElNRX0ucHJlX2VjbWFfbWFwcGluZ19zdGF0dXNcbiAgICAgIC0tICAge0lTRV9SVU5USU1FfS5zZXRfcHJlX2VjbWFfbWFwcGluZyAobm90IGlzX3ByZV9lY21hX21hcHBpbmdfZGlzYWJsZWQpXG4gICAgICAtLSAgIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LnR5cGVfaWRfZnJvbV9uYW1lIChsX2NzdHIuaXRlbSlcbiAgICAgIC0tICAge0lTRV9SVU5USU1FfS5zZXRfcHJlX2VjbWFfbWFwcGluZyAobF9wcmVfZWNtYV9zdGF0dXMpXG4gICAgICAtLSAgIGxfdGFibGUucHV0IChSZXN1bHQsIGNsYXNzX3R5cGUpXG4gICAgICAtLSBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9mcm9tX3N0cmluZ192YWxpZDogUmVzdWx0ID0gLTEgb3IgUmVzdWx0ID0gbm9uZV90eXBlIG9yIFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgbmV3X2luc3RhbmNlX29mICh0eXBlX2lkOiBJTlRFR0VSKTogQU5ZXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgZHluYW1pYyBgdHlwZV9pZCcuXG4gICAgICAtLSBOb3RlOiByZXR1cm5lZCBvYmplY3QgaXMgbm90IGluaXRpYWxpemVkIGFuZCBtYXlcbiAgICAgIC0tIGhlbmNlIHZpb2xhdGUgaXRzIGludmFyaWFudC5cbiAgICAgIC0tIGB0eXBlX2lkJyBjYW5ub3QgcmVwcmVzZW50IGEgU1BFQ0lBTCB0eXBlLCB1c2VcbiAgICAgIC0tIGBuZXdfc3BlY2lhbF9hbnlfaW5zdGFuY2UnIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICBub3Rfc3BlY2lhbF90eXBlOiBub3QgaXNfc3BlY2lhbF90eXBlICh0eXBlX2lkKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19uZXdfaW5zdGFuY2Vfb2YgKHR5cGVfaWQpXG4gICAgZW5zdXJlXG4gICAgICBub3Rfc3BlY2lhbF90eXBlOiBub3QgYXR0YWNoZWQge1NQRUNJQUwgW2RldGFjaGFibGUgQU5ZXX0gUmVzdWx0XG4gICAgICBkeW5hbWljX3R5cGVfc2V0OiBSZXN1bHQuZ2VuZXJhdGluZ190eXBlLnR5cGVfaWQgPSB0eXBlX2lkXG4gICAgZW5kXG5cbiAgbmV3X3NwZWNpYWxfYW55X2luc3RhbmNlICh0eXBlX2lkLCBjb3VudDogSU5URUdFUik6IFNQRUNJQUwgW2RldGFjaGFibGUgQU5ZXVxuICAgICAgLS0gTmV3IGluc3RhbmNlIG9mIGR5bmFtaWMgYHR5cGVfaWQnIHRoYXQgcmVwcmVzZW50c1xuICAgICAgLS0gYSBTUEVDSUFMIHdpdGggYGNvdW50JyBlbGVtZW50LiBUbyBjcmVhdGUgYSBTUEVDSUFMIG9mXG4gICAgICAtLSBiYXNpYyB0eXBlLCB1c2UgYFNQRUNJQUwnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNvdW50X3ZhbGlkOiBjb3VudCA+PSAwXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICAgIHNwZWNpYWxfdHlwZTogaXNfc3BlY2lhbF9hbnlfdHlwZSAodHlwZV9pZClcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5IChjb3VudClcbiAgICAgIGNfc2V0X2R5bmFtaWNfdHlwZSAoUmVzdWx0LCB0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgZHluYW1pY190eXBlX3NldDogUmVzdWx0LmdlbmVyYXRpbmdfdHlwZS50eXBlX2lkID0gdHlwZV9pZFxuICAgICAgY291bnRfc2V0OiBSZXN1bHQuY291bnQgPSAwXG4gICAgICBjYXBhY2l0eV9zZXQ6IFJlc3VsdC5jYXBhY2l0eSA9IGNvdW50XG4gICAgZW5kXG5cbiAgbmV3X3R1cGxlX2Zyb21fc3BlY2lhbCAodHlwZV9pZDogSU5URUdFUjsgdmFsdWVzOiBTUEVDSUFMIFtkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWV0pOiBkZXRhY2hhYmxlIFRVUExFXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgYSB0dXBsZSBvZiB0eXBlIGB0eXBlX2lkJyBmaWxsZWQgd2l0aCBgdmFsdWVzJyBpZiBhbGwgdHlwZXMgb2YgaXRlbXMgYXJlIHN1aXRhYmxlLlxuICAgICAgLS0gYFZvaWQnIGlmIHNvbWUgaXRlbXMgZnJvbSBgdmFsdWVzJyBhcmUgaW5hcHByb3ByaWF0ZSBmb3IgYSB0dXBsZSBvZiB0eXBlIGB0eXBlX2lkJy5cbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICAgIGlzX3R1cGxlX3R5cGU6IGlzX3R1cGxlX3R5cGUgKHR5cGVfaWQpXG4gICAgICAtLSBzdWZmaWNpZW50X3ZhbHVlc19jb3VudDogdmFsdWVzLmNvdW50ID49IHR1cGxlX3R5cGVfY291bnQgKHR5cGVfaWQpXG4gICAgICAtLSB2YWxpZF92YWx1ZV90eXBlczogYWNyb3NzIDEgfC4ufCB0dXBsZV90eXBlX2NvdW50ICh0eXBlX2lkKSBhcyBpIGFsbCB2YWxpZF9vYmplY3RfZm9yX3R1cGxlX2luZGV4ICh2YWx1ZXMgW2kgLSAxXSwgaSlcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgdjogZGV0YWNoYWJsZSBzZXBhcmF0ZSBBTllcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNfbmV3X3R1cGxlX2luc3RhbmNlX29mICh0eXBlX2lkKVxuICAgICAgaSA6PSBSZXN1bHQuY291bnRcbiAgICAgIGlmIGkgPD0gdmFsdWVzLmNvdW50IHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPD0gMCBvciBlbHNlIG5vdCBhdHRhY2hlZCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIHYgOj0gdmFsdWVzIFtpIC0gMV1cbiAgICAgICAgICBpZiBSZXN1bHQudmFsaWRfdHlwZV9mb3JfaW5kZXggKHYsIGkpIHRoZW5cbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIGNvbXBhdGlibGUgd2l0aCB0dXBsZSBpdGVtIGF0IGluZGV4IGBpJy5cbiAgICAgICAgICAgIFJlc3VsdCBbaV0gOj0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdHVwbGUgaXRlbSBhdCBpbmRleCBgaScuXG4gICAgICAgICAgICBSZXN1bHQgOj0gVm9pZFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gSW5zdWZmaWNpZW50IG51bWJlciBvZiB2YWx1ZXMuXG4gICAgICAgIFJlc3VsdCA6PSBWb2lkXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9zZXQ6IGF0dGFjaGVkIFJlc3VsdCBpbXBsaWVzIFJlc3VsdC5nZW5lcmF0aW5nX3R5cGUudHlwZV9pZCA9IHR5cGVfaWRcbiAgICAgIHZhbHVlc19zZXQ6IGF0dGFjaGVkIFJlc3VsdCBpbXBsaWVzIGFjcm9zcyAxIHwuLnwgUmVzdWx0LmNvdW50IGFzIGsgYWxsIFJlc3VsdC5pdGVtIChrLml0ZW0pID0gdmFsdWVzIFtrLml0ZW0gLSAxXSBlbmRcbiAgICBlbmRcblxuICBuZXdfdHVwbGVfZnJvbV90dXBsZSAodHlwZV9pZDogSU5URUdFUjsgc291cmNlOiBzZXBhcmF0ZSBUVVBMRSk6IGRldGFjaGFibGUgVFVQTEVcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBhIHR1cGxlIG9mIHR5cGUgYHR5cGVfaWQnIGZpbGxlZCB3aXRoIHZhbHVlcyBmb20gYHNvdXJjZScgaWYgYWxsIHZhbHVlIHR5cGVzIGFyZSBzdWl0YWJsZS5cbiAgICAgIC0tIGBWb2lkJyBpZiBzb21lIHZhbHVlcyBmcm9tIGBzb3VyY2UnIGFyZSBpbmFwcHJvcHJpYXRlIGZvciBhIHR1cGxlIG9mIHR5cGUgYHR5cGVfaWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgICAgaXNfdHVwbGVfdHlwZTogaXNfdHVwbGVfdHlwZSAodHlwZV9pZClcbiAgICAgIC0tIHN1ZmZpY2llbnRfdmFsdWVzX2NvdW50OiBzb3VyY2UuY291bnQgPj0gdHVwbGVfdHlwZV9jb3VudCAodHlwZV9pZClcbiAgICAgIC0tIHZhbGlkX3ZhbHVlX3R5cGVzOiBhY3Jvc3MgMSB8Li58IHR1cGxlX3R5cGVfY291bnQgKHR5cGVfaWQpIGFzIGkgYWxsIHZhbGlkX29iamVjdF9mb3JfdHVwbGVfaW5kZXggKHZhbHVlcyBbaSAtIDFdLCBpKVxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICB2OiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY19uZXdfdHVwbGVfaW5zdGFuY2Vfb2YgKHR5cGVfaWQpXG4gICAgICBpIDo9IFJlc3VsdC5jb3VudFxuICAgICAgaWYgaSA8PSBzb3VyY2UuY291bnQgdGhlblxuICAgICAgICBpZiBzb3VyY2Uub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIFJlc3VsdC5jb21wYXJlX29iamVjdHNcbiAgICAgICAgZW5kXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpIDw9IDAgb3IgZWxzZSBub3QgYXR0YWNoZWQgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICB2IDo9IHNvdXJjZSBbaV1cbiAgICAgICAgICBpZiBSZXN1bHQudmFsaWRfdHlwZV9mb3JfaW5kZXggKHYsIGkpIHRoZW5cbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIGNvbXBhdGlibGUgd2l0aCB0dXBsZSBpdGVtIGF0IGluZGV4IGBpJy5cbiAgICAgICAgICAgIFJlc3VsdCBbaV0gOj0gdlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gVmFsdWUgYHYnIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggdHVwbGUgaXRlbSBhdCBpbmRleCBgaScuXG4gICAgICAgICAgICBSZXN1bHQgOj0gVm9pZFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gSW5zdWZmaWNpZW50IG51bWJlciBvZiB2YWx1ZXMuXG4gICAgICAgIFJlc3VsdCA6PSBWb2lkXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9zZXQ6IGF0dGFjaGVkIFJlc3VsdCBpbXBsaWVzIFJlc3VsdC5nZW5lcmF0aW5nX3R5cGUudHlwZV9pZCA9IHR5cGVfaWRcbiAgICAgIG9iamVjdF9jb21wYXJpc29uX3NldDogYXR0YWNoZWQgUmVzdWx0IGltcGxpZXMgUmVzdWx0Lm9iamVjdF9jb21wYXJpc29uID0gc291cmNlLm9iamVjdF9jb21wYXJpc29uXG4gICAgICB2YWx1ZXNfc2V0OiBhdHRhY2hlZCBSZXN1bHQgaW1wbGllcyBhY3Jvc3MgMSB8Li58IFJlc3VsdC5jb3VudCBhcyBrIGFsbCBSZXN1bHQuaXRlbSAoay5pdGVtKSA9IHNvdXJjZSBbay5pdGVtXSBlbmRcbiAgICBlbmRcblxuICB0eXBlX29mX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBUWVBFIFtkZXRhY2hhYmxlIEFOWV1cbiAgICAgIC0tIEFzc29jaWF0ZWQgVFlQRSBpbnN0YW5jZSBmb3IgYW4gb2JqZWN0IG9mIHR5cGUgaWQgYHR5cGVfaWQnXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjX25ld190eXBlX2luc3RhbmNlX29mICh0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19zcGVjaWFsX2FueV90eXBlICh0eXBlX2lkOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSByZXByZXNlbnRlZCBieSBgdHlwZV9pZCcgcmVwcmVzZW50XG4gICAgICAtLSBhIFNQRUNJQUwgW1hYXSB3aGVyZSBYWCBpcyBhIHJlZmVyZW5jZSB0eXBlLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlIChFSUZfSU5URUdFUik6IEVJRl9CT09MRUFOIHVzZSAlXCJlaWZfaW50ZXJuYWwuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZWlmX3NwZWNpYWxfYW55X3R5cGVcIlxuICAgIGVuZFxuXG4gIGlzX3NwZWNpYWxfdHlwZSAodHlwZV9pZDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIHR5cGUgcmVwcmVzZW50ZWQgYnkgYHR5cGVfaWQnIHJlcHJlc2VudFxuICAgICAgLS0gYSBTUEVDSUFMIFtYWF0gd2hlcmUgWFggaXMgYSByZWZlcmVuY2UgdHlwZVxuICAgICAgLS0gb3IgYSBiYXNpYyB0eXBlLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlIChFSUZfSU5URUdFUik6IEJPT0xFQU4gdXNlICVcImVpZl9pbnRlcm5hbC5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJlaWZfaXNfc3BlY2lhbF90eXBlXCJcbiAgICBlbmRcblxuICBpc190dXBsZV90eXBlICh0eXBlX2lkOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSByZXByZXNlbnRlZCBieSBgdHlwZV9pZCcgcmVwcmVzZW50IGEgVFVQTEU/XG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBzaWduYXR1cmUgKEVJRl9JTlRFR0VSKTogQk9PTEVBTiB1c2UgJVwiZWlmX2ludGVybmFsLmglXCJcIlxuICAgIGFsaWFzXG4gICAgICBcImVpZl9pc190dXBsZV90eXBlXCJcbiAgICBlbmRcblxuICBpc19hdHRhY2hlZF90eXBlIChhX3R5cGVfaWQ6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYV90eXBlX2lkJyBhbiBhdHRhY2hlZCB0eXBlP1xuICAgIHJlcXVpcmVcbiAgICAgIGFfdHlwZV9ub25fbmVnYXRpdmU6IGFfdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uaXNfYXR0YWNoZWRfdHlwZSAoYV90eXBlX2lkKVxuICAgIGVuZFxuXG4gIGlzX2ZpZWxkX3RyYW5zaWVudF9vZl90eXBlIChpOiBJTlRFR0VSOyBhX3R5cGVfaWQ6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaSctdGggZmllbGQgb2YgYG9iamVjdCcgYSB0cmFuc2llbnQgYXR0cmlidXRlP1xuICAgICAgLS0gSS5lLiBhbiBhdHRyaWJ1dGUgdGhhdCBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0b3JlZD9cbiAgICByZXF1aXJlXG4gICAgICBhX3R5cGVfbm9uX25lZ2F0aXZlOiBhX3R5cGVfaWQgPj0gMFxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDFcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBmaWVsZF9jb3VudF9vZl90eXBlIChhX3R5cGVfaWQpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uaXNfZmllbGRfdHJhbnNpZW50X29mX3R5cGUgKGksIGFfdHlwZV9pZClcbiAgICBlbmRcblxuICBpc19maWVsZF9leHBhbmRlZF9vZl90eXBlIChpOiBJTlRFR0VSOyBhX3R5cGVfaWQ6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaSctdGggZmllbGQgb2YgdHlwZSBgYV90eXBlX2lkJyBhIHVzZXItZGVmaW5lZCBleHBhbmRlZCBhdHRyaWJ1dGU/XG4gICAgcmVxdWlyZVxuICAgICAgYV90eXBlX25vbl9uZWdhdGl2ZTogYV90eXBlX2lkID49IDBcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAxXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gZmllbGRfY291bnRfb2ZfdHlwZSAoYV90eXBlX2lkKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LmlzX2ZpZWxkX2V4cGFuZGVkX29mX3R5cGUgKGksIGFfdHlwZV9pZClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBjbGFzc19uYW1lX29mX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIGR5bmFtaWMgdHlwZSBgdHlwZV9pZCcuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uZ2VuZXJhdG9yX29mX3R5cGUgKHR5cGVfaWQpXG4gICAgZW5kXG5cbiAgdHlwZV9uYW1lX29mX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgYHR5cGVfaWQnJ3MgZ2VuZXJhdGluZyB0eXBlICh0eXBlIG9mIHdoaWNoIGB0eXBlX2lkJ1xuICAgICAgLS0gaXMgYSBkaXJlY3QgaW5zdGFuY2UpLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LmdlbmVyYXRpbmdfdHlwZV9vZl90eXBlICh0eXBlX2lkKVxuICAgIGVuZFxuXG4gIGF0dGFjaGVkX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBBdHRhY2hlZCB2ZXJzaW9uIG9mIGB0eXBlX2lkJy5cbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS5hdHRhY2hlZF90eXBlICh0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgdW5jaGFuZ2VkX2lmX2F0dGFjaGVkOiBpc19hdHRhY2hlZF90eXBlICh0eXBlX2lkKSBpbXBsaWVzIHR5cGVfaWQgPSBSZXN1bHRcbiAgICBlbmRcblxuICBkZXRhY2hhYmxlX3R5cGUgKHR5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBEZXRhY2hhYmxlIHZlcnNpb24gb2YgYHR5cGVfaWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIFJlc3VsdCA6PSB7SVNFX1JVTlRJTUV9LmRldGFjaGFibGVfdHlwZSAodHlwZV9pZClcbiAgICBlbnN1cmVcbiAgICAgIHVuY2hhbmdlZF9pZl9kZXRhY2hhYmxlOiBub3QgaXNfYXR0YWNoZWRfdHlwZSAodHlwZV9pZCkgaW1wbGllcyB0eXBlX2lkID0gUmVzdWx0XG4gICAgZW5kXG5cbiAgZ2VuZXJpY19jb3VudF9vZl90eXBlICh0eXBlX2lkOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGdlbmVyaWMgcGFyYW1ldGVyIGluIGB0eXBlX2lkJy5cbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS5nZW5lcmljX3BhcmFtZXRlcl9jb3VudCAodHlwZV9pZClcbiAgICBlbmRcblxuICBnZW5lcmljX2R5bmFtaWNfdHlwZV9vZl90eXBlICh0eXBlX2lkOiBJTlRFR0VSOyBpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gRHluYW1pYyB0eXBlIG9mIGdlbmVyaWMgcGFyYW1ldGVyIG9mIGB0eXBlX2lkJyBhdCBwb3NpdGlvbiBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICB0eXBlX2lkX2dlbmVyaWM6IGdlbmVyaWNfY291bnRfb2ZfdHlwZSAodHlwZV9pZCkgPiAwXG4gICAgICBpX3ZhbGlkOiBpID4gMCBhbmQgaSA8PSBnZW5lcmljX2NvdW50X29mX3R5cGUgKHR5cGVfaWQpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uZWlmX2dlbl9wYXJhbV9pZCAodHlwZV9pZCwgaSlcbiAgICBlbnN1cmVcbiAgICAgIGR5bmFtaWNfdHlwZV9ub25uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBzdG9yYWJsZV92ZXJzaW9uX29mX3R5cGUgKGFfdHlwZV9pZDogSU5URUdFUik6IGRldGFjaGFibGUgSU1NVVRBQkxFX1NUUklOR184XG4gICAgICAtLSBTdG9yYWJsZSB2ZXJzaW9uIGlmIGFueSBzcGVjaWZpZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV90eXBlX2lkX25vbm5lZ2F0aXZlOiBhX3R5cGVfaWQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX3Jlc3VsdCwgbF9udWxsOiBQT0lOVEVSXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gaWRfdG9fc3RvcmFibGVfdmVyc2lvbi5zZWFyY2ggKGFfdHlwZV9pZClcbiAgICAgIC0tIGlmIGlkX3RvX3N0b3JhYmxlX3ZlcnNpb24uZm91bmQgdGhlblxuICAgICAgLS0gICBSZXN1bHQgOj0gaWRfdG9fc3RvcmFibGVfdmVyc2lvbi5mb3VuZF9pdGVtXG4gICAgICAtLSBlbHNlXG4gICAgICAtLSAgIGxfcmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uc3RvcmFibGVfdmVyc2lvbl9vZl90eXBlIChhX3R5cGVfaWQpXG4gICAgICAtLSAgIGlmIGxfcmVzdWx0IC89IGxfbnVsbCB0aGVuXG4gICAgICAtLSAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fYyAobF9yZXN1bHQpXG4gICAgICAtLSAgICAgaWYgUmVzdWx0LmlzX2VtcHR5IHRoZW5cbiAgICAgIC0tICAgICAgIFJlc3VsdCA6PSBWb2lkXG4gICAgICAtLSAgICAgZW5kXG4gICAgICAtLSAgIGVuZFxuICAgICAgLS0gICBpZF90b19zdG9yYWJsZV92ZXJzaW9uLnB1dCAoUmVzdWx0LCBhX3R5cGVfaWQpXG4gICAgICAtLSBlbmRcbiAgICBlbmRcblxuICBmaWVsZF9uYW1lX29mX3R5cGUgKGk6IElOVEVHRVI7IHR5cGVfaWQ6IElOVEVHRVIpOiBTVFJJTkdcbiAgICAgIC0tIE5hbWUgb2YgYGknLXRoIGZpZWxkIG9mIGR5bmFtaWMgdHlwZSBgdHlwZV9pZCcuXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdodDogaSA8PSBmaWVsZF9jb3VudF9vZl90eXBlICh0eXBlX2lkKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICAgIC0tIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX2MgKHtJU0VfUlVOVElNRX0uZmllbGRfbmFtZV9vZl90eXBlIChpLCB0eXBlX2lkKSlcbiAgICBlbmRcblxuICBmaWVsZF90eXBlX29mX3R5cGUgKGk6IElOVEVHRVI7IHR5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIG9mIGBpJy10aCBmaWVsZCBvZiBkeW5hbWljIHR5cGUgYHR5cGVfaWQnXG4gICAgcmVxdWlyZVxuICAgICAgdHlwZV9pZF9ub25uZWdhdGl2ZTogdHlwZV9pZCA+PSAwXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPj0gMVxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGZpZWxkX2NvdW50X29mX3R5cGUgKHR5cGVfaWQpXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0uZmllbGRfdHlwZV9vZl90eXBlIChpLCB0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgZmllbGRfdHlwZV9ub25uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBmaWVsZF9zdGF0aWNfdHlwZV9vZl90eXBlIChpOiBJTlRFR0VSOyB0eXBlX2lkOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gU3RhdGljIHR5cGUgb2YgZGVjbGFyZWQgYGknLXRoIGZpZWxkIG9mIGR5bmFtaWMgdHlwZSBgdHlwZV9pZCdcbiAgICByZXF1aXJlXG4gICAgICB0eXBlX2lkX25vbm5lZ2F0aXZlOiB0eXBlX2lkID49IDBcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAxXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gZmllbGRfY291bnRfb2ZfdHlwZSAodHlwZV9pZClcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgICAtLSBSZXN1bHQgOj0ge0lTRV9SVU5USU1FfS5maWVsZF9zdGF0aWNfdHlwZV9vZl90eXBlIChpLCB0eXBlX2lkKVxuICAgIGVuc3VyZVxuICAgICAgZmllbGRfdHlwZV9ub25uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBWZXJzaW9uXG5cbiAgY29tcGlsZXJfdmVyc2lvbjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgZmllbGRfY291bnRfb2ZfdHlwZSAodHlwZV9pZDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBsb2dpY2FsIGZpZWxkcyBpbiBkeW5hbWljIHR5cGUgYHR5cGVfaWQnLlxuICAgIHJlcXVpcmVcbiAgICAgIHR5cGVfaWRfbm9ubmVnYXRpdmU6IHR5cGVfaWQgPj0gMFxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gc2lnbmF0dXJlIChFSUZfSU5URUdFUik6IEVJRl9JTlRFR0VSIHVzZSAlXCJlaWZfaW50ZXJuYWwuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiZWlfY291bnRfZmllbGRfb2ZfdHlwZVwiXG4gICAgZW5kXG5cbiAgcGVyc2lzdGVudF9maWVsZF9jb3VudF9vZl90eXBlIChhX3R5cGVfaWQ6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgbG9naWNhbCBmaWVsZHMgaW4gZHluYW1pYyB0eXBlIGB0eXBlX2lkJyB0aGF0IGFyZSBub3QgdHJhbnNpZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIGFfdHlwZV9ub25fbmVnYXRpdmU6IGFfdHlwZV9pZCA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0ucGVyc2lzdGVudF9maWVsZF9jb3VudF9vZl90eXBlIChhX3R5cGVfaWQpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgaW50ZXJuYWxfZHluYW1pY190eXBlX3N0cmluZ190YWJsZTogU1RSSU5HX1RBQkxFIFtJTlRFR0VSXVxuICAgICAgLS0gVGFibGUgb2YgZHluYW1pYyB0eXBlIGluZGV4ZWQgYnkgdHlwZSBuYW1lXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMDApXG4gICAgZW5zdXJlXG4gICAgICBpbnRlcm5hbF9keW5hbWljX3R5cGVfc3RyaW5nX3RhYmxlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGlkX3RvX3N0b3JhYmxlX3ZlcnNpb246IEhBU0hfVEFCTEUgW2RldGFjaGFibGUgSU1NVVRBQkxFX1NUUklOR184LCBJTlRFR0VSXVxuICAgICAgLS0gQnVmZmVyIGZvciBgc3RvcmFibGVfdmVyc2lvbl9vZl90eXBlJyBsb29rdXBzIGluZGV4IGJ5IHR5cGVfaWQuXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMDApXG4gICAgZW5zdXJlXG4gICAgICBpZF90b19zdG9yYWJsZV92ZXJzaW9uX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGNfbmV3X2luc3RhbmNlX29mICh0eXBlX2lkOiBJTlRFR0VSKTogQU5ZXG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgZHluYW1pYyBgdHlwZV9pZCcuXG4gICAgICAtLSBOb3RlOiByZXR1cm5lZCBvYmplY3QgaXMgbm90IGluaXRpYWxpemVkIGFuZCBtYXlcbiAgICAgIC0tIGhlbmNlIHZpb2xhdGUgaXRzIGludmFyaWFudC5cbiAgICAgIC0tIGB0eXBlX2lkJyBjYW5ub3QgcmVwcmVzZW50IGEgU1BFQ0lBTCB0eXBlLCB1c2VcbiAgICAgIC0tIGBuZXdfc3BlY2lhbF9hbnlfaW5zdGFuY2UnIGluc3RlYWQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX21hY3Jvcy5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJSVExOU01BUlRcIlxuICAgIGVuZFxuXG4gIGNfbmV3X3R1cGxlX2luc3RhbmNlX29mICh0eXBlX2lkOiBJTlRFR0VSKTogVFVQTEVcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiB0dXBsZSBvZiB0eXBlIGB0eXBlX2lkJy5cbiAgICAgIC0tIE5vdGU6IHJldHVybmVkIG9iamVjdCBpcyBub3QgaW5pdGlhbGl6ZWQgYW5kIG1heVxuICAgICAgLS0gaGVuY2UgdmlvbGF0ZSBpdHMgaW52YXJpYW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9tYWNyb3MuaCVcIlwiXG4gICAgYWxpYXNcbiAgICAgIFwiUlRMTlRcIlxuICAgIGVuZFxuXG4gIGNfbmV3X3R5cGVfaW5zdGFuY2Vfb2YgKHR5cGVfaWQ6IElOVEVHRVIpOiBUWVBFIFtkZXRhY2hhYmxlIEFOWV1cbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBUWVBFIGZvciBvYmplY3Qgb2YgdHlwZSBgdHlwZV9pZCcuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX21hY3Jvcy5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJSVExOVFlcIlxuICAgIGVuZFxuXG4gIGNfc2V0X2R5bmFtaWNfdHlwZSAob2JqOiBTUEVDSUFMIFtkZXRhY2hhYmxlIEFOWV07IGR0eXBlOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBvYmonIGR5bmFtaWMgdHlwZSB0byBgZHR5cGUnLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luIHN0YXRpY1wiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEzLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb25zdGFudHMgdG8gcmVwcmVzZW50IGFic3RyYWN0IHR5cGVzIGluIHtSRUZGTEVDVE9SfSBhbmQge09CSkVDVF9QUk9YWX0uXCJcbiAgY2VjaWw6IFwiVGhlIHZhbHVlcyBhcmUgaW4gc3luYyB3aXRoIENFQ0lMIGNvbnN0YW50cyBFSUZfKl9UWVBFLlwiXG4gIHJ1bnRpbWU6IFwiVGhlIHZhbHVlcyByZXByZXNlbnQgYWJzdHJhY3QgdHlwZXMgdXNlZCBieSBydW4tdGltZSwgZS5nLiB7SVNFX1JVTlRJTUV9LmZpZWxkX3R5cGVfb2ZfdHlwZS5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA1LTIwIDE2OjE1OjE3IC0wNzAwIChNb24sIDIwIE1heSAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjU1NyAkXCJcblxuY2xhc3NcbiAgUkVGTEVDVE9SX0NPTlNUQU5UU1xuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIG5vbmVfdHlwZTogSU5URUdFUiA9IC0yXG4gICAgICAtLSBUeXBlIElEIHJlcHJlc2VudGF0aW9uIGZvciBOT05FLlxuXG4gIHBvaW50ZXJfdHlwZTogSU5URUdFUiA9IDBcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7UE9JTlRFUn0uXG5cbiAgcmVmZXJlbmNlX3R5cGU6IElOVEVHRVIgPSAxXG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBhIHJlZmVyZW5jZSB0eXBlLlxuXG4gIGNoYXJhY3Rlcl84X3R5cGUsIGNoYXJhY3Rlcl90eXBlOiBJTlRFR0VSID0gMlxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtDSEFSQUNURVJfOH0uXG5cbiAgYm9vbGVhbl90eXBlOiBJTlRFR0VSID0gM1xuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtCT09MRUFOfS5cblxuICBpbnRlZ2VyXzMyX3R5cGUsIGludGVnZXJfdHlwZTogSU5URUdFUiA9IDRcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7SU5URUdFUl8zMn0uXG5cbiAgcmVhbF8zMl90eXBlLCByZWFsX3R5cGU6IElOVEVHRVIgPSA1XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBwcmVkZWZpbmVkIHR5cGUge1JFQUxfMzJ9LlxuXG4gIHJlYWxfNjRfdHlwZSwgZG91YmxlX3R5cGU6IElOVEVHRVIgPSA2XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBwcmVkZWZpbmVkIHR5cGUge1JFQUxfNjR9LlxuXG4gIGV4cGFuZGVkX3R5cGU6IElOVEVHRVIgPSA3XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBhIG5vbi1wcmVkZWZpbmVkIGV4cGFuZGVkIHR5cGUuXG5cbiAgYml0X3R5cGU6IElOVEVHRVIgPSA4XG4gICAgICAtLSBUaGlzIHR5cGUgaXMgb2Jzb2xldGUgYW5kIGlzIG5vdCB1c2VkIGFueW1vcmUuXG5cbiAgaW50ZWdlcl84X3R5cGU6IElOVEVHRVIgPSA5XG4gICAgICAtLSBBYnN0cmFjdCB0eXBlIElEIGZvciBwcmVkZWZpbmVkIHR5cGUge0lOVEVHRVJfOH0uXG5cbiAgaW50ZWdlcl8xNl90eXBlOiBJTlRFR0VSID0gMTBcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7SU5URUdFUl8xNn0uXG5cbiAgaW50ZWdlcl82NF90eXBlOiBJTlRFR0VSID0gMTFcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7SU5URUdFUl82NH0uXG5cbiAgY2hhcmFjdGVyXzMyX3R5cGUsIHdpZGVfY2hhcmFjdGVyX3R5cGU6IElOVEVHRVIgPSAxMlxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtDSEFSQUNURVJfMzJ9LlxuXG4gIG5hdHVyYWxfOF90eXBlOiBJTlRFR0VSID0gMTNcbiAgICAgIC0tIEFic3RyYWN0IHR5cGUgSUQgZm9yIHByZWRlZmluZWQgdHlwZSB7TkFUVVJBTF84fS5cblxuICBuYXR1cmFsXzE2X3R5cGU6IElOVEVHRVIgPSAxNFxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtOQVRVUkFMXzE2fS5cblxuICBuYXR1cmFsXzMyX3R5cGU6IElOVEVHRVIgPSAxNVxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtOQVRVUkFMXzMyfS5cblxuICBuYXR1cmFsXzY0X3R5cGU6IElOVEVHRVIgPSAxNlxuICAgICAgLS0gQWJzdHJhY3QgdHlwZSBJRCBmb3IgcHJlZGVmaW5lZCB0eXBlIHtOQVRVUkFMXzY0fS5cblxuICBtaW5fcHJlZGVmaW5lZF90eXBlOiBJTlRFR0VSID0gLTJcbiAgbWF4X3ByZWRlZmluZWRfdHlwZTogSU5URUdFUiA9IDE2XG5cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiSGVscGVyIGZvciByb3V0aW5lcyBpbiBJTlRFUk5BTCBjbGFzcy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDMtMDQgMTU6MDE6MjUgLTA4MDAgKE1vbiwgMDQgTWFyIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTc4ICRcIlxuXG5jbGFzc1xuICBSRUZMRUNUT1JfSEVMUEVSXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX3ByZV9lY21hX21hcHBpbmdfZGlzYWJsZWQ6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB3ZSBtYXBwaW5nIG9sZCBuYW1lcyB0byBuZXcgRUNNQSBuYW1lcz9cbiAgICAgIC0tIEZhbHNlIG1lYW5zIG1hcHBpbmcgU1RSSU5HIHRvIFNUUklOR184LCBJTlRFR0VSIHRvIElOVEVHRVJfMzIsLi4uXG4gICAgICAtLSBSZWRlZmluZSBpbiBkZXNjZW5kYW50cyBvZiBSRUZMRUNUT1IgdG8gbW9kaWZ5IHRoZSBiZWhhdmlvciBvZiBpbnNwZWN0aW9uIHF1ZXJpZXMgb2YgUkVGTEVDVE9SLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICBlbmRcblxuICBpc192YWxpZF90eXBlX3N0cmluZyAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgcycgYSB2YWxpZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGEgVFlQRS5cbiAgICBsb2NhbFxuICAgICAgbF90eXBlX25hbWU6IFNUUklOR18zMlxuICAgICAgbF9zdGFydF9wb3MsIGxfZW5kX3BvczogSU5URUdFUlxuICAgICAgbF9jbGFzc190eXBlX25hbWU6IFNUUklOR18zMlxuICAgICAgbF9wYXJhbWV0ZXJzOiBsaWtlIHBhcmFtZXRlcnNfZGVjb21wb3NpdGlvblxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgYW5kIHRoZW4gbm90IHMuaXNfZW1wdHkgdGhlblxuICAgICAgICBjcmVhdGUgbF9jbGFzc190eXBlX25hbWUubWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChzKVxuICAgICAgICBsX2NsYXNzX3R5cGVfbmFtZS5sZWZ0X2FkanVzdFxuICAgICAgICBsX2NsYXNzX3R5cGVfbmFtZS5yaWdodF9hZGp1c3RcblxuICAgICAgICAgIC0tIExldCdzIHNlZSBpZiBpdCBpcyBhIGdlbmVyaWMgdHlwZS5cbiAgICAgICAgbF9zdGFydF9wb3MgOj0gbF9jbGFzc190eXBlX25hbWUuaW5kZXhfb2YgKCdbJywgMSlcblxuICAgICAgICBpZiBsX3N0YXJ0X3BvcyA+IDEgdGhlblxuICAgICAgICAgICAgLS0gTG9va3MgbGlrZSBpdCBpcyBhIGdlbmVyaWMgY2xhc3MuXG4gICAgICAgICAgbF9lbmRfcG9zIDo9IGxfY2xhc3NfdHlwZV9uYW1lLmNvdW50XG4gICAgICAgICAgaWYgbF9jbGFzc190eXBlX25hbWUuaXRlbSAobF9lbmRfcG9zKSAvPSAnXScgdGhlblxuICAgICAgICAgICAgbF9lbmRfcG9zIDo9IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpZlxuICAgICAgICAgICAgbF9lbmRfcG9zID0gbF9jbGFzc190eXBlX25hbWUuY291bnQgYW5kIGxfc3RhcnRfcG9zIDwgbF9lbmRfcG9zIGFuZFxuICAgICAgICAgICAgbF9jbGFzc190eXBlX25hbWUub2NjdXJyZW5jZXMgKCdbJykgPSBsX2NsYXNzX3R5cGVfbmFtZS5vY2N1cnJlbmNlcyAoJ10nKVxuICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgLS0gQSB3ZWxsIGZvcm1lZCBnZW5lcmljIGNsYXNzLlxuICAgICAgICAgICAgbF90eXBlX25hbWUgOj0gbF9jbGFzc190eXBlX25hbWUuc3Vic3RyaW5nICgxLCBsX3N0YXJ0X3BvcyAtIDEpXG4gICAgICAgICAgICBsX3R5cGVfbmFtZS5sZWZ0X2FkanVzdFxuICAgICAgICAgICAgbF90eXBlX25hbWUucmlnaHRfYWRqdXN0XG5cbiAgICAgICAgICAgIGlmIGlzX3ZhbGlkX2lkZW50aWZpZXIgKGxfdHlwZV9uYW1lKSB0aGVuXG4gICAgICAgICAgICAgIGxfcGFyYW1ldGVycyA6PSBwYXJhbWV0ZXJzX2RlY29tcG9zaXRpb24gKFxuICAgICAgICAgICAgICAgIGxfY2xhc3NfdHlwZV9uYW1lLnN1YnN0cmluZyAobF9zdGFydF9wb3MgKyAxLCBsX2VuZF9wb3MgLSAxKSlcbiAgICAgICAgICAgICAgaWYgbF9wYXJhbWV0ZXJzIC89IFZvaWQgdGhlblxuICAgICAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICAgICAgICBsX3BhcmFtZXRlcnMuc3RhcnRcbiAgICAgICAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgICAgICAgbF9wYXJhbWV0ZXJzLmFmdGVyIG9yIG5vdCBSZXN1bHRcbiAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfdHlwZV9zdHJpbmcgKGxfcGFyYW1ldGVycy5pdGVtKVxuICAgICAgICAgICAgICAgICAgbF9wYXJhbWV0ZXJzLmZvcnRoXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEVuc3VyZXMgdGhhdCBpdCBpcyBhIHZhbGlkIHR5cGUgbmFtZS5cbiAgICAgICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaWRlbnRpZmllciAobF9jbGFzc190eXBlX25hbWUpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWFwcGVkX3R5cGUgKGFfdHlwZTogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgICAgLS0gSWYgYGlzX3ByZV9lY21hX21hcHBpbmdfZGlzYWJsZWQnIGBhX3R5cGUnLCBvdGhlcndpc2VcbiAgICAgIC0tIHRoZSBtYXBwZWQgdHlwZWQuXG4gICAgcmVxdWlyZVxuICAgICAgYV90eXBlX25vdF92b2lkOiBhX3R5cGUgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBsX3RhYmxlOiBsaWtlIHByZV9lY21hX3R5cGVfbWFwcGluZ1xuICAgICAgcjogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfcHJlX2VjbWFfbWFwcGluZ19kaXNhYmxlZCB0aGVuXG4gICAgICAgIGxfdGFibGUgOj0gcHJlX2VjbWFfdHlwZV9tYXBwaW5nXG4gICAgICAgIGxfdGFibGUuc2VhcmNoIChhX3R5cGUpXG4gICAgICAgIGlmIGxfdGFibGUuZm91bmQgdGhlblxuICAgICAgICAgIHIgOj0gbF90YWJsZS5mb3VuZF9pdGVtXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiByID0gVm9pZCB0aGVuXG4gICAgICAgIHIgOj0gYV90eXBlXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSByXG4gICAgZW5zdXJlXG4gICAgICBtYXBwZWRfdHlwZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb246IHN0YXR1cyByZXBvcnRcblxuICBpc192YWxpZF9pZGVudGlmaWVyIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBzJyBhIHZhbGlkIEVpZmZlbCBpZGVudGlmaWVyP1xuICAgIHJlcXVpcmVcbiAgICAgIG5hbWVfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgY2M6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICBpZiBub3Qgcy5pc19lbXB0eSB0aGVuXG4gICAgICAgIGNjIDo9IHMuaXRlbSAoMSlcbiAgICAgICAgbmIgOj0gcy5jb3VudCArIDFcbiAgICAgICAgaWYgY2MgPSBhdHRhY2hlZF9tYXJrIG9yIGNjID0gZGV0YWNoYWJsZV9tYXJrIHRoZW5cbiAgICAgICAgICBpIDo9IDJcbiAgICAgICAgZWxzZWlmIHMuc3Vic3RyaW5nX2luZGV4IChhdHRhY2hlZF9rZXl3b3JkLCAxKSA9IDEgdGhlblxuICAgICAgICAgIGkgOj0gYXR0YWNoZWRfa2V5d29yZC5jb3VudCArIDFcbiAgICAgICAgZWxzZWlmIHMuc3Vic3RyaW5nX2luZGV4IChkZXRhY2hhYmxlX2tleXdvcmQsIDEpID0gMSB0aGVuXG4gICAgICAgICAgaSA6PSBkZXRhY2hhYmxlX2tleXdvcmQuY291bnQgKyAxXG4gICAgICAgIGVsc2VpZiBzLnN1YnN0cmluZ19pbmRleCAoZXhwYW5kZWRfa2V5d29yZCwgMSkgPSAxIHRoZW5cbiAgICAgICAgICBpIDo9IGV4cGFuZGVkX2tleXdvcmQuY291bnQgKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPiAxIHRoZW5cbiAgICAgICAgICAgIC0tIFJlbW92ZSBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBhdHRhY2htZW50IG1hcmsgYW5kIHRoZSB0eXBlIG5hbWUuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmIgb3Igbm90IHMuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBzLml0ZW0gKGkpLmlzX2FscGhhIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBjYyA6PSBzLml0ZW0gKGkpXG4gICAgICAgICAgICBpZiBub3QgKGNjLmlzX2FscGhhIG9yIGNjLmlzX2RpZ2l0IG9yIGNjID0gJ18nKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIERlY29tcG9zZSBzdHJpbmcgdHlwZVxuXG4gIHBhcmFtZXRlcnNfZGVjb21wb3NpdGlvbiAoYV9zdHI6IFJFQURBQkxFX1NUUklOR18zMik6IGRldGFjaGFibGUgQVJSQVlFRF9MSVNUIFtSRUFEQUJMRV9TVFJJTkdfMzJdXG4gICAgICAtLSBEZWNvbXBvc2UgYGFfc3RyJyB3aGljaCBzaG91bGQgYmUgb2YgdGhlIGZvcm0gXCJBLCBCLCBEIFtHXSwgSCBbRSAsRl1cIlxuICAgICAgLS0gaW50byBhIGxpc3Qgb2Ygc3RyaW5ncyBcIkFcIiwgXCJCXCIsIFwiRCBbR11cIiwgXCJIIFtFLCBGXVwiXG4gICAgICAtLSBJZiBkZWNvbXBvc2l0aW9uIGlzIG5vdCBwb3NzaWJsZSwgVm9pZC5cbiAgICByZXF1aXJlXG4gICAgICBhX3N0cl9ub3Rfdm9pZDogYV9zdHIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9pbnZhbGlkOiBCT09MRUFOXG4gICAgICBsX2ZpcnN0X3BvczogSU5URUdFUlxuICAgICAgbF9uZXN0aW5nOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICg1KVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgbF9maXJzdF9wb3MgOj0gMVxuICAgICAgICBuYiA6PSBhX3N0ci5jb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iIG9yIGxfaW52YWxpZFxuICAgICAgbG9vcFxuICAgICAgICBpbnNwZWN0XG4gICAgICAgICAgYV9zdHIuaXRlbSAoaSlcbiAgICAgICAgd2hlbiAnLCcgdGhlblxuICAgICAgICAgIGlmIGxfbmVzdGluZyA9IDAgdGhlblxuICAgICAgICAgICAgUmVzdWx0LmV4dGVuZCAoYV9zdHIuc3Vic3RyaW5nIChsX2ZpcnN0X3BvcywgaSAtIDEpKVxuICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgd2hlbiAnWycgdGhlblxuICAgICAgICAgIGxfbmVzdGluZyA6PSBsX25lc3RpbmcgKyAxXG4gICAgICAgIHdoZW4gJ10nIHRoZW5cbiAgICAgICAgICBsX25lc3RpbmcgOj0gbF9uZXN0aW5nIC0gMVxuICAgICAgICAgIGxfaW52YWxpZCA6PSBsX25lc3RpbmcgPCAwXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAtLSBEbyBub3RoaW5nXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIG5vdCBsX2ludmFsaWQgYW5kIHRoZW4gbF9uZXN0aW5nID0gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5leHRlbmQgKGFfc3RyLnN1YnN0cmluZyAobF9maXJzdF9wb3MsIGkgLSAxKSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IFZvaWRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBFQ01BIG1hcHBpbmcgaGVscGVyXG5cbiAgcHJlX2VjbWFfdHlwZV9tYXBwaW5nOiBTVFJJTkdfVEFCTEUgW1NUUklOR11cbiAgICAgIC0tIE1hcHBpbmcgYmV0d2VlbiBwcmUtRUNNQSB0eXBlIG5hbWluZyBhbmQgbmV3IG5hbWVzLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMTIpXG4gICAgICBSZXN1bHQucHV0IChcIlNUUklOR184XCIsIFwiU1RSSU5HXCIpXG4gICAgICBSZXN1bHQucHV0IChcIklOVEVHRVJfMzJcIiwgXCJJTlRFR0VSXCIpXG4gICAgICBSZXN1bHQucHV0IChcIklOVEVHRVJfMzJfUkVGXCIsIFwiSU5URUdFUl9SRUZcIilcbiAgICAgIFJlc3VsdC5wdXQgKFwiQ0hBUkFDVEVSXzhcIiwgXCJDSEFSQUNURVJcIilcbiAgICAgIFJlc3VsdC5wdXQgKFwiQ0hBUkFDVEVSXzhfUkVGXCIsIFwiQ0hBUkFDVEVSX1JFRlwiKVxuICAgICAgUmVzdWx0LnB1dCAoXCJDSEFSQUNURVJfMzJcIiwgXCJXSURFX0NIQVJBQ1RFUlwiKVxuICAgICAgUmVzdWx0LnB1dCAoXCJDSEFSQUNURVJfMzJfUkVGXCIsIFwiV0lERV9DSEFSQUNURVJfUkVGXCIpXG4gICAgICBSZXN1bHQucHV0IChcIlJFQUxfMzJcIiwgXCJSRUFMXCIpXG4gICAgICBSZXN1bHQucHV0IChcIlJFQUxfMzJfUkVGXCIsIFwiUkVBTF9SRUZcIilcbiAgICAgIFJlc3VsdC5wdXQgKFwiUkVBTF82NFwiLCBcIkRPVUJMRVwiKVxuICAgICAgUmVzdWx0LnB1dCAoXCJSRUFMXzY0X1JFRlwiLCBcIkRPVUJMRV9SRUZcIilcbiAgICBlbnN1cmVcbiAgICAgIHByZV9lY21hX3R5cGVfbWFwcGluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBhdHRhY2hlZF9tYXJrOiBDSEFSQUNURVJfMzIgPSAnISdcbiAgZGV0YWNoYWJsZV9tYXJrOiBDSEFSQUNURVJfMzIgPSAnPydcbiAgYXR0YWNoZWRfa2V5d29yZDogU1RSSU5HID0gXCJhdHRhY2hlZFwiXG4gIGRldGFjaGFibGVfa2V5d29yZDogU1RSSU5HID0gXCJkZXRhY2hhYmxlXCJcbiAgZXhwYW5kZWRfa2V5d29yZDogU1RSSU5HID0gXCJleHBhbmRlZFwiXG4gICAgICAtLSBTeW1ib2xzIHVzZSBmb3IgYXR0YWNobWVudCBtYXJrcy5cblxuZmVhdHVyZSB7Tk9ORX0gLS0gVHlwZSBjcmVhdGlvblxuXG4gIHR5cGVfa2V5d29yZDogU1RSSU5HID0gXCJUWVBFXCI7XG4gICAgICAtLSBVc2VkIGZvciBjcmVhdGluZyB0eXBlIG9iamVjdHMuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiRmluaXRlIHN0cnVjdHVyZXMgd2hvc2UgaXRlbSBjb3VudCBpcyBzdWJqZWN0IHRvIGNoYW5nZVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHN0b3JhZ2U7XG4gIHNpemU6IHJlc2l6YWJsZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIFJFU0laQUJMRSBbR10gaW5oZXJpdFxuXG4gIEJPVU5ERUQgW0ddXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBHcm93dGhfcGVyY2VudGFnZTogSU5URUdFUiA9IDUwXG4gICAgICAtLSBQZXJjZW50YWdlIGJ5IHdoaWNoIHN0cnVjdHVyZSB3aWxsIGdyb3cgYXV0b21hdGljYWxseVxuXG4gIE1pbmltYWxfaW5jcmVhc2U6IElOVEVHRVIgPSA1XG4gICAgICAtLSBNaW5pbWFsIG51bWJlciBvZiBhZGRpdGlvbmFsIGl0ZW1zXG5cbiAgYWRkaXRpb25hbF9zcGFjZTogSU5URUdFUlxuICAgICAgLS0gUHJvcG9zZWQgbnVtYmVyIG9mIGFkZGl0aW9uYWwgaXRlbXNcbiAgICAgIC0tfCBSZXN1bHQgaXMgYSByZWFzb25hYmxlIHZhbHVlLCByZXN1bHRpbmcgZnJvbSBhIHNwYWNlLXRpbWUgdHJhZGVvZmYuXG4gICAgZG9cbiAgICAgICAgLS0gVG8gcHJldmVudCBvdmVyZmxvdyB3ZSBkbyBub3QgdXNlIGBncm93dGhfcGVyY2VudGFnZScgYnV0IGl0cyBrbm93biB2YWx1ZS5cbiAgICAgIFJlc3VsdCA6PSAoY2FwYWNpdHkgLy8gMikubWF4IChNaW5pbWFsX2luY3JlYXNlKVxuICAgIGVuc3VyZVxuICAgICAgQXRfbGVhc3Rfb25lOiBSZXN1bHQgPj0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZXNpemFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgY2FwYWNpdHknIGJlIGNoYW5nZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBhdXRvbWF0aWNfZ3Jvd1xuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhY2NvbW1vZGF0ZSBhdCBsZWFzdFxuICAgICAgLS0gYEdyb3d0aF9wZXJjZW50YWdlJyBtb3JlIGl0ZW1zLlxuICAgICAgLS18IFRyYWRlcyBzcGFjZSBmb3IgdGltZTpcbiAgICAgIC0tfCBhbGxvY2F0ZXMgZmFpcmx5IGxhcmdlIGNodW5rcyBvZiBtZW1vcnkgYnV0IG5vdCB2ZXJ5IG9mdGVuLlxuICAgIHJlcXVpcmVcbiAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlXG4gICAgZG9cbiAgICAgIGdyb3cgKGNhcGFjaXR5ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICBlbnN1cmVcbiAgICAgIGluY3JlYXNlZF9jYXBhY2l0eTogY2FwYWNpdHkgPj0gb2xkIGNhcGFjaXR5ICsgb2xkIGFkZGl0aW9uYWxfc3BhY2VcbiAgICBlbmRcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgY2FwYWNpdHkgaXMgYXQgbGVhc3QgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jYXBhY2l0eTogY2FwYWNpdHkgPj0gaVxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIERlY3JlYXNlIGBjYXBhY2l0eScgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICAtLSBBcHBseSB0byByZWR1Y2UgYWxsb2NhdGVkIHN0b3JhZ2UuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBtaW5pbWFsX2NhcGFjaXR5OiBjYXBhY2l0eSA9IGNvdW50XG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGluY3JlYXNlX2J5X2F0X2xlYXN0X29uZTogTWluaW1hbF9pbmNyZWFzZSA+PSAxXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgT2JqZWN0cyByZXByZXNlbnRpbmcgZGVsYXllZCBjYWxscyB0byBhIHJvdXRpbmUsXG4gICAgd2l0aCBzb21lIG9wZXJhbmRzIHBvc3NpYmx5IHN0aWxsIG9wZW5cbiAgICBdXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTI4IDE0OjM1OjIzIC0wODAwIChUdWUsIDI4IEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDEwOSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgUk9VVElORSBbQkFTRV9UWVBFIC0+IGRldGFjaGFibGUgQU5ZLCBPUEVOX0FSR1MgLT4gZGV0YWNoYWJsZSBUVVBMRSBjcmVhdGUgZGVmYXVsdF9jcmVhdGUgZW5kXVxuXG5pbmhlcml0XG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFJFRkxFQ1RPUlxuICAgIGV4cG9ydFxuICAgICAge05PTkV9IGFsbFxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LFxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIGFkYXB0IChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIGBvdGhlcicuXG4gICAgICAtLSBVc2VmdWwgaW4gZGVzY2VuZGFudHMuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBjb25mb3JtaW5nOiBjb25mb3Jtc190byAob3RoZXIpXG4gICAgZG9cbiAgICAgIHJvdXRfZGlzcCA6PSBvdGhlci5yb3V0X2Rpc3BcbiAgICAgIGVuY2Fwc19yb3V0X2Rpc3AgOj0gb3RoZXIuZW5jYXBzX3JvdXRfZGlzcFxuICAgICAgY2FsY19yb3V0X2FkZHIgOj0gb3RoZXIuY2FsY19yb3V0X2FkZHJcbiAgICAgIGNsb3NlZF9vcGVyYW5kcyA6PSBvdGhlci5jbG9zZWRfb3BlcmFuZHNcbiAgICAgIG9wZXJhbmRzIDo9IG90aGVyLm9wZXJhbmRzXG4gICAgICByb3V0aW5lX2lkIDo9IG90aGVyLnJvdXRpbmVfaWRcbiAgICAgIGlzX2Jhc2ljIDo9IG90aGVyLmlzX2Jhc2ljXG4gICAgICBpc190YXJnZXRfY2xvc2VkIDo9IG90aGVyLmlzX3RhcmdldF9jbG9zZWRcbiAgICAgIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQgOj0gb3RoZXIud3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudFxuICAgICAgb3Blbl9jb3VudCA6PSBvdGhlci5vcGVuX2NvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgZnJvemVuIG9wZXJhbmRzOiBkZXRhY2hhYmxlIE9QRU5fQVJHU1xuXG4gIHRhcmdldDogZGV0YWNoYWJsZSBBTllcbiAgICAgIC0tIFRhcmdldCBvZiBjYWxsXG4gICAgbG9jYWxcbiAgICAgIGM6IGxpa2UgY2xvc2VkX29wZXJhbmRzXG4gICAgZG9cbiAgICAgICAgLS0gQmVjYXVzZSBhIHRhcmdldCBvYmplY3QgaXMgbmV2ZXIgc2VwYXJhdGUgcmVsYXRpdmUgdG8gdGhlIHJvdXRpbmUgb2JqZWN0LFxuICAgICAgICAtLSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgY2hlY2tlZCBhZ2FpbnN0IHtBTll9IHJhdGhlciB0aGFuIHtzZXBhcmF0ZSBBTll9LlxuICAgICAgaWYgaXNfdGFyZ2V0X2Nsb3NlZCB0aGVuXG4gICAgICAgIGMgOj0gY2xvc2VkX29wZXJhbmRzXG4gICAgICAgIGlmIGMgLz0gVm9pZCBhbmQgdGhlbiBjLmNvdW50ID4gMCBhbmQgdGhlbiBhdHRhY2hlZCB7QU5ZfSBjLml0ZW0gKDEpIGFzIHIgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSByXG4gICAgICAgIGVuZFxuICAgICAgZWxzZWlmIGF0dGFjaGVkIHtUVVBMRX0gb3BlcmFuZHMgYXMgbyBhbmQgdGhlbiBvLmNvdW50ID4gMCBhbmQgdGhlbiBhdHRhY2hlZCB7QU5ZfSBvLml0ZW0gKDEpIGFzIHIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSByb3V0X2Rpc3AuaGFzaF9jb2RlLmJpdF94b3IgKHJvdXRpbmVfaWQuaGFzaF9jb2RlKVxuICAgIGVuZFxuXG4gIHByZWNvbmRpdGlvbiAoYXJnczogbGlrZSBvcGVyYW5kcyk6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBhcmdzJyBzYXRpc2Z5IHJvdXRpbmUncyBwcmVjb25kaXRpb25cbiAgICAgIC0tIGluIGN1cnJlbnQgc3RhdGU/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAtLXwgRklYTUUgY29tcGlsZXIgc3VwcG9ydCBuZWVkZWQhXG4gICAgZW5kXG5cbiAgcG9zdGNvbmRpdGlvbiAoYXJnczogbGlrZSBvcGVyYW5kcyk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBzdGF0ZSBzYXRpc2Z5IHJvdXRpbmUnc1xuICAgICAgLS0gcG9zdGNvbmRpdGlvbiBmb3IgYGFyZ3MnP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgLS18IEZJWE1FIGNvbXBpbGVyIHN1cHBvcnQgbmVlZGVkIVxuICAgIGVuZFxuXG4gIGVtcHR5X29wZXJhbmRzOiBhdHRhY2hlZCBPUEVOX0FSR1NcbiAgICAgIC0tIEVtcHR5IHR1cGxlIG1hdGNoaW5nIG9wZW4gb3BlcmFuZHMuXG4gICAgb2Jzb2xldGUgXCJUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZCBhcyBub24tdm9pZC1zYWZlLiBbMjIuMDcuMjAxM11cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9vcGVyYW5kc19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgY2FsbGFibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBDYW4gcm91dGluZSBiZSBjYWxsZWQgb24gY3VycmVudCBvYmplY3Q/XG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBhc3NvY2lhdGVkIHJvdXRpbmUgdGhlIHNhbWUgYXMgdGhlIG9uZVxuICAgICAgLS0gYXNzb2NpYXRlZCB3aXRoIGBvdGhlcicuXG4gICAgZG9cbiAgICAgIC0tfCBEbyBub3QgY29tcGFyZSBpbXBsZW1lbnRhdGlvbiBkYXRhXG4gICAgICBSZXN1bHQgOj0gY2xvc2VkX29wZXJhbmRzIH4gb3RoZXIuY2xvc2VkX29wZXJhbmRzXG4gICAgICAgIGFuZCB0aGVuIG9wZXJhbmRzIH4gb3RoZXIub3BlcmFuZHNcbiAgICAgICAgYW5kIHRoZW4gb3Blbl9tYXAgfiBvdGhlci5vcGVuX21hcFxuICAgICAgICBhbmQgdGhlbiAocm91dF9kaXNwID0gb3RoZXIucm91dF9kaXNwKVxuICAgICAgICBhbmQgdGhlbiAocm91dGluZV9pZCA9IG90aGVyLnJvdXRpbmVfaWQpXG4gICAgICAgIGFuZCB0aGVuICh3cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50ID0gb3RoZXIud3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudClcbiAgICAgICAgYW5kIHRoZW4gKGVuY2Fwc19yb3V0X2Rpc3AgPSBvdGhlci5lbmNhcHNfcm91dF9kaXNwKVxuICAgICAgICBhbmQgdGhlbiAoY2FsY19yb3V0X2FkZHIgPSBvdGhlci5jYWxjX3JvdXRfYWRkcilcbiAgICBlbmRcblxuICB2YWxpZF9vcGVyYW5kcyAoYXJnczogZGV0YWNoYWJsZSBzZXBhcmF0ZSBUVVBMRSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYXJncycgdmFsaWQgb3BlcmFuZHMgZm9yIHRoaXMgcm91dGluZT9cbiAgICBsb2NhbFxuICAgICAgaSwgYXJnX3R5cGVfY29kZTogSU5URUdFUlxuICAgICAgYXJnOiBsaWtlIHtUVVBMRX0uaXRlbVxuICAgICAgb3Blbl90eXBlX2NvZGVzOiBTVFJJTkdcbiAgICAgIGxfdHlwZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhcmdzID0gVm9pZCB0aGVuXG4gICAgICAgICAgLS0gVm9pZCBvcGVyYW5kcyBhcmUgb25seSBhbGxvd2VkXG4gICAgICAgICAgLS0gaWYgb2JqZWN0IGhhcyBubyBvcGVuIG9wZXJhbmRzLlxuICAgICAgICBSZXN1bHQgOj0gKG9wZW5fY291bnQgPSAwKVxuICAgICAgZWxzZWlmIGFyZ3MuY291bnQgPj0gb3Blbl9jb3VudCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIG9wZW5fdHlwZV9jb2RlcyA6PSBlaWZfZ2VuX3R5cGVjb2RlX3N0ciAoJEN1cnJlbnQpXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG9wZW5fY291bnQgb3Igbm90IFJlc3VsdFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXJnX3R5cGVfY29kZSA6PSBhcmdzLml0ZW1fY29kZSAoaSlcbiAgICAgICAgICBSZXN1bHQgOj0gYXJnX3R5cGVfY29kZSA9IG9wZW5fdHlwZV9jb2Rlcy5pdGVtIChpICsgMSkuY29kZVxuICAgICAgICAgIGlmIFJlc3VsdCBhbmQgdGhlbiBhcmdfdHlwZV9jb2RlID0ge1RVUExFfS5yZWZlcmVuY2VfY29kZSB0aGVuXG4gICAgICAgICAgICBhcmcgOj0gYXJncy5pdGVtIChpKVxuICAgICAgICAgICAgbF90eXBlIDo9IG9wZW5fb3BlcmFuZF90eXBlIChpKVxuICAgICAgICAgICAgICAtLSBJZiBleHBlY3RlZCB0eXBlIGlzIGF0dGFjaGVkLCB0aGVuIHdlIG5lZWQgdG8gdmVyaWZ5IHRoYXQgdGhlIGFjdHVhbFxuICAgICAgICAgICAgICAtLSBpcyBpbmRlZWQgYXR0YWNoZWQuXG4gICAgICAgICAgICBpZiBpc19hdHRhY2hlZF90eXBlIChsX3R5cGUpIHRoZW5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IGFyZyAvPSBWb2lkIGFuZCB0aGVuXG4gICAgICAgICAgICAgICAgZmllbGRfY29uZm9ybXNfdG8gKHR5cGVfaWRfb2YgKGFyZyksIGxfdHlwZSlcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IGFyZyA9IFZvaWQgb3IgZWxzZVxuICAgICAgICAgICAgICAgIGZpZWxkX2NvbmZvcm1zX3RvICh0eXBlX2lkX29mIChhcmcpLCBsX3R5cGUpXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiBSZXN1bHQgYW5kIHRoZW4gbm90IGlzX3RhcmdldF9jbG9zZWQgYW5kIHRoZW4gYXJncyAvPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZ3MuaXRlbSAoMSkgLz0gVm9pZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdmFsaWRfdGFyZ2V0IChhcmdzOiBkZXRhY2hhYmxlIFRVUExFKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdHVwbGUgYGFyZ3MnIGEgdmFsaWQgdGFyZ2V0XG4gICAgZG9cbiAgICAgIGlmIGFyZ3MgLz0gVm9pZCBhbmQgdGhlbiBhcmdzLmNvdW50ID4gMCB0aGVuXG4gICAgICAgIGlmIGFyZ3MuaXNfcmVmZXJlbmNlX2l0ZW0gKDEpIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gYXJncy5yZWZlcmVuY2VfaXRlbSAoMSkgLz0gVm9pZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc190YXJnZXRfY2xvc2VkOiBCT09MRUFOXG4gICAgICAtLSBJcyB0YXJnZXQgZm9yIGN1cnJlbnQgYWdlbnQgY2xvc2VkLCBpLmUuIHNwZWNpZmllZCBhdCBjcmVhdGlvbiB0aW1lP1xuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgb3Blbl9jb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIG9wZW4gb3BlcmFuZHMuXG5cbmZlYXR1cmUgLS0gU2V0dGluZ3NcblxuICBmcm96ZW4gc2V0X29wZXJhbmRzIChhcmdzOiBkZXRhY2hhYmxlIE9QRU5fQVJHUylcbiAgICAgIC0tIFVzZSBgYXJncycgYXMgb3BlcmFuZHMgZm9yIG5leHQgY2FsbC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZG9cbiAgICAgIG9wZXJhbmRzIDo9IGFyZ3NcbiAgICBlbnN1cmVcbiAgICAgIG9wZXJhbmRzX3NldDogKG9wZXJhbmRzIC89IFZvaWQgaW1wbGllcyAob3BlcmFuZHMgfiBhcmdzKSkgb3JcbiAgICAgICAgKG9wZXJhbmRzID0gVm9pZCBpbXBsaWVzIChhcmdzID0gVm9pZCBvciBlbHNlIGFyZ3MuaXNfZW1wdHkpKVxuICAgIGVuZFxuXG4gIHNldF90YXJnZXQgKGFfdGFyZ2V0OiBsaWtlIHRhcmdldClcbiAgICAgIC0tIFNldCBgYV90YXJnZXQnIGFzIHRoZSBuZXh0IGB0YXJnZXQnIGZvciByZW1haW5pbmcgY2FsbHMgdG8gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBhX3RhcmdldF9ub3Rfdm9pZDogYV90YXJnZXQgLz0gVm9pZFxuICAgICAgaXNfdGFyZ2V0X2Nsb3NlZDogaXNfdGFyZ2V0X2Nsb3NlZFxuICAgICAgdGFyZ2V0X25vdF92b2lkOiB0YXJnZXQgLz0gVm9pZFxuICAgICAgc2FtZV90YXJnZXRfdHlwZTogYXR0YWNoZWQgdGFyZ2V0IGFzIHQgYW5kIHRoZW4gdC5zYW1lX3R5cGUgKGFfdGFyZ2V0KVxuICAgIGxvY2FsXG4gICAgICBjOiBsaWtlIGNsb3NlZF9vcGVyYW5kc1xuICAgIGRvXG4gICAgICBjIDo9IGNsb3NlZF9vcGVyYW5kc1xuICAgICAgaWYgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYy5wdXQgKGFfdGFyZ2V0LCAxKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0YXJnZXRfc2V0OiB0YXJnZXQgPSBhX3RhcmdldFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFVzZSBzYW1lIHJvdXRpbmUgYXMgYG90aGVyJy5cbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIHN0YW5kYXJkX2NvcHkgKG90aGVyKVxuICAgICAgICBpZiBhdHRhY2hlZCBvcGVyYW5kcyBhcyBsX29wZXJhbmRzIHRoZW5cbiAgICAgICAgICBvcGVyYW5kcyA6PSBsX29wZXJhbmRzLnR3aW5cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9jYWxsX3N0YXR1czogb3RoZXIuY2FsbGFibGUgaW1wbGllcyBjYWxsYWJsZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBjYWxsIChhcmdzOiBkZXRhY2hhYmxlIHNlcGFyYXRlIE9QRU5fQVJHUylcbiAgICAgIC0tIENhbGwgcm91dGluZSB3aXRoIGBhcmdzJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBhcHBseVxuICAgICAgLS0gQ2FsbCByb3V0aW5lIHdpdGggYG9wZXJhbmRzJyBhcyBsYXN0IHNldC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKG9wZXJhbmRzKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRXh0ZW5kZWQgb3BlcmF0aW9uc1xuXG4gIGZsZXhpYmxlX2NhbGwgKGE6IGRldGFjaGFibGUgc2VwYXJhdGUgVFVQTEUpXG4gICAgICAtLSBDYWxsIHJvdXRpbmUgd2l0aCBhcmd1bWVudHMgYGEnLlxuICAgICAgLS0gQ29tcGFyZWQgdG8gYGNhbGwnIHRoZSB0eXBlIG9mIGBhJyBtYXkgYmUgZGlmZmVyZW50IGZyb20gYHtPUEVOX0FSR1N9Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9vcGVyYW5kczogdmFsaWRfb3BlcmFuZHMgKGEpXG4gICAgbG9jYWxcbiAgICAgIGRlZmF1bHRfYXJndW1lbnRzOiBkZXRhY2hhYmxlIE9QRU5fQVJHU1xuICAgIGRvXG4gICAgICBpZiBub3QgYXR0YWNoZWQgYSB0aGVuXG4gICAgICAgIGNhbGwgKGRlZmF1bHRfYXJndW1lbnRzKVxuICAgICAgZWxzZVxuICAgICAgICAtLSBUT0RPIGltcGxlbWVudCBpbiBqYXZhc2NyaXB0XG4gICAgICAgIC0tIGNoZWNrXG4gICAgICAgIC0tICAgZnJvbV9wcmVjb25kaXRpb246IGF0dGFjaGVkIHtPUEVOX0FSR1N9IG5ld190dXBsZV9mcm9tX3R1cGxlICgoe09QRU5fQVJHU30pLnR5cGVfaWQsIGEpIGFzIHhcbiAgICAgICAgLS0gdGhlblxuICAgICAgICAtLSAgIGNhbGwgKHgpXG4gICAgICAgIC0tIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT2Jzb2xldGVcblxuICBhZGFwdF9mcm9tIChvdGhlcjogbGlrZSBDdXJyZW50KVxuICAgICAgLS0gQWRhcHQgZnJvbSBgb3RoZXInLiBVc2VmdWwgaW4gZGVzY2VuZGFudHMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiUGxlYXNlIHVzZSBgYWRhcHQnIGluc3RlYWQgKGl0J3MgYWxzbyBhIGNyZWF0aW9uIHByb2NlZHVyZSlcIlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgY29uZm9ybWluZzogY29uZm9ybXNfdG8gKG90aGVyKVxuICAgIGRvXG4gICAgICBhZGFwdCAob3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge1JPVVRJTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZnJvemVuIGNsb3NlZF9vcGVyYW5kczogZGV0YWNoYWJsZSBUVVBMRVxuICAgICAgLS0gQWxsIGNsb3NlZCBhcmd1bWVudHMgcHJvdmlkZWQgYXQgY3JlYXRpb24gdGltZVxuXG4gIGNsb3NlZF9jb3VudDogSU5URUdFUlxuICAgICAgLS0gVGhlIG51bWJlciBvZiBjbG9zZWQgb3BlcmFuZHMgKGluY2x1ZGluZyB0aGUgdGFyZ2V0IGlmIGl0IGlzIGNsb3NlZClcbiAgICBsb2NhbFxuICAgICAgYzogZGV0YWNoYWJsZSBUVVBMRVxuICAgIGRvXG4gICAgICBjIDo9IGNsb3NlZF9vcGVyYW5kc1xuICAgICAgaWYgYyAvPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGMuY291bnRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb3plbiByb3V0X2Rpc3A6IFBPSU5URVJcbiAgICAgIC0tIFJvdXRpbmUgZGlzcGF0Y2hlclxuXG4gIGZyb3plbiBjYWxjX3JvdXRfYWRkcjogUE9JTlRFUlxuICAgICAgLS0gQWRkcmVzcyBvZiB0aGUgZmluYWwgcm91dGluZVxuXG4gIGZyb3plbiBvcGVuX21hcDogZGV0YWNoYWJsZSBBUlJBWSBbSU5URUdFUl1cbiAgICAgIC0tIEluZGV4IG1hcCBmb3Igb3BlbiBhcmd1bWVudHNcblxuICBmcm96ZW4gZW5jYXBzX3JvdXRfZGlzcDogUE9JTlRFUlxuICAgICAgLS0gRWlmZmVsIHJvdXRpbmUgZGlzcGF0Y2hlclxuXG4gIGZyb3plbiByb3V0aW5lX2lkOiBJTlRFR0VSXG5cbiAgZnJvemVuIGlzX2Jhc2ljOiBCT09MRUFOXG5cbiAgZnJvemVuIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQ6IElOVEVHRVJcblxuICBmcm96ZW4gc2V0X3JvdXRfZGlzcCAoYV9yb3V0X2Rpc3AsIGFfZW5jYXBzX3JvdXRfZGlzcCwgYV9jYWxjX3JvdXRfYWRkcjogUE9JTlRFUjtcbiAgICAgICAgICAgICAgYV9yb3V0aW5lX2lkOiBJTlRFR0VSOyBhX29wZW5fbWFwOiBsaWtlIG9wZW5fbWFwO1xuICAgICAgICAgICAgICBhX2lzX2Jhc2ljLCBhX2lzX3RhcmdldF9jbG9zZWQ6IEJPT0xFQU47IGFfd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudDogSU5URUdFUjtcbiAgICAgICAgICAgICAgYV9jbG9zZWRfb3BlcmFuZHM6IFRVUExFOyBhX29wZW5fY291bnQ6IElOVEVHRVIpXG4gICAgICAtLSBJbml0aWFsaXplIG9iamVjdC5cbiAgICByZXF1aXJlXG4gICAgICB0YXJnZXRfdmFsaWQ6IGFfaXNfdGFyZ2V0X2Nsb3NlZCBpbXBsaWVzIHZhbGlkX3RhcmdldCAoYV9jbG9zZWRfb3BlcmFuZHMpXG4gICAgZG9cbiAgICAgIHNldF9yb3V0X2Rpc3BfaW50IChhX3JvdXRfZGlzcCwgYV9lbmNhcHNfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyLCBhX3JvdXRpbmVfaWQsXG4gICAgICAgICAgICAgICAgIGFfb3Blbl9tYXAsIGFfaXNfYmFzaWMsIGFfaXNfdGFyZ2V0X2Nsb3NlZCxcbiAgICAgICAgICAgICAgICAgYV93cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50LCBhX2Nsb3NlZF9vcGVyYW5kcywgYV9vcGVuX2NvdW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfcm91dF9kaXNwX2ZpbmFsIChhX3JvdXRfZGlzcCwgYV9lbmNhcHNfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSXG4gICAgICAgICAgICAgICAgICBhX2Nsb3NlZF9vcGVyYW5kczogVFVQTEU7IGFfaXNfdGFyZ2V0X2Nsb3NlZDogQk9PTEVBTjsgYV9vcGVuX2NvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBvYmplY3QuXG4gICAgZG9cbiAgICAgIHJvdXRfZGlzcCA6PSBhX3JvdXRfZGlzcFxuICAgICAgZW5jYXBzX3JvdXRfZGlzcCA6PSBhX2VuY2Fwc19yb3V0X2Rpc3BcbiAgICAgIGNhbGNfcm91dF9hZGRyIDo9IGFfY2FsY19yb3V0X2FkZHJcbiAgICAgIGNsb3NlZF9vcGVyYW5kcyA6PSBhX2Nsb3NlZF9vcGVyYW5kc1xuICAgICAgaXNfdGFyZ2V0X2Nsb3NlZCA6PSBhX2lzX3RhcmdldF9jbG9zZWRcbiAgICAgIG9wZW5fY291bnQgOj0gYV9vcGVuX2NvdW50XG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9yb3V0X2Rpc3BfaW50IChhX3JvdXRfZGlzcCwgYV9lbmNhcHNfcm91dF9kaXNwLCBhX2NhbGNfcm91dF9hZGRyOiBQT0lOVEVSO1xuICAgICAgICAgICAgICAgICAgYV9yb3V0aW5lX2lkOiBJTlRFR0VSOyBhX29wZW5fbWFwOiBsaWtlIG9wZW5fbWFwO1xuICAgICAgICAgICAgICAgIGFfaXNfYmFzaWMsIGFfaXNfdGFyZ2V0X2Nsb3NlZDogQk9PTEVBTjsgYV93cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50OiBJTlRFR0VSO1xuICAgICAgICAgICAgICAgIGFfY2xvc2VkX29wZXJhbmRzOiBUVVBMRTsgYV9vcGVuX2NvdW50OiBJTlRFR0VSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBvYmplY3QuXG4gICAgcmVxdWlyZVxuICAgICAgYV9yb3V0aW5lX2lkX3ZhbGlkOiBhX3JvdXRpbmVfaWQgPiAtMVxuICAgIGRvXG4gICAgICByb3V0X2Rpc3AgOj0gYV9yb3V0X2Rpc3BcbiAgICAgIGVuY2Fwc19yb3V0X2Rpc3AgOj0gYV9lbmNhcHNfcm91dF9kaXNwXG4gICAgICBjYWxjX3JvdXRfYWRkciA6PSBhX2NhbGNfcm91dF9hZGRyXG4gICAgICByb3V0aW5lX2lkIDo9IGFfcm91dGluZV9pZFxuICAgICAgb3Blbl9tYXAgOj0gYV9vcGVuX21hcFxuICAgICAgaXNfYmFzaWMgOj0gYV9pc19iYXNpY1xuICAgICAgaXNfdGFyZ2V0X2Nsb3NlZCA6PSBhX2lzX3RhcmdldF9jbG9zZWRcbiAgICAgIHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQgOj0gYV93cml0dGVuX3R5cGVfaWRfaW5saW5lX2FnZW50XG4gICAgICBjbG9zZWRfb3BlcmFuZHMgOj0gYV9jbG9zZWRfb3BlcmFuZHNcbiAgICAgIG9wZW5fY291bnQgOj0gYV9vcGVuX2NvdW50XG4gICAgZW5zdXJlXG4gICAgICByb3V0X2Rpc3Bfc2V0OiByb3V0X2Rpc3AgPSBhX3JvdXRfZGlzcFxuICAgICAgZW5jYXBzX3JvdXRfZGlzcF9zZXQ6IGVuY2Fwc19yb3V0X2Rpc3AgPSBhX2VuY2Fwc19yb3V0X2Rpc3BcbiAgICAgIGNhbGNfcm91dF9hZGRyX3NldDogY2FsY19yb3V0X2FkZHIgPSBhX2NhbGNfcm91dF9hZGRyXG4gICAgICByb3V0aW5lX2lkX3NldDogcm91dGluZV9pZCA9IGFfcm91dGluZV9pZFxuICAgICAgb3Blbl9tYXBfc2V0OiBvcGVuX21hcCA9IGFfb3Blbl9tYXBcbiAgICAgIGlzX3RhcmdldF9jbG9zZWRfc2V0OiBpc190YXJnZXRfY2xvc2VkID0gYV9pc190YXJnZXRfY2xvc2VkXG4gICAgICBpc19iYXNpY19zZXQ6IGlzX2Jhc2ljID0gYV9pc19iYXNpY1xuICAgICAgd3JpdHRlbl90eXBlX2lkX2lubGluZV9hZ2VudF9zZXQ6IHdyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnQgPSBhX3dyaXR0ZW5fdHlwZV9pZF9pbmxpbmVfYWdlbnRcbiAgICAgIGNsb3NlZF9vcGVyYW5kc19zZXQ6IGNsb3NlZF9vcGVyYW5kcyA9IGFfY2xvc2VkX29wZXJhbmRzXG4gICAgICBvcGVuX2NvdW50X3NldDogb3Blbl9jb3VudCA9IGFfb3Blbl9jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBvcGVuX3R5cGVzOiBkZXRhY2hhYmxlIEFSUkFZIFtJTlRFR0VSXVxuICAgICAgLS0gVHlwZXMgb2Ygb3BlbiBvcGVyYW5kc1xuXG4gIG9wZW5fb3BlcmFuZF90eXBlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gVHlwZSBvZiBgaSd0aCBvcGVuIG9wZXJhbmQuXG4gICAgcmVxdWlyZVxuICAgICAgcG9zaXRpdmU6IGkgPj0gMVxuICAgICAgd2l0aGluX2JvdW5kczogaSA8PSBvcGVuX2NvdW50XG4gICAgbG9jYWxcbiAgICAgIG86IGxpa2Ugb3Blbl90eXBlc1xuICAgIGRvXG4gICAgICBvIDo9IG9wZW5fdHlwZXNcbiAgICAgIGlmIG8gPSBWb2lkIHRoZW5cbiAgICAgICAgY3JlYXRlIG8ubWFrZV9maWxsZWQgKC0xLCAxLCBvcGVuX2NvdW50KVxuICAgICAgICBvcGVuX3R5cGVzIDo9IG9cbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IG8uaXRlbSAoaSlcbiAgICAgIGlmIFJlc3VsdCA9IC0xIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9ICh7T1BFTl9BUkdTfSkuZ2VuZXJpY19wYXJhbWV0ZXJfdHlwZSAoaSkudHlwZV9pZFxuICAgICAgICBvLnB1dCAoUmVzdWx0LCBpKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHlwZV9pZF9vZiAoYTogc2VwYXJhdGUgQU5ZKTogSU5URUdFUlxuICAgICAgLS0gVHlwZSBJRCBvZiBhbiBvYmplY3QgYGEnLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYS5nZW5lcmF0aW5nX3R5cGUudHlwZV9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBFeHRlcm5hbHNcblxuICBlaWZfZ2VuX3R5cGVjb2RlX3N0ciAob2JqOiBQT0lOVEVSKTogU1RSSU5HXG4gICAgICAtLSBDb2RlIG5hbWUgZm9yIGdlbmVyaWMgcGFyYW1ldGVyIGBwb3MnIGluIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgc2lnbmF0dXJlIChFSUZfUkVGRVJFTkNFKTogRUlGX1JFRkVSRU5DRSB1c2UgJVwiZWlmX2dlbl9jb25mLmglXCJcIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE9ic29sZXRlXG5cbiAgYXJndW1lbnRzOiBkZXRhY2hhYmxlIE9QRU5fQVJHU1xuICAgIG9ic29sZXRlXG4gICAgICBcInVzZSBvcGVyYW5kc1wiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvcGVyYW5kc1xuICAgIGVuZFxuXG4gIHNldF9hcmd1bWVudHMgKGFyZ3M6IGRldGFjaGFibGUgT1BFTl9BUkdTKVxuICAgIG9ic29sZXRlXG4gICAgICBcInVzZSBzZXRfb3BlcmFuZHNcIlxuICAgIGRvXG4gICAgICBzZXRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZW5kXG5cbiAgdmFsaWRfYXJndW1lbnRzIChhcmdzOiBkZXRhY2hhYmxlIE9QRU5fQVJHUyk6IEJPT0xFQU5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJ1c2UgdmFsaWRfb3BlcmFuZHNcIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdmFsaWRfb3BlcmFuZHMgKGFyZ3MpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJbXG4gICAgRmluaXRlIHNlcXVlbmNlczogc3RydWN0dXJlcyB3aGVyZSBleGlzdGluZyBpdGVtcyBhcmUgYXJyYW5nZWRcbiAgICBhbmQgYWNjZXNzZWQgc2VxdWVudGlhbGx5LCBhbmQgbmV3IG9uZXMgY2FuIGJlIGFkZGVkIGF0IHRoZSBlbmQuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHNlcXVlbmNlO1xuICBhY2Nlc3M6IGN1cnNvciwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBTRVFVRU5DRSBbR10gaW5oZXJpdFxuXG4gIEFDVElWRSBbR11cbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsXG4gICAgZW5kXG5cbiAgQklMSU5FQVIgW0ddXG5cbiAgRklOSVRFIFtHXVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICByZWFkYWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgYSBjdXJyZW50IGl0ZW0gdGhhdCBtYXkgYmUgcmVhZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBvZmZcbiAgICBlbmRcblxuXG4gIHdyaXRhYmxlOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBhIGN1cnJlbnQgaXRlbSB0aGF0IG1heSBiZSBtb2RpZmllZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBvZmZcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIGZvcmNlICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBBZGQgYHYnIHRvIGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gICAgZG9cbiAgICAgIGV4dGVuZCAodilcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGhhcyAodilcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFNFUVVFTkNFIFtHXSlcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbDogbGlrZSBzXG4gICAgZG9cbiAgICAgIGwgOj0gc1xuICAgICAgaWYgcyA9IEN1cnJlbnQgdGhlblxuICAgICAgICBsIDo9IHR3aW5cbiAgICAgIGVuZFxuICAgICAgZnJvbVxuICAgICAgICBsLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBsLmV4aGF1c3RlZFxuICAgICAgbG9vcFxuICAgICAgICBleHRlbmQgKGwuaXRlbSlcbiAgICAgICAgbC5mb3J0aFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID49IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIHB1dCAodjogbGlrZSBpdGVtKVxuICAgICAgLS0gQWRkIGB2JyB0byBlbmQuXG4gICAgZG9cbiAgICAgIGV4dGVuZCAodilcbiAgICBlbnN1cmUgdGhlblxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcHJ1bmUgKHY6IGxpa2UgaXRlbSlcbiAgICAgIC0tIFJlbW92ZSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdicgaWYgYW55LlxuICAgICAgLS0gSWYgbm8gc3VjaCBvY2N1cnJlbmNlIGdvIGBvZmYnLlxuICAgIGRvXG4gICAgICBzdGFydFxuICAgICAgc2VhcmNoICh2KVxuICAgICAgaWYgbm90IGV4aGF1c3RlZCB0aGVuXG4gICAgICAgIHJlbW92ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsICh2OiBsaWtlIGl0ZW0pXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGB2JzsgZ28gYG9mZicuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgc3RhcnRcbiAgICAgIHVudGlsXG4gICAgICAgIGV4aGF1c3RlZFxuICAgICAgbG9vcFxuICAgICAgICBzZWFyY2ggKHYpXG4gICAgICAgIGlmIG5vdCBleGhhdXN0ZWQgdGhlblxuICAgICAgICAgIHJlbW92ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTAzLTA0IDE1OjAxOjI1IC0wODAwIChNb24sIDA0IE1hciAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjE3OCAkXCJcblxuZnJvemVuIGNsYXNzXG4gIFNQRUNJQUwgW1RdXG5cbmluaGVyaXRcbiAgQUJTVFJBQ1RfU1BFQ0lBTFxuICAgIHJlZGVmaW5lXG4gICAgICBkZWJ1Z19vdXRwdXRcbiAgICBlbmRcblxuICBSRUFEQUJMRV9JTkRFWEFCTEUgW1RdXG5cbmNyZWF0ZVxuICBtYWtlX2VtcHR5LFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX25hdGl2ZV9hcnJheVxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHkgKG46IElOVEVHRVIpXG4gICAgICAtLSBDcmVhdGUgYSBzcGVjaWFsIG9iamVjdCBmb3IgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBjYXBhY2l0eV9zZXQ6IGNhcGFjaXR5ID0gblxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IDBcbiAgICBlbmRcblxuICBtYWtlX2ZpbGxlZCAodjogVDsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBhIHNwZWNpYWwgb2JqZWN0IGZvciBgbicgZW50cmllcyBpbml0aWFsaXplZCB3aXRoIGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlX2VtcHR5IChuKVxuICAgICAgZmlsbF93aXRoICh2LCAwLCBuIC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X3NldDogY2FwYWNpdHkgPSBuXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAodiwgMCwgbiAtIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX25hdGl2ZV9hcnJheSAoYW5fYXJyYXk6IGxpa2UgbmF0aXZlX2FycmF5KVxuICAgICAgLS0gQ3JlYXRlIGEgc3BlY2lhbCBvYmplY3QgZnJvbSBgYW5fYXJyYXknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIGFuX2FycmF5X25vdF92b2lkOiBhbl9hcnJheSAvPSBWb2lkXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiAoaTogSU5URUdFUik6IFQgYXNzaWduIHB1dFxuICAgICAgLS0gSXRlbSBhdCBgaSctdGggcG9zaXRpb25cbiAgICAgIC0tIChpbmRpY2VzIGJlZ2luIGF0IDApXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogVFxuICAgICAgLS0gSXRlbSBhdCBgaSctdGggcG9zaXRpb25cbiAgICAgIC0tIChpbmRpY2VzIGJlZ2luIGF0IDApXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAoaSlcbiAgICBlbmRcblxuICBpbmRleF9vZiAodjogVDsgc3RhcnRfcG9zaXRpb246IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGl0ZW0gaWRlbnRpY2FsIHRvIGB2Jy5cbiAgICAgIC0tIC0xIGlmIG5vbmUuXG4gICAgICAtLSAoVXNlIG9iamVjdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbi4pXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfcG9zaXRpb246IHN0YXJ0X3Bvc2l0aW9uID49IDBcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfcG9zaXRpb25cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA+PSBuYiBvciBlbHNlIGl0ZW0gKFJlc3VsdCkgfiB2XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIFJlc3VsdCA+PSBuYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBmb3VuZF9vcl9ub3RfZm91bmQ6IFJlc3VsdCA9IC0xIG9yIGVsc2UgKFJlc3VsdCA+PSAwIGFuZCB0aGVuIFJlc3VsdCA8IGNvdW50KVxuICAgIGVuZFxuXG4gIGl0ZW1fYWRkcmVzcyAoaTogSU5URUdFUik6IFBPSU5URVJcbiAgICAgIC0tIEFkZHJlc3Mgb2YgZWxlbWVudCBhdCBwb3NpdGlvbiBgaScuXG4gICAgICAtLSBVc2Ugb25seSB3aGVuIGludGVyZmFjaW5nIHdpdGggQyBleHRlcm5hbHMgd2hlbiBDdXJyZW50IGlzIGd1YXJhbnRlZWQgdG8gbm90IG1vdmUgaW4gbWVtb3J5LlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDBcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8IGNvdW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBiYXNlX2FkZHJlc3MgKyBpICogZWxlbWVudF9zaXplXG4gICAgZW5zdXJlXG4gICAgICBlbGVtZW50X2FkZHJlc3Nfbm90X251bGw6IFJlc3VsdCAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBlbmRcblxuICBiYXNlX2FkZHJlc3M6IFBPSU5URVJcbiAgICAgIC0tIEFkZHJlc3Mgb2YgZWxlbWVudCBhdCBwb3NpdGlvbiBgMCcuXG4gICAgICAtLSBVc2Ugb25seSB3aGVuIGludGVyZmFjaW5nIHdpdGggQyBleHRlcm5hbHMgd2hlbiBDdXJyZW50IGlzIGd1YXJhbnRlZWQgdG8gbm90IG1vdmUgaW4gbWVtb3J5LlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGJhc2VfYWRkcmVzc19ub3RfbnVsbDogUmVzdWx0IC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGVuZFxuXG4gIG5hdGl2ZV9hcnJheTogTkFUSVZFX0FSUkFZIFtUXVxuICAgICAgLS0gT25seSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIC5ORVRcbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICBlbmRcblxuICB0b19hcnJheTogQVJSQVkgW1RdXG4gICAgICAtLSBCdWlsZCBhbiBhcnJheSByZXByZXNlbnRhdGlvbiBvZiBDdXJyZW50IGZyb20gYDEnIHRvIGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3NwZWNpYWwgKEN1cnJlbnQpXG4gICAgZW5zdXJlXG4gICAgICB0b19hcnJheV9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHRvX2FycmF5X2xvd2VyX3NldDogUmVzdWx0Lmxvd2VyID0gMVxuICAgICAgdG9fYXJyYXlfdXBwZXJfc2V0OiBSZXN1bHQudXBwZXIgPSBjb3VudFxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsb3dlciwgdXBwZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBsb3dlcjogSU5URUdFUiA9IDBcbiAgICAgIC0tIE1pbmltdW0gaW5kZXggb2YgQ3VycmVudFxuXG4gIHVwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBNYXhpbXVtIGluZGV4IG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNvdW50IC0gMVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogbG93ZXIgPD0gUmVzdWx0ICsgMVxuICAgIGVuZFxuXG4gIGNvdW50OiBJTlRFR0VSXG4gICAgICAtLSBDb3VudCBvZiBzcGVjaWFsIGFyZWFcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIENhcGFjaXR5IG9mIHNwZWNpYWwgYXJlYVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZmlsbGVkX3dpdGggKHY6IFQ7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIGJldHdlZW4gaW5kZXggYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHNldCB0byBgdic/XG4gICAgICAtLSAoVXNlIHJlZmVyZW5jZSBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbi4pXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBjb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleCBvciBlbHNlIG5vdCBSZXN1bHRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpID0gdlxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzYW1lX2l0ZW1zIChvdGhlcjogbGlrZSBDdXJyZW50OyBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIHRoZSBgbicgZWxlbWVudHMgb2YgYG90aGVyJyBmcm9tIGBzb3VyY2VfaW5kZXgnIHBvc2l0aW9uIHRoZSBzYW1lIGFzXG4gICAgICAtLSB0aGUgYG4nIGVsZW1lbnRzIG9mIGBDdXJyZW50JyBmcm9tIGBkZXN0aW5hdGlvbl9pbmRleCc/XG4gICAgICAtLSAoVXNlIHJlZmVyZW5jZSBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbi4pXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gb3RoZXIuY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNvdW50XG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc291cmNlX2luZGV4XG4gICAgICAgICAgaiA6PSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIG90aGVyLml0ZW0gKGkpIC89IGl0ZW0gKGopIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfb25fZW1wdHlfYXJlYTogKG4gPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIEN1cnJlbnQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoMCA8PSBpKSBhbmQgKGkgPCBjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAodjogVDsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYGknLXRoIGl0ZW0gYnkgYHYnLlxuICAgICAgLS0gKEluZGljZXMgYmVnaW4gYXQgMC4pXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDBcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8IGNvdW50XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gdlxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgZm9yY2UgKHY6IFQ7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJZiBgaScgaXMgZXF1YWwgdG8gYGNvdW50JyBpbmNyZWFzZSBgY291bnQnIGJ5IG9uZSBhbmQgaW5zZXJ0IGB2JyBhdCBpbmRleCBgY291bnQnLFxuICAgICAgLS0gb3RoZXJ3aXNlIHJlcGxhY2UgYGknLXRoIGl0ZW0gYnkgYHYnLlxuICAgICAgLS0gKEluZGljZXMgYmVnaW4gYXQgMC4pXG4gICAgcmVxdWlyZVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID49IDBcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudFxuICAgICAgbm90X2Z1bGw6IGkgPSBjb3VudCBpbXBsaWVzIGNvdW50IDwgY2FwYWNpdHlcbiAgICBkb1xuICAgICAgaWYgaSA8IGNvdW50IHRoZW5cbiAgICAgICAgcHV0ICh2LCBpKVxuICAgICAgZWxzZVxuICAgICAgICBleHRlbmQgKHYpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gKGkgKyAxKS5tYXggKG9sZCBjb3VudClcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgZW5kXG5cbiAgZXh0ZW5kICh2OiBUKVxuICAgICAgLS0gQWRkIGB2JyBhdCBpbmRleCBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIGNvdW50X3NtYWxsX2Vub3VnaDogY291bnQgPCBjYXBhY2l0eVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X2luY3JlYXNlZDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50IC0gMSkgPSB2XG4gICAgZW5kXG5cbiAgZXh0ZW5kX2ZpbGxlZCAodjogVClcbiAgICAgIC0tIFNldCBpdGVtcyBiZXR3ZWVuIGBjb3VudCcgYW5kIGBjYXBhY2l0eSAtIDEnIHdpdGggYHYnLlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKHYsIGNvdW50LCBjYXBhY2l0eSAtIDEpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfaW5jcmVhc2VkOiBjb3VudCA9IGNhcGFjaXR5XG4gICAgICBmaWxsZWQ6IGZpbGxlZF93aXRoICh2LCBvbGQgY291bnQsIGNhcGFjaXR5IC0gMSlcbiAgICBlbmRcblxuICBmaWxsX3dpdGggKHY6IFQ7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgaXRlbXMgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4JyB3aXRoIGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X2luX2JvdW5kOiBzdGFydF9pbmRleCA8PSBjb3VudFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgY2FwYWNpdHlcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfY291bnQ6IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGxfY291bnQgOj0gY291bnQubWluIChlbmRfaW5kZXggKyAxKVxuICAgICAgICBuYiA6PSBsX2NvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgcHV0ICh2LCBpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBsX2NvdW50XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleCArIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBleHRlbmQgKHYpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X2RlZmluaXRpb246IGNvdW50ID0gKG9sZCBjb3VudCkubWF4IChlbmRfaW5kZXggKyAxKVxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAodiwgc3RhcnRfaW5kZXgsIGVuZF9pbmRleClcbiAgICBlbmRcblxuICBmaWxsX3dpdGhfZGVmYXVsdCAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIENsZWFyIGl0ZW1zIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfc2VsZl9pbml0aWFsaXppbmc6ICh7VH0pLmhhc19kZWZhdWx0XG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGNvdW50XG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoKHtUfSkuZGVmYXVsdCwgc3RhcnRfaW5kZXgsIGVuZF9pbmRleClcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKCh7VH0pLmRlZmF1bHQsIHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X2RhdGEgKG90aGVyOiBTUEVDSUFMIFtUXTsgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgbicgZWxlbWVudHMgb2YgYG90aGVyJyBmcm9tIGBzb3VyY2VfaW5kZXgnIHBvc2l0aW9uIHRvIEN1cnJlbnQgYXRcbiAgICAgIC0tIGBkZXN0aW5hdGlvbl9pbmRleCcgYW5kIHNoaWZ0IGVsZW1lbnRzIGJldHdlZW4gYGRlc3RpbmF0aW9uX2luZGV4JyBhbmQgYGNvdW50J1xuICAgICAgLS0gdG8gdGhlIHJpZ2h0LiBPdGhlciBlbGVtZW50cyBvZiBDdXJyZW50IHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBvdGhlci5jb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBjb3VudCArIG4gPD0gY2FwYWNpdHlcbiAgICAgIHNhbWVfdHlwZTogb3RoZXIuY29uZm9ybXNfdG8gKEN1cnJlbnQpXG4gICAgbG9jYWxcbiAgICAgIGxfcmVtYWluaW5nX2l0ZW1zLCBsX29mZnNldCwgbF9uYl9pdGVtc19sZWZ0OiBJTlRFR0VSXG4gICAgICBsX3NvdXJjZV9pbmRleCwgbF9lbmRfaW5kZXgsIGxfZGVzdGluYXRpb25faW5kZXg6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9yZW1haW5pbmdfaXRlbXMgOj0gY291bnQgLSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgaWYgbF9yZW1haW5pbmdfaXRlbXMgPSAwIHRoZW5cbiAgICAgICAgICAtLSBJdCBpcyBiZWluZyBhZGRlZCBhdCB0aGUgZW5kIG9mIEN1cnJlbnQsIHRoZXJlZm9yZSB3ZSBjYW4gc2ltcGx5IGV4dGVuZC5cbiAgICAgICAgY29weV9kYXRhIChvdGhlciwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGVsc2VpZiBuIDw9IGxfcmVtYWluaW5nX2l0ZW1zIHRoZW5cbiAgICAgICAgICAtLSBTaW1wbGUgY2FzZSB3aGVyZSB3ZSBjYW4gcGVyZm9ybSBhIG1vdmUgb2YgdGhlIGV4aXN0aW5nIGl0ZW1zIHRvIHRoZSBlbmRcbiAgICAgICAgICAtLSBhbmQgdGhlbiBjb3B5IHRoZSBlbGVtZW50cyBvZiBgb3RoZXInLlxuICAgICAgICBtb3ZlX2RhdGEgKGRlc3RpbmF0aW9uX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCArIG4sIGxfcmVtYWluaW5nX2l0ZW1zKVxuICAgICAgICBjb3B5X2RhdGEgKG90aGVyLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEJlY2F1c2Ugd2UgY2Fubm90IGhhdmUgdW5pbml0aWFsaXplZCBpdGVtcywgd2UgY2Fubm90IG1vdmUgYWxsIHRoZSByZW1haW5pbmcgaXRlbXMgYmV5b25kIGNvdW50XG4gICAgICAgICAgLS0gaW5zdGVhZCB3ZSBjb3B5IGJ5IGNodW5rcyBvZiBgbF9yZW1haW5pbmdfaXRlbXMnLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zb3VyY2VfaW5kZXggOj0gc291cmNlX2luZGV4XG4gICAgICAgICAgbF9kZXN0aW5hdGlvbl9pbmRleCA6PSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIGxfZW5kX2luZGV4IDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgICBsX25iX2l0ZW1zX2xlZnQgOj0gblxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfcmVtYWluaW5nX2l0ZW1zXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zb3VyY2VfaW5kZXggPj0gbF9lbmRfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG1vdmVfZGF0YSAobF9kZXN0aW5hdGlvbl9pbmRleCwgbF9kZXN0aW5hdGlvbl9pbmRleCArIGxfb2Zmc2V0LCBsX3JlbWFpbmluZ19pdGVtcylcbiAgICAgICAgICBjb3B5X2RhdGEgKG90aGVyLCBsX3NvdXJjZV9pbmRleCwgbF9kZXN0aW5hdGlvbl9pbmRleCwgbF9vZmZzZXQpXG4gICAgICAgICAgbF9kZXN0aW5hdGlvbl9pbmRleCA6PSBsX2Rlc3RpbmF0aW9uX2luZGV4ICsgbF9vZmZzZXRcbiAgICAgICAgICBsX3NvdXJjZV9pbmRleCA6PSBsX3NvdXJjZV9pbmRleCArIGxfb2Zmc2V0XG4gICAgICAgICAgICAtLSBDb21wdXRlIGhvdyBtYW55IG1vcmUgaXRlbXMgd2UgaGF2ZSB0byBjb3B5LlxuICAgICAgICAgIGxfbmJfaXRlbXNfbGVmdCA6PSBsX25iX2l0ZW1zX2xlZnQgLSBsX3JlbWFpbmluZ19pdGVtc1xuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfb2Zmc2V0Lm1pbiAobF9uYl9pdGVtc19sZWZ0KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY29waWVkOiBzYW1lX2l0ZW1zIChvdGhlciwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gb2xkIGNvdW50ICsgblxuICAgIGVuZFxuXG4gIGNvcHlfZGF0YSAob3RoZXI6IFNQRUNJQUwgW1RdOyBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBgbicgZWxlbWVudHMgb2YgYG90aGVyJyBmcm9tIGBzb3VyY2VfaW5kZXgnIHBvc2l0aW9uIHRvIEN1cnJlbnQgYXRcbiAgICAgIC0tIGBkZXN0aW5hdGlvbl9pbmRleCcuIE90aGVyIGVsZW1lbnRzIG9mIEN1cnJlbnQgcmVtYWluIHVuY2hhbmdlZC5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IG90aGVyLmNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgICAgc2FtZV90eXBlOiBvdGhlci5jb25mb3Jtc190byAoQ3VycmVudClcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgbW92ZV9kYXRhIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgZWxzZVxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBqIDo9IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICAgICAgbmIgOj0gc291cmNlX2luZGV4ICsgblxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9yY2UgKG90aGVyLml0ZW0gKGkpLCBqKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjb3BpZWQ6IHNhbWVfaXRlbXMgKG90aGVyLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGRlc3RpbmF0aW9uX2luZGV4ICsgbilcbiAgICBlbmRcblxuICBtb3ZlX2RhdGEgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpXG4gICAgICAtLSBNb3ZlIGBuJyBlbGVtZW50cyBvZiBDdXJyZW50IGZyb20gYHNvdXJjZV9zdGFydCcgcG9zaXRpb24gdG8gYGRlc3RpbmF0aW9uX2luZGV4Jy5cbiAgICAgIC0tIE90aGVyIGVsZW1lbnRzIHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgc291cmNlX2luZGV4X25vbl9uZWdhdGl2ZTogc291cmNlX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X25vbl9uZWdhdGl2ZTogZGVzdGluYXRpb25faW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfaW5fYm91bmQ6IGRlc3RpbmF0aW9uX2luZGV4IDw9IGNvdW50XG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IGNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBpZiBzb3VyY2VfaW5kZXggPSBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICBlbHNlaWYgc291cmNlX2luZGV4ID4gZGVzdGluYXRpb25faW5kZXggdGhlblxuICAgICAgICBpZiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPCBzb3VyY2VfaW5kZXggdGhlblxuICAgICAgICAgIG5vbl9vdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGlmIHNvdXJjZV9pbmRleCArIG4gPCBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICAgICAgbm9uX292ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbW92ZWQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGRlc3RpbmF0aW9uX2luZGV4ICsgbilcbiAgICBlbmRcblxuICBvdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBgbicgZWxlbWVudHMgb2YgQ3VycmVudCBmcm9tIGBzb3VyY2Vfc3RhcnQnIHBvc2l0aW9uIHRvIGBkZXN0aW5hdGlvbl9pbmRleCcuXG4gICAgICAtLSBPdGhlciBlbGVtZW50cyByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgZGlmZmVyZW50X3NvdXJjZV9hbmRfdGFyZ2V0OiBzb3VyY2VfaW5kZXggLz0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogZGVzdGluYXRpb25faW5kZXggKyBuIDw9IGNhcGFjaXR5XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX29mZnNldDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBzb3VyY2VfaW5kZXggPCBkZXN0aW5hdGlvbl9pbmRleCB0aGVuXG4gICAgICAgICAgLS0gV2Ugc2hpZnQgZnJvbSBsZWZ0IHRvIHJpZ2h0IHN0YXJ0aW5nIGZyb20gdGhlIGVuZFxuICAgICAgICAgIC0tIGR1ZSB0byBwb3NzaWJsZSBvdmVybGFwcGluZy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc291cmNlX2luZGV4ICsgbiAtIDFcbiAgICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggLSAxXG4gICAgICAgICAgbF9vZmZzZXQgOj0gZGVzdGluYXRpb25faW5kZXggLSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25faW5kZXggKyBuID49IGNvdW50KSB0aGVuXG4gICAgICAgICAgICAgIC0tIEluaXRpYWxpemUgZWxlbWVudHMgYWJvdmUgYGNvdW50JyB0byBhIGR1bW15IGl0ZW0uXG4gICAgICAgICAgICBmaWxsX3dpdGggKGl0ZW0gKHNvdXJjZV9pbmRleCksIGNvdW50LCBkZXN0aW5hdGlvbl9pbmRleCArIG4gLSAxKVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGNoZWNrXG4gICAgICAgICAgICBsX29mZnNldF9wb3NpdGl2ZTogbF9vZmZzZXQgPiAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBwdXQgKGl0ZW0gKGkpLCBpICsgbF9vZmZzZXQpXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBXZSBzaGlmdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHNvdXJjZV9pbmRleFxuICAgICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgICBsX29mZnNldCA6PSBzb3VyY2VfaW5kZXggLSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIGNoZWNrXG4gICAgICAgICAgICBsX29mZnNldF9wb3NpdGl2ZTogbF9vZmZzZXQgPiAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBmb3JjZSAoaXRlbSAoaSksIGkgLSBsX29mZnNldClcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBtb3ZlZDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZGVzdGluYXRpb25faW5kZXggKyBuKVxuICAgIGVuZFxuXG4gIG5vbl9vdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBgbicgZWxlbWVudHMgb2YgQ3VycmVudCBmcm9tIGBzb3VyY2Vfc3RhcnQnIHBvc2l0aW9uIHRvIGBkZXN0aW5hdGlvbl9pbmRleCcuXG4gICAgICAtLSBPdGhlciBlbGVtZW50cyByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgZGlmZmVyZW50X3NvdXJjZV9hbmRfdGFyZ2V0OiBzb3VyY2VfaW5kZXggLz0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgIG5vbl9vdmVybGFwcGluZzpcbiAgICAgICAgKHNvdXJjZV9pbmRleCA8IGRlc3RpbmF0aW9uX2luZGV4IGltcGxpZXMgc291cmNlX2luZGV4ICsgbiA8IGRlc3RpbmF0aW9uX2luZGV4KSBvclxuICAgICAgICAoc291cmNlX2luZGV4ID4gZGVzdGluYXRpb25faW5kZXggaW1wbGllcyBkZXN0aW5hdGlvbl9pbmRleCArIG4gPCBzb3VyY2VfaW5kZXgpXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IGNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHNvdXJjZV9pbmRleFxuICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggKyBuXG4gICAgICAgIGxfb2Zmc2V0IDo9IGRlc3RpbmF0aW9uX2luZGV4IC0gc291cmNlX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgZm9yY2UgKGl0ZW0gKGkpLCBpICsgbF9vZmZzZXQpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbW92ZWQ6IHNhbWVfaXRlbXMgKEN1cnJlbnQsIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZGVzdGluYXRpb25faW5kZXggKyBuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gS2VlcCB0aGUgZmlyc3QgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICAgIGxlc3NfdGhhbl9jb3VudDogbiA8PSBjb3VudFxuICAgIGRvXG4gICAgICBzZXRfY291bnQgKG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG5cbiAgICAgIGtlcHQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCAwLCAwLCBuKVxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIEtlZXAgdGhlIGxhc3QgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICAgIGxlc3NfdGhhbl9jb3VudDogbiA8PSBjb3VudFxuICAgIGRvXG4gICAgICBvdmVybGFwcGluZ19tb3ZlIChjb3VudCAtIG4sIDAsIG4pXG4gICAgICBzZXRfY291bnQgKG4pXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG5cbiAgICAgIGtlcHQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCBuLCAwLCBuKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIHRoZSBmaXJzdCBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgICAgbGVzc190aGFuX2NvdW50OiBuIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBvbGQgY291bnQgLSBuXG4gICAgICBrZXB0OiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgbiwgMCwgY291bnQpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBLZWVwIHRoZSBmaXJzdCAgYGNvdW50IC0gbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgICAgbGVzc190aGFuX2NvdW50OiBuIDw9IGNvdW50XG4gICAgZG9cbiAgICAgIGtlZXBfaGVhZCAoY291bnQgLSBuKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBvbGQgY291bnQgLSBuXG4gICAgICBrZXB0OiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgMCwgMCwgY291bnQpXG4gICAgZW5kXG5cbiAgcmVzaXplZF9hcmVhIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDcmVhdGUgYSBjb3B5IG9mIEN1cnJlbnQgd2l0aCBhIGNvdW50IG9mIGBuJ1xuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2VtcHR5IChuKVxuICAgICAgUmVzdWx0LmNvcHlfZGF0YSAoQ3VycmVudCwgMCwgMCwgbi5taW4gKGNvdW50KSlcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF9kaWZmZXJlbnRfZnJvbV9jdXJyZW50OiBSZXN1bHQgLz0gQ3VycmVudFxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAgbmV3X2NhcGFjaXR5OiBSZXN1bHQuY2FwYWNpdHkgPSBuXG4gICAgICBwcmVzZXJ2ZWQ6IFJlc3VsdC5zYW1lX2l0ZW1zIChDdXJyZW50LCAwLCAwLCBuLm1pbiAob2xkIGNvdW50KSlcbiAgICBlbmRcblxuICByZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0IChhX2RlZmF1bHRfdmFsdWU6IFQ7IG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENyZWF0ZSBhIGNvcHkgb2YgQ3VycmVudCB3aXRoIGEgY291bnQgb2YgYG4nIHdoZXJlIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbiAgICAgIC0tIGVudHJpZXMgYXJlIHNldCB0byBgYV9kZWZhdWx0X3ZhbHVlJy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAobilcbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdC5jb3B5X2RhdGEgKEN1cnJlbnQsIDAsIDAsIGNvdW50KVxuICAgICAgICBSZXN1bHQuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIGNvdW50LCBuIC0gMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0LmNvcHlfZGF0YSAoQ3VycmVudCwgMCwgMCwgbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgUmVzdWx0X2RpZmZlcmVudF9mcm9tX2N1cnJlbnQ6IFJlc3VsdCAvPSBDdXJyZW50XG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG5cbiAgICAgIG5ld19jYXBhY2l0eTogUmVzdWx0LmNhcGFjaXR5ID0gblxuICAgICAgcHJlc2VydmVkOiBSZXN1bHQuc2FtZV9pdGVtcyAoQ3VycmVudCwgMCwgMCwgbi5taW4gKG9sZCBjb3VudCkpXG4gICAgZW5kXG5cbiAgYWxpYXNlZF9yZXNpemVkX2FyZWEgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRyeSB0byByZXNpemUgYEN1cnJlbnQnIHdpdGggYSBjb3VudCBvZiBgbicsIGlmIG5vdFxuICAgICAgLS0gcG9zc2libGUgYSBuZXcgY29weVxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBuZXdfY2FwYWNpdHk6IFJlc3VsdC5jYXBhY2l0eSA9IG5cbiAgICAgIHByZXNlcnZlZDogUmVzdWx0LnNhbWVfaXRlbXMgKG9sZCB0d2luLCAwLCAwLCBuLm1pbiAob2xkIGNvdW50KSlcbiAgICBlbmRcblxuICBhbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogVDsgbjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVHJ5IHRvIHJlc2l6ZSBgQ3VycmVudCcgd2l0aCBhIGNvdW50IG9mIGBuJywgaWYgbm90XG4gICAgICAtLSBwb3NzaWJsZSBhIG5ldyBjb3B5LiBOb24geWV0IGluaXRpYWxpemVkIGVudHJpZXMgYXJlIHNldCB0byBgYV9kZWZhdWx0X3ZhbHVlJy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIFJlc3VsdC5maWxsX3dpdGggKGFfZGVmYXVsdF92YWx1ZSwgUmVzdWx0LmNvdW50LCBuIC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIG5ld19jb3VudDogUmVzdWx0LmNvdW50ID0gblxuICAgICAgbmV3X2NhcGFjaXR5OiBSZXN1bHQuY2FwYWNpdHkgPSBuXG4gICAgICBwcmVzZXJ2ZWQ6IFJlc3VsdC5zYW1lX2l0ZW1zIChvbGQgdHdpbiwgMCwgMCwgbi5taW4gKG9sZCBjb3VudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlcGxhY2VfYWxsICh2OiBUKVxuICAgICAgLS0gUmVwbGFjZSBhbGwgaXRlbXMgd2l0aCBgdicuXG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGNvdW50IC0gMVxuICAgICAgdW50aWxcbiAgICAgICAgaSA8IDBcbiAgICAgIGxvb3BcbiAgICAgICAgcHV0ICh2LCBpKVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNsZWFyZWQ6IGZpbGxlZF93aXRoICh2LCAwLCB1cHBlcilcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVzZXQgY291bnQgdG8gemVyby5cbiAgICBkb1xuICAgICAgc2V0X2NvdW50ICgwKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X3Jlc2V0OiBjb3VudCA9IDBcbiAgICBlbmRcblxuICBjbGVhcl9hbGxcbiAgICAgIC0tIFJlc2V0IGFsbCBpdGVtcyB0byBkZWZhdWx0IHZhbHVlcy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJCZWNhdXNlIG9mIHRoZSBuZXcgcHJlY29uZGl0aW9uLCBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYGZpbGxfd2l0aCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGhhc19kZWZhdWx0OiAoe1R9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBmaWxsX3dpdGhfZGVmYXVsdCAoMCwgdXBwZXIpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfcmVzZXQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1RdXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtIChpKV0pXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2lmX2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1RdXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1RdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2l0ZW0gKGkpXSkgdGhlblxuICAgICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbSAoaSldKVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdGhlcmVfZXhpc3RzX2luX2JvdW5kcyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1RdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhdCBsZWFzdCBvbmUgaXRlbT9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iIG9yIFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gdGVzdC5pdGVtIChbaXRlbSAoaSldKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmb3JfYWxsX2luX2JvdW5kcyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1RdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhbGwgaXRlbXM/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSB0ZXN0Lml0ZW0gKFtpdGVtIChpKV0pXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGRvX2FsbF93aXRoX2luZGV4X2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1QsIElOVEVHRVJdXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIHJlY2VpdmVzIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgaiA6PSBsb3dlclxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBhY3Rpb24uY2FsbCAoW2l0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4X2luX2JvdW5kcyAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW1QsIElOVEVHRVJdXTsgdGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW1QsIElOVEVHRVJdLCBCT09MRUFOXTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0gdGhhdCBzYXRpc2ZpZXMgYHRlc3QnLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBgYWN0aW9uJyBhbmQgYHRlc3QnIHJlY2VpdmUgdGhlIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBvciBgdGVzdCcgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgaiA6PSBsb3dlclxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiB0ZXN0Lml0ZW0gKFtpdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2l0ZW0gKGkpLCBqXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgZGVidWdfb3V0cHV0OiBTVFJJTkdcbiAgICAgIC0tIFN0cmluZyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGVidWdnZXIgdG8gcmVwcmVzZW50IGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFByZWN1cnNvclxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmcgKFwiLCBjYXBhY2l0eT1cIilcbiAgICAgIFJlc3VsdC5hcHBlbmRfaW50ZWdlciAoY2FwYWNpdHkpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZWxlbWVudF9zaXplOiBJTlRFR0VSXG4gICAgICAtLSBTaXplIG9mIGVsZW1lbnRzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZWxlbWVudF9zaXplX25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBzZXRfY291bnQgKG46IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB3aXRoIGBuJy5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICB2YWxpZF9uZXdfY291bnQ6IG4gPD0gY291bnRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgY2FwYWNpdHlfcHJlc2VydmVkOiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgY291bnRfbGVzc190aGFuX2NhcGFjaXR5OiBjb3VudCA8PSBjYXBhY2l0eVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsImNsYXNzXG4gIFNUUklOR1xuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR18zMlxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgZW5kXG5cbiAgU1RSSU5HX0dFTkVSQUxcbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaGFzLCBpbmRleF9vZiwgbGFzdF9pbmRleF9vZiwgb2NjdXJyZW5jZXNcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWxcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0NIQVJBQ1RFUl8zMiwgSU5URUdFUl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBwcnVuZV9hbGwsXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgUkVTSVpBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaXRlbSwgYXQsIHB1dCwgdmFsaWRfaW5kZXhcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fc3RyaW5nLFxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIGFzX3N0cmluZ184OiB7UkVBREFCTEVfU1RSSU5HXzgsIFNUUklOR184fVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgczMyIHRoZW5cbiAgICAgICAgbWFrZV9mcm9tX3N0cmluZyAoczMyKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlIChzLmNvdW50KVxuICAgICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IGRldGFjaGFibGUgU1lTVEVNX1NUUklORylcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCB3aXRoIGBhX3N5c3RlbV9zdHJpbmcnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBhX3N5c3RlbV9zdHJpbmcubGVuZ3RoICsgZG90bmV0X2NvbnZlcnRvci5lc2NhcGVfY291bnQgKGFfc3lzdGVtX3N0cmluZylcbiAgICAgIGVuZFxuICAgICAgbWFrZSAobF9jb3VudClcbiAgICAgIGlmIGxfY291bnQgPiAwIGFuZCB0aGVuIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgc2V0X2NvdW50IChsX2NvdW50KVxuICAgICAgICBkb3RuZXRfY29udmVydG9yLnJlYWRfc3lzdGVtX3N0cmluZ19pbnRvIChhX3N5c3RlbV9zdHJpbmcsIEN1cnJlbnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGxfY291bnQgOj0gY19zdHJpbmdfcHJvdmlkZXIuY291bnRcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3RyaW5nX2ludG8gKEN1cnJlbnQpXG4gICAgZW5zdXJlXG4gICAgICBub196ZXJvX2J5dGU6IG5vdCBoYXMgKCclLzAvJylcbiAgICAgIC0tIGNoYXJhY3RlcnM6IGZvciBhbGwgaSBpbiAxLi5jb3VudCwgaXRlbSAoaSkgZXF1YWxzXG4gICAgICAtLSAgICAgICBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIChpIC0gMSlcbiAgICAgIC0tIGNvcnJlY3RfY291bnQ6IHRoZSBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIGNvdW50XG4gICAgICAtLSAgICAgICBpcyBOVUxMXG4gICAgZW5kXG5cbiAgZnJvbV9jX3N1YnN0cmluZyAoY19zdHJpbmc6IFBPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIHN1YnN0cmluZyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChjX3N0cmluZyArIChzdGFydF9wb3MgLSAxKSwgbF9jb3VudClcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvIChDdXJyZW50LCAxLCBsX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY291bnQ6IGNvdW50ID0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIC0tIGNoYXJhY3RlcnM6IGZvciBhbGwgaSBpbiAxLi5jb3VudCwgaXRlbSAoaSkgZXF1YWxzXG4gICAgICAtLSAgICAgICBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIChpIC0gMSlcbiAgICBlbmRcblxuICBhZGFwdCAoczogU1RSSU5HXzMyKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPYmplY3Qgb2YgYSB0eXBlIGNvbmZvcm1pbmcgdG8gdGhlIHR5cGUgb2YgYHMnLFxuICAgICAgLS0gaW5pdGlhbGl6ZWQgd2l0aCBhdHRyaWJ1dGVzIGZyb20gYHMnXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgUmVzdWx0LnNoYXJlIChzKVxuICAgIGVuc3VyZVxuICAgICAgYWRhcHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzaGFyZWRfaW1wbGVtZW50YXRpb246IFJlc3VsdC5zaGFyZWRfd2l0aCAocylcbiAgICBlbmRcblxuICByZW1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9zdHJpbmc6IGNvdW50ID0gMFxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzIgYXNzaWduIHB1dFxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSkuY29kZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIG9ic29sZXRlXG4gICAgICBcIkR1ZSB0byBwb3RlbnRpYWwgdHJ1bmNhdGlvbiBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYGNvZGUgKGkpJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5uYXR1cmFsXzMyX2NvZGUuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGFyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnNcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/IChBbnN3ZXI6IHllcy4pXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiB5ZXMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG4gIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IEJPT0xFQU4gPSBGYWxzZVxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0ICh0OiBSRUFEQUJMRV9TVFJJTkdfMzI7IG4xLCBuMjogSU5URUdFUilcbiAgICAgIC0tIFNldCBjdXJyZW50IHN0cmluZyB0byBzdWJzdHJpbmcgb2YgYHQnIGZyb20gaW5kaWNlcyBgbjEnXG4gICAgICAtLSB0byBgbjInLCBvciB0byBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBzdWJzdHJpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHQgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfMzJcbiAgICBkb1xuICAgICAgcyA6PSB0LnN1YnN0cmluZyAobjEsIG4yKVxuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19zdWJzdHJpbmc6IHNhbWVfc3RyaW5nICh0LnN1YnN0cmluZyAobjEsIG4yKSlcbiAgICBlbmRcblxuICBzdWJjb3B5IChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kXG4gICAgICAtLSBgZW5kX3BvcycgdG8gY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICAgIGVub3VnaF9zcGFjZTogKGNvdW50IC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBsb2NhbFxuICAgICAgbF9vdGhlcl9hcmVhLCBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBlbmRfcG9zID49IHN0YXJ0X3BvcyB0aGVuXG4gICAgICAgIGxfb3RoZXJfYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGlmIGxfYXJlYSAvPSBsX290aGVyX2FyZWEgdGhlblxuICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfb3RoZXJfYXJlYSwgc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBjb3BpZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpbmRleF9wb3MgLSAxKSArXG4gICAgICAgIG9sZCBvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykgK1xuICAgICAgICBvbGQgc3Vic3RyaW5nIChpbmRleF9wb3MgKyAoZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnIHRvIGBlbmRfaW5kZXgnIHdpdGggYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBkaWZmOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgc19jb3VudDogSU5URUdFUlxuICAgICAgb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHNfY291bnQgOj0gcy5jb3VudFxuICAgICAgb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICBkaWZmIDo9IHNfY291bnQgLSAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgbmV3X3NpemUgOj0gZGlmZiArIG9sZF9jb3VudFxuICAgICAgaWYgZGlmZiA+IDAgdGhlblxuICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIHRoZSBzdHJpbmcuXG4gICAgICAgIGdyb3cgKG5ld19zaXplKVxuICAgICAgZW5kXG5cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIC0tfCBXZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBmb3J3YXJkIChpZiBkaWZmIGlzID4gMCksIGJhY2t3YXJkIChpZiBkaWZmIDwgMCksXG4gICAgICAgIC0tfCBhbmQgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICBpZiBkaWZmIC89IDAgdGhlblxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoZW5kX2luZGV4LCBlbmRfaW5kZXggKyBkaWZmLCBvbGRfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICBlbmRcbiAgICAgICAgLS18IFNldCBuZXcgY291bnRcbiAgICAgIHNldF9jb3VudCAobmV3X3NpemUpXG4gICAgICAgIC0tfCBXZSBjb3B5IHRoZSBzdWJzdHJpbmcuXG4gICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgc3RhcnRfaW5kZXggLSAxLCBzX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50IC0gZW5kX2luZGV4ICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICByZXBsYWNlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCAoc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICtcbiAgICAgICAgICBzICsgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZ19hbGwgKG9yaWdpbmFsLCBuZXc6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgb2NjdXJyZW5jZSBvZiBgb3JpZ2luYWwnIHdpdGggYG5ldycuXG4gICAgcmVxdWlyZVxuICAgICAgb3JpZ2luYWxfZXhpc3RzOiBvcmlnaW5hbCAvPSBWb2lkXG4gICAgICBuZXdfZXhpc3RzOiBuZXcgLz0gVm9pZFxuICAgICAgb3JpZ2luYWxfbm90X2VtcHR5OiBub3Qgb3JpZ2luYWwuaXNfZW1wdHlcbiAgICBleHRlcm5cbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHJlcGxhY2VfYmxhbmtcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGN1cnJlbnQgY2hhcmFjdGVycyB3aXRoIGJsYW5rcy5cbiAgICBkb1xuICAgICAgZmlsbF93aXRoICgnICcpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3NpemU6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGFsbF9ibGFuazogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzICgnICcpID0gY291bnRcbiAgICBlbmRcblxuICBmaWxsX2JsYW5rXG4gICAgICAtLSBGaWxsIHdpdGggYGNhcGFjaXR5JyBibGFuayBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBmaWxsX2NoYXJhY3RlciAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgZmlsbGVkOiBmdWxsXG4gICAgICBzYW1lX3NpemU6IChjb3VudCA9IGNhcGFjaXR5KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgLS0gYWxsX2JsYW5rOiBGb3IgZXZlcnkgYGknIGluIGBjb3VudCcuLmBjYXBhY2l0eScsIGBpdGVtJyAoYGknKSA9IGBCbGFuaydcbiAgICBlbmRcblxuICBmaWxsX3dpdGggKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGxfY291bnQgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NvdW50IC0gMSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICByZXBsYWNlX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBjaGFyYWN0ZXIgd2l0aCBgYycuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGZpbGxfd2l0aCcgaW5zdGVhZCdcIlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKGMpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBmaWxsZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIGRvXG4gICAgICBpZiBuIDwgY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBrZWVwX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgbGFzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIGxvY2FsXG4gICAgICBuYjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbiA8IG5iIHRoZW5cbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYiAtIG4sIDAsIG4pXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGxlZnRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBuYiwgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIG5iX3NwYWNlID4gbmIgb3IgZWxzZSBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAobmJfc3BhY2UpKVxuICAgICAgbG9vcFxuICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQgdmFsdWUuXG4gICAgICAgIG5iIDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdC5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iX3NwYWNlLCAwLCBuYilcbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50LlxuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmlnaHRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzMyXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgcmlnaHQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBpIDo9IG5iXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpIDwgMFxuICAgICAgbG9vcFxuICAgICAgICBjIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICBpZiBub3QgbF9wcm9wLmlzX3NwYWNlIChjKSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBhcmUgZG9uZS5cbiAgICAgICAgICBpIDo9IC0xXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNoYXJlIChvdGhlcjogU1RSSU5HXzMyKVxuICAgICAgLS0gTWFrZSBjdXJyZW50IHN0cmluZyBzaGFyZSB0aGUgdGV4dCBvZiBgb3RoZXInLlxuICAgICAgLS0gU3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nXG4gICAgICAtLSB3aWxsIGFsc28gYWZmZWN0IGBvdGhlcicsIGFuZCBjb252ZXJzZWx5LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBzaGFyZWRfY291bnQ6IG90aGVyLmNvdW50ID0gY291bnRcbiAgICAgIHNoYXJlZF9hcmVhOiBvdGhlci5hcmVhID0gYXJlYVxuICAgIGVuZFxuXG4gIHB1dCAoYzogQ0hBUkFDVEVSXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknIGJ5IGBjJy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKGMsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc3RhYmxlX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICBwdXRfY29kZSAodjogTkFUVVJBTF8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBjaGFyYWN0ZXIgb2YgY29kZSBgdicuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0ICh2LnRvX2NoYXJhY3Rlcl8zMiwgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBsX3MzMiB0aGVuXG4gICAgICAgIHByZXBlbmQgKGxfczMyKVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHByZWNlZGUsIHByZXBlbmRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBBZGQgYGMnIGF0IGZyb250LlxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBjb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgMSwgY291bnQpXG4gICAgICBsX2FyZWEucHV0IChjLCAwKVxuICAgICAgY291bnQgOj0gY291bnQgKyAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICBlbmRcblxuICBwcmVwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgMSlcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocyArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCBsX3NfY291bnQsIGNvdW50KVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGJlZ2lubmluZy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIDAsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChkLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChpLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChyLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIHMgLz0gVm9pZCB0aGVuXG4gICAgICAgIHByZXBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBsX3MzMiB0aGVuXG4gICAgICAgIGFwcGVuZCAobF9zMzIpXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7U1RSSU5HX0dFTkVSQUx9IChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBsX2NvdW50LCBsX3NfY291bnQpXG4gICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50XG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKEN1cnJlbnQgKyBzKSlcbiAgICBlbmRcblxuICBhcHBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpKSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIFJlc3VsdC5hcHBlbmQgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gQXBwZW5kIGEgY29weSBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIHMgLz0gVm9pZCB0aGVuXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYXBwZW5kZWQ6IHMgLz0gVm9pZCBpbXBsaWVzXG4gICAgICAgIChlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgdHdpbiArIG9sZCBzLnR3aW4pKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSfS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl84fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl8xNiAoaTogSU5URUdFUl8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl8xNn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfNjQgKGk6IElOVEVHRVJfNjQpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzY0XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfNjR9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzggKGk6IE5BVFVSQUxfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzE2IChpOiBOQVRVUkFMXzE2KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF8xNlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzMyIChpOiBOQVRVUkFMXzMyKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF8zMlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzY0IChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChyLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgZCcgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKGQub3V0KVxuICAgIGVuZFxuXG4gIGFwcGVuZF9jaGFyYWN0ZXIsIGV4dGVuZCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gQXBwZW5kIGBjJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgY3VycmVudF9jb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjdXJyZW50X2NvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgYXJlYS5wdXQgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgICBjb3VudCA6PSBjdXJyZW50X2NvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXRlbV9pbnNlcnRlZDogaXRlbSAoY291bnQpID0gY1xuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHN0YWJsZV9iZWZvcmU6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGNvdW50IC0gMSkgfiAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgYXBwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKGIub3V0KVxuICAgIGVuZFxuXG4gIGluc2VydCAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQWRkIGBzJyB0byBsZWZ0IG9mIHBvc2l0aW9uIGBpJyBpbiBjdXJyZW50IHN0cmluZy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgaW5zZXJ0X3N0cmluZycgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnQgKyAxXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPiAwXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIGkpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X3N0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBzJyBhdCBpbmRleCBgaScsIHNoaWZ0aW5nIGNoYXJhY3RlcnMgYmV0d2VlbiByYW5rc1xuICAgICAgLS0gYGknIGFuZCBgY291bnQnIHJpZ2h0d2FyZHMuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50IC89IDAgdGhlblxuICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgY291bnRcbiAgICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBwb3MgOj0gaSAtIDFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAocG9zLCBwb3MgKyBsX3NfY291bnQsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGluZGV4IGBwb3MnLlxuICAgICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgcG9zLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkgKyBvbGQgKHMudHdpbikgKyBvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIGluc2VydF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgYycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgIG5ld19zaXplIDo9IDEgKyBjb3VudFxuICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgcG9zIDo9IGkgLSAxXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgMSwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgLS0gSW5zZXJ0IG5ldyBjaGFyYWN0ZXJcbiAgICAgIGxfYXJlYS5wdXQgKGMsIHBvcylcblxuICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBvbmVfbW9yZV9jaGFyYWN0ZXI6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gY1xuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmUgKGk6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYGknLXRoIGNoYXJhY3Rlci5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKGksIGkgLSAxLCBsX2NvdW50IC0gaSlcbiAgICAgICAgLS0gVXBkYXRlIGNvbnRlbnQuXG4gICAgICBjb3VudCA6PSBsX2NvdW50IC0gMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nIChuLm1pbiAoY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnXG4gICAgICAtLSB0byBgZW5kX2luZGV4JyBpbmNsdXNpdmUuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIG5iX3JlbW92ZWQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmJfcmVtb3ZlZCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIG5iX3JlbW92ZWQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X2luZGV4ICsgbmJfcmVtb3ZlZCAtIDEsIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgICAgY291bnQgOj0gbF9jb3VudCAtIG5iX3JlbW92ZWRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArIG9sZCBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBsYXN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbiA+IGxfY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAobF9jb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGNvdW50IC0gbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcHJ1bmUgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJywgaWYgYW55LlxuICAgIHJlcXVpcmUgZWxzZVxuICAgICAgVHJ1ZVxuICAgIGxvY2FsXG4gICAgICBjb3VudGVyOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgY291bnRlciA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBjb3VudGVyID4gY291bnQgb3IgZWxzZSAoaXRlbSAoY291bnRlcikgPSBjKVxuICAgICAgbG9vcFxuICAgICAgICBjb3VudGVyIDo9IGNvdW50ZXIgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIGNvdW50ZXIgPD0gY291bnQgdGhlblxuICAgICAgICByZW1vdmUgKGNvdW50ZXIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIHJlcXVpcmUgZWxzZVxuICAgICAgVHJ1ZVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfY2hhcjogQ0hBUkFDVEVSXzMyXG4gICAgZG9cbiAgICAgICAgLS0gVHJhdmVyc2Ugc3RyaW5nIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0XG4gICAgICAgIC0tIGVhY2ggdGltZSB3ZSBmaW5kIGFuIG9jY3VycmVuY2Ugb2YgYGMnLlxuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY2hhciA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbF9jaGFyIC89IGMgdGhlblxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfY2hhciwgailcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGNvdW50IDo9IGpcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNoYW5nZWRfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCkgLSAob2xkIG9jY3VycmVuY2VzIChjKSlcbiAgICAgIC0tIHJlbW92ZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpIC89IGBjJ1xuICAgIGVuZFxuXG4gIHBydW5lX2FsbF9sZWFkaW5nIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGxlYWRpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKDEpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlICgxKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsX3RyYWlsaW5nIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIHRyYWlsaW5nIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHkgb3IgZWxzZSBpdGVtIChjb3VudCkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgd2lwZV9vdXRcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXNfZW1wdHk6IGNvdW50ID0gMFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuICBjbGVhcl9hbGxcbiAgICAgIC0tIFJlc2V0IGFsbCBjaGFyYWN0ZXJzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgd2lwZV9vdXQnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBhZGFwdF9zaXplXG4gICAgICAtLSBBZGFwdCB0aGUgc2l6ZSB0byBhY2NvbW1vZGF0ZSBgY291bnQnIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIHJlc2l6ZSAoY291bnQpXG4gICAgZW5kXG5cbiAgcmVzaXplIChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIHN0cmluZyBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gYXQgbGVhc3QgYG5ld3NpemUnIGNoYXJhY3RlcnMuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGNoYXJhY3Rlci5cbiAgICBkb1xuICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyUvMDAwLycsIG5ld3NpemUgKyAxKVxuICAgIGVuZFxuXG4gIGdyb3cgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBFbnN1cmUgdGhhdCB0aGUgY2FwYWNpdHkgaXMgYXQgbGVhc3QgYG5ld3NpemUnLlxuICAgIGRvXG4gICAgICBpZiBuZXdzaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld3NpemUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0cmltXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBuOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG4gOj0gY291bnRcbiAgICAgIGlmIG4gPCBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYW1lX3N0cmluZzogc2FtZV9zdHJpbmcgKG9sZCB0d2luKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19sb3dlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b19sb3dlclxuICAgIGVuZFxuXG4gIGFzX3VwcGVyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiB1cHBlciBjYXNlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fdXBwZXJcbiAgICBlbmRcblxuICBsZWZ0X2p1c3RpZnlcbiAgICAgIC0tIExlZnQganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2l0ZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZSBzcGFjZXMuXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgbGVmdF9hZGp1c3RcblxuICAgICAgICAtLSBHZXQgbmV3IGNvdW50XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgIC0tIGBsZWZ0X2FkanVzdCcgZGlkIHJlbW92ZSBzb21lIGNoYXJhY3RlcnMsIHNvIHdlIG5lZWQgdG8gYWRkXG4gICAgICAgICAgLS0gc29tZSB3aGl0ZSBzcGFjZXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY2VudGVyX2p1c3RpZnlcbiAgICAgIC0tIENlbnRlciBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmIsIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgICBsZWZ0X25iX3NwYWNlLCByaWdodF9uYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBsZWZ0X25iX3NwYWNlID0gbmIgb3IgZWxzZSBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAobGVmdF9uYl9zcGFjZSkpXG4gICAgICBsb29wXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgOj0gbGVmdF9uYl9zcGFjZSArIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgcmlnaHQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbmIgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gLTEgb3IgZWxzZSBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAoaSkpXG4gICAgICBsb29wXG4gICAgICAgIHJpZ2h0X25iX3NwYWNlIDo9IHJpZ2h0X25iX3NwYWNlICsgMVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBXZSBlbmNvdXJhZ2UgdGhhdCBtb3JlIHNwYWNlcyB3aWxsIGJlIHB1dCB0byB0aGUgbGVmdCwgd2hlblxuICAgICAgICAtLSBudW1iZXIgb2Ygc3BhY2VzIGlzIG5vdCBldmVuLlxuICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSArIHJpZ2h0X25iX3NwYWNlXG4gICAgICBpZiBsX29mZnNldCBcXFxcIDIgPSAwIHRoZW5cbiAgICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC8vIDJcbiAgICAgIGVsc2VcbiAgICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC8vIDIgLSAxXG4gICAgICBlbmRcbiAgICAgIGlmIGxfb2Zmc2V0IC89IDAgdGhlblxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0IG9yIGxlZnQgKGRlcGVuZGluZyBvbiBzaWduIG9mXG4gICAgICAgICAgLS0gYGxfb2Zmc2V0JyBieSBgbF9vZmZzZXQnIHBvc2l0aW9uLlxuICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQsXG4gICAgICAgICAgbmIgLSBsZWZ0X25iX3NwYWNlIC0gcmlnaHRfbmJfc3BhY2UpXG5cbiAgICAgICAgaWYgbF9vZmZzZXQgPCAwIHRoZW5cbiAgICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgbGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gRmlsbCByaWdodCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgbmIgLSByaWdodF9uYl9zcGFjZSAtIGxfb2Zmc2V0LCBuYiAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmlnaHRfanVzdGlmeVxuICAgICAgLS0gUmlnaHQganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIHJpZ2h0X2FkanVzdFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgbmJfc3BhY2UgOj0gbmIgLSBpXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChpKSwgaSArIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaSArIDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIG5iX3NwYWNlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIG5iX3NwYWNlICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfanVzdGlmeSAocGl2b3Q6IENIQVJBQ1RFUl8zMjsgcG9zaXRpb246IElOVEVHRVIpXG4gICAgICAtLSBKdXN0aWZ5IGEgc3RyaW5nIGJhc2VkIG9uIGEgYHBpdm90J1xuICAgICAgLS0gYW5kIHRoZSBgcG9zaXRpb24nIGl0IG5lZWRzIHRvIGJlIGluXG4gICAgICAtLSB0aGUgZmluYWwgc3RyaW5nLlxuICAgICAgLS0gVGhpcyB3aWxsIGdyb3cgdGhlIHN0cmluZyBpZiBuZWNlc3NhcnlcbiAgICAgIC0tIHRvIGdldCB0aGUgcGl2b3QgaW4gdGhlIGNvcnJlY3QgcGxhY2UuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfcG9zaXRpb246IHBvc2l0aW9uIDw9IGNhcGFjaXR5XG4gICAgICBwb3NpdGl2ZV9wb3NpdGlvbjogcG9zaXRpb24gPj0gMVxuICAgICAgcGl2b3Rfbm90X3NwYWNlOiBwaXZvdCAvPSAnICdcbiAgICAgIG5vdF9lbXB0eTogbm90IGlzX2VtcHR5XG4gICAgbG9jYWxcbiAgICAgIGxfaW5kZXhfb2ZfcGl2b3QsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfaW5kZXhfb2ZfcGl2b3QgOj0gaW5kZXhfb2YgKHBpdm90LCAxKVxuICAgICAgaWYgbF9pbmRleF9vZl9waXZvdCAvPSAwIHRoZW5cbiAgICAgICAgaWYgbF9pbmRleF9vZl9waXZvdCA8IHBvc2l0aW9uIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIEN1cnJlbnQgc28gdGhhdCB3ZSBjYW4gc2hpZnQgQ3VycmVudCBieVxuICAgICAgICAgICAgLS0gYGxfaW5kZXhfb2ZfcGl2b3QgLSBwb3NpdGlvbicuXG4gICAgICAgICAgbF9uZXdfc2l6ZSA6PSBjb3VudCArIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdFxuICAgICAgICAgIGdyb3cgKGxfbmV3X3NpemUpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhICgwLCBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3QsIGNvdW50KVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90IC0gMSlcbiAgICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIFNpbXBseSBzaGlmdCBjb250ZW50IHRvIHRoZSBsZWZ0IGFuZCByZXNldCB0cmFpbGluZyB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxfaW5kZXhfb2ZfcGl2b3QgLSBwb3NpdGlvbiwgMCwgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24pXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBjb3VudCAtIGxfaW5kZXhfb2ZfcGl2b3QgKyBwb3NpdGlvbiwgY291bnQgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX2xvd2VyXG4gICAgICAtLSBDb252ZXJ0IHRvIGxvd2VyIGNhc2UuXG4gICAgZG9cbiAgICAgIHRvX2xvd2VyX2FyZWEgKGFyZWEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBsZW5ndGhfYW5kX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBhc19sb3dlcilcbiAgICBlbmRcblxuICB0b191cHBlclxuICAgICAgLS0gQ29udmVydCB0byB1cHBlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b191cHBlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfdXBwZXIpXG4gICAgZW5kXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNvdW50XG4gICAgICBsb29wXG4gICAgICAgIHRlbXAuZXh0ZW5kIChpdGVtIChpKSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gdGVtcFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19jOiBBTllcbiAgICAgIC0tIEEgcmVmZXJlbmNlIHRvIGEgQyBmb3JtIG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgLS0gVXNlZnVsIG9ubHkgZm9yIGludGVyZmFjaW5nIHdpdGggQyBzb2Z0d2FyZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5wdXQgKCclVScsIGNvdW50KVxuICAgICAgUmVzdWx0IDo9IGxfYXJlYVxuICAgIGVuZFxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBSZXN1bHQubWlycm9yXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtaXJyb3JcbiAgICAgIC0tIFJldmVyc2UgdGhlIG9yZGVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAtLSBcIkhlbGxvIHdvcmxkXCIgLT4gXCJkbHJvdyBvbGxlSFwiLlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBjb3VudCAtIDFcbiAgICAgICAgICBhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpIDw9IGpcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMgOj0gYS5pdGVtIChpKVxuICAgICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICAgIGEucHV0IChjLCBqKVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgLS0gcmV2ZXJzZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gb2xkIGBpdGVtJyAoYGNvdW50JysxLWBpJylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgZG9cbiAgICAgIGlmICgxIDw9IHN0YXJ0X2luZGV4KSBhbmQgKHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCkgYW5kIChlbmRfaW5kZXggPD0gY291bnQpIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgICAgUmVzdWx0LmFyZWEuY29weV9kYXRhIChhcmVhLCBzdGFydF9pbmRleCAtIDEsIDAsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgICAgUmVzdWx0LnNldF9jb3VudCAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoMClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG11bHRpcGx5IChuOiBJTlRFR0VSKVxuICAgICAgLS0gRHVwbGljYXRlIGEgc3RyaW5nIHdpdGhpbiBpdHNlbGZcbiAgICAgIC0tIChcImhlbGxvXCIpLm11bHRpcGx5KDMpID0+IFwiaGVsbG9oZWxsb2hlbGxvXCJcbiAgICByZXF1aXJlXG4gICAgICBtZWFuaW5nZnVsX211bHRpcGxpZXI6IG4gPj0gMVxuICAgIGxvY2FsXG4gICAgICBzOiBsaWtlIEN1cnJlbnRcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgcyA6PSB0d2luXG4gICAgICBncm93IChuICogY291bnQpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gblxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDFcbiAgICAgIGxvb3BcbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7U1RSSU5HX0hBTkRMRVJ9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZnJvemVuIHNldF9jb3VudCAobnVtYmVyOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBjb3VudCcgdG8gYG51bWJlcicgb2YgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gbnVtYmVyXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIG5ld19zdHJpbmcgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBjdXJyZW50IHdpdGggc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVHJhbnNmb3JtYXRpb25cblxuICBjb3JyZWN0X21pc21hdGNoXG4gICAgICAtLSBBdHRlbXB0IHRvIGNvcnJlY3Qgb2JqZWN0IG1pc21hdGNoIGR1cmluZyByZXRyaWV2ZSB1c2luZyBgbWlzbWF0Y2hfaW5mb3JtYXRpb24nLlxuICAgIGRvXG4gICAgICAgIC0tIE5vdGhpbmcgdG8gYmUgZG9uZSBiZWNhdXNlIHdlIG9ubHkgYWRkZWQgYGludGVybmFsX2hhc2hfY29kZScgdGhhdCB3aWxsXG4gICAgICAgIC0tIGJlIHJlY29tcHV0ZWQgbmV4dCB0aW1lIHdlIHF1ZXJ5IGBoYXNoX2NvZGUnLlxuXG4gICAgICAgIC0tIEluIC5ORVQsIHdlIGhhdmUgYSBtaXNtYXRjaCB0aGF0IGlzIHRyaWdnZXJlZCBkdWUgdG8gdGhlIGltcGxlbWVudGF0aW9uIG9mXG4gICAgICAgIC0tIFNQRUNJQUwgW0NIQVJBQ1RFUl8zMl0gYXMgYSAuTkVUIGFycmF5IG9mIFVJbnQxNi5cbiAgICAgIGlmIGFyZWEgPSBWb2lkIGFuZCB0aGVuIGF0dGFjaGVkIHtsaWtlIGFyZWF9IG1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKFwiYXJlYVwiKSBhcyBsX2FyZWEgdGhlblxuICAgICAgICBhcmVhIDo9IGxfYXJlYVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gIGNvbXBhcmVfY2hhcmFjdGVyOiBub3Qgb2JqZWN0X2NvbXBhcmlzb25cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBTZXF1ZW5jZXMgb2YgMzItYml0IGNoYXJhY3RlcnMsIGFjY2Vzc2libGUgdGhyb3VnaCBpbnRlZ2VyIGluZGljZXNcbiAgICBpbiBhIGNvbnRpZ3VvdXMgcmFuZ2UuXG4gICAgXVwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wMy0yNSAyMDo0Njo1NCAtMDcwMCAoVHVlLCAyNSBNYXIgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTQ3MTcgJFwiXG5cbmNsYXNzXG4gIFNUUklOR18zMlxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR18zMlxuICAgIGV4cG9ydFxuICAgICAge0FOWX0gbWFrZSwgbWFrZV9lbXB0eSwgbWFrZV9maWxsZWQsIG1ha2VfZnJvbV9jLCBtYWtlX2Zyb21fc3RyaW5nLCBmaWxsX2NoYXJhY3RlclxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgU1RSSU5HX0dFTkVSQUxcbiAgICByZW5hbWVcbiAgICAgIGFwcGVuZCBhcyBhcHBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBhcHBlbmRfc3Vic3RyaW5nIGFzIGFwcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmQgYXMgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3Vic3RyaW5nIGFzIHByZXBlbmRfc3Vic3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGhhcywgaW5kZXhfb2YsIGxhc3RfaW5kZXhfb2YsIG9jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWxcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0NIQVJBQ1RFUl8zMiwgSU5URUdFUl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBwcnVuZV9hbGwsXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgUkVTSVpBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaXRlbSwgYXQsIHB1dCwgdmFsaWRfaW5kZXhcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fc3RyaW5nLFxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsLFxuICBtYWtlX2Zyb21fc2VwYXJhdGVcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgbWFrZV9mcm9tX2NpbCAoe1NZU1RFTV9TVFJJTkd9KSxcbiAgYXNfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOCwgU1RSSU5HXzh9XG5cbmZlYXR1cmUgLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBzMzIgdGhlblxuICAgICAgICBtYWtlX2Zyb21fc3RyaW5nIChzMzIpXG4gICAgICBlbHNlXG4gICAgICAgIG1ha2UgKHMuY291bnQpXG4gICAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jaWwgKGFfc3lzdGVtX3N0cmluZzogZGV0YWNoYWJsZSBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IHdpdGggYGFfc3lzdGVtX3N0cmluZycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGFfc3lzdGVtX3N0cmluZy5sZW5ndGggKyBkb3RuZXRfY29udmVydG9yLmVzY2FwZV9jb3VudCAoYV9zeXN0ZW1fc3RyaW5nKVxuICAgICAgZW5kXG4gICAgICBtYWtlIChsX2NvdW50KVxuICAgICAgaWYgbF9jb3VudCA+IDAgYW5kIHRoZW4gYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBzZXRfY291bnQgKGxfY291bnQpXG4gICAgICAgIGRvdG5ldF9jb252ZXJ0b3IucmVhZF9zeXN0ZW1fc3RyaW5nX2ludG8gKGFfc3lzdGVtX3N0cmluZywgQ3VycmVudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBjb250ZW50cyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdHJpbmdfaW50byAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIG5vX3plcm9fYnl0ZTogbm90IGhhcyAoJyUvMC8nKVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgICAgLS0gY29ycmVjdF9jb3VudDogdGhlIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgY291bnRcbiAgICAgIC0tICAgICAgIGlzIE5VTExcbiAgICBlbmRcblxuICBmcm9tX2Nfc3Vic3RyaW5nIChjX3N0cmluZzogUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gc3Vic3RyaW5nIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGNfc3RyaW5nICsgKHN0YXJ0X3BvcyAtIDEpLCBsX2NvdW50KVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG8gKEN1cnJlbnQsIDEsIGxfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgIGVuZFxuXG4gIGFkYXB0IChzOiBTVFJJTkdfMzIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9iamVjdCBvZiBhIHR5cGUgY29uZm9ybWluZyB0byB0aGUgdHlwZSBvZiBgcycsXG4gICAgICAtLSBpbml0aWFsaXplZCB3aXRoIGF0dHJpYnV0ZXMgZnJvbSBgcydcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBSZXN1bHQuc2hhcmUgKHMpXG4gICAgZW5zdXJlXG4gICAgICBhZGFwdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNoYXJlZF9pbXBsZW1lbnRhdGlvbjogUmVzdWx0LnNoYXJlZF93aXRoIChzKVxuICAgIGVuZFxuXG4gIHJlbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG1ha2UnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkb1xuICAgICAgbWFrZSAobilcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5X3N0cmluZzogY291bnQgPSAwXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMiBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKVxuICAgIGVuZFxuXG4gIGNvZGUgKGk6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLm5hdHVyYWxfMzJfY29kZS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gU3RvcmFnZSBmb3IgY2hhcmFjdGVyc1xuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gTWF5IG5ldyBpdGVtcyBiZSBhZGRlZD8gKEFuc3dlcjogeWVzLilcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvbjogQk9PTEVBTiA9IEZhbHNlXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXQgKHQ6IFJFQURBQkxFX1NUUklOR18zMjsgbjEsIG4yOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGN1cnJlbnQgc3RyaW5nIHRvIHN1YnN0cmluZyBvZiBgdCcgZnJvbSBpbmRpY2VzIGBuMSdcbiAgICAgIC0tIHRvIGBuMicsIG9yIHRvIGVtcHR5IHN0cmluZyBpZiBubyBzdWNoIHN1YnN0cmluZy5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIHM6IFJFQURBQkxFX1NUUklOR18zMlxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyB0byBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgICAgZW5vdWdoX3NwYWNlOiAoY291bnQgLSBpbmRleF9wb3MpID49IChlbmRfcG9zIC0gc3RhcnRfcG9zKVxuICAgIGxvY2FsXG4gICAgICBsX290aGVyX2FyZWEsIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGVuZF9wb3MgPj0gc3RhcnRfcG9zIHRoZW5cbiAgICAgICAgbF9vdGhlcl9hcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaWYgbF9hcmVhIC89IGxfb3RoZXJfYXJlYSB0aGVuXG4gICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9vdGhlcl9hcmVhLCBzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGNvcGllZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGluZGV4X3BvcyAtIDEpICtcbiAgICAgICAgb2xkIG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSArXG4gICAgICAgIG9sZCBzdWJzdHJpbmcgKGluZGV4X3BvcyArIChlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCcgdG8gYGVuZF9pbmRleCcgd2l0aCBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bGxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGRpZmY6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBzX2NvdW50OiBJTlRFR0VSXG4gICAgICBvbGRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBvbGRfY291bnQgOj0gY291bnRcbiAgICAgIGRpZmYgOj0gc19jb3VudCAtIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBuZXdfc2l6ZSA6PSBkaWZmICsgb2xkX2NvdW50XG4gICAgICBpZiBkaWZmID4gMCB0aGVuXG4gICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgdGhlIHN0cmluZy5cbiAgICAgICAgZ3JvdyAobmV3X3NpemUpXG4gICAgICBlbmRcblxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgLS18IFdlIG1vdmUgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGZvcndhcmQgKGlmIGRpZmYgaXMgPiAwKSwgYmFja3dhcmQgKGlmIGRpZmYgPCAwKSxcbiAgICAgICAgLS18IGFuZCBub3RoaW5nIG90aGVyd2lzZS5cbiAgICAgIGlmIGRpZmYgLz0gMCB0aGVuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChlbmRfaW5kZXgsIGVuZF9pbmRleCArIGRpZmYsIG9sZF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgIGVuZFxuICAgICAgICAtLXwgU2V0IG5ldyBjb3VudFxuICAgICAgc2V0X2NvdW50IChuZXdfc2l6ZSlcbiAgICAgICAgLS18IFdlIGNvcHkgdGhlIHN1YnN0cmluZy5cbiAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBzdGFydF9pbmRleCAtIDEsIHNfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnQgLSBlbmRfaW5kZXggKyBzdGFydF9pbmRleCAtIDFcbiAgICAgIHJlcGxhY2VkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIChzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgK1xuICAgICAgICAgIHMgKyBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nX2FsbCAob3JpZ2luYWwsIG5ldzogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2ZpcnN0X3BvcywgbF9uZXh0X3BvczogSU5URUdFUlxuICAgICAgbF9vcmlnX2NvdW50LCBsX25ld19jb3VudCwgbF9uZXdfbG93ZXIsIGxfY291bnQsIGksIGxfaW5kZXhfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfc3JjX2luZGV4LCBsX2Rlc3RfaW5kZXgsIGxfcHJldl9pbmRleCwgbF9jb3B5X2RlbHRhOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfbmV3X2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxfc3RyaW5nX3NlYXJjaGVyOiBsaWtlIHN0cmluZ19zZWFyY2hlclxuICAgICAgbF9pbmRleF9saXN0OiBTUEVDSUFMIFtJTlRFR0VSXVxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfc3RyaW5nX3NlYXJjaGVyIDo9IHN0cmluZ19zZWFyY2hlclxuICAgICAgICBsX3N0cmluZ19zZWFyY2hlci5pbml0aWFsaXplX2RlbHRhcyAob3JpZ2luYWwpXG4gICAgICAgIGxfb3JpZ19jb3VudCA6PSBvcmlnaW5hbC5jb3VudFxuICAgICAgICBsX25ld19jb3VudCA6PSBuZXcuY291bnRcbiAgICAgICAgaWYgbF9vcmlnX2NvdW50ID49IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCAxLCBsX2NvdW50KVxuICAgICAgICAgIGlmIGxfZmlyc3RfcG9zID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBsX29yaWdfY291bnQgPSBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3RyaW5nIHdpbGwgbm90IGJlIHJlc2l6ZWQsIHNpbXBseSBwZXJmb3JtIGNoYXJhY3RlciBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgPSAwXG4gICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICBpZiBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IDw9IGxfY291bnQgdGhlblxuICAgICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSAwXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZWlmIGxfb3JpZ19jb3VudCA+IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgLS0gTmV3IHN0cmluZyBpcyBzbWFsbGVyIHRoYW4gcHJldmlvdXMgc3RyaW5nLCB3ZSBjYW4gb3B0aW1pemVcbiAgICAgICAgICAgICAgLS0gc3Vic3RpdHV0aW9uIGJ5IG9ubHkgbW92aW5nIGJsb2NrIGJldHdlZW4gdHdvIG9jY3VycmVuY2VzIG9mIGBvcmdpbmFsJy5cbiAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCBsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgdW50aWxcbiAgICAgICAgICAgICAgbF9uZXh0X3BvcyA9IDBcbiAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICAtLSBDb3B5IG5ldyBzdHJpbmcgaW50byBDdXJyZW50XG4gICAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2ZpcnN0X3BvcyAtIDEgLSBsX29mZnNldCwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyBiZXR3ZWVuIGBsX2ZpcnN0X3BvcycgYW5kIGBsX25leHRfcG9zJ1xuICAgICAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQgLSAxLFxuICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgLSAxIC0gbF9vZmZzZXQsIGxfbmV4dF9wb3MgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9uZXh0X3Bvc1xuICAgICAgICAgICAgICBsX29mZnNldCA6PSBsX29mZnNldCArIChsX29yaWdfY291bnQgLSBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgaWYgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCA8PSBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICBsX25leHRfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50LCBsX2NvdW50KVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSAwXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIC0tIFBlcmZvcm0gZmluYWwgc3Vic3RpdHV0aW9uOlxuICAgICAgICAgICAgICAtLSBDb3B5IG5ldyBzdHJpbmcgaW50byBDdXJyZW50XG4gICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxIC0gbF9vZmZzZXQsIGxfbmV3X2NvdW50KVxuICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQgLSAxLFxuICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IC0gMSAtIGxfb2Zmc2V0LCBsX2NvdW50ICsgMSAtIGxfZmlyc3RfcG9zIC0gbF9vcmlnX2NvdW50KVxuICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gbGFzdCBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgIGxfb2Zmc2V0IDo9IGxfb2Zmc2V0ICsgKGxfb3JpZ19jb3VudCAtIGxfbmV3X2NvdW50KVxuXG4gICAgICAgICAgICAgIC0tIFVwZGF0ZSBgY291bnQnXG4gICAgICAgICAgICBzZXRfY291bnQgKGxfY291bnQgLSBsX29mZnNldClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAtLSBTdHJpbmcgd2FzIG1vZGlmaWVkIHdlIG5lZWQgdG8gcmVjb21wdXRlIHRoZSBgaGFzaF9jb2RlJy5cbiAgICAgICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBhdHRhY2hlZCBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfbGlzdF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIDEsIGxfY291bnQpIGFzIGxfbGlzdCB0aGVuXG4gICAgICAgICAgICAtLSBHZXQgdGhlIG51bWJlciBvZiBzdWJzdGl0dXRpb24gdG8gYmUgcGVyZm9ybWVkIGJ5IGdldHRpbmcgYSBsaXN0XG4gICAgICAgICAgICAtLSBvZiBsb2NhdGlvbiB3aGVyZSBgb3JpZ2luYWwnIGFwcGVhcnMuXG4gICAgICAgICAgbF9pbmRleF9saXN0IDo9IGxfbGlzdC5hcmVhXG4gICAgICAgICAgbF9pbmRleF9jb3VudCA6PSBsX2luZGV4X2xpc3QuY291bnRcbiAgICAgICAgICAgIC0tIFN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgdXAgdG8gd2hpY2ggd2UgbmVlZCB0byBtb3ZlXG4gICAgICAgICAgICAtLSBjaGFyYWN0ZXJzIGluIHRoZSByZWFsbG9jYXRlZCBzdHJpbmcuXG4gICAgICAgICAgbF9wcmV2X2luZGV4IDo9IGxfY291bnRcbiAgICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAgbF9jb3B5X2RlbHRhIDo9IGxfbmV3X2NvdW50IC0gbF9vcmlnX2NvdW50XG4gICAgICAgICAgbF9jb3VudCA6PSBsX2NvdW50ICsgKGxfaW5kZXhfY291bnQgKiBsX2NvcHlfZGVsdGEpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyVVJywgbF9jb3VudCArIDEpXG4gICAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgICAgICAgIC0tIFBlcmZvcm0gdGhlIHN1YnN0aXR1dGlvbiBzdGFydGluZyBmcm9tIHRoZSBlbmQuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgaSA6PSBsX2luZGV4X2NvdW50XG4gICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGxfc3JjX2luZGV4IDo9IGxfaW5kZXhfbGlzdC5pdGVtIChpKVxuICAgICAgICAgICAgbF9kZXN0X2luZGV4IDo9IGxfc3JjX2luZGV4ICsgaSAqIGxfY29weV9kZWx0YVxuICAgICAgICAgICAgICAtLSBTaGlmdCBub24tbWF0Y2hpbmcgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb2YgdGhlIG5ld2x5IHJlcGxhY2VkIHN0cmluZy5cbiAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX3NyY19pbmRleCArIGxfb3JpZ19jb3VudCAtIDEsIGxfZGVzdF9pbmRleCArIGxfbmV3X2NvdW50IC0gMSwgbF9wcmV2X2luZGV4IC0gbF9zcmNfaW5kZXggLSBsX29yaWdfY291bnQgKyAxKVxuICAgICAgICAgICAgICAtLSBTdG9yZSBuZXcgZW5kIG9mIHN0cmluZyB3aGVyZSBjaGFyYWN0ZXJzIHdpbGwgYmUgbW92ZWQuXG4gICAgICAgICAgICBsX3ByZXZfaW5kZXggOj0gbF9zcmNfaW5kZXggLSAxXG5cbiAgICAgICAgICAgICAgLS0gQ29weSBgbmV3JyB0byBpdHMgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2Rlc3RfaW5kZXggLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIFVwZGF0ZSB0aGUgbmV3IGBjb3VudCcgd2hpY2ggYWxzbyByZXNldHMgdGhlIGBoYXNoX2NvZGUnLlxuICAgICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBsX2NvdW50IC89IDAgdGhlblxuICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYywgMCwgbF9jb3VudCAtIDEpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgcmVwbGFjZV9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBmaWxsX3dpdGgnIGluc3RlYWQnXCJcbiAgICBkb1xuICAgICAgZmlsbF93aXRoIChjKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgZmlyc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBkb1xuICAgICAgaWYgbiA8IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBsb2NhbFxuICAgICAgbmI6IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsZWZ0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgbmIsIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBuYl9zcGFjZSA+IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKG5iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50IHZhbHVlLlxuICAgICAgICBuYiA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYl9zcGFjZSwgMCwgbmIpXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgaSA6PSBuYlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA8IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbm90IGxfcHJvcC5pc19zcGFjZSAoYykgdGhlblxuICAgICAgICAgICAgLS0gV2UgYXJlIGRvbmUuXG4gICAgICAgICAgaSA6PSAtMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzaGFyZSAob3RoZXI6IFNUUklOR18zMilcbiAgICAgIC0tIE1ha2UgY3VycmVudCBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJy5cbiAgICAgIC0tIFN1YnNlcXVlbnQgY2hhbmdlcyB0byB0aGUgY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZ1xuICAgICAgLS0gd2lsbCBhbHNvIGFmZmVjdCBgb3RoZXInLCBhbmQgY29udmVyc2VseS5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgIGNvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkX2NvdW50OiBvdGhlci5jb3VudCA9IGNvdW50XG4gICAgICBzaGFyZWRfYXJlYTogb3RoZXIuYXJlYSA9IGFyZWFcbiAgICBlbmRcblxuICBwdXQgKGM6IENIQVJBQ1RFUl8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfMzIsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBwcmVwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcmVjZWRlLCBwcmVwZW5kX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gQWRkIGBjJyBhdCBmcm9udC5cbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIDEsIGNvdW50KVxuICAgICAgbF9hcmVhLnB1dCAoYywgMClcbiAgICAgIGNvdW50IDo9IGNvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgZW5kXG5cbiAgcHJlcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBvZiBjdXJyZW50LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgbF9zX2NvdW50LCBjb3VudClcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBiZWdpbm5pbmcuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCAwLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoaS5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBwcmVwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBhcHBlbmQgKGxfczMyKVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSkpXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChjb3VudCArIHMuY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGFwcGVuZGVkOiBzIC89IFZvaWQgaW1wbGllc1xuICAgICAgICAoZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHR3aW4gKyBvbGQgcy50d2luKSlcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfOCAoaTogSU5URUdFUl84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfOH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzY0IChpOiBJTlRFR0VSXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8zMiAoaTogTkFUVVJBTF8zMilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMzJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF82NCAoaTogTkFUVVJBTF82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWEucHV0IChjLCBjdXJyZW50X2NvdW50KVxuICAgICAgY291bnQgOj0gY3VycmVudF9jb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBpbnNlcnQgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEFkZCBgcycgdG8gbGVmdCBvZiBwb3NpdGlvbiBgaScgaW4gY3VycmVudCBzdHJpbmcuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGluc2VydF9zdHJpbmcnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50ICsgMVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID4gMFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCBpKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkgKyBvbGQgKHMudHdpbikgKyBvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIGluc2VydF9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICBuZXdfc2l6ZSA6PSAxICsgY291bnRcbiAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgIHBvcyA6PSBpIC0gMVxuICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIDEsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgIC0tIEluc2VydCBuZXcgY2hhcmFjdGVyXG4gICAgICBsX2FyZWEucHV0IChjLCBwb3MpXG5cbiAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgb25lX21vcmVfY2hhcmFjdGVyOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IGNcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChpLCBpIC0gMSwgbF9jb3VudCAtIGkpXG4gICAgICAgIC0tIFVwZGF0ZSBjb250ZW50LlxuICAgICAgY291bnQgOj0gbF9jb3VudCAtIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAobi5taW4gKGNvdW50KSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4J1xuICAgICAgLS0gdG8gYGVuZF9pbmRleCcgaW5jbHVzaXZlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBuYl9yZW1vdmVkOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iX3JlbW92ZWQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBuYl9yZW1vdmVkID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9pbmRleCArIG5iX3JlbW92ZWQgLSAxLCBzdGFydF9pbmRleCAtIDEsIGxfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICAgIGNvdW50IDo9IGxfY291bnQgLSBuYl9yZW1vdmVkXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgKyBvbGQgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgbGFzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIG4gPiBsX2NvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX2hlYWQgKGxfY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBjb3VudCAtIG4ubWluIChjb3VudCkpKVxuICAgIGVuZFxuXG4gIHBydW5lIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycsIGlmIGFueS5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgY291bnRlcjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGNvdW50ZXIgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgY291bnRlciA+IGNvdW50IG9yIGVsc2UgKGl0ZW0gKGNvdW50ZXIpID0gYylcbiAgICAgIGxvb3BcbiAgICAgICAgY291bnRlciA6PSBjb3VudGVyICsgMVxuICAgICAgZW5kXG4gICAgICBpZiBjb3VudGVyIDw9IGNvdW50IHRoZW5cbiAgICAgICAgcmVtb3ZlIChjb3VudGVyKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICAgIC0tIFRyYXZlcnNlIHN0cmluZyBhbmQgc2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdFxuICAgICAgICAtLSBlYWNoIHRpbWUgd2UgZmluZCBhbiBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBsX2NoYXIgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIGxfY2hhciAvPSBjIHRoZW5cbiAgICAgICAgICBsX2FyZWEucHV0IChsX2NoYXIsIGopXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBqXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjaGFuZ2VkX2NvdW50OiBjb3VudCA9IChvbGQgY291bnQpIC0gKG9sZCBvY2N1cnJlbmNlcyAoYykpXG4gICAgICAtLSByZW1vdmVkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSAvPSBgYydcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfbGVhZGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBsZWFkaW5nIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHkgb3IgZWxzZSBpdGVtICgxKSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbF90cmFpbGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBjaGFyYWN0ZXIuXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKCclLzAwMC8nLCBuZXdzaXplICsgMSlcbiAgICBlbmRcblxuICBncm93IChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgdGhlIGNhcGFjaXR5IGlzIGF0IGxlYXN0IGBuZXdzaXplJy5cbiAgICBkb1xuICAgICAgaWYgbmV3c2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdzaXplKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuIDo9IGNvdW50XG4gICAgICBpZiBuIDwgY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9zdHJpbmc6IHNhbWVfc3RyaW5nIChvbGQgdHdpbilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX3VwcGVyXG4gICAgZW5kXG5cbiAgbGVmdF9qdXN0aWZ5XG4gICAgICAtLSBMZWZ0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpdGR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGUgc3BhY2VzLlxuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGxlZnRfYWRqdXN0XG5cbiAgICAgICAgLS0gR2V0IG5ldyBjb3VudFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgaWYgaSA8IG5iIHRoZW5cbiAgICAgICAgICAtLSBgbGVmdF9hZGp1c3QnIGRpZCByZW1vdmUgc29tZSBjaGFyYWN0ZXJzLCBzbyB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAgIC0tIHNvbWUgd2hpdGUgc3BhY2VzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNlbnRlcl9qdXN0aWZ5XG4gICAgICAtLSBDZW50ZXIganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iLCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbGVmdF9uYl9zcGFjZSwgcmlnaHRfbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA9IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGxlZnRfbmJfc3BhY2UpKVxuICAgICAgbG9vcFxuICAgICAgICBsZWZ0X25iX3NwYWNlIDo9IGxlZnRfbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IC0xIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGkpKVxuICAgICAgbG9vcFxuICAgICAgICByaWdodF9uYl9zcGFjZSA6PSByaWdodF9uYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gV2UgZW5jb3VyYWdlIHRoYXQgbW9yZSBzcGFjZXMgd2lsbCBiZSBwdXQgdG8gdGhlIGxlZnQsIHdoZW5cbiAgICAgICAgLS0gbnVtYmVyIG9mIHNwYWNlcyBpcyBub3QgZXZlbi5cbiAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgKyByaWdodF9uYl9zcGFjZVxuICAgICAgaWYgbF9vZmZzZXQgXFxcXCAyID0gMCB0aGVuXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyXG4gICAgICBlbHNlXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyIC0gMVxuICAgICAgZW5kXG4gICAgICBpZiBsX29mZnNldCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodCBvciBsZWZ0IChkZXBlbmRpbmcgb24gc2lnbiBvZlxuICAgICAgICAgIC0tIGBsX29mZnNldCcgYnkgYGxfb2Zmc2V0JyBwb3NpdGlvbi5cbiAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0LFxuICAgICAgICAgIG5iIC0gbGVmdF9uYl9zcGFjZSAtIHJpZ2h0X25iX3NwYWNlKVxuXG4gICAgICAgIGlmIGxfb2Zmc2V0IDwgMCB0aGVuXG4gICAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEZpbGwgcmlnaHQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIG5iIC0gcmlnaHRfbmJfc3BhY2UgLSBsX29mZnNldCwgbmIgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2p1c3RpZnlcbiAgICAgIC0tIFJpZ2h0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICByaWdodF9hZGp1c3RcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIG5iX3NwYWNlIDo9IG5iIC0gaVxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAoaSksIGkgKyBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGkgKyAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBuYl9zcGFjZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBuYl9zcGFjZSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX2p1c3RpZnkgKHBpdm90OiBDSEFSQUNURVJfMzI7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgdGVtcDogQVJSQVlFRF9MSVNUIFtDSEFSQUNURVJfMzJdXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSB0ZW1wLm1ha2UgKGNhcGFjaXR5KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjb3VudFxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYzogQU5ZXG4gICAgICAtLSBBIHJlZmVyZW5jZSB0byBhIEMgZm9ybSBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIC0tIFVzZWZ1bCBvbmx5IGZvciBpbnRlcmZhY2luZyB3aXRoIEMgc29mdHdhcmUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2lzX2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEucHV0ICgnJVUnLCBjb3VudClcbiAgICAgIFJlc3VsdCA6PSBsX2FyZWFcbiAgICBlbmRcblxuICBtaXJyb3JlZDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBNaXJyb3IgaW1hZ2Ugb2Ygc3RyaW5nO1xuICAgICAgLS0gUmVzdWx0IGZvciBcIkhlbGxvIHdvcmxkXCIgaXMgXCJkbHJvdyBvbGxlSFwiLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0Lm1pcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yXG4gICAgICAtLSBSZXZlcnNlIHRoZSBvcmRlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgLS0gXCJIZWxsbyB3b3JsZFwiIC0+IFwiZGxyb3cgb2xsZUhcIi5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgICAtLSBOb3RoaW5nIHRvIGJlIGRvbmUgYmVjYXVzZSB3ZSBvbmx5IGFkZGVkIGBpbnRlcm5hbF9oYXNoX2NvZGUnIHRoYXQgd2lsbFxuICAgICAgICAtLSBiZSByZWNvbXB1dGVkIG5leHQgdGltZSB3ZSBxdWVyeSBgaGFzaF9jb2RlJy5cblxuICAgICAgICAtLSBJbiAuTkVULCB3ZSBoYXZlIGEgbWlzbWF0Y2ggdGhhdCBpcyB0cmlnZ2VyZWQgZHVlIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAgICAtLSBTUEVDSUFMIFtDSEFSQUNURVJfMzJdIGFzIGEgLk5FVCBhcnJheSBvZiBVSW50MTYuXG4gICAgICBpZiBhcmVhID0gVm9pZCBhbmQgdGhlbiBhdHRhY2hlZCB7bGlrZSBhcmVhfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcImFyZWFcIikgYXMgbF9hcmVhIHRoZW5cbiAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMjYgMTQ6NDk6NDAgLTA3MDAgKFdlZCwgMjYgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NzIxICRcIlxuXG5jbGFzc1xuICBTVFJJTkdfOFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR184XG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBlbmRcblxuICBTVFJJTkdfR0VORVJBTFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwsXG4gICAgICBpdGVtIGFzIGNoYXJhY3Rlcl8zMl9pdGVtLFxuICAgICAgaGFzIGFzIGNoYXJhY3Rlcl8zMl9oYXMsXG4gICAgICBpbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfaW5kZXhfb2YsXG4gICAgICBsYXN0X2luZGV4X29mIGFzIGNoYXJhY3Rlcl8zMl9sYXN0X2luZGV4X29mLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgY2hhcmFjdGVyXzMyX29jY3VycmVuY2VzXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbQ0hBUkFDVEVSXzgsIElOVEVHRVJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsLFxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFJFU0laQUJMRSBbQ0hBUkFDVEVSXzhdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl84XVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBpdGVtLCBhdCwgcHV0LCB2YWxpZF9pbmRleFxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9zdHJpbmcsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIGFzX3N0cmluZ18zMjoge1JFQURBQkxFX1NUUklOR18zMiwgU1RSSU5HXzMyfVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gYV9zeXN0ZW1fc3RyaW5nLmxlbmd0aCArIGRvdG5ldF9jb252ZXJ0b3IuZXNjYXBlX2NvdW50IChhX3N5c3RlbV9zdHJpbmcpXG4gICAgICBlbmRcbiAgICAgIG1ha2UgKGxfY291bnQpXG4gICAgICBpZiBsX2NvdW50ID4gMCBhbmQgdGhlbiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZG90bmV0X2NvbnZlcnRvci5yZWFkX3N5c3RlbV9zdHJpbmdfaW50byAoYV9zeXN0ZW1fc3RyaW5nLCBDdXJyZW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvbV9jIChjX3N0cmluZzogUE9JTlRFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyIChjX3N0cmluZylcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N0cmluZ19pbnRvIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgbm9femVyb19ieXRlOiBub3QgaGFzICgnJS8wLycpXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgICAtLSBjb3JyZWN0X2NvdW50OiB0aGUgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyBjb3VudFxuICAgICAgLS0gICAgICAgaXMgTlVMTFxuICAgIGVuZFxuXG4gIGZyb21fY19zdWJzdHJpbmcgKGNfc3RyaW5nOiBQT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBzdWJzdHJpbmcgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoY19zdHJpbmcgKyAoc3RhcnRfcG9zIC0gMSksIGxfY291bnQpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdWJzdHJpbmdfaW50byAoQ3VycmVudCwgMSwgbF9jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NvdW50OiBjb3VudCA9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgZW5kXG5cbiAgYWRhcHQgKHM6IFNUUklOR184KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPYmplY3Qgb2YgYSB0eXBlIGNvbmZvcm1pbmcgdG8gdGhlIHR5cGUgb2YgYHMnLFxuICAgICAgLS0gaW5pdGlhbGl6ZWQgd2l0aCBhdHRyaWJ1dGVzIGZyb20gYHMnXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgUmVzdWx0LnNoYXJlIChzKVxuICAgIGVuc3VyZVxuICAgICAgYWRhcHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzaGFyZWRfaW1wbGVtZW50YXRpb246IFJlc3VsdC5zaGFyZWRfd2l0aCAocylcbiAgICBlbmRcblxuICByZW1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9zdHJpbmc6IGNvdW50ID0gMFxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfOCBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfMzJfaXRlbSAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICBkb1xuICAgICAgICAtLSBXZSBzaG91bGQgYmUgdXNpbmcgYGFyZWEuaXRlbSAoaSAtIDEpLnRvX2NoYXJhY3Rlcl8zMidcbiAgICAgICAgLS0gYnV0IHNvbWUgZGVzY2VuZGFudHMgb2YgU1RSSU5HIHRoYXQgaGF2ZSB0aGVpciBjb250ZW50IGVuY29kZWRcbiAgICAgICAgLS0gaW4gVVRGLTggZm9yIGV4YW1wbGUgcmVsaWVzIG9uIGBjb2RlJyB0byBnZXQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLS0gQ0hBUkFDVEVSXzMyIGJ5IHJlYWRpbmcgbW9yZSB0aGFuIG9uZSBieXRlLiBPbmNlIHRoZXkgaGF2ZVxuICAgICAgICAtLSBiZWVuIHVwZGF0ZWQgdG8gdXNlIGBjaGFyYWN0ZXJfMzJfaXRlbScgd2UgY2FuIHJldmVydCB0aGUgY29kZVxuICAgICAgICAtLSBiYWNrIHRvIHVzaW5nIGBhcmVhJyBkaXJlY3RseS5cbiAgICAgIFJlc3VsdCA6PSBjb2RlIChpKS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1lcmljIGNvZGUgb2YgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICAgIC0tIFVzZSBgY29kZScgaW5zdGVhZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBVbmljb2RlIGhhbmRsaW5nLlxuICAgICAgLS18IE5vdCBvYnNvbGV0ZSBiZWNhdXNlIG9sZCBjb2RlIHVzaW5nIGp1c3QgQVNDSUkgaXMgc2FmZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLmNvZGVcbiAgICBlbmRcblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnMuXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkPyAoQW5zd2VyOiB5ZXMuKVxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBCT09MRUFOID0gRmFsc2VcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldCAodDogUkVBREFCTEVfU1RSSU5HXzg7IG4xLCBuMjogSU5URUdFUilcbiAgICAgIC0tIFNldCBjdXJyZW50IHN0cmluZyB0byBzdWJzdHJpbmcgb2YgYHQnIGZyb20gaW5kaWNlcyBgbjEnXG4gICAgICAtLSB0byBgbjInLCBvciB0byBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBzdWJzdHJpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHQgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfOFxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIHRvIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgICBlbm91Z2hfc3BhY2U6IChjb3VudCAtIGluZGV4X3BvcykgPj0gKGVuZF9wb3MgLSBzdGFydF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGxfb3RoZXJfYXJlYSwgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgZW5kX3BvcyA+PSBzdGFydF9wb3MgdGhlblxuICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpZiBsX2FyZWEgLz0gbF9vdGhlcl9hcmVhIHRoZW5cbiAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX290aGVyX2FyZWEsIHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY29waWVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaW5kZXhfcG9zIC0gMSkgK1xuICAgICAgICBvbGQgb3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpICtcbiAgICAgICAgb2xkIHN1YnN0cmluZyAoaW5kZXhfcG9zICsgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKSwgY291bnQpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnIHRvIGBlbmRfaW5kZXgnIHdpdGggYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBkaWZmOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgc19jb3VudDogSU5URUdFUlxuICAgICAgb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHNfY291bnQgOj0gcy5jb3VudFxuICAgICAgb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICBkaWZmIDo9IHNfY291bnQgLSAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgbmV3X3NpemUgOj0gZGlmZiArIG9sZF9jb3VudFxuICAgICAgaWYgZGlmZiA+IDAgdGhlblxuICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIHRoZSBzdHJpbmcuXG4gICAgICAgIGdyb3cgKG5ld19zaXplKVxuICAgICAgZW5kXG5cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIC0tfCBXZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBmb3J3YXJkIChpZiBkaWZmIGlzID4gMCksIGJhY2t3YXJkIChpZiBkaWZmIDwgMCksXG4gICAgICAgIC0tfCBhbmQgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICBpZiBkaWZmIC89IDAgdGhlblxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoZW5kX2luZGV4LCBlbmRfaW5kZXggKyBkaWZmLCBvbGRfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICBlbmRcbiAgICAgICAgLS18IFNldCBuZXcgY291bnRcbiAgICAgIHNldF9jb3VudCAobmV3X3NpemUpXG4gICAgICAgIC0tfCBXZSBjb3B5IHRoZSBzdWJzdHJpbmcuXG4gICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgc3RhcnRfaW5kZXggLSAxLCBzX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50IC0gZW5kX2luZGV4ICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICByZXBsYWNlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCAoc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICtcbiAgICAgICAgICBzICsgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZ19hbGwgKG9yaWdpbmFsLCBuZXc6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2ZpcnN0X3BvcywgbF9uZXh0X3BvczogSU5URUdFUlxuICAgICAgbF9vcmlnX2NvdW50LCBsX25ld19jb3VudCwgbF9uZXdfbG93ZXIsIGxfY291bnQsIGksIGxfaW5kZXhfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfc3JjX2luZGV4LCBsX2Rlc3RfaW5kZXgsIGxfcHJldl9pbmRleCwgbF9jb3B5X2RlbHRhOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfbmV3X2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxfc3RyaW5nX3NlYXJjaGVyOiBsaWtlIHN0cmluZ19zZWFyY2hlclxuICAgICAgbF9pbmRleF9saXN0OiBTUEVDSUFMIFtJTlRFR0VSXVxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfc3RyaW5nX3NlYXJjaGVyIDo9IHN0cmluZ19zZWFyY2hlclxuICAgICAgICBsX3N0cmluZ19zZWFyY2hlci5pbml0aWFsaXplX2RlbHRhcyAob3JpZ2luYWwpXG4gICAgICAgIGxfb3JpZ19jb3VudCA6PSBvcmlnaW5hbC5jb3VudFxuICAgICAgICBsX25ld19jb3VudCA6PSBuZXcuY291bnRcbiAgICAgICAgaWYgbF9vcmlnX2NvdW50ID49IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCAxLCBsX2NvdW50KVxuICAgICAgICAgIGlmIGxfZmlyc3RfcG9zID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBsX29yaWdfY291bnQgPSBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3RyaW5nIHdpbGwgbm90IGJlIHJlc2l6ZWQsIHNpbXBseSBwZXJmb3JtIGNoYXJhY3RlciBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgPSAwXG4gICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICBpZiBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IDw9IGxfY291bnQgdGhlblxuICAgICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSAwXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZWlmIGxfb3JpZ19jb3VudCA+IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAtLSBOZXcgc3RyaW5nIGlzIHNtYWxsZXIgdGhhbiBwcmV2aW91cyBzdHJpbmcsIHdlIGNhbiBvcHRpbWl6ZVxuICAgICAgICAgICAgICAgIC0tIHN1YnN0aXR1dGlvbiBieSBvbmx5IG1vdmluZyBibG9jayBiZXR3ZWVuIHR3byBvY2N1cnJlbmNlcyBvZiBgb3JnaW5hbCcuXG4gICAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgICBsX25leHRfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50LCBsX2NvdW50KVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA9IDBcbiAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgLS0gQ29weSBuZXcgc3RyaW5nIGludG8gQ3VycmVudFxuICAgICAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2ZpcnN0X3BvcyAtIDEgLSBsX29mZnNldCwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgYGxfbmV4dF9wb3MnXG4gICAgICAgICAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50IC0gMSxcbiAgICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgLSAxIC0gbF9vZmZzZXQsIGxfbmV4dF9wb3MgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX25leHRfcG9zXG4gICAgICAgICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQgKyAobF9vcmlnX2NvdW50IC0gbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgaWYgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCA8PSBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAgIGxfbmV4dF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQsIGxfY291bnQpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSAwXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gZmluYWwgc3Vic3RpdHV0aW9uOlxuICAgICAgICAgICAgICAgIC0tIENvcHkgbmV3IHN0cmluZyBpbnRvIEN1cnJlbnRcbiAgICAgICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9uZXdfYXJlYSwgbF9uZXdfbG93ZXIsIGxfZmlyc3RfcG9zIC0gMSAtIGxfb2Zmc2V0LCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCAtIDEgLSBsX29mZnNldCwgbF9jb3VudCArIDEgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gbGFzdCBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQgKyAobF9vcmlnX2NvdW50IC0gbF9uZXdfY291bnQpXG5cbiAgICAgICAgICAgICAgICAtLSBVcGRhdGUgYGNvdW50J1xuICAgICAgICAgICAgICBzZXRfY291bnQgKGxfY291bnQgLSBsX29mZnNldClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAtLSBTdHJpbmcgd2FzIG1vZGlmaWVkIHdlIG5lZWQgdG8gcmVjb21wdXRlIHRoZSBgaGFzaF9jb2RlJy5cbiAgICAgICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBhdHRhY2hlZCBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfbGlzdF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIDEsIGxfY291bnQpIGFzIGxfbGlzdCB0aGVuXG4gICAgICAgICAgICAtLSBHZXQgdGhlIG51bWJlciBvZiBzdWJzdGl0dXRpb24gdG8gYmUgcGVyZm9ybWVkIGJ5IGdldHRpbmcgYSBsaXN0XG4gICAgICAgICAgICAtLSBvZiBsb2NhdGlvbiB3aGVyZSBgb3JpZ2luYWwnIGFwcGVhcnMuXG4gICAgICAgICAgbF9pbmRleF9saXN0IDo9IGxfbGlzdC5hcmVhXG4gICAgICAgICAgbF9pbmRleF9jb3VudCA6PSBsX2luZGV4X2xpc3QuY291bnRcbiAgICAgICAgICAgIC0tIFN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgdXAgdG8gd2hpY2ggd2UgbmVlZCB0byBtb3ZlXG4gICAgICAgICAgICAtLSBjaGFyYWN0ZXJzIGluIHRoZSByZWFsbG9jYXRlZCBzdHJpbmcuXG4gICAgICAgICAgbF9wcmV2X2luZGV4IDo9IGxfY291bnRcbiAgICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAgbF9jb3B5X2RlbHRhIDo9IGxfbmV3X2NvdW50IC0gbF9vcmlnX2NvdW50XG4gICAgICAgICAgbF9jb3VudCA6PSBsX2NvdW50ICsgKGxfaW5kZXhfY291bnQgKiBsX2NvcHlfZGVsdGEpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyVVJywgbF9jb3VudCArIDEpXG4gICAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgICAgICAgIC0tIFBlcmZvcm0gdGhlIHN1YnN0aXR1dGlvbiBzdGFydGluZyBmcm9tIHRoZSBlbmQuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgaSA6PSBsX2luZGV4X2NvdW50XG4gICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGxfc3JjX2luZGV4IDo9IGxfaW5kZXhfbGlzdC5pdGVtIChpKVxuICAgICAgICAgICAgbF9kZXN0X2luZGV4IDo9IGxfc3JjX2luZGV4ICsgaSAqIGxfY29weV9kZWx0YVxuICAgICAgICAgICAgICAtLSBTaGlmdCBub24tbWF0Y2hpbmcgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb2YgdGhlIG5ld2x5IHJlcGxhY2VkIHN0cmluZy5cbiAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX3NyY19pbmRleCArIGxfb3JpZ19jb3VudCAtIDEsIGxfZGVzdF9pbmRleCArIGxfbmV3X2NvdW50IC0gMSwgbF9wcmV2X2luZGV4IC0gbF9zcmNfaW5kZXggLSBsX29yaWdfY291bnQgKyAxKVxuICAgICAgICAgICAgICAtLSBTdG9yZSBuZXcgZW5kIG9mIHN0cmluZyB3aGVyZSBjaGFyYWN0ZXJzIHdpbGwgYmUgbW92ZWQuXG4gICAgICAgICAgICBsX3ByZXZfaW5kZXggOj0gbF9zcmNfaW5kZXggLSAxXG5cbiAgICAgICAgICAgICAgLS0gQ29weSBgbmV3JyB0byBpdHMgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2Rlc3RfaW5kZXggLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIFVwZGF0ZSB0aGUgbmV3IGBjb3VudCcgd2hpY2ggYWxzbyByZXNldHMgdGhlIGBoYXNoX2NvZGUnLlxuICAgICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGxfY291bnQgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NvdW50IC0gMSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICByZXBsYWNlX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkJ1wiXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoYylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgbG9jYWxcbiAgICAgIG5iOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGVmdF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIG5iLCBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbmJfc3BhY2UgPiBuYiBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAobmJfc3BhY2UpLmlzX3NwYWNlXG4gICAgICBsb29wXG4gICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudCB2YWx1ZS5cbiAgICAgICAgbmIgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmJfc3BhY2UsIDAsIG5iKVxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGkgOj0gbmJcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwIG9yIGVsc2Ugbm90IGxfYXJlYS5pdGVtIChpKS5pc19zcGFjZVxuICAgICAgbG9vcFxuICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNoYXJlIChvdGhlcjogU1RSSU5HXzgpXG4gICAgICAtLSBNYWtlIGN1cnJlbnQgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcicuXG4gICAgICAtLSBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmdcbiAgICAgIC0tIHdpbGwgYWxzbyBhZmZlY3QgYG90aGVyJywgYW5kIGNvbnZlcnNlbHkuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICBjb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZF9jb3VudDogb3RoZXIuY291bnQgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IG90aGVyLmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbiAgcHV0IChjOiBDSEFSQUNURVJfODsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfOCwgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHByZWNlZGUsIHByZXBlbmRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIEFkZCBgYycgYXQgZnJvbnQuXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCAxLCBjb3VudClcbiAgICAgIGxfYXJlYS5wdXQgKGMsIDApXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR184fSBzIGFzIGxfczggdGhlblxuICAgICAgICBwcmVwZW5kIChsX3M4KVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCBsX3NfY291bnQsIGNvdW50KVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGJlZ2lubmluZy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIDAsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmQgKGIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChkLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChpLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChyLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgcHJlcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzh9IHMgYXMgbF9zOCB0aGVuXG4gICAgICAgIGFwcGVuZCAobF9zOClcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpKSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIFJlc3VsdC5hcHBlbmQgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzgpXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhcHBlbmRlZDogcyAvPSBWb2lkIGltcGxpZXNcbiAgICAgICAgKGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCB0d2luICsgb2xkIHMudHdpbikpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl8xNn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzggKGk6IE5BVFVSQUxfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMzIgKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzMyXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzY0IChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gQXBwZW5kIGBjJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgY3VycmVudF9jb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjdXJyZW50X2NvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgYXJlYS5wdXQgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgICBjb3VudCA6PSBjdXJyZW50X2NvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXRlbV9pbnNlcnRlZDogaXRlbSAoY291bnQpID0gY1xuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHN0YWJsZV9iZWZvcmU6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGNvdW50IC0gMSkgfiAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgYXBwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmQgKGIub3V0KVxuICAgIGVuZFxuXG4gIGluc2VydCAoczogUkVBREFCTEVfU1RSSU5HXzg7IGk6IElOVEVHRVIpXG4gICAgICAtLSBBZGQgYHMnIHRvIGxlZnQgb2YgcG9zaXRpb24gYGknIGluIGN1cnJlbnQgc3RyaW5nLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBpbnNlcnRfc3RyaW5nJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudCArIDFcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfODsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgYycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgIG5ld19zaXplIDo9IDEgKyBjb3VudFxuICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgcG9zIDo9IGkgLSAxXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgMSwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgLS0gSW5zZXJ0IG5ldyBjaGFyYWN0ZXJcbiAgICAgIGxfYXJlYS5wdXQgKGMsIHBvcylcblxuICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBvbmVfbW9yZV9jaGFyYWN0ZXI6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gY1xuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmUgKGk6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYGknLXRoIGNoYXJhY3Rlci5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKGksIGkgLSAxLCBsX2NvdW50IC0gaSlcbiAgICAgICAgLS0gVXBkYXRlIGNvbnRlbnQuXG4gICAgICBjb3VudCA6PSBsX2NvdW50IC0gMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nIChuLm1pbiAoY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnXG4gICAgICAtLSB0byBgZW5kX2luZGV4JyBpbmNsdXNpdmUuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIG5iX3JlbW92ZWQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmJfcmVtb3ZlZCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIG5iX3JlbW92ZWQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X2luZGV4ICsgbmJfcmVtb3ZlZCAtIDEsIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgICAgY291bnQgOj0gbF9jb3VudCAtIG5iX3JlbW92ZWRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArIG9sZCBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBsYXN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbiA+IGxfY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAobF9jb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGNvdW50IC0gbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcHJ1bmUgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnLCBpZiBhbnkuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBjb3VudGVyIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGNvdW50ZXIgPiBjb3VudCBvciBlbHNlIChpdGVtIChjb3VudGVyKSA9IGMpXG4gICAgICBsb29wXG4gICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgY291bnRlciA8PSBjb3VudCB0aGVuXG4gICAgICAgIHJlbW92ZSAoY291bnRlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgZG9cbiAgICAgICAgLS0gVHJhdmVyc2Ugc3RyaW5nIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0XG4gICAgICAgIC0tIGVhY2ggdGltZSB3ZSBmaW5kIGFuIG9jY3VycmVuY2Ugb2YgYGMnLlxuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY2hhciA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbF9jaGFyIC89IGMgdGhlblxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfY2hhciwgailcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGNvdW50IDo9IGpcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNoYW5nZWRfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCkgLSAob2xkIG9jY3VycmVuY2VzIChjKSlcbiAgICAgIC0tIHJlbW92ZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpIC89IGBjJ1xuICAgIGVuZFxuXG4gIHBydW5lX2FsbF9sZWFkaW5nIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlbW92ZSBhbGwgbGVhZGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoMSkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfdHJhaWxpbmcgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgnJS8wMDAvJywgbmV3c2l6ZSArIDEpXG4gICAgZW5kXG5cbiAgZ3JvdyAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIEVuc3VyZSB0aGF0IHRoZSBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgbmV3c2l6ZScuXG4gICAgZG9cbiAgICAgIGlmIG5ld3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3c2l6ZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfc3RyaW5nOiBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b191cHBlclxuICAgIGVuZFxuXG4gIGxlZnRfanVzdGlmeVxuICAgICAgLS0gTGVmdCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aXRkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlIHNwYWNlcy5cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBsZWZ0X2FkanVzdFxuXG4gICAgICAgIC0tIEdldCBuZXcgY291bnRcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgLS0gYGxlZnRfYWRqdXN0JyBkaWQgcmVtb3ZlIHNvbWUgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAtLSBzb21lIHdoaXRlIHNwYWNlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjZW50ZXJfanVzdGlmeVxuICAgICAgLS0gQ2VudGVyIGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYiwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxlZnRfbmJfc3BhY2UsIHJpZ2h0X25iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgPSBuYiBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAobGVmdF9uYl9zcGFjZSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA6PSBsZWZ0X25iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAtMSBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgcmlnaHRfbmJfc3BhY2UgOj0gcmlnaHRfbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFdlIGVuY291cmFnZSB0aGF0IG1vcmUgc3BhY2VzIHdpbGwgYmUgcHV0IHRvIHRoZSBsZWZ0LCB3aGVuXG4gICAgICAgIC0tIG51bWJlciBvZiBzcGFjZXMgaXMgbm90IGV2ZW4uXG4gICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlICsgcmlnaHRfbmJfc3BhY2VcbiAgICAgIGlmIGxfb2Zmc2V0IFxcXFwgMiA9IDAgdGhlblxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMlxuICAgICAgZWxzZVxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMiAtIDFcbiAgICAgIGVuZFxuICAgICAgaWYgbF9vZmZzZXQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgbGVmdCAoZGVwZW5kaW5nIG9uIHNpZ24gb2ZcbiAgICAgICAgICAtLSBgbF9vZmZzZXQnIGJ5IGBsX29mZnNldCcgcG9zaXRpb24uXG4gICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCxcbiAgICAgICAgICBuYiAtIGxlZnRfbmJfc3BhY2UgLSByaWdodF9uYl9zcGFjZSlcblxuICAgICAgICBpZiBsX29mZnNldCA8IDAgdGhlblxuICAgICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaWxsIHJpZ2h0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBuYiAtIHJpZ2h0X25iX3NwYWNlIC0gbF9vZmZzZXQsIG5iIC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9qdXN0aWZ5XG4gICAgICAtLSBSaWdodCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBuYl9zcGFjZSA6PSBuYiAtIGlcbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGkpLCBpICsgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpICsgMVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbmJfc3BhY2UgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgbmJfc3BhY2UgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9qdXN0aWZ5IChwaXZvdDogQ0hBUkFDVEVSXzg7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0NIQVJBQ1RFUl84XVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2M6IEFOWVxuICAgICAgLS0gQSByZWZlcmVuY2UgdG8gYSBDIGZvcm0gb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICAtLSBVc2VmdWwgb25seSBmb3IgaW50ZXJmYWNpbmcgd2l0aCBDIHNvZnR3YXJlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLnB1dCAoJyVVJywgY291bnQpXG4gICAgICBSZXN1bHQgOj0gbF9hcmVhXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5taXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvclxuICAgICAgLS0gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgIC0tIFwiSGVsbG8gd29ybGRcIiAtPiBcImRscm93IG9sbGVIXCIuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzhcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgLS0gTm90aGluZyB0byBiZSBkb25lIGJlY2F1c2Ugd2Ugb25seSBhZGRlZCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB0aGF0IHdpbGxcbiAgICAgIC0tIGJlIHJlY29tcHV0ZWQgbmV4dCB0aW1lIHdlIHF1ZXJ5IGBoYXNoX2NvZGUnLlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVtcHR5X2FyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl84XVxuICAgICAgLS0gRW1wdHkgYGFyZWEnIHRvIGF2b2lkIHVzZWxlc3MgY3JlYXRpb24gb2YgZW1wdHkgYXJlYXMgd2hlbiB3aXBpbmcgb3V0IGEgU1RSSU5HLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlNpbXBseSBjcmVhdGUgYGFyZWEnIGRpcmVjdGx5LlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAoMSlcbiAgICAgIFJlc3VsdC5leHRlbmQgKCclVScpXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9hcmVhX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb21tb24gYW5jZXN0b3JzIHRvIGFsbCBTVFJJTkcgY2xhc3Nlcy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMTkgMDc6MzY6MTAgLTA3MDAgKFdlZCwgMTkgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NjMzICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBTVFJJTkdfR0VORVJBTFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICBlbmRcblxuY29udmVydFxuICBhc19zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzIsIFNUUklOR18zMn0sXG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9XG5cbmZlYXR1cmUgLS0gU2V0dGluZ3NcblxuICBwdXRfY29kZSAodjogbGlrZSBjb2RlOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGNvZGUgYHYnIGF0IHBvc2l0aW9uIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb2RlOiB2YWxpZF9jb2RlICh2KVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogY29kZSAoaSkgPSB2XG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gU2V0dGluZ3NcblxuICBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IDAgPD0gbnVtYmVyIGFuZCBudW1iZXIgPD0gY2FwYWNpdHlcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG51bWJlclxuICAgIGVuZFxuXG4gIHNldF9pbnRlcm5hbF9oYXNoX2NvZGUgKHY6IGxpa2UgaW50ZXJuYWxfaGFzaF9jb2RlKVxuICAgICAgLS0gU2V0IGBpbnRlcm5hbF9oYXNoX2NvZGUnIHdpdGggYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm9ubmVnYXRpdmU6IHYgPj0gMFxuICAgIGRvXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gdlxuICAgIGVuc3VyZVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlX3NldDogaW50ZXJuYWxfaGFzaF9jb2RlID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgYXBwZW5kX2NvZGUgKGM6IGxpa2UgY29kZSlcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NvZGU6IHZhbGlkX2NvZGUgKGMpXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudClcbiAgICAgIGVuZFxuICAgICAgc2V0X2NvdW50IChjdXJyZW50X2NvdW50KVxuICAgICAgcHV0X2NvZGUgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGNvZGUgKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBsX3NfY291bnRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jb2RlIChzLmNvZGUgKGkpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50XG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHRvX3N0cmluZ18zMiArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUpXG4gICAgICAgIGVuZFxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jb2RlIChzLmNvZGUgKGkpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkICh0b19zdHJpbmdfMzIgKyBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkpKVxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSlcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgQ3VycmVudCcgYXQgdGhlIGVuZCBzdGFydGluZyBmcm9tIHRoZSBlbmQgc2luY2UgaXQgd2lsbCBwcm9iYWJseSBvdmVybGFwLlxuICAgICAgICBzZXRfY291bnQgKGxfbmV3X3NpemUpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxfY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKGNvZGUgKGkpLCBpICsgbF9zX2NvdW50KVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgcycgYXQgdGhlIGJlZ2lubmluZyBvZiBDdXJyZW50LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGxfc19jb3VudFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKHMuY29kZSAoaSksIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnRvX3N0cmluZ18zMiArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBDb3B5IGBDdXJyZW50JyBhdCB0aGUgZW5kIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBzaW5jZSBpdCB3aWxsIHByb2JhYmx5IG92ZXJsYXAuXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbF9jb3VudFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBwdXRfY29kZSAoY29kZSAoaSksIGkgKyBsX3NfY291bnQpXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBDb3B5IGBzJyBhdCB0aGUgYmVnaW5uaW5nIG9mIEN1cnJlbnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgICAgaiA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKHMuY29kZSAoaSksIGopXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpLnRvX3N0cmluZ18zMiArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAga2VwdDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKGNvdW50IC0gbi5taW4oY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIGxlZnRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtICgxKS5pc19zcGFjZVxuICAgICAga2VwdDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAoKG9sZCB0d2luKS5zdWJzdHJpbmcgKG9sZCBjb3VudCAtIGNvdW50ICsgMSwgb2xkIGNvdW50KSlcbiAgICAgIG9ubHlfc3BhY2VzX3JlbW92ZWRfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoMSwgKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpIC0gMSlcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtIChjb3VudCkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKChvbGQgdHdpbikuc3Vic3RyaW5nICgxLCBjb3VudCkpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2FmdGVyOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpICsgY291bnQsIG9sZCBjb3VudClcbiAgICBlbmRcblxuICBhZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGRvXG4gICAgICBsZWZ0X2FkanVzdFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnRfbGVmdDogbm90IGlzX2VtcHR5IGltcGxpZXMgbm90IGl0ZW0gKDEpLmlzX3NwYWNlXG4gICAgICBuZXdfY291bnRfcmlnaHQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtIChjb3VudCkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyAob2xkIHR3aW4pLmhhc19zdWJzdHJpbmcgKEN1cnJlbnQpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIChvbGQgdHdpbikuaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIChvbGQgdHdpbikuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCAxKSAtIDEpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2FmdGVyOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpICsgY291bnQsIG9sZCBjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50IC0gMVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIHRvX3N0cmluZ18zMiB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkudG9fc3RyaW5nXzMyICsgb2xkIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KS50b19zdHJpbmdfMzIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIG5ld19zaXplX2xhcmdlX2Vub3VnaDogbmV3c2l6ZSA+PSBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY2FwYWNpdHlfbGFyZ2VfZW5vdWdoOiBjYXBhY2l0eSA+PSBuZXdzaXplXG4gICAgICBzYW1lX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBtdXRhYmxlOiBub3QgaXNfaW1tdXRhYmxlXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJPYmplY3RzIHRoYXQgY2FuIGFjY2VzcyBgc2V0X2NvdW50JyBmcm9tIFNUUklOR1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIFNUUklOR19IQU5ETEVSXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJGYWtlIGFic3RyYWN0aW9uIG9mIGEgLk5FVCBTWVNURU1fU1RSSU5HIGluIGEgbm9uLS5ORVQgc3lzdGVtXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3NcbiAgU1lTVEVNX1NUUklOR1xuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGxlbmd0aDogSU5URUdFUiBkbyBlbmRcblxuaW52YXJpYW50XG4gIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkNvbnRhaW5lcnMgd2hvc2UgaXRlbXMgYXJlIGFjY2Vzc2libGUgdGhyb3VnaCBrZXlzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogdGFibGUsIGFjY2VzcztcbiAgYWNjZXNzOiBrZXksIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgVEFCTEUgW0csIEhdIGluaGVyaXRcblxuICBCQUcgW0ddXG4gICAgcmVuYW1lXG4gICAgICBwdXQgYXMgYmFnX3B1dFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoazogSCk6IEcgYXNzaWduIGZvcmNlXG4gICAgICAtLSBFbnRyeSBvZiBrZXkgYGsnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfa2V5IChrKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHZhbGlkX2tleSAoazogSCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBrJyBhIHZhbGlkIGtleT9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBHOyBrOiBIKVxuICAgICAgLS0gQXNzb2NpYXRlIHZhbHVlIGB2JyB3aXRoIGtleSBgaycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9rZXkgKGspXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBmb3JjZSAodjogRzsgazogSClcbiAgICAgIC0tIEFzc29jaWF0ZSB2YWx1ZSBgdicgd2l0aCBrZXkgYGsnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfa2V5IChrKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaykgPSB2XG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluYXBwbGljYWJsZVxuXG4gIGJhZ19wdXQgKHY6IEcpXG4gICAgZG9cbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gc3BlY2lhbCBvYmplY3RzLCBmb3IgZGlyZWN0IGFjY2VzcyB0byBhcnJheXMgYW5kIHN0cmluZ3NcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBUT19TUEVDSUFMIFtUXVxuXG5jcmVhdGVcbiAgbWFrZV9lbXB0eV9hcmVhLFxuICBtYWtlX2ZpbGxlZF9hcmVhXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgYXJlYTogU1BFQ0lBTCBbVF1cbiAgICAgIC0tIFNwZWNpYWwgZGF0YSB6b25lXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9lbXB0eV9hcmVhIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlcyBhIHNwZWNpYWwgb2JqZWN0IGZvciBgbicgZW50cmllcy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2VtcHR5IChuKVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGFyZWEgLz0gVm9pZFxuICAgICAgY2FwYWNpdHlfc2V0OiBhcmVhLmNhcGFjaXR5ID0gblxuICAgICAgY291bnRfc2V0OiBhcmVhLmNvdW50ID0gMFxuICAgIGVuZFxuXG4gIG1ha2VfZmlsbGVkX2FyZWEgKGFfZGVmYXVsdF92YWx1ZTogVDsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZXMgYSBzcGVjaWFsIG9iamVjdCBmb3IgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKGFfZGVmYXVsdF92YWx1ZSwgbilcbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBhcmVhIC89IFZvaWRcbiAgICAgIGNhcGFjaXR5X3NldDogYXJlYS5jYXBhY2l0eSA9IG5cbiAgICAgIGNvdW50X3NldDogYXJlYS5jb3VudCA9IG5cbiAgICAgIGFyZWFfZmlsbGVkOiBhcmVhLmZpbGxlZF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIDAsIG4gLSAxKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IFQgYXNzaWduIHB1dFxuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgQ3VycmVudD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEudmFsaWRfaW5kZXggKGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQgKHY6IFQ7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIGFyZWEucHV0ICh2LCBpKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9hcmVhIChvdGhlcjogbGlrZSBhcmVhKVxuICAgICAgLS0gTWFrZSBgb3RoZXInIHRoZSBuZXcgYGFyZWEnXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gb3RoZXJcbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfc2V0OiBhcmVhID0gb3RoZXJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIltcbiAgICBTdHJ1Y3R1cmVzIGZvciB3aGljaCB0aGVyZSBleGlzdHMgYSB0cmF2ZXJzYWwgcG9saWN5XG4gICAgdGhhdCB3aWxsIHZpc2l0IGV2ZXJ5IGVsZW1lbnQgZXhhY3RseSBvbmNlLlxuICAgIF1cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiB0cmF2ZXJzYWJsZSwgdHJhdmVyc2luZztcbiAgYWNjZXNzOiBjdXJzb3I7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgVFJBVkVSU0FCTEUgW0ddXG5cbmluaGVyaXRcblxuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogR1xuICAgICAgLS0gSXRlbSBhdCBjdXJyZW50IHBvc2l0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgbm90X29mZjogbm90IG9mZlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIG9mZjogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gY3VycmVudCBpdGVtP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ3Vyc29yIG1vdmVtZW50XG5cbiAgc3RhcnRcbiAgICAgIC0tIE1vdmUgdG8gZmlyc3QgcG9zaXRpb24gaWYgYW55LlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cblxuICBkb19hbGwgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fZXhpc3RzOiBhY3Rpb24gLz0gVm9pZFxuICAgIGRvXG4gICAgICBsaW5lYXJfcmVwcmVzZW50YXRpb24uZG9fYWxsIChhY3Rpb24pXG4gICAgZW5kXG5cbiAgZG9faWYgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV07XG4gICB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fZXhpc3RzOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9leGlzdHM6IHRlc3QgLz0gVm9pZFxuICAgICAgLS0gdGVzdC5pc19wdXJlXG4gICAgZG9cbiAgICAgIGxpbmVhcl9yZXByZXNlbnRhdGlvbi5kb19pZiAoYWN0aW9uLCB0ZXN0KVxuICAgIGVuZFxuXG4gIHRoZXJlX2V4aXN0cyAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhdCBsZWFzdCBvbmUgaXRlbT9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X2V4aXN0czogdGVzdCAvPSBWb2lkXG4gICAgICAtLSB0ZXN0LmlzX3B1cmVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGxpbmVhcl9yZXByZXNlbnRhdGlvbi50aGVyZV9leGlzdHMgKHRlc3QpXG4gICAgZW5kXG5cbiAgZm9yX2FsbCAodGVzdDogRlVOQ1RJT04gW0FOWSwgVFVQTEUgW0ddLCBCT09MRUFOXSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB0ZXN0JyB0cnVlIGZvciBhbGwgaXRlbXM/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9leGlzdHM6IHRlc3QgLz0gVm9pZFxuICAgICAgLS0gdGVzdC5pc19wdXJlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBsaW5lYXJfcmVwcmVzZW50YXRpb24uZm9yX2FsbCAodGVzdClcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgZW1wdHlfY29uc3RyYWludDogaXNfZW1wdHkgaW1wbGllcyBvZmZcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkltcGxlbWVudGF0aW9uIG9mIFRVUExFXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTAxLTAxIDA0OjMzOjQ3IC0wODAwIChXZWQsIDAxIEphbiAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5Mzg2NSAkXCJcblxuY2xhc3NcbiAgVFVQTEVcblxuaW5oZXJpdFxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHJlZGVmaW5lXG4gICAgICBjb3JyZWN0X21pc21hdGNoLCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIFJFQURBQkxFX0lOREVYQUJMRSBbZGV0YWNoYWJsZSBzZXBhcmF0ZSBBTlldXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaW5kZXg6IElOVEVHRVIpOiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWSBhc3NpZ24gcHV0XG4gICAgICAtLSBFbnRyeSBvZiBrZXkgYGluZGV4Jy5cbiAgICBkb1xuICAgICAgaW5zcGVjdCBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIGJvb2xlYW5fY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIGNoYXJhY3Rlcl84X2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX2NoYXJhY3Rlcl84X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX2NoYXJhY3Rlcl8zMl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIHJlYWxfNjRfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfcmVhbF82NF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIHJlYWxfMzJfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfcmVhbF8zMl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIHBvaW50ZXJfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfcG9pbnRlcl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICB3aGVuIG5hdHVyYWxfOF9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9uYXR1cmFsXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBuYXR1cmFsXzE2X2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX25hdHVyYWxfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX25hdHVyYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBuYXR1cmFsXzY0X2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX25hdHVyYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBpbnRlZ2VyXzhfY29kZSB0aGVuIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl84X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gaW50ZWdlcl8xNl9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9pbnRlZ2VyXzE2X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gaW50ZWdlcl8zMl9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9pbnRlZ2VyXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gaW50ZWdlcl82NF9jb2RlIHRoZW4gUmVzdWx0IDo9IGVpZl9pbnRlZ2VyXzY0X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICAgIHdoZW4gUmVmZXJlbmNlX2NvZGUgdGhlbiBSZXN1bHQgOj0gZWlmX3JlZmVyZW5jZV9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZWZlcmVuY2VfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWVxuICAgICAgLS0gUmVmZXJlbmNlIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfcmVmZXJlbmNlOiBpc19yZWZlcmVuY2VfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfcmVmZXJlbmNlX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICBib29sZWFuX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2Jvb2xlYW46IGlzX2Jvb2xlYW5faXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzhfaXRlbSwgY2hhcmFjdGVyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2NoYXJhY3Rlcl84OiBpc19jaGFyYWN0ZXJfOF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9jaGFyYWN0ZXJfOF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzMyX2l0ZW0sIHdpZGVfY2hhcmFjdGVyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19jaGFyYWN0ZXJfMzI6IGlzX2NoYXJhY3Rlcl8zMl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9jaGFyYWN0ZXJfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIHJlYWxfNjRfaXRlbSwgZG91YmxlX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogUkVBTF82NFxuICAgICAgLS0gRG91YmxlIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfbnVtZXJpYzogaXNfZG91YmxlX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX3JlYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfOF9pdGVtIChpbmRleDogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gTkFUVVJBTF84IGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfaW50ZWdlcjogaXNfbmF0dXJhbF84X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX25hdHVyYWxfOF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgbmF0dXJhbF8xNl9pdGVtIChpbmRleDogSU5URUdFUik6IE5BVFVSQUxfMTZcbiAgICAgIC0tIE5BVFVSQUxfMTYgaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19pbnRlZ2VyOiBpc19uYXR1cmFsXzE2X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX25hdHVyYWxfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBOQVRVUkFMXzMyIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfaW50ZWdlcjogaXNfbmF0dXJhbF8zMl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9uYXR1cmFsXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICBuYXR1cmFsXzY0X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogTkFUVVJBTF82NFxuICAgICAgLS0gTkFUVVJBTF82NCBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2ludGVnZXI6IGlzX25hdHVyYWxfNjRfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfbmF0dXJhbF82NF9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgaW50ZWdlcl84X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBJTlRFR0VSXzggaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzhfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl84X2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICBpbnRlZ2VyXzE2X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogSU5URUdFUl8xNlxuICAgICAgLS0gSU5URUdFUl8xNiBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2ludGVnZXI6IGlzX2ludGVnZXJfMTZfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl8xNl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9pdGVtLCBpbnRlZ2VyXzMyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gSU5URUdFUl8zMiBpdGVtIGF0IGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIGlzX2ludGVnZXI6IGlzX2ludGVnZXJfMzJfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfaW50ZWdlcl8zMl9pdGVtICgkQ3VycmVudCwgaW5kZXgpXG4gICAgZW5kXG5cbiAgaW50ZWdlcl82NF9pdGVtIChpbmRleDogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIElOVEVHRVJfNjQgaXRlbSBhdCBgaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzY0X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX2ludGVnZXJfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuXG4gIHBvaW50ZXJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBQb2ludGVyIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfcG9pbnRlcjogaXNfcG9pbnRlcl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9wb2ludGVyX2l0ZW0gKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICByZWFsXzMyX2l0ZW0sIHJlYWxfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBSRUFMXzMyXG4gICAgICAtLSByZWFsIGl0ZW0gYXQgYGluZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgaXNfcmVhbF9vcl9pbnRlZ2VyOiBpc19yZWFsX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZWlmX3JlYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4KVxuICAgIGVuZFxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgb2JqZWN0X2NvbXBhcmlzb246IEJPT0xFQU5cbiAgICAgIC0tIE11c3Qgc2VhcmNoIG9wZXJhdGlvbnMgdXNlIGBlcXVhbCcgcmF0aGVyIHRoYW4gYD0nXG4gICAgICAtLSBmb3IgY29tcGFyaW5nIHJlZmVyZW5jZXM/IChEZWZhdWx0OiBubywgdXNlIGA9Jy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBlaWZfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgMClcbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IGNvbnNpZGVyZWRcbiAgICAgIC0tIGVxdWFsIHRvIGN1cnJlbnQgb2JqZWN0P1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9vYmplY3RfY29tcGFyZTogQk9PTEVBTlxuICAgIGRvXG4gICAgICBsX29iamVjdF9jb21wYXJlIDo9IG9iamVjdF9jb21wYXJpc29uXG4gICAgICBpZiBsX29iamVjdF9jb21wYXJlID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICBpZiBsX29iamVjdF9jb21wYXJlIHRoZW5cbiAgICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgIGkgPiBuYiBvciBub3QgUmVzdWx0XG4gICAgICAgICAgICBsb29wXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBpdGVtIChpKSB+IG90aGVyLml0ZW0gKGkpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IFByZWN1cnNvciB7SEFTSEFCTEV9IChvdGhlcilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgc2V0dGluZ1xuXG4gIGNvbXBhcmVfb2JqZWN0c1xuICAgICAgLS0gRW5zdXJlIHRoYXQgZnV0dXJlIHNlYXJjaCBvcGVyYXRpb25zIHdpbGwgdXNlIGBlcXVhbCdcbiAgICAgIC0tIHJhdGhlciB0aGFuIGA9JyBmb3IgY29tcGFyaW5nIHJlZmVyZW5jZXMuXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgMCwgVHJ1ZSlcbiAgICBlbnN1cmVcbiAgICAgIG9iamVjdF9jb21wYXJpc29uOiBvYmplY3RfY29tcGFyaXNvblxuICAgIGVuZFxuXG4gIGNvbXBhcmVfcmVmZXJlbmNlc1xuICAgICAgLS0gRW5zdXJlIHRoYXQgZnV0dXJlIHNlYXJjaCBvcGVyYXRpb25zIHdpbGwgdXNlIGA9J1xuICAgICAgLS0gcmF0aGVyIHRoYW4gYGVxdWFsJyBmb3IgY29tcGFyaW5nIHJlZmVyZW5jZXMuXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgMCwgRmFsc2UpXG4gICAgZW5zdXJlXG4gICAgICByZWZlcmVuY2VfY29tcGFyaXNvbjogbm90IG9iamVjdF9jb21wYXJpc29uXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgbG9jYWxcbiAgICAgIGksIG5iLCBsX2hhc2g6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBpbnNwZWN0IGVpZl9pdGVtX3R5cGUoJEN1cnJlbnQsIGkpXG4gICAgICAgIHdoZW4gYm9vbGVhbl9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9ib29sZWFuX2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiBjaGFyYWN0ZXJfOF9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9jaGFyYWN0ZXJfOF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX2NoYXJhY3Rlcl8zMl9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gcmVhbF82NF9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9yZWFsXzY0X2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiByZWFsXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX3JlYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGkpLmhhc2hfY29kZVxuICAgICAgICB3aGVuIHBvaW50ZXJfY29kZSB0aGVuIGxfaGFzaCA6PSBlaWZfcG9pbnRlcl9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gbmF0dXJhbF84X2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX25hdHVyYWxfOF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gbmF0dXJhbF8xNl9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9uYXR1cmFsXzE2X2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX25hdHVyYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGkpLmhhc2hfY29kZVxuICAgICAgICB3aGVuIG5hdHVyYWxfNjRfY29kZSB0aGVuIGxfaGFzaCA6PSBlaWZfbmF0dXJhbF82NF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gaW50ZWdlcl84X2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX2ludGVnZXJfOF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gaW50ZWdlcl8xNl9jb2RlIHRoZW4gbF9oYXNoIDo9IGVpZl9pbnRlZ2VyXzE2X2l0ZW0gKCRDdXJyZW50LCBpKS5oYXNoX2NvZGVcbiAgICAgICAgd2hlbiBpbnRlZ2VyXzMyX2NvZGUgdGhlbiBsX2hhc2ggOj0gZWlmX2ludGVnZXJfMzJfaXRlbSAoJEN1cnJlbnQsIGkpLmhhc2hfY29kZVxuICAgICAgICB3aGVuIGludGVnZXJfNjRfY29kZSB0aGVuIGxfaGFzaCA6PSBlaWZfaW50ZWdlcl82NF9pdGVtICgkQ3VycmVudCwgaSkuaGFzaF9jb2RlXG4gICAgICAgIHdoZW4gcmVmZXJlbmNlX2NvZGUgdGhlblxuICAgICAgICAgIGlmIGF0dGFjaGVkIHtIQVNIQUJMRX0gZWlmX3JlZmVyZW5jZV9pdGVtICgkQ3VycmVudCwgaSkgYXMgbF9rZXkgdGhlblxuICAgICAgICAgICAgbF9oYXNoIDo9IGxfa2V5Lmhhc2hfY29kZVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfaGFzaCA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgbF9oYXNoICogaW50ZXJuYWxfcHJpbWVzLmlfdGggKGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgICAtLSBFbnN1cmUgaXQgaXMgYSBwb3NpdGl2ZSB2YWx1ZS5cbiAgICAgIFJlc3VsdCA6PSBSZXN1bHQuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGs6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaycgYSB2YWxpZCBrZXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBrID49IDEgYW5kIHRoZW4gayA8PSBjb3VudFxuICAgIGVuZFxuXG4gIHZhbGlkX3R5cGVfZm9yX2luZGV4ICh2OiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWTsgaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBvYmplY3QgYHYnIGEgdmFsaWQgdGFyZ2V0IGZvciBlbGVtZW50IGF0IHBvc2l0aW9uIGBpbmRleCc/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBsb2NhbFxuICAgICAgbF9yZWZsZWN0b3I6IFJFRkxFQ1RPUlxuICAgIGRvXG4gICAgICBpZiB2ID0gVm9pZCB0aGVuXG4gICAgICAgICAgLS0gQSBWb2lkIGVudHJ5IGlzIHZhbGlkIG9ubHkgZm9yIHJlZmVyZW5jZXMgYW5kIGFzIGxvbmcgYXMgdGhlIGV4cGVjdGVkIHR5cGVcbiAgICAgICAgICAtLSBpcyBkZXRhY2hhYmxlLlxuICAgICAgICBpZiBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gcmVmZXJlbmNlX2NvZGUgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBub3QgZ2VuZXJhdGluZ190eXBlLmdlbmVyaWNfcGFyYW1ldGVyX3R5cGUgKGluZGV4KS5pc19hdHRhY2hlZFxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgaW5zcGVjdCBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpXG4gICAgICAgIHdoZW4gYm9vbGVhbl9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtCT09MRUFOX1JFRn0gdiBhcyBsX2JcbiAgICAgICAgd2hlbiBjaGFyYWN0ZXJfOF9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtDSEFSQUNURVJfOF9SRUZ9IHYgYXMgbF9jXG4gICAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge0NIQVJBQ1RFUl8zMl9SRUZ9IHYgYXMgbF93Y1xuICAgICAgICB3aGVuIHJlYWxfNjRfY29kZSB0aGVuIFJlc3VsdCA6PSBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IHYgYXMgbF9kXG4gICAgICAgIHdoZW4gcmVhbF8zMl9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtSRUFMXzMyX1JFRn0gdiBhcyBsX3JcbiAgICAgICAgd2hlbiBwb2ludGVyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge1BPSU5URVJfUkVGfSB2IGFzIGxfcFxuICAgICAgICB3aGVuIG5hdHVyYWxfOF9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtOQVRVUkFMXzhfUkVGfSB2IGFzIGxfdWk4XG4gICAgICAgIHdoZW4gbmF0dXJhbF8xNl9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtOQVRVUkFMXzE2X1JFRn0gdiBhcyBsX3VpMTZcbiAgICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge05BVFVSQUxfMzJfUkVGfSB2IGFzIGxfdWkzMlxuICAgICAgICB3aGVuIG5hdHVyYWxfNjRfY29kZSB0aGVuIFJlc3VsdCA6PSBhdHRhY2hlZCB7TkFUVVJBTF82NF9SRUZ9IHYgYXMgbF91aTY0XG4gICAgICAgIHdoZW4gaW50ZWdlcl84X2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge0lOVEVHRVJfOF9SRUZ9IHYgYXMgbF9pOFxuICAgICAgICB3aGVuIGludGVnZXJfMTZfY29kZSB0aGVuIFJlc3VsdCA6PSBhdHRhY2hlZCB7SU5URUdFUl8xNl9SRUZ9IHYgYXMgbF9pMTZcbiAgICAgICAgd2hlbiBpbnRlZ2VyXzMyX2NvZGUgdGhlbiBSZXN1bHQgOj0gYXR0YWNoZWQge0lOVEVHRVJfMzJfUkVGfSB2IGFzIGxfaTMyXG4gICAgICAgIHdoZW4gaW50ZWdlcl82NF9jb2RlIHRoZW4gUmVzdWx0IDo9IGF0dGFjaGVkIHtJTlRFR0VSXzY0X1JFRn0gdiBhcyBsX2k2NFxuICAgICAgICB3aGVuIFJlZmVyZW5jZV9jb2RlIHRoZW5cbiAgICAgICAgICAgIC0tIExldCdzIGNoZWNrIHRoYXQgdHlwZSBvZiBgdicgY29uZm9ybXMgdG8gc3BlY2lmaWVkIHR5cGUgb2YgYGluZGV4Jy10aFxuICAgICAgICAgICAgLS0gYXJndW1lbnRzIG9mIGN1cnJlbnQgVFVQTEUuXG4gICAgICAgICAgY3JlYXRlIGxfcmVmbGVjdG9yXG4gICAgICAgICAgUmVzdWx0IDo9IGxfcmVmbGVjdG9yLmZpZWxkX2NvbmZvcm1zX3RvICh2LmdlbmVyYXRpbmdfdHlwZS50eXBlX2lkLCBnZW5lcmF0aW5nX3R5cGUuZ2VuZXJpY19wYXJhbWV0ZXJfdHlwZSAoaW5kZXgpLnR5cGVfaWQpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBlbGVtZW50IGluIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGxvd2VyOiBJTlRFR0VSID0gMVxuICAgICAgLS0gTG93ZXIgYm91bmQgb2YgVFVQTEUuXG5cbiAgdXBwZXI6IElOVEVHRVJcbiAgICAgIC0tIFVwcGVyIGJvdW5kIG9mIFRVUExFLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gY291bnRcbiAgICBlbmRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgQ3VycmVudCBlbXB0eT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGNvdW50ID0gMFxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobG93ZXIsIHVwcGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWTsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGVfZm9yX2luZGV4OiB2YWxpZF90eXBlX2Zvcl9pbmRleCAodiwgaW5kZXgpXG4gICAgZG9cbiAgICAgIGluc3BlY3QgZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgd2hlbiBib29sZWFuX2NvZGUgdGhlbiBlaWZfcHV0X2Jvb2xlYW5faXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gY2hhcmFjdGVyXzhfY29kZSB0aGVuIGVpZl9wdXRfY2hhcmFjdGVyXzhfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gY2hhcmFjdGVyXzMyX2NvZGUgdGhlbiBlaWZfcHV0X2NoYXJhY3Rlcl8zMl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiByZWFsXzY0X2NvZGUgdGhlbiBlaWZfcHV0X3JlYWxfNjRfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gcmVhbF8zMl9jb2RlIHRoZW4gZWlmX3B1dF9yZWFsXzMyX2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIHBvaW50ZXJfY29kZSB0aGVuIGVpZl9wdXRfcG9pbnRlcl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiBuYXR1cmFsXzhfY29kZSB0aGVuIGVpZl9wdXRfbmF0dXJhbF84X2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIG5hdHVyYWxfMTZfY29kZSB0aGVuIGVpZl9wdXRfbmF0dXJhbF8xNl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiBuYXR1cmFsXzMyX2NvZGUgdGhlbiBlaWZfcHV0X25hdHVyYWxfMzJfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gbmF0dXJhbF82NF9jb2RlIHRoZW4gZWlmX3B1dF9uYXR1cmFsXzY0X2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIGludGVnZXJfOF9jb2RlIHRoZW4gZWlmX3B1dF9pbnRlZ2VyXzhfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gaW50ZWdlcl8xNl9jb2RlIHRoZW4gZWlmX3B1dF9pbnRlZ2VyXzE2X2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgICB3aGVuIGludGVnZXJfMzJfY29kZSB0aGVuIGVpZl9wdXRfaW50ZWdlcl8zMl9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgd2hlbiBpbnRlZ2VyXzY0X2NvZGUgdGhlbiBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbV93aXRoX29iamVjdCAoJEN1cnJlbnQsIGluZGV4LCAkdilcbiAgICAgIHdoZW4gUmVmZXJlbmNlX2NvZGUgdGhlbiBlaWZfcHV0X3JlZmVyZW5jZV9pdGVtX3dpdGhfb2JqZWN0ICgkQ3VycmVudCwgaW5kZXgsICR2KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHV0X3JlZmVyZW5jZSAodjogZGV0YWNoYWJsZSBzZXBhcmF0ZSBBTlk7IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGVfZm9yX2luZGV4OiB2YWxpZF90eXBlX2Zvcl9pbmRleCAodiwgaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19yZWZlcmVuY2VfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfcmVmZXJlbmNlX2l0ZW1fd2l0aF9vYmplY3QgKCRDdXJyZW50LCBpbmRleCwgJHYpXG4gICAgZW5kXG5cbiAgcHV0X2Jvb2xlYW4gKHY6IEJPT0xFQU47IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGU6IGlzX2Jvb2xlYW5faXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfYm9vbGVhbl9pdGVtICgkQ3VycmVudCwgaW5kZXgsIHYpXG4gICAgZW5kXG5cbiAgcHV0X2NoYXJhY3Rlcl84LCBwdXRfY2hhcmFjdGVyICh2OiBDSEFSQUNURVJfODsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfY2hhcmFjdGVyXzhfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfY2hhcmFjdGVyXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9jaGFyYWN0ZXJfMzIsIHB1dF93aWRlX2NoYXJhY3RlciAodjogQ0hBUkFDVEVSXzMyOyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19jaGFyYWN0ZXJfMzJfaXRlbSAoaW5kZXgpXG4gICAgZG9cbiAgICAgIGVpZl9wdXRfY2hhcmFjdGVyXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfcmVhbF82NCwgcHV0X2RvdWJsZSAodjogUkVBTF82NDsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfZG91YmxlX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X3JlYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9yZWFsXzMyLCBwdXRfcmVhbCAodjogUkVBTF8zMjsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfcmVhbF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9yZWFsXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfcG9pbnRlciAodjogUE9JTlRFUjsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfcG9pbnRlcl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9wb2ludGVyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfbmF0dXJhbF84ICh2OiBOQVRVUkFMXzg7IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGU6IGlzX25hdHVyYWxfOF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9uYXR1cmFsXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzE2ICh2OiBOQVRVUkFMXzE2OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19uYXR1cmFsXzE2X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X25hdHVyYWxfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzMyICh2OiBOQVRVUkFMXzMyOyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19uYXR1cmFsXzMyX2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X25hdHVyYWxfMzJfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9uYXR1cmFsXzY0ICh2OiBOQVRVUkFMXzY0OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19uYXR1cmFsXzY0X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X25hdHVyYWxfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyLCBwdXRfaW50ZWdlcl8zMiAodjogSU5URUdFUl8zMjsgaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQdXQgYHYnIGF0IHBvc2l0aW9uIGBpbmRleCcgaW4gQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgICAgdmFsaWRfdHlwZTogaXNfaW50ZWdlcl8zMl9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9pbnRlZ2VyXzMyX2l0ZW0gKCRDdXJyZW50LCBpbmRleCwgdilcbiAgICBlbmRcblxuICBwdXRfaW50ZWdlcl84ICh2OiBJTlRFR0VSXzg7IGluZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGB2JyBhdCBwb3NpdGlvbiBgaW5kZXgnIGluIEN1cnJlbnQuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICAgIHZhbGlkX3R5cGU6IGlzX2ludGVnZXJfOF9pdGVtIChpbmRleClcbiAgICBkb1xuICAgICAgZWlmX3B1dF9pbnRlZ2VyXzhfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzE2ICh2OiBJTlRFR0VSXzE2OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19pbnRlZ2VyXzE2X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X2ludGVnZXJfMTZfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG4gIHB1dF9pbnRlZ2VyXzY0ICh2OiBJTlRFR0VSXzY0OyBpbmRleDogSU5URUdFUilcbiAgICAgIC0tIFB1dCBgdicgYXQgcG9zaXRpb24gYGluZGV4JyBpbiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgICB2YWxpZF90eXBlOiBpc19pbnRlZ2VyXzY0X2l0ZW0gKGluZGV4KVxuICAgIGRvXG4gICAgICBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbSAoJEN1cnJlbnQsIGluZGV4LCB2KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFR5cGUgcXVlcmllc1xuXG4gIGlzX2Jvb2xlYW5faXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYSBCT09MRUFOP1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IGJvb2xlYW5fY29kZSlcbiAgICBlbmRcblxuICBpc19jaGFyYWN0ZXJfOF9pdGVtLCBpc19jaGFyYWN0ZXJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYSBDSEFSQUNURVJfOD9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBjaGFyYWN0ZXJfOF9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2NoYXJhY3Rlcl8zMl9pdGVtLCBpc193aWRlX2NoYXJhY3Rlcl9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhIENIQVJBQ1RFUl8zMj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBjaGFyYWN0ZXJfMzJfY29kZSlcbiAgICBlbmRcblxuICBpc19kb3VibGVfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYSBSRUFMXzY0P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IHJlYWxfNjRfY29kZSlcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzhfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYW4gTkFUVVJBTF84P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IG5hdHVyYWxfOF9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfMTZfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYW4gTkFUVVJBTF8xNj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBuYXR1cmFsXzE2X2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfbmF0dXJhbF8zMl9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBOQVRVUkFMXzMyP1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IG5hdHVyYWxfMzJfY29kZSlcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzY0X2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgaXRlbSBhdCBgaW5kZXgnIGFuIE5BVFVSQUxfNjQ/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gbmF0dXJhbF82NF9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2ludGVnZXJfOF9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBJTlRFR0VSXzg/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gaW50ZWdlcl84X2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl8xNl9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBJTlRFR0VSXzE2P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IGludGVnZXJfMTZfY29kZSlcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyX2l0ZW0sIGlzX2ludGVnZXJfMzJfaXRlbSAoaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBpdGVtIGF0IGBpbmRleCcgYW4gSU5URUdFUl8zMj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBpbnRlZ2VyXzMyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfaW50ZWdlcl82NF9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhbiBJTlRFR0VSXzY0P1xuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaW5kZXgpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KSA9IGludGVnZXJfNjRfY29kZSlcbiAgICBlbmRcblxuICBpc19wb2ludGVyX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgaXRlbSBhdCBgaW5kZXgnIGEgUE9JTlRFUj9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSBwb2ludGVyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfcmVhbF9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhIFJFQUxfMzI/XG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaW5kZXgpID0gcmVhbF8zMl9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX3JlZmVyZW5jZV9pdGVtIChpbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGl0ZW0gYXQgYGluZGV4JyBhIFJFRkVSRU5DRT9cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleCkgPSByZWZlcmVuY2VfY29kZSlcbiAgICBlbmRcblxuICBpc19udW1lcmljX2l0ZW0gKGluZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgaXRlbSBhdCBgaW5kZXgnIGEgbnVtYmVyP1xuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0aGUgcHJlY2lzZSB0eXBlIHF1ZXJ5IGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGluZGV4KVxuICAgIGxvY2FsXG4gICAgICB0Y29kZTogbGlrZSBpdGVtX2NvZGVcbiAgICBkb1xuICAgICAgdGNvZGUgOj0gZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGluZGV4KVxuICAgICAgaW5zcGVjdCB0Y29kZVxuICAgICAgd2hlblxuICAgICAgICBpbnRlZ2VyXzhfY29kZSwgaW50ZWdlcl8xNl9jb2RlLCBpbnRlZ2VyXzMyX2NvZGUsXG4gICAgICAgIGludGVnZXJfNjRfY29kZSwgcmVhbF8zMl9jb2RlLCByZWFsXzY0X2NvZGVcbiAgICAgIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgLS0gTm90aGluZyB0byBkbyBoZXJlIHNpbmNlIFJlc3VsdCBhbHJlYWR5IGluaXRpYWxpemVkIHRvIEZhbHNlLlxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0aGUgc2FtZSBiYXNpYyB0eXBlIG9yIGFsbCBvZiByZWZlcmVuY2UgdHlwZT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKGFueV9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1fYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIEJPT0xFQU4/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChib29sZWFuX2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9jaGFyYWN0ZXJfOCwgaXNfdW5pZm9ybV9jaGFyYWN0ZXI6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKGNoYXJhY3Rlcl84X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9jaGFyYWN0ZXJfMzIsIGlzX3VuaWZvcm1fd2lkZV9jaGFyYWN0ZXI6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChjaGFyYWN0ZXJfMzJfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX2RvdWJsZTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIFJFQUxfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChyZWFsXzY0X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9uYXR1cmFsXzg6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBOQVRVUkFMXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChuYXR1cmFsXzhfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX25hdHVyYWxfMTY6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBOQVRVUkFMXzE2P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAobmF0dXJhbF8xNl9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1fbmF0dXJhbF8zMjogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIE5BVFVSQUxfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChuYXR1cmFsXzMyX2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9uYXR1cmFsXzY0OiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIG9mIHR5cGUgTkFUVVJBTF82ND9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKG5hdHVyYWxfNjRfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX2ludGVnZXJfODogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIElOVEVHRVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKGludGVnZXJfOF9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1faW50ZWdlcl8xNjogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIElOVEVHRVJfMTY/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChpbnRlZ2VyXzE2X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9pbnRlZ2VyLCBpc191bmlmb3JtX2ludGVnZXJfMzI6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBJTlRFR0VSP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAoaW50ZWdlcl8zMl9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1faW50ZWdlcl82NDogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBvZiB0eXBlIElOVEVHRVJfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc190dXBsZV91bmlmb3JtIChpbnRlZ2VyXzY0X2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgaXNfdW5pZm9ybV9wb2ludGVyOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIG9mIHR5cGUgUE9JTlRFUj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3R1cGxlX3VuaWZvcm0gKHBvaW50ZXJfY29kZSlcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc191bmlmb3JtX3JlYWw6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBSRUFMXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAocmVhbF8zMl9jb2RlKVxuICAgIGVuc3VyZVxuICAgICAgeWVzX2lmX2VtcHR5OiAoY291bnQgPSAwKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX3VuaWZvcm1fcmVmZXJlbmNlOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIG9mIHJlZmVyZW5jZSB0eXBlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdHVwbGVfdW5pZm9ybSAocmVmZXJlbmNlX2NvZGUpXG4gICAgZW5zdXJlXG4gICAgICB5ZXNfaWZfZW1wdHk6IChjb3VudCA9IDApIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoYV9vdGhlcjogVFVQTEUpOiBkZXRhY2hhYmxlIGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29uY2F0ZW5hdGlvbiBvZiBgQ3VycmVudCcgd2l0aCBgYV9vdGhlcidcbiAgICAgIC0tfCBub3RlOiBpdCBtYXkgYmUgVm9pZCBpZiB0aGUgcmVzdWx0IGV4Y2VlZHMgdGhlIGFsbG93ZWQgY2FwYWNpdHkgZm9yIGEgdHVwbGUuXG4gICAgICAtLXwgd2FybmluZzogdGhpcyBmdW5jdGlvbiBoYXMgcG9vciBwZXJmb3JtYW5jZSwgdXNlIGl0IHdpdGggcGFyc2ltb255LlxuICAgIGxvY2FsXG4gICAgICBsX3JlZmxlY3RvcjogUkVGTEVDVE9SXG4gICAgICBpLCBuMSxuMjogSU5URUdFUlxuICAgICAgdDEsIHQyOiBUWVBFIFtkZXRhY2hhYmxlIFRVUExFXVxuICAgICAgbF90eXBlX2lkOiBJTlRFR0VSXG4gICAgICBsX2l0ZW1zOiBTUEVDSUFMIFtkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWV1cbiAgICAgIGxfdHlwZV9zdHJpbmc6IFNUUklOR1xuICAgIGRvXG4gICAgICBuMSA6PSBjb3VudFxuICAgICAgbjIgOj0gYV9vdGhlci5jb3VudFxuXG4gICAgICBpZiBuMSA9IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYV9vdGhlci50d2luXG4gICAgICBlbHNlaWYgbjIgPSAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGVsc2VcbiAgICAgICAgY3JlYXRlIGxfdHlwZV9zdHJpbmcubWFrZV9mcm9tX3N0cmluZyAoXCJUVVBMRSBbXCIpXG5cbiAgICAgICAgY3JlYXRlIGxfaXRlbXMubWFrZV9lbXB0eSAobjEgKyBuMilcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHQxIDo9IGdlbmVyYXRpbmdfdHlwZVxuICAgICAgICAgIGNoZWNrIHNhbWVfY291bnQ6IHQxLmdlbmVyaWNfcGFyYW1ldGVyX2NvdW50ID0gbjEgZW5kXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG4xXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpID4gMSB0aGVuXG4gICAgICAgICAgICBsX3R5cGVfc3RyaW5nLmFwcGVuZF9jaGFyYWN0ZXIgKCcsJylcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBsX3R5cGVfc3RyaW5nLmFwcGVuZCAodDEuZ2VuZXJpY19wYXJhbWV0ZXJfdHlwZSAoaSkubmFtZSlcbiAgICAgICAgICBsX2l0ZW1zLmZvcmNlIChpdGVtIChpKSwgaSAtIDEpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgZnJvbVxuICAgICAgICAgIHQyIDo9IGFfb3RoZXIuZ2VuZXJhdGluZ190eXBlXG4gICAgICAgICAgY2hlY2sgc2FtZV9jb3VudDogdDIuZ2VuZXJpY19wYXJhbWV0ZXJfY291bnQgPSBuMiBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbjEgKyBuMlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90eXBlX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyICgnLCcpXG4gICAgICAgICAgbF90eXBlX3N0cmluZy5hcHBlbmQgKHQyLmdlbmVyaWNfcGFyYW1ldGVyX3R5cGUgKGkgLSBuMSkubmFtZSlcbiAgICAgICAgICBsX2l0ZW1zLmZvcmNlIChhX290aGVyLml0ZW0gKGkgLSBuMSksIGkgLSAxKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgbF90eXBlX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyICgnXScpXG4gICAgICAgIGNyZWF0ZSBsX3JlZmxlY3RvclxuICAgICAgICBsX3R5cGVfaWQgOj0gbF9yZWZsZWN0b3IuZHluYW1pY190eXBlX2Zyb21fc3RyaW5nIChsX3R5cGVfc3RyaW5nKVxuICAgICAgICBpZiBsX3R5cGVfaWQgPj0gMCB0aGVuXG4gICAgICAgICAgaWYgYXR0YWNoZWQge2xpa2UgcGx1c30gbF9yZWZsZWN0b3IubmV3X3R1cGxlX2Zyb21fc3BlY2lhbCAobF90eXBlX2lkLCBsX2l0ZW1zKSBhcyByZXMgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IHJlc1xuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLXwgSXQgbWF5IGJlIHRoYXQgdGhlIG1heGltdW0gdHVwbGUgY2FwYWNpdHkgd2FzIHJlYWNoZWQuXG4gICAgICAgICAgICAtLXwgYmV0dGVyIHJldHVybiBWb2lkIHRoYW4gYSB0cnVuY2F0ZWQgdHVwbGUuXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBoYXNfZXhwZWN0ZWRfY291bnQ6IFJlc3VsdCAvPSBWb2lkIGltcGxpZXMgUmVzdWx0LmNvdW50ID0gY291bnQgKyBhX290aGVyLmNvdW50XG4gICAgICBoYXNfZXhwZWN0ZWRfaXRlbXM6IFJlc3VsdCAvPSBWb2lkIGltcGxpZXMgKFxuICAgICAgICAgICAgKGFjcm9zcyAxIHwuLnwgY291bnQgYXMgaWNfMSBhbGwgUmVzdWx0W2ljXzEuaXRlbV0gPSBpdGVtIChpY18xLml0ZW0pIGVuZCkgYW5kXG4gICAgICAgICAgICAoYWNyb3NzIDEgfC4ufCBhX290aGVyLmNvdW50IGFzIGljXzIgYWxsIFJlc3VsdFtjb3VudCArIGljXzIuaXRlbV0gPSBhX290aGVyIFtpY18yLml0ZW1dIGVuZClcbiAgICAgICAgICApXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVHlwZSBjb252ZXJzaW9uIHF1ZXJpZXNcblxuICBjb252ZXJ0aWJsZV90b19kb3VibGU6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgY29udmVydGlibGUgdG8gYW4gYXJyYXkgb2YgZG91Ymxlcz9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICBsb2NhbFxuICAgICAgaSwgY250OiBJTlRFR0VSXG4gICAgICB0Y29kZTogbGlrZSBpdGVtX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICAgIGNudCA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNudCBvciBlbHNlIG5vdCBSZXN1bHRcbiAgICAgIGxvb3BcbiAgICAgICAgdGNvZGUgOj0gZWlmX2l0ZW1fdHlwZSAoJEN1cnJlbnQsIGkpXG4gICAgICAgIGluc3BlY3QgdGNvZGVcbiAgICAgICAgd2hlblxuICAgICAgICAgIGludGVnZXJfOF9jb2RlLCBpbnRlZ2VyXzE2X2NvZGUsIGludGVnZXJfMzJfY29kZSxcbiAgICAgICAgICBpbnRlZ2VyXzY0X2NvZGUsIHJlYWxfMzJfY29kZSwgcmVhbF82NF9jb2RlXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBjb252ZXJ0aWJsZV90b19yZWFsOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGNvbnZlcnRpYmxlIHRvIGFuIGFycmF5IG9mIHJlYWxzP1xuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICAgIHRjb2RlOiBsaWtlIGl0ZW1fY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250IG9yIGVsc2Ugbm90IFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICB0Y29kZSA6PSBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaSlcbiAgICAgICAgaW5zcGVjdCB0Y29kZVxuICAgICAgICB3aGVuXG4gICAgICAgICAgaW50ZWdlcl84X2NvZGUsIGludGVnZXJfMTZfY29kZSwgaW50ZWdlcl8zMl9jb2RlLFxuICAgICAgICAgIGludGVnZXJfNjRfY29kZSwgcmVhbF8zMl9jb2RlXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHllc19pZl9lbXB0eTogKGNvdW50ID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXJyYXllZDogQVJSQVkgW2RldGFjaGFibGUgc2VwYXJhdGUgQU5ZXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKFZvaWQsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAoaXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgYm9vbGVhbl9hcnJheWVkOiBBUlJBWSBbQk9PTEVBTl1cbiAgICAgIC0tIEl0ZW1zIG9mIEN1cnJlbnQgYXMgYXJyYXlcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICByZXF1aXJlXG4gICAgICBpc191bmlmb3JtX2Jvb2xlYW46IGlzX3VuaWZvcm1fYm9vbGVhblxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKEZhbHNlLCAxLCBjbnQpXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdC5wdXQgKGJvb2xlYW5faXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyXzhfYXJyYXllZCwgY2hhcmFjdGVyX2FycmF5ZWQ6IEFSUkFZIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIEl0ZW1zIG9mIEN1cnJlbnQgYXMgYXJyYXlcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICByZXF1aXJlXG4gICAgICBpc191bmlmb3JtX2NoYXJhY3RlcjogaXNfdW5pZm9ybV9jaGFyYWN0ZXJcbiAgICBsb2NhbFxuICAgICAgaSwgY250OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICAgIGNudCA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZmlsbGVkICgnICcsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAoY2hhcmFjdGVyXzhfaXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgZG91YmxlX2FycmF5ZWQ6IEFSUkFZIFtSRUFMXzY0XVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIHJlcXVpcmVcbiAgICAgIGNvbnZlcnRpYmxlOiBjb252ZXJ0aWJsZV90b19kb3VibGVcbiAgICBsb2NhbFxuICAgICAgaSwgY250OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICAgIGNudCA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZmlsbGVkICh7UkVBTF82NH0gMC4wLCAxLCBjbnQpXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdC5wdXQgKGRvdWJsZV9pdGVtIChpKSwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9pdGVtczogLS0gSXRlbXMgYXJlIHRoZSBzYW1lIGluIHNhbWUgb3JkZXJcbiAgICBlbmRcblxuICBpbnRlZ2VyX2FycmF5ZWQ6IEFSUkFZIFtJTlRFR0VSXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX3VuaWZvcm1faW50ZWdlcjogaXNfdW5pZm9ybV9pbnRlZ2VyXG4gICAgbG9jYWxcbiAgICAgIGksIGNudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgICBjbnQgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoe0lOVEVHRVJ9IDAsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAoaW50ZWdlcl8zMl9pdGVtIChpKSwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9pdGVtczogLS0gSXRlbXMgYXJlIHRoZSBzYW1lIGluIHNhbWUgb3JkZXJcbiAgICBlbmRcblxuICBwb2ludGVyX2FycmF5ZWQ6IEFSUkFZIFtQT0lOVEVSXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgIG9ic29sZXRlXG4gICAgICBcIldpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXNcIlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX3VuaWZvcm1fcG9pbnRlcjogaXNfdW5pZm9ybV9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGksIGNudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgICBjbnQgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoRGVmYXVsdF9wb2ludGVyLCAxLCBjbnQpXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY250XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdC5wdXQgKHBvaW50ZXJfaXRlbSAoaSksIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIHNhbWVfaXRlbXM6IC0tIEl0ZW1zIGFyZSB0aGUgc2FtZSBpbiBzYW1lIG9yZGVyXG4gICAgZW5kXG5cbiAgcmVhbF9hcnJheWVkOiBBUlJBWSBbUkVBTF8zMl1cbiAgICAgIC0tIEl0ZW1zIG9mIEN1cnJlbnQgYXMgYXJyYXlcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJXaWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2VzXCJcbiAgICByZXF1aXJlXG4gICAgICBjb252ZXJ0aWJsZTogY29udmVydGlibGVfdG9fcmVhbFxuICAgIGxvY2FsXG4gICAgICBpLCBjbnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgICAgY250IDo9IGNvdW50XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKHtSRUFMXzMyfSAwLjAsIDEsIGNudClcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjbnRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0LnB1dCAocmVhbF9pdGVtIChpKSwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgc2FtZV9pdGVtczogLS0gSXRlbXMgYXJlIHRoZSBzYW1lIGluIHNhbWUgb3JkZXJcbiAgICBlbmRcblxuICBzdHJpbmdfYXJyYXllZDogQVJSQVkgW2RldGFjaGFibGUgU1RSSU5HXVxuICAgICAgLS0gSXRlbXMgb2YgQ3VycmVudCBhcyBhcnJheVxuICAgICAgLS0gTk9URTogSXRlbXMgd2l0aCBhIHR5cGUgbm90IGNjb25mb3JtaW5nIHRvXG4gICAgICAtLSAgICAgICB0eXBlIFNUUklORyBhcmUgc2V0IHRvIFZvaWQuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiV2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlc1wiXG4gICAgbG9jYWxcbiAgICAgIGksIGNudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgICBjbnQgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2ZpbGxlZCAoVm9pZCwgMSwgY250KVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNudFxuICAgICAgbG9vcFxuICAgICAgICBpZiBhdHRhY2hlZCB7U1RSSU5HfSBpdGVtIChpKSBhcyBzIHRoZW5cbiAgICAgICAgICBSZXN1bHQucHV0IChzLCBpKVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBleGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2NvdW50OiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJldHJpZXZhbFxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYW55OiBBTllcbiAgICBkb1xuICAgICAgICAtLSBPbGQgdmVyc2lvbiBvZiBUVVBMRSBoYWQgYSBTUEVDSUFMIFtBTlldIHRvIHN0b3JlIGFsbCB2YWx1ZXMuXG4gICAgICAgIC0tIElmIHdlIGNhbiBnZXQgYWNjZXNzIHRvIGl0LCB0aGVuIG1vc3QgbGlrZWx5IHdlIGNhbiByZWNvdmVyIHRoaXNcbiAgICAgICAgLS0gb2xkIFRVUExFIGltcGxlbWVudGF0aW9uLlxuICAgICAgaWYgYXR0YWNoZWQge1NQRUNJQUwgW0FOWV19IE1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKGFyZWFfbmFtZSkgYXMgbF9hcmVhIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICAgIG5iIDo9IGxfYXJlYS5jb3VudFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hbnkgOj0gbF9hcmVhLml0ZW0gKGkgLSAxKVxuICAgICAgICAgIGlmIHZhbGlkX3R5cGVfZm9yX2luZGV4IChsX2FueSwgaSkgdGhlblxuICAgICAgICAgICAgcHV0IChsX2FueSwgaSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFdlIGZvdW5kIGFuIHVuZXhwZWN0ZWQgdHlwZSBpbiBvbGQgc3BlY2lhbC4gV2UgY2Fubm90IGdvIG9uLlxuICAgICAgICAgICAgUHJlY3Vyc29yIHtNSVNNQVRDSF9DT1JSRUNUT1J9XG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtNSVNNQVRDSF9DT1JSRUNUT1J9XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtX2NvZGUgKGluZGV4OiBJTlRFR0VSKTogTkFUVVJBTF84XG4gICAgICAtLSBUeXBlIGNvZGUgb2YgaXRlbSBhdCBgaW5kZXgnLiBVc2VkIGZvclxuICAgICAgLS0gYXJndW1lbnQgcHJvY2Vzc2luZyBpbiBST1VUSU5FXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpbmRleClcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGVpZl9pdGVtX3R5cGUgKCRDdXJyZW50LCBpbmRleClcbiAgICBlbmRcblxuICByZWZlcmVuY2VfY29kZTogTkFUVVJBTF84ID0gMHgwMFxuICBib29sZWFuX2NvZGU6IE5BVFVSQUxfOCA9IDB4MDFcbiAgY2hhcmFjdGVyXzhfY29kZSwgY2hhcmFjdGVyX2NvZGU6IE5BVFVSQUxfOCA9IDB4MDJcbiAgcmVhbF82NF9jb2RlOiBOQVRVUkFMXzggPSAweDAzXG4gIHJlYWxfMzJfY29kZTogTkFUVVJBTF84ID0gMHgwNFxuICBwb2ludGVyX2NvZGU6IE5BVFVSQUxfOCA9IDB4MDVcbiAgaW50ZWdlcl84X2NvZGU6IE5BVFVSQUxfOCA9IDB4MDZcbiAgaW50ZWdlcl8xNl9jb2RlOiBOQVRVUkFMXzggPSAweDA3XG4gIGludGVnZXJfMzJfY29kZTogTkFUVVJBTF84ID0gMHgwOFxuICBpbnRlZ2VyXzY0X2NvZGU6IE5BVFVSQUxfOCA9IDB4MDlcbiAgbmF0dXJhbF84X2NvZGU6IE5BVFVSQUxfOCA9IDB4MEFcbiAgbmF0dXJhbF8xNl9jb2RlOiBOQVRVUkFMXzggPSAweDBCXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF84ID0gMHgwQ1xuICBuYXR1cmFsXzY0X2NvZGU6IE5BVFVSQUxfOCA9IDB4MERcbiAgY2hhcmFjdGVyXzMyX2NvZGUsIHdpZGVfY2hhcmFjdGVyX2NvZGU6IE5BVFVSQUxfOCA9IDB4MEVcbiAgYW55X2NvZGU6IE5BVFVSQUxfOCA9IDB4RkZcbiAgICAgIC0tIENvZGUgdXNlZCB0byBpZGVudGlmeSB0eXBlIGluIFRVUExFLlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGFyZWFfbmFtZTogU1RSSU5HID0gXCJhcmVhXCJcbiAgICAgIC0tIE5hbWUgb2YgYXR0cmlidXRlcyB3aGVyZSBUVVBMRSBlbGVtZW50cyB3ZXJlIHN0b3JlZC5cblxuICBpc190dXBsZV91bmlmb3JtIChjb2RlOiBsaWtlIGl0ZW1fY29kZSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBhbGwgaXRlbXMgb2YgdHlwZSBgY29kZSc/XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvZGU6IGxpa2UgaXRlbV9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgICBpZiBjb2RlID0gYW55X2NvZGUgdGhlblxuICAgICAgICAgICAgICAtLSBXZSB0YWtlIGZpcnN0IHR5cGUgY29kZSBhbmQgY29tcGFyZSBhbGwgdGhlIHJlbWFpbmluZyBvbmVzXG4gICAgICAgICAgICAgIC0tIGFnYWluc3QgaXQuXG4gICAgICAgICAgICBpIDo9IDJcbiAgICAgICAgICAgIGxfY29kZSA6PSBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgMSlcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICAgIGxfY29kZSA6PSBjb2RlXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IG5iIG9yIG5vdCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2NvZGUgPSBlaWZfaXRlbV90eXBlICgkQ3VycmVudCwgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfcHJpbWVzOiBQUklNRVNcbiAgICAgIC0tIEZvciBxdWljayBhY2Nlc3MgdG8gcHJpbWUgbnVtYmVycy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEV4dGVybmFsczogQWNjZXNzXG5cbiAgZWlmX2l0ZW1fdHlwZSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIENvZGUgZm9yIGdlbmVyaWMgcGFyYW1ldGVyIGBwb3MnIGluIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBhbGlhc1xuICAgICAgXCJlaWZfaXRlbV90eXBlXCJcbiAgICBlbmRcblxuICBlaWZfYm9vbGVhbl9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX2NoYXJhY3Rlcl84X2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfY2hhcmFjdGVyXzMyX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBXaWRlIGNoYXJhY3RlciBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcmVhbF82NF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IFJFQUxfNjRcbiAgICAgIC0tIERvdWJsZSBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcmVhbF8zMl9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IFJFQUxfMzJcbiAgICAgIC0tIFJlYWwgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3BvaW50ZXJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBQb2ludGVyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9uYXR1cmFsXzhfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIE5BVFVSQUxfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfbmF0dXJhbF8xNl9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6ICBOQVRVUkFMXzE2XG4gICAgICAtLSBOQVRVUkFMXzE2IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9uYXR1cmFsXzMyX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogIE5BVFVSQUxfMzJcbiAgICAgIC0tIE5BVFVSQUxfMzIgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX25hdHVyYWxfNjRfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiAgTkFUVVJBTF82NFxuICAgICAgLS0gTkFUVVJBTF82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfaW50ZWdlcl84X2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogSU5URUdFUl84XG4gICAgICAtLSBJTlRFR0VSXzggaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX2ludGVnZXJfMTZfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVIpOiBJTlRFR0VSXzE2XG4gICAgICAtLSBJTlRFR0VSXzE2IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9pbnRlZ2VyXzMyX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gSU5URUdFUl8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfaW50ZWdlcl82NF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IElOVEVHRVJfNjRcbiAgICAgIC0tIElOVEVHRVJfNjQgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3JlZmVyZW5jZV9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUik6IGRldGFjaGFibGUgQU5ZXG4gICAgICAtLSBSZWZlcmVuY2UgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEV4dGVybmFsczogU2V0dGluZ1xuXG4gIGVpZl9wdXRfYm9vbGVhbl9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBib29sZWFuIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfY2hhcmFjdGVyXzhfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgY2hhcmFjdGVyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfY2hhcmFjdGVyXzMyX2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IHdpZGUgY2hhcmFjdGVyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfcmVhbF82NF9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBkb3VibGUgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9yZWFsXzMyX2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IHJlYWwgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9wb2ludGVyX2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IHBvaW50ZXIgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9uYXR1cmFsXzhfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgTkFUVVJBTF84IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfbmF0dXJhbF8xNl9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBOQVRVUkFMXzE2IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfbmF0dXJhbF8zMl9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBOQVRVUkFMXzMyIGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfbmF0dXJhbF82NF9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCBOQVRVUkFMXzY0IGl0ZW0gYXQgcG9zaXRpb24gYHBvcycgaW4gdHVwbGUgYG9iaicgd2l0aCBgdicuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiQyBtYWNybyB1c2UgJVwiZWlmX3JvdXRfb2JqLmglXCJcIlxuICAgIGVuZFxuXG4gIGVpZl9wdXRfaW50ZWdlcl84X2l0ZW1fd2l0aF9vYmplY3QgKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBQT0lOVEVSKVxuICAgICAgLS0gU2V0IGludGVnZXJfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMTZfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8xNiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMzJfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbV93aXRoX29iamVjdCAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X3JlZmVyZW5jZV9pdGVtX3dpdGhfb2JqZWN0IChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogUE9JTlRFUilcbiAgICAgIC0tIFNldCByZWZlcmVuY2UgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9ib29sZWFuX2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBCT09MRUFOKVxuICAgICAgLS0gU2V0IGJvb2xlYW4gaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9jaGFyYWN0ZXJfOF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBTZXQgY2hhcmFjdGVyXzggaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9jaGFyYWN0ZXJfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFNldCBjaGFyYWN0ZXJfMzIgaXRlbSBhdCBwb3NpdGlvbiBgcG9zJyBpbiB0dXBsZSBgb2JqJyB3aXRoIGB2Jy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJDIG1hY3JvIHVzZSAlXCJlaWZfcm91dF9vYmouaCVcIlwiXG4gICAgZW5kXG5cbiAgZWlmX3B1dF9yZWFsXzY0X2l0ZW0gKG9iajogUE9JTlRFUjsgcG9zOiBJTlRFR0VSOyB2OiBSRUFMXzY0KVxuICAgICAgLS0gU2V0IGRvdWJsZSBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X3JlYWxfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFJFQUxfMzIpXG4gICAgICAtLSBTZXQgcmVhbCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X3BvaW50ZXJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IFBPSU5URVIpXG4gICAgICAtLSBTZXQgcG9pbnRlciBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfOF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogTkFUVVJBTF84KVxuICAgICAgLS0gU2V0IE5BVFVSQUxfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfMTZfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IE5BVFVSQUxfMTYpXG4gICAgICAtLSBTZXQgTkFUVVJBTF8xNiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBTZXQgTkFUVVJBTF8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X25hdHVyYWxfNjRfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IE5BVFVSQUxfNjQpXG4gICAgICAtLSBTZXQgTkFUVVJBTF82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfOF9pdGVtIChvYmo6IFBPSU5URVI7IHBvczogSU5URUdFUjsgdjogSU5URUdFUl84KVxuICAgICAgLS0gU2V0IGludGVnZXJfOCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMTZfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IElOVEVHRVJfMTYpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8xNiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfMzJfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IElOVEVHRVJfMzIpXG4gICAgICAtLSBTZXQgaW50ZWdlcl8zMiBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxuICBlaWZfcHV0X2ludGVnZXJfNjRfaXRlbSAob2JqOiBQT0lOVEVSOyBwb3M6IElOVEVHRVI7IHY6IElOVEVHRVJfNjQpXG4gICAgICAtLSBTZXQgaW50ZWdlcl82NCBpdGVtIGF0IHBvc2l0aW9uIGBwb3MnIGluIHR1cGxlIGBvYmonIHdpdGggYHYnLlxuICAgIGV4dGVybmFsXG4gICAgICBcIkMgbWFjcm8gdXNlICVcImVpZl9yb3V0X29iai5oJVwiXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlcHJlc2VudGF0aW9uIG9mIGFuIEVpZmZlbCB0eXBlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wOS0wNSAwMzoyOToyNCAtMDcwMCAoVGh1LCAwNSBTZXAgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTI5MTMgJFwiXG5cbmNsYXNzXG4gIFRZUEUgW0ddXG5cbmluaGVyaXRcbiAgSEFTSEFCTEVcbiAgICByZW5hbWVcbiAgICAgIGRlZmF1bHQgYXMgYW55X2RlZmF1bHRcbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIFBBUlRfQ09NUEFSQUJMRVxuICAgIHJlbmFtZVxuICAgICAgZGVmYXVsdCBhcyBhbnlfZGVmYXVsdCxcbiAgICAgIGlzX2xlc3MgYXMgaXNfc3RyaWN0bHlfY29uZm9ybWluZ190byBhbGlhcyBcIjxcIixcbiAgICAgIGlzX2xlc3NfZXF1YWwgYXMgaXNfY29uZm9ybWluZ190byBhbGlhcyBcIjw9XCJcbiAgICByZWRlZmluZVxuICAgICAgaXNfY29uZm9ybWluZ190bywgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIERFQlVHX09VVFBVVFxuICAgIHJlbmFtZVxuICAgICAgZGVmYXVsdCBhcyBhbnlfZGVmYXVsdFxuICAgIHJlZGVmaW5lXG4gICAgICBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmNyZWF0ZSB7Tk9ORX1cbiAgLS0gQ3JlYXRpb24gaXMgZG9uZSBlaXRoZXIgYnkgdXNpbmcgbWFuaWZlc3QgdHlwZXNcbiAgLS0gb3IgYnkgY2FsbGluZyBBTlkuZ2VuZXJhdGluZ190eXBlLlxuXG5jb252ZXJ0XG4gICAgLS0gQ29udmVyc2lvbiB1c2VmdWwgZm9yIHRoZSB0cmFuc2l0aW9uIHBlcmlvZCBiZWNhdXNlIG9mIHRoZVxuICAgIC0tIG1vZGlmaWNhdGlvbiBpbiBBTlk6XG4gICAgLS0gICAgZ2VuZXJhdGluZ190eXBlOiBTVFJJTkdcbiAgICAtLSBiZWNvbWVzOlxuICAgIC0tICAgIGdlbmVyYXRpbmdfdHlwZTogVFlQRSBbbGlrZSBDdXJyZW50XVxuICB0b19zdHJpbmdfODoge1NUUklOR184LCBTVFJJTkdfR0VORVJBTCwgUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwsIFJFQURBQkxFX1NUUklOR184fSxcbiAgdG9fc3RyaW5nXzMyOiB7U1RSSU5HXzMyLCBSRUFEQUJMRV9TVFJJTkdfMzJ9XG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgbmFtZTogSU1NVVRBQkxFX1NUUklOR184XG4gICAgICAtLSBOYW1lIG9mIEVpZmZlbCB0eXBlIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50JywgdXNpbmcgRWlmZmVsIHN0eWxlIGd1aWRlbGluZXNcbiAgICAgIC0tIGFzIHNwZWNpZmllZCBpbiBPT1NDMiAoZS5nLiBDT01QQVJBQkxFLCBIQVNIX1RBQkxFIFtGT08sIEJBUl0sIC4uLilcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQgaW50ZXJuYWxfbmFtZSBhcyBsX25hbWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9uYW1lXG4gICAgICBlbHNlXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAocnVudGltZV9uYW1lKVxuICAgICAgICBpbnRlcm5hbF9uYW1lIDo9IFJlc3VsdFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuYW1lX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGdlbmVyaWNfcGFyYW1ldGVyX3R5cGUgKGk6IElOVEVHRVIpOiBUWVBFIFtkZXRhY2hhYmxlIEFOWV1cbiAgICAgIC0tIGBpJy10aCBnZW5lcmljIHBhcmFtZXRlciBvZiBFaWZmZWwgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCdcbiAgICByZXF1aXJlXG4gICAgICBpX2xhcmdlX2Vub3VnaDogaSA+PSAxXG4gICAgICBpX3NtYWxsX2Vub3VnaDogaSA8PSBnZW5lcmljX3BhcmFtZXRlcl9jb3VudFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGdlbmVyaWNfcGFyYW1ldGVyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHR5cGVfaWQ6IElOVEVHRVJcbiAgICAgIC0tIElkIG9mIHRoZSBFaWZmZWwgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCdcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICB0eXBlX2lkX25vdF9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHlwZV9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgZ2VuZXJpY19wYXJhbWV0ZXJfY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBnZW5lcmljIHBhcmFtZXRlcnMgaW4gRWlmZmVsIHR5cGUgcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZ2VuZXJpY19wYXJhbWV0ZXJfY291bnRfbm90X25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBoYXNfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCB0eXBlIGEgdHlwZSB0aGF0IGhhcyBhIGRlZmF1bHQgdmFsdWU/XG4gICAgICAtLSBJLmUuIGEgZGV0YWNoYWJsZSB0eXBlIG9yIGFuIGV4cGFuZGVkIHR5cGUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlzX2V4cGFuZGVkOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IHR5cGUgYW4gZXhwYW5kZWQgdHlwZT9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaXNfYXR0YWNoZWQ6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgdHlwZSBhdHRhY2hlZD9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3QgY29uc2lkZXJlZFxuICAgICAgLS0gZXF1YWwgdG8gY3VycmVudCBvYmplY3Q/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0eXBlX2lkID0gb3RoZXIudHlwZV9pZFxuICAgIGVuZFxuXG4gIGlzX3N0cmljdGx5X2NvbmZvcm1pbmdfdG8gYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHR5cGUgcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnIGNvbmZvcm0gdG8gdHlwZSByZXByZXNlbnRlZCBieSBgb3RoZXInIGFuZCBkaWZmZXIgZnJvbSBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR5cGVfaWQgLz0gb3RoZXIudHlwZV9pZCBhbmQgdGhlbiBpc19jb25mb3JtaW5nX3RvIChvdGhlcilcbiAgICBlbmRcblxuICBpc19jb25mb3JtaW5nX3RvIGFsaWFzIFwiPD1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCcgY29uZm9ybSB0byB0eXBlIHJlcHJlc2VudGVkIGJ5IGBvdGhlcic/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwibWFnaWNcIlxuICAgICAgLS0gUmVzdWx0IDo9IHtJU0VfUlVOVElNRX0udHlwZV9jb25mb3Jtc190byAodHlwZV9pZCwgb3RoZXIudHlwZV9pZClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYWRhcHQgYWxpYXMgXCJbXVwiIChnOiBkZXRhY2hhYmxlIEcpOiBkZXRhY2hhYmxlIEdcbiAgICAgIC0tIEFkYXB0cyBgZycgb3IgY2FsbHMgbmVjZXNzYXJ5IGNvbnZlcnNpb24gcm91dGluZSB0byBhZGFwdCBgZydcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGdcbiAgICBlbnN1cmVcbiAgICAgIGFkYXB0ZWQ6IFJlc3VsdCB+IGdcbiAgICBlbmRcblxuICBhdHRlbXB0IGFsaWFzIFwiIz9cIiAob2JqOiBkZXRhY2hhYmxlIHNlcGFyYXRlIEFOWSk6IGRldGFjaGFibGUgR1xuICAgICAgLS0gUmVzdWx0IG9mIGFzc2lnbm1lbnQgYXR0ZW1wdCBvZiBgb2JqJyB0byBlbnRpdHkgb2YgdHlwZSBHXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtHfSBvYmogYXMgbF9nIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGxfZ1xuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc3NpZ25lZF9vcl92b2lkOiBSZXN1bHQgPSBvYmogb3IgUmVzdWx0ID0gZGVmYXVsdF9kZXRhY2hhYmxlX3ZhbHVlXG4gICAgZW5kXG5cbiAgZGVmYXVsdF9kZXRhY2hhYmxlX3ZhbHVlOiBkZXRhY2hhYmxlIEdcbiAgICBkb1xuICAgIGVuZFxuXG4gIGRlZmF1bHQ6IEdcbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdDogaGFzX2RlZmF1bHRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAobmFtZSlcbiAgICBlbmRcblxuICBkZWJ1Z19vdXRwdXQ6IFNUUklOR1xuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChuYW1lKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEZlYXR1cmVzIGZyb20gU1RSSU5HIG5lZWRlZCBoZXJlIGZvciB0aGUgdHJhbnNpdGlvbiBwZXJpb2QgKHNlZSBjb252ZXJ0IGNsYXVzZSlcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogU1RSSU5HKTogU1RSSU5HXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mICdzJyBhdCB0aGUgZW5kIG9mIGEgY29weSBvZiB0aGUgbmFtZSBvZiB0aGVcbiAgICAgIC0tIEVpZmZlbCB0eXBlIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50JywgdGhlbiByZXR1cm4gdGhlIFJlc3VsdC5cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBmcm9tIFNUUklORyBpcyBuZWVkZWQgaGVyZSBmb3IgdGhlXG4gICAgICAtLSB0cmFuc2l0aW9uIHBlcmlvZCAoc2VlIGNvbnZlcnQgY2xhdXNlKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDcwODEzXSBVc2UgJ25hbWUgKyBvdGhlcicgaW5zdGVhZCAob3IgJ291dCArIG90aGVyJyBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kKS5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobmFtZS5jb3VudCArIG90aGVyLmNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAobmFtZSlcbiAgICAgIFJlc3VsdC5hcHBlbmQgKG90aGVyKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdC5zYW1lX3N0cmluZyAobmFtZSArIG90aGVyKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogU1RSSU5HKTogQk9PTEVBTlxuICAgICAgLS0gRG8gdGhlIG5hbWUgb2YgdGhlIEVpZmZlbCB0eXBlIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50J1xuICAgICAgLS0gYW5kIGBvdGhlcicgaGF2ZSBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZT9cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBmcm9tIFNUUklORyBpcyBuZWVkZWQgaGVyZSBmb3IgdGhlXG4gICAgICAtLSB0cmFuc2l0aW9uIHBlcmlvZCAoc2VlIGNvbnZlcnQgY2xhdXNlKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDcwODEzXSBVc2UgJ25hbWUuc2FtZV9zdHJpbmcgKG90aGVyKScgaW5zdGVhZCAob3IgJ291dC5zYW1lX3N0cmluZyAob3RoZXIpJyBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kKS5cIlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYW1lLnNhbWVfc3RyaW5nIChvdGhlcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IG5hbWUuc2FtZV9zdHJpbmcgKG90aGVyKVxuICAgIGVuZFxuXG4gIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyOiBTVFJJTkcpOiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGUgbmFtZSBvZiB0aGUgRWlmZmVsIHR5cGUgcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnXG4gICAgICAtLSBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcicgcmVnYXJkbGVzc1xuICAgICAgLS0gb2YgY2FzaW5nIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICAgIC0tIFRoaXMgZmVhdHVyZSBmcm9tIFNUUklORyBpcyBuZWVkZWQgaGVyZSBmb3IgdGhlXG4gICAgICAtLSB0cmFuc2l0aW9uIHBlcmlvZCAoc2VlIGNvbnZlcnQgY2xhdXNlKS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDcwODEzXSBVc2UgJ25hbWUuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIpJyBpbnN0ZWFkIChvciAnb3V0LmlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyKScgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHBlcmlvZCkuXCJcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmFtZS5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcilcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IG5hbWUuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIpXG4gICAgZW5kXG5cbiAgYXNfbG93ZXI6IFNUUklOR1xuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIG9mIHRoZSBuYW1lIG9mIHRoZSBFaWZmZWwgdHlwZVxuICAgICAgLS0gcmVwcmVzZW50ZWQgYnkgYEN1cnJlbnQnIGluIGxvd2VyIGNhc2UuXG4gICAgICAtLSBUaGlzIGZlYXR1cmUgZnJvbSBTVFJJTkcgaXMgbmVlZGVkIGhlcmUgZm9yIHRoZVxuICAgICAgLS0gdHJhbnNpdGlvbiBwZXJpb2QgKHNlZSBjb252ZXJ0IGNsYXVzZSkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiWzA3MDgxM10gVXNlICduYW1lLmFzX2xvd2VyJyBpbnN0ZWFkIChvciAnb3V0LmFzX2xvd2VyJyBkdXJpbmcgdGhlIHRyYW5zaXRpb24gcGVyaW9kKS5cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9zdHJpbmcgKG5hbWUpXG4gICAgICBSZXN1bHQudG9fbG93ZXJcbiAgICBlbnN1cmVcbiAgICAgIGFzX2xvd2VyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0LnNhbWVfc3RyaW5nIChuYW1lLmFzX2xvd2VyKVxuICAgIGVuZFxuXG4gIGFzX3VwcGVyOiBTVFJJTkdcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBvZiB0aGUgbmFtZSBvZiB0aGUgRWlmZmVsIHR5cGVcbiAgICAgIC0tIHJlcHJlc2VudGVkIGJ5IGBDdXJyZW50JyBpbiB1cHBlciBjYXNlLlxuICAgICAgLS0gVGhpcyBmZWF0dXJlIGZyb20gU1RSSU5HIGlzIG5lZWRlZCBoZXJlIGZvciB0aGVcbiAgICAgIC0tIHRyYW5zaXRpb24gcGVyaW9kIChzZWUgY29udmVydCBjbGF1c2UpLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlswNzA4MTNdIFVzZSAnbmFtZS5hc191cHBlcicgaW5zdGVhZCAob3IgJ291dC5hc191cHBlcicgZHVyaW5nIHRoZSB0cmFuc2l0aW9uIHBlcmlvZCkuXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChuYW1lKVxuICAgICAgUmVzdWx0LnRvX3VwcGVyXG4gICAgZW5zdXJlXG4gICAgICBhc191cHBlcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdC5zYW1lX3N0cmluZyAobmFtZS5hc191cHBlcilcbiAgICBlbmRcblxuICB0b19zdHJpbmdfODogU1RSSU5HXzhcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG5hbWUnIGluc3RlYWQgKG9yIGBvdXQnIGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2QpLlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZyAobmFtZSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3N0cmluZ184X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3N0cmluZ18zMjogU1RSSU5HXzMyXG4gICAgICAtLSBOYW1lIG9mIHR5cGVcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJbMDgwNzE3XSBVc2UgJ25hbWUnIGluc3RlYWQgKG9yICdvdXQnIGR1cmluZyB0aGUgdHJhbnNpdGlvbiBwZXJpb2QpLlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChuYW1lKVxuICAgIGVuc3VyZVxuICAgICAgdG9fc3RyaW5nXzMyX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvbjogQWNjZXNzXG5cbiAgaW50ZXJuYWxfbmFtZTogZGV0YWNoYWJsZSBJTU1VVEFCTEVfU1RSSU5HXzhcbiAgICAgIC0tIFN0b3JhZ2UgZm9yIG9uY2UgcGVyIG9iamVjdCBgbmFtZSdcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBydW50aW1lX25hbWU6IFNUUklOR1xuICAgICAgLS0gTmFtZSBvZiBFaWZmZWwgdHlwZSByZXByZXNlbnRlZCBieSBgQ3VycmVudCcsIHVzaW5nIEVpZmZlbCBzdHlsZSBndWlkZWxpbmVzXG4gICAgICAtLSBhcyBzcGVjaWZpZWQgaW4gT09TQzIgKGUuZy4gQ09NUEFSQUJMRSwgSEFTSF9UQUJMRSBbRk9PLCBCQVJdLCAuLi4pXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgbmFtZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbiAgc291cmNlOiBcIltcbiAgICAgIEVpZmZlbCBTb2Z0d2FyZVxuICAgICAgNTk0OSBIb2xsaXN0ZXIgQXZlLiwgR29sZXRhLCBDQSA5MzExNyBVU0FcbiAgICAgIFRlbGVwaG9uZSA4MDUtNjg1LTEwMDYsIEZheCA4MDUtNjg1LTY4NjlcbiAgICAgIFdlYnNpdGUgaHR0cDovL3d3dy5laWZmZWwuY29tXG4gICAgICBDdXN0b21lciBzdXBwb3J0IGh0dHA6Ly9zdXBwb3J0LmVpZmZlbC5jb21cbiAgICBdXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkZpbml0ZSBzdHJ1Y3R1cmVzIHdob3NlIGl0ZW0gY291bnQgaXMgbm90IGJvdW5kZWRcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiB1bmJvdW5kZWQsIHN0b3JhZ2U7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBVTkJPVU5ERUQgW0ddIGluaGVyaXRcblxuICBGSU5JVEUgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIC0tZXh0ZW5kaWJsZTogQk9PTEVBTiBpcyB0cnVlO1xuICAgIC0tIENhbiBuZXcgaXRlbXMgYmUgYWRkZWQ/IChBbnN3ZXI6IHllcylcblxuLS0gaW52YXJpYW50XG5cbiAgLS0gZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiW1xuICAgICAgQ29udmVydGVyIGZyb20vdG8gVVRGLTgsIFVURi0xNiBhbmQgVVRGLTMyIGVuY29kaW5ncy5cblxuICAgICAgSGFuZGxpbmcgb2YgaW52YWxpZCBlbmNvZGluZ3NcbiAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICAgIFdoZW5ldmVyIGEgVVRGLTggb3IgVVRGLTE2IHNlcXVlbmNlIGlzIGRlY29kZWQsIHRoZSBkZWNvZGluZyByb3V0aW5lcyBhbHNvIGNoZWNrXG4gICAgICB0aGF0IHRoZSBzZXF1ZW5jZSBpcyB2YWxpZC4gSWYgaXQgaXMgbm90LCBpdCB3aWxsIHJlcGxhY2UgdGhlIGludmFsaWQgdW5pdCAoZS5nLiBhIGJ5dGVcbiAgICAgIGZvciBVVEYtOCBhbmQgYSAyLWJ5dGUgZm9yIFVURi0xNiBieSB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIFUrRkZGRCBhcyBkZXNjcmliZWQgYnlcbiAgICAgIHZhcmlhbnQgIzMgb2YgdGhlIHJlY29tbWVuZGVkIHByYWN0aWNlIGZvciByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW4gVW5pY29kZSAoc2VlXG4gICAgICBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3Jldmlldy9wci0xMjEuaHRtbCBmb3IgbW9yZSBkZXRhaWxzKS5cblxuICAgICAgSG93ZXZlciBpdCBtZWFucyB0aGF0IHlvdSBjYW5ub3Qgcm91bmR0cmlwIGluY29ycmVjdGx5IGVuY29kZWQgc2VxdWVuY2UgYmFjayBhbmQgZm9ydGhcbiAgICAgIGJldHdlZW4gdGhlIGVuY29kZWQgdmVyc2lvbiBhbmQgdGhlIGRlY29kZWQgU1RSSU5HXzMyIHZlcnNpb24uIFRvIGFsbG93IHJvdW5kdHJpcCwgYW5cbiAgICAgIGVzY2FwZWQgcmVwcmVzZW50YXRpb24gb2YgYSBiYWQgZW5jb2RlZCBzZXF1ZW5jZSBoYXMgYmVlbiBpbnRyb2R1Y2VkLiBJdCBpcyBhZGRpbmcgYVxuICAgICAgYSBmb3VydGggdmFyaWFudCAod2hpY2ggaXMgYSBzbGlnaHQgbW9kaWZpY2F0aW9uIG9mIHZhcmlhbnQgIzMpIHRvIHRoZSByZWNvbW1lbmRlZFxuICAgICAgcHJhY3RpY2Ugd2hlcmUgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBmb2xsb3dlZCBieSB0aGUgcHJpbnRlZCBoZXhhZGVjaW1hbCB2YWx1ZVxuICAgICAgb2YgdGhlIGludmFsaWQgYnl0ZSBvciB0aGUgaW52YWxpZCAyLWJ5dGUgc2VxdWVuY2UuXG5cbiAgICAgIFRvIHByb3ZpZGUgYW4gZXhhbXBsZSAoYXNzdW1pbmcgdGhhdCB0aGUgVW5pY29kZSBjaGFyYWN0ZXIgVStGRkZEIGlzIHJlcHJlc2VudGVkIGFzXG4gICAgICA/IHRleHR1YWxseSk6XG4gICAgICAxIC0gb24gVU5JWCwgYW55IGludmFsaWQgVVRGLTggYnl0ZSBzZXF1ZW5jZSBzdWNoIGFzIDB4OEYgMHg4RiBpcyBlbmNvZGVkIGFzIHRoZVxuICAgICAgZm9sbG93aW5nIFVuaWNvZGUgc2VxdWVuY2U6IFUrRkZGRCBVKzAwMzggVSswMDQ2IFUrRkZGRiBVKzAwMzggVSswMDQ2LCBhbmQgdGV4dHVhbGx5XG4gICAgICBpdCBsb29rcyBsaWtlIFwiPzhGPzhGXCIuXG4gICAgICAyIC0gb24gV2luZG93cywgYW55IGludmFsaWQgVVRGLTE2IDItYnl0ZSBzZXF1ZW5jZSBzdWNoIGFzIDB4RDgwMCAweDAwNTQgaXMgZW5jb2RlZCBhcyB0aGVcbiAgICAgIGZvbGxvd2luZyBVbmljb2RlIHNlcXVlbmNlOiBVK0ZGRkQgVSswMDc1IFUrMDA0NCBVKzAwMzggVSswMDMwIFUrMDAzMCBVK0ZGRkQgVSswMDM1IFUrMDAzMyxcbiAgICAgIGFuZCB0ZXh0dWFsbHkgaXQgbG9va3MgbGlrZSBcIj91RDgwMD81NFwiLiBUaGUgcnVsZSBpcyB0aGF0IGlmIHRoZSAyLWJ5dGUgc2VxdWVuY2UgZG9lcyBub3QgZml0XG4gICAgICBpbnRvIDEgYnl0ZSwgaXQgdXNlcyB0aGUgbGV0dGVyIGB1JyBmb2xsb3dlZCBieSB0aGUgaGV4YWRlY2ltYWwgdmFsdWUgb2YgdGhlIDItYnl0ZSBzZXF1ZW5jZSxcbiAgICAgIG90aGVyd2lzZSBpdCBzaW1wbHkgdXNlcyB0aGUgMS1ieXRlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICAgIF1cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA0LTI5IDE0OjI2OjM4IC0wNzAwIChUdWUsIDI5IEFwciAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NDkyMCAkXCJcblxuZXhwYW5kZWQgY2xhc3NcbiAgVVRGX0NPTlZFUlRFUlxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGVzY2FwZV9jaGFyYWN0ZXI6IENIQVJBQ1RFUl8zMiA9ICclLzB4RkZGRC8nXG4gICAgICAtLSBVbmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlciB0byBlc2NhcGUgaW52YWxpZCBVVEYtOCBvciBVVEYtMTYgZW5jb2RpbmcuXG4gICAgICAtLSBVVEYtOCBlbmNvZGluZzogMHhFRiAweEJGIDB4QkRcbiAgICAgIC0tIEJpbmFyeSBVVEYtOCBlbmNvZGluZzogMTExMDExMTEgMTAxMTExMTEgMTAxMTExMDFcbiAgICAgIC0tIFVURi0xNiBlbmNvZGluZzogMHhGRkZEXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX3ZhbGlkX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBzJyBhIHZhbGlkIFVURi04IFVuaWNvZGUgc2VxdWVuY2U/XG4gICAgbG9jYWxcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gcy5jb3VudFxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMTI3IHRoZW5cbiAgICAgICAgICAgIC0tIEZvcm0gMHh4eHh4eHguXG4gICAgICAgIGVsc2VpZiAoYyAmIDB4RTApID0gMHhDMCBhbmQgaSA8IG5iIHRoZW5cbiAgICAgICAgICAgIC0tIEZvcm0gMTEweHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIFJlc3VsdCA6PSAocy5jb2RlIChpKSAmIDB4QzApID0gMHg4MFxuICAgICAgICBlbHNlaWYgKGMgJiAweEYwKSA9IDB4RTAgYW5kIGkgKyAxIDwgbmIgdGhlblxuICAgICAgICAgIC0tIEZvcm0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIFJlc3VsdCA6PSAocy5jb2RlIChpIC0gMSkgJiAweEMwKSA9IDB4ODAgYW5kXG4gICAgICAgICAgICAocy5jb2RlIChpKSAmIDB4QzApID0gMHg4MFxuICAgICAgICBlbHNlaWYgKGMgJiAweEY4KSA9IDB4RjAgYW5kIGkgKyAyIDwgbmIgdGhlblxuICAgICAgICAgIC0tIEZvcm0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgaSA6PSBpICsgM1xuICAgICAgICAgIFJlc3VsdCA6PSAocy5jb2RlIChpIC0gMikgJiAweEMwKSA9IDB4ODAgYW5kXG4gICAgICAgICAgICAocy5jb2RlIChpIC0gMSkgJiAweEMwKSA9IDB4ODAgYW5kXG4gICAgICAgICAgICAocy5jb2RlIChpKSAmIDB4QzApID0gMHg4MFxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBBbnl0aGluZyBlbHNlIGlzIG5vdCBhIHZhbGlkIFVURi04IHNlcXVlbmNlIHRoYXQgd291bGQgeWllbGQgYSB2YWxpZCBVbmljb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc192YWxpZF91dGZfMTZsZV9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgcycgYSB2YWxpZCBVVEYtMTZMRSBVbmljb2RlIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBjMSwgYzI6IE5BVFVSQUxfMzJcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IHMuY291bnRcbiAgICAgICAgLS0gSWYgYG5iJyBpcyBub3QgZXZlbiwgdGhlbiBjbGVhcmx5IG5vdCBhIHZhbGlkIFVURi0xNiBzdHJpbmcuXG4gICAgICBpZiAobmIgXFxcXCAyKSA9IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID49IG5iIG9yIG5vdCBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDJcbiAgICAgICAgICBjMSA6PSBzLmNvZGUgKGkgLSAxKSB8IChzLmNvZGUgKGkpIHw8PCA4KVxuICAgICAgICAgIGlmIGMxIDwgMHhEODAwIG9yIGMxID49IDB4RTAwMCB0aGVuXG4gICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LCB0aGlzIGlzIHZhbGlkIFVuaWNvZGUuXG4gICAgICAgICAgZWxzZWlmIGMxIDw9IDB4REJGRiB0aGVuXG4gICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICBpZiBpIDw9IG5iIHRoZW5cbiAgICAgICAgICAgICAgYzIgOj0gcy5jb2RlIChpIC0gMSkgfCAocy5jb2RlIChpKSB8PDwgOClcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IDB4REMwMCA8PSBjMiBhbmQgYzIgPD0gMHhERkZcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBTdXJyb2dhdGUgcGFpciBpcyBpbmNvbXBsZXRlLCBjbGVhcmx5IG5vdCBhIHZhbGlkIFVURi0xNiBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgc3RhcnRpbmcgc3Vycm9nYXRlIHBhaXIgd2hpY2ggc2hvdWxkIGJlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc192YWxpZF91dGZfMTZfc3VicG9pbnRlciAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHAnIGEgdmFsaWQgVVRGLTE2IFVuaWNvZGUgc2VxdWVuY2UgYmV0d2VlbiBjb2RlIHVuaXQgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJz9cbiAgICAgIC0tIElmIGBhX3N0b3BfYXRfbnVsbCcgd2Ugc3RvcCBjaGVja2luZyBhZnRlciBmaW5kaW5nIGEgbnVsbCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBpZiBwLmNvdW50ID49IDIgYW5kIHN0YXJ0X3BvcyA+PSAwIGFuZCBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDEgYW5kIGVuZF9wb3MgPCAocC5jb3VudCAvLyAyKSB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHN0YXJ0X3BvcyAqIDJcbiAgICAgICAgICBuIDo9IGVuZF9wb3MgKiAyXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbiBvciBub3QgUmVzdWx0XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjMSA6PSBwLnJlYWRfbmF0dXJhbF8xNiAoaSlcbiAgICAgICAgICBpZiBjMSA9IDAgYW5kIGFfc3RvcF9hdF9udWxsIHRoZW5cbiAgICAgICAgICAgICAgLS0gV2UgaGl0IG91ciBudWxsIHRlcm1pbmF0aW5nIGNoYXJhY3Rlciwgd2UgY2FuIHN0b3BcbiAgICAgICAgICAgIGkgOj0gbiArIDFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBpZiBjMSA8IDB4RDgwMCBvciBjMSA+PSAweEUwMDAgdGhlblxuICAgICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LCB0aGlzIGlzIHZhbGlkIFVuaWNvZGUuXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVsc2VpZiBjMSA8PSAweERCRkYgdGhlblxuICAgICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICAgICAgYzIgOj0gcC5yZWFkX25hdHVyYWxfMTYgKGkpXG4gICAgICAgICAgICAgICAgUmVzdWx0IDo9IDB4REMwMCA8PSBjMiBhbmQgYzIgPD0gMHhERkZcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgLS0gU3Vycm9nYXRlIHBhaXIgaXMgaW5jb21wbGV0ZSwgY2xlYXJseSBub3QgYSB2YWxpZCBVVEYtMTYgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgc3RhcnRpbmcgc3Vycm9nYXRlIHBhaXIgd2hpY2ggc2hvdWxkIGJlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfdXRmXzE2IChzOiBTUEVDSUFMIFtOQVRVUkFMXzE2XSk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBzJyBhIHZhbGlkIFVURi0xNiBVbmljb2RlIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBpLCBuOiBJTlRFR0VSXG4gICAgICBjMSwgYzI6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDBcbiAgICAgICAgbiA6PSBzLmNvdW50XG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIGMxIDo9IHMuaXRlbSAoaSlcbiAgICAgICAgaWYgYzEgPSAwIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhpdCBvdXIgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIsIHdlIGNhbiBzdG9wXG4gICAgICAgICAgaSA6PSBuICsgMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgYzEgPCAweEQ4MDAgb3IgYzEgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQsIHRoaXMgaXMgdmFsaWQgVW5pY29kZS5cbiAgICAgICAgICBlbHNlaWYgYzEgPD0gMHhEQkZGIHRoZW5cbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICAgIGMyIDo9IHMuaXRlbSAoaSlcbiAgICAgICAgICAgICAgUmVzdWx0IDo9IDB4REMwMCA8PSBjMiBhbmQgYzIgPD0gMHhERkZcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBTdXJyb2dhdGUgcGFpciBpcyBpbmNvbXBsZXRlLCBjbGVhcmx5IG5vdCBhIHZhbGlkIFVURi0xNiBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgc3RhcnRpbmcgc3Vycm9nYXRlIHBhaXIgd2hpY2ggc2hvdWxkIGJlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIHV0Zl84X2J5dGVzX2NvdW50IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGJ5dGVzIG5lY2Vzc2FyeSB0byBlbmNvZGUgaW4gVVRGLTggYHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpJy5cbiAgICAgIC0tIE5vdGUgdGhhdCB0aGlzIGZlYXR1cmUgY2FuIGJlIHVzZWQgZm9yIGJvdGggZXNjYXBlZCBhbmQgbm9uLWVzY2FwZWQgc3RyaW5nLlxuICAgICAgLS0gSW4gdGhlIGNhc2Ugb2YgZXNjYXBlZCBzdHJpbmdzLCB0aGUgcmVzdWx0IHdpbGwgYmUgcG9zc2libHkgaGlnaGVyIHRoYW4gcmVhbGx5IG5lZWRlZC5cbiAgICAgIC0tIEl0IGRvZXMgbm90IGluY2x1ZGUgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBzLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X3Bvc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9wb3NcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMHg3RiB0aGVuXG4gICAgICAgICAgICAtLSAweHh4eHh4eC5cbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICBlbHNlaWYgYyA8PSAweDdGRiB0aGVuXG4gICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAyXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAtLSAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAzXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIGMgPD0gMUZGRkZGIC0gdGhlcmUgYXJlIG5vIGhpZ2hlciBjb2RlIHBvaW50c1xuICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgNFxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2X2NoYXJhY3RlcnNfY291bnRfZm9ybV9wb2ludGVyIChtOiBNQU5BR0VEX1BPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRoZSBVVEYtMTYgZW5jb2RlZCBgbScgc3RhcnRpbmcgYXQgYHN0YXJ0X3BvcycgaW4gYG0nIHVwIHRvIGBlbmRfcG9zIC0gMScuXG4gICAgICAtLSBJdCBkb2VzIG5vdCBpbmNsdWRlIHRoZSB0ZXJtaW5hdGluZyBudWxsIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMFxuICAgICAgZW5kX3Bvc2l0aW9uOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDJcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdodDogZW5kX3BvcyA8IG0uY291bnRcbiAgICAgIGV2ZW5fc3RhcnRfcG9zaXRpb246IHN0YXJ0X3BvcyBcXFxcIDIgPSAwXG4gICAgICBldmVuX2VuZF9wb3NpdGlvbjogZW5kX3BvcyBcXFxcIDIgPSAwXG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X3Bvc1xuICAgICAgICBuIDo9IGVuZF9wb3NcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gZW5kX3Bvc1xuICAgICAgbG9vcFxuICAgICAgICBjIDo9IG0ucmVhZF9uYXR1cmFsXzE2IChpKVxuICAgICAgICBpZiBjIDwgMHhEODAwIG9yIGMgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICBlbHNlaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgaSA6PSBpICsgNFxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHV0Zl8xNl9ieXRlc19jb3VudCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBieXRlcyBuZWNlc3NhcnkgYXQgdGhlIHZlcnkgbGVhc3QgdG8gZW5jb2RlIGluIFVURi0xNiBgcy5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcyknLlxuICAgICAgLS0gTm90ZSB0aGF0IHRoaXMgZmVhdHVyZSBjYW4gYmUgdXNlZCBmb3IgYm90aCBlc2NhcGVkIGFuZCBub24tZXNjYXBlZCBzdHJpbmcuXG4gICAgICAtLSBJbiB0aGUgY2FzZSBvZiBlc2NhcGVkIHN0cmluZ3MsIHRoZSByZXN1bHQgd2lsbCBiZSBwb3NzaWJseSBoaWdoZXIgdGhhbiByZWFsbHkgbmVlZGVkLlxuICAgICAgLS0gSXQgZG9lcyBub3QgaW5jbHVkZSB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDw9IHMuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfcG9zXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gZW5kX3Bvc1xuICAgICAgbG9vcFxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweEZGRkYgdGhlblxuICAgICAgICAgICAgLS0gQ29kZSBwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyA0XG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB1dGZfOF90b19zdHJpbmdfMzJfY291bnQgKHM6IFNQRUNJQUwgW0NIQVJBQ1RFUl07IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENvdW50IG9mIGNoYXJhY3RlcnMgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcy5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBuOiBJTlRFR0VSXG4gICAgICBjOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9wb3NcbiAgICAgICAgbiA6PSBlbmRfcG9zXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gblxuICAgICAgbG9vcFxuICAgICAgICBjIDo9IHMgW2ldLmNvZGVcbiAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4REYgdGhlblxuICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RUYgdGhlblxuICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBpIDo9IGkgKyAzXG4gICAgICAgICAgaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RjcgdGhlblxuICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBpIDo9IGkgKyA0XG4gICAgICAgICAgaWYgaSA8PSBuIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBSZXN1bHQgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVVRGLTMyIHRvIFVURi04XG5cbiAgc3RyaW5nXzMyX3RvX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKFJlc3VsdCkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgc3RyaW5nXzMyX2ludG9fdXRmXzhfc3RyaW5nXzggKHM6IFJFQURBQkxFX1NUUklOR18zMjsgYV9yZXN1bHQ6IFNUUklOR184KVxuICAgICAgLS0gQ29weSB0aGUgVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgYXBwZW5kZWQgaW50byBgYV9yZXN1bHQnLlxuICAgIGRvXG4gICAgICB1dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfc3RyaW5nXzggKHMsIGFfcmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IFNUUklOR184XG4gICAgICAtLSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZS5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChzLmNvdW50KVxuICAgICAgdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84X3N0cmluZ184IChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAoUmVzdWx0KS5zYW1lX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIHV0Zl8zMl9zdHJpbmdfaW50b191dGZfOF9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IGFfcmVzdWx0OiBTVFJJTkdfOClcbiAgICAgIC0tIENvcHkgdGhlIFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgbG9jYWxcbiAgICAgIGk6IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyBuKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMHg3RiB0aGVuXG4gICAgICAgICAgICAtLSAweHh4eHh4eFxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoYy50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgZWxzZWlmIGMgPD0gMHg3RkYgdGhlblxuICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyB8Pj4gNikgfCAweEMwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVsc2VpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAtLSAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjIHw+PiAxMikgfCAweEUwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIGMgPD0gMUZGRkZGIC0gdGhlcmUgYXJlIG5vIGhpZ2hlciBjb2RlIHBvaW50c1xuICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyB8Pj4gMTgpIHwgMHhGMCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKChjIHw+PiAxMikgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKCgoYyB8Pj4gNikgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogdXRmXzhfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBlc2NhcGVkX3V0Zl8zMl9zdWJzdHJpbmdfaW50b191dGZfOF8wX3BvaW50ZXIgKFxuICAgICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSOyBwOiBNQU5BR0VEX1BPSU5URVI7XG4gICAgICAgIHBfb2Zmc2V0OiBJTlRFR0VSOyBhX25ld191cHBlcjogZGV0YWNoYWJsZSBDRUxMIFtJTlRFR0VSXVxuICAgIClcbiAgICAgIC0tIFdyaXRlIFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnLCBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSB0aGF0IGNvdWxkXG4gICAgICAtLSBiZSBlc2NhcGVkLCB3aXRoIHRlcm1pbmF0aW5nIHplcm8gdG8gYWRkcmVzcyBgcCArIHBfb2Zmc2V0JyBhbmQgdXBkYXRlIHRoZSBzaXplIG9mIGBwJyB0byB0aGVcbiAgICAgIC0tIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgemVyby10ZXJtaW5hdGVkLlxuICAgICAgLS0gSWYgYHMnIGNvbnRhaW5zIHRoZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWQgYnkgZWl0aGVyIFwiSEhcIiBvciBcInVISEhIXCIgd2hlcmUgSCBzdGFuZHNcbiAgICAgIC0tIGZvciBhbiBoZXhhZGVjaW1hbCBkaWdpdCwgdGhlbiBgcycgaGFzIGJlZW4gZXNjYXBlZCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gd2hhdCBpc1xuICAgICAgLS0gZXhwZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAtLSBPdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGFuZCBpdCB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gICAgICAtLSBTZWUgdGhlIG5vdGUgY2xhdXNlIGZvciB0aGUgY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZW5jb2RpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDw9IHMuY291bnRcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBpLCBuLCBtLCBsX2NvdW50OiBJTlRFR0VSXG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBsX2VuY29kZWRfdmFsdWU6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICBsX2RlY29kZWQsIGxfcmVzaXplZDogQk9PTEVBTlxuICAgIGRvXG4gICAgICAgIC0tIEJhc2ljIGFzc3VtcHRpb25zIHRoYXQgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZS1ieXRlIGNvZGUgdW5pdHMuXG4gICAgICBuIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBsX2NvdW50IDo9IHAuY291bnRcbiAgICAgICAgLS0gQ2hlY2sgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBgbicgYnl0ZXMgYXZhaWxhYmxlIHBsdXMgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLlxuICAgICAgaWYgbF9jb3VudCAtIHBfb2Zmc2V0IDwgKG4gKyAxKSB0aGVuXG4gICAgICAgICAgLS0gT3B0aW1pemUgcmVzaXppbmcsIG9uY2Ugd2UgaGF2ZSB0byByZXNpemUsIHdlIGFjdHVhbGx5IHBlcmZvcm0gdGhlIHJlc2l6aW5nXG4gICAgICAgICAgLS0gb25seSBvbmNlLlxuICAgICAgICBsX2NvdW50IDo9IHBfb2Zmc2V0ICsgdXRmXzhfYnl0ZXNfY291bnQgKHMsIHN0YXJ0X3BvcywgZW5kX3BvcykgKyAxXG4gICAgICAgIHAucmVzaXplIChsX2NvdW50KVxuICAgICAgICBsX3Jlc2l6ZWQgOj0gVHJ1ZVxuICAgICAgZW5kXG5cbiAgICAgIGZyb21cbiAgICAgICAgbSA6PSBwX29mZnNldFxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gZW5kX3Bvc1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGMgOj0gcy5jb2RlIChpKVxuXG4gICAgICAgIGlmIGMgPSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBtaWdodCBiZSBmYWNpbmcgYSBjaGFyYWN0ZXIgdGhhdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICAgIC0tIEluIHRoZSBVbml4IGNhc2UsIHdlIG9ubHkgYWNjZXB0IHRoZSAxLWJ5dGUgZW5jb2RlZCBmb3JtYXQuXG4gICAgICAgICAgaWYgaSA8IG4gYW5kIHRoZW4gcy5pdGVtIChpICsgMSkgPSBlc2NhcGVfY2hhcmFjdGVyIHRoZW5cbiAgICAgICAgICAgICAgLS0gVGhlIGBlc2NhcGVfY2hhcmFjdGVyJyB3YXMgZXNjYXBlZCwgaXQgbWVhbnQgdGhleSByZWFsbHkgd2FudGVkIGFuIGBlc2NhcGVfY2hhcmFjdGVyJy5cbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbHNlaWYgaSArIDEgPCBuIHRoZW5cbiAgICAgICAgICAgICAgLS0gV2UgaGF2ZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgdG8gcmVhZCwgbWFrZSBzdXJlIHRoZXkgcmVwcmVzZW50IGFuIGhleGFkZWNpbWFsXG4gICAgICAgICAgICAgIC0tIHZhbHVlLlxuICAgICAgICAgICAgbF9lbmNvZGVkX3ZhbHVlIDo9IHMuc3Vic3RyaW5nIChpICsgMSwgaSArIDIpXG4gICAgICAgICAgICBpZiBpc19oZXhhX2RlY2ltYWwgKGxfZW5jb2RlZF92YWx1ZSkgdGhlblxuICAgICAgICAgICAgICBjIDo9IHRvX25hdHVyYWxfMzIgKGxfZW5jb2RlZF92YWx1ZSlcbiAgICAgICAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgICAgICAgIC0tIFZhbHVlIHdhcyBlbmNvZGVkIHdoZW4gaXQgc2hvdWxkIG5vdCBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAgIC0tIGRvIG5vdGhpbmcsIHdlIGxlYXZlIHRoZSBvcmlnaW5hbCBjb250ZW50IGFzIGlzLlxuICAgICAgICAgICAgICAgIGMgOj0gZXNjYXBlX2NoYXJhY3Rlci5uYXR1cmFsXzMyX2NvZGVcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGxfZGVjb2RlZCA6PSBUcnVlXG4gICAgICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gTm90IGFuIGhleGFkZWNpbWFsIHZhbHVlLCBpdCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBOb3QgZW5vdWdoIHRvIHJlYWQgdG8gbWFrZSBpdCB2YWxpZCwgaXQgd2FzIG5vdCBlc2NhcGVkLlxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICBpZiBub3QgbF9kZWNvZGVkIHRoZW5cbiAgICAgICAgICBpZiBjIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgICAtLSAweHh4eHh4eFxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84IChjLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICAgIG0gOj0gbSArIDFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIE1ha2Ugc3VyZSB0aGVyZSBpcyBzdWZmaWNpZW50IHJvb20gZm9yIGFsbCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYW5kXG4gICAgICAgICAgICAgIC0tIGF0IGxlYXN0IDUgYnl0ZXMsIGkuZS4gNCBieXRlcyBmb3IgdGhlIG1heGltdW0gVVRGLTggZW5jb2RpbmcsXG4gICAgICAgICAgICAgIC0tIGFuZCBvbmUgYnl0ZSBmb3IgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLiBOb3RlIHRoYXQgd2UgZG8gbm90XG4gICAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgICAgLS0gTm90ZSB0aGF0IGBlbmRfcG9zIC0gaScgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgIC0tIHRvIHByb2Nlc3MgaW4gdGhlIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDUgKyAoZW5kX3BvcyAtIGkpID4gbF9jb3VudCkgdGhlblxuICAgICAgICAgICAgICAgIC0tIE9wdGltaXplIHJlc2l6aW5nLCBvbmNlIHdlIGhhdmUgdG8gcmVzaXplLCB3ZSBhY3R1YWxseSBwZXJmb3JtIHRoZSByZXNpemluZ1xuICAgICAgICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgICAgICAgbF9jb3VudCA6PSBtICsgdXRmXzhfYnl0ZXNfY291bnQgKHMsIGksIGVuZF9wb3MpICsgMVxuICAgICAgICAgICAgICBwLnJlc2l6ZSAobF9jb3VudClcbiAgICAgICAgICAgICAgbF9yZXNpemVkIDo9IFRydWVcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgaWYgYyA8PSAweDdGRiB0aGVuXG4gICAgICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgfD4+IDYpIHwgMHhDMCkudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMSlcbiAgICAgICAgICAgICAgbSA6PSBtICsgMlxuICAgICAgICAgICAgZWxzZWlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgICAtLSAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyB8Pj4gMTIpIHwgMHhFMCkudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMilcbiAgICAgICAgICAgICAgbSA6PSBtICsgM1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIGMgPD0gMUZGRkZGIC0gdGhlcmUgYXJlIG5vIGhpZ2hlciBjb2RlIHBvaW50c1xuICAgICAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKChjIHw+PiAxOCkgfCAweEYwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKCgoYyB8Pj4gMTIpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAyKVxuICAgICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMylcbiAgICAgICAgICAgICAgbSA6PSBtICsgNFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2RlY29kZWQgOj0gRmFsc2VcbiAgICAgICAgICAgIC0tIFNpbXBseSBwdXQgZGVjb2RlZCB2YWx1ZSBkaXJlY3RseSBpbiBzdHJlYW0uXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF84IChjLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBtIDo9IG0gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBpZiBsX3Jlc2l6ZWQgdGhlblxuICAgICAgICAgIC0tIGBwJyB3YXMgcmVzaXplZCBzbyB3ZSBhZGp1c3QgaXQgdG8gYWNjb21tb2RhdGUgdXAgdG8gdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLlxuICAgICAgICBwLnJlc2l6ZSAobSArIDEpXG4gICAgICBlbmRcbiAgICAgIHAucHV0X25hdHVyYWxfOCAoMCwgbSlcbiAgICAgIGlmIGFfbmV3X3VwcGVyIC89IFZvaWQgdGhlblxuICAgICAgICBhX25ld191cHBlci5wdXQgKG0pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYV9uZXdfdXBwZXIgLz0gVm9pZCBpbXBsaWVzIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIGFfbmV3X3VwcGVyLml0ZW0gLSAxLCBGYWxzZSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocy5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykpXG4gICAgICByb3VuZHRyaXA6IChhX25ld191cHBlciA9IFZvaWQgYW5kIHRoZW4gbm90IHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpLmhhcyAoJyVVJykpIGltcGxpZXNcbiAgICAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIHAuY291bnQsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfOF9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UgdGhhdCBjb3VsZCBiZSBlc2NhcGVkLlxuICAgICAgLS0gSWYgYHMnIGNvbnRhaW5zIHRoZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWQgYnkgZWl0aGVyIFwiSEhcIiBvciBcInVISEhIXCIgd2hlcmUgSCBzdGFuZHNcbiAgICAgIC0tIGZvciBhbiBoZXhhZGVjaW1hbCBkaWdpdCwgdGhlbiBgcycgaGFzIGJlZW4gZXNjYXBlZCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gd2hhdCBpc1xuICAgICAgLS0gZXhwZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAtLSBPdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGFuZCBpdCB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gICAgICAtLSBTZWUgdGhlIG5vdGUgY2xhdXNlIGZvciB0aGUgY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZW5jb2RpbmcuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIGVzY2FwZWRfdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84X3N0cmluZ184IChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl84X3N0cmluZ184X3RvX2VzY2FwZWRfc3RyaW5nXzMyIChSZXN1bHQpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgZXNjYXBlZF91dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfc3RyaW5nXzggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBhX3Jlc3VsdDogU1RSSU5HXzgpXG4gICAgICAtLSBDb3B5IHRoZSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSB0aGF0IGNvdWxkXG4gICAgICAtLSBiZSBlc2NhcGVkIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICAgIC0tIElmIGBzJyBjb250YWlucyB0aGUgYGVzY2FwZV9jaGFyYWN0ZXInIGZvbGxvd2VkIGJ5IGVpdGhlciBcIkhIXCIgb3IgXCJ1SEhISFwiIHdoZXJlIEggc3RhbmRzXG4gICAgICAtLSBmb3IgYW4gaGV4YWRlY2ltYWwgZGlnaXQsIHRoZW4gYHMnIGhhcyBiZWVuIGVzY2FwZWQgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIHdoYXQgaXNcbiAgICAgIC0tIGV4cGVjdGVkIGJ5IHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAgLS0gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZCBhbmQgaXQgd2lsbCBiZSBsZWZ0IGFzIGlzLlxuICAgICAgLS0gU2VlIHRoZSBub3RlIGNsYXVzZSBmb3IgdGhlIGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdGhlIGVuY29kaW5nLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBuOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBsX2VuY29kZWRfdmFsdWU6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICBsX2RlY29kZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyBuKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG5cbiAgICAgICAgaWYgYyA9IGVzY2FwZV9jaGFyYWN0ZXIubmF0dXJhbF8zMl9jb2RlIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG1pZ2h0IGJlIGZhY2luZyBhIGNoYXJhY3RlciB0aGF0IHdhcyBlc2NhcGVkLlxuICAgICAgICAgICAgLS0gSW4gdGhlIFVuaXggY2FzZSwgd2Ugb25seSBhY2NlcHQgdGhlIDEtYnl0ZSBlbmNvZGVkIGZvcm1hdC5cbiAgICAgICAgICBpZiBpIDwgbiBhbmQgdGhlbiBzLml0ZW0gKGkgKyAxKSA9IGVzY2FwZV9jaGFyYWN0ZXIgdGhlblxuICAgICAgICAgICAgICAtLSBUaGUgYGVzY2FwZV9jaGFyYWN0ZXInIHdhcyBlc2NhcGVkLCBpdCBtZWFudCB0aGV5IHJlYWxseSB3YW50ZWQgYW4gYGVzY2FwZV9jaGFyYWN0ZXInLlxuICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGVsc2VpZiBpICsgMSA8IG4gdGhlblxuICAgICAgICAgICAgICAtLSBXZSBoYXZlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyB0byByZWFkLCBtYWtlIHN1cmUgdGhleSByZXByZXNlbnQgYW4gaGV4YWRlY2ltYWxcbiAgICAgICAgICAgICAgLS0gdmFsdWUuXG4gICAgICAgICAgICBsX2VuY29kZWRfdmFsdWUgOj0gcy5zdWJzdHJpbmcgKGkgKyAxLCBpICsgMilcbiAgICAgICAgICAgIGlmIGlzX2hleGFfZGVjaW1hbCAobF9lbmNvZGVkX3ZhbHVlKSB0aGVuXG4gICAgICAgICAgICAgIGMgOj0gdG9fbmF0dXJhbF8zMiAobF9lbmNvZGVkX3ZhbHVlKVxuICAgICAgICAgICAgICBpZiBjIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgICAgICAgLS0gVmFsdWUgd2FzIGVuY29kZWQgd2hlbiBpdCBzaG91bGQgbm90IGhhdmUgYmVlblxuICAgICAgICAgICAgICAgICAgLS0gZG8gbm90aGluZywgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIGNvbnRlbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgYyA6PSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbF9kZWNvZGVkIDo9IFRydWVcbiAgICAgICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBOb3QgYW4gaGV4YWRlY2ltYWwgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIE5vdCBlbm91Z2ggdG8gcmVhZCB0byBtYWtlIGl0IHZhbGlkLCBpdCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGlmIG5vdCBsX2RlY29kZWQgdGhlblxuICAgICAgICAgIGlmIGMgPD0gMHg3RiB0aGVuXG4gICAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgZWxzZWlmIGMgPD0gMHg3RkYgdGhlblxuICAgICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgfD4+IDYpIHwgMHhDMCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgZWxzZWlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjIHw+PiAxMikgfCAweEUwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKCgoYyB8Pj4gNikgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gYyA8PSAxRkZGRkYgLSB0aGVyZSBhcmUgbm8gaGlnaGVyIGNvZGUgcG9pbnRzXG4gICAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyB8Pj4gMTgpIHwgMHhGMCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoKGMgfD4+IDEyKSAmIDB4M0YpIHwgMHg4MCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChjICYgMHgzRikgfCAweDgwKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfZGVjb2RlZCA6PSBGYWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHB1dCBkZWNvZGVkIHZhbHVlIGRpcmVjdGx5IGluIHN0cmVhbS5cbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl84X3N0cmluZ184X3RvX2VzY2FwZWRfc3RyaW5nXzMyIChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBzdHJpbmdfMzJfaW50b191dGZfOF8wX3BvaW50ZXIgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgcDogTUFOQUdFRF9QT0lOVEVSOyBwX29mZnNldDogSU5URUdFUjsgYV9uZXdfdXBwZXI6IGRldGFjaGFibGUgQ0VMTCBbSU5URUdFUl0pXG4gICAgICAtLSBXcml0ZSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyB3aXRoIHRlcm1pbmF0aW5nIHplcm9cbiAgICAgIC0tIHRvIGFkZHJlc3MgYHAgKyBwX29mZnNldCcgYW5kIHVwZGF0ZSB0aGUgc2l6ZSBvZiBgcCcgdG8gdGhlIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgemVyby10ZXJtaW5hdGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGRvXG4gICAgICB1dGZfMzJfc3RyaW5nX2ludG9fdXRmXzhfMF9wb2ludGVyIChzLCBwLCBwX29mZnNldCwgYV9uZXdfdXBwZXIpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfOF8wX3N1YnBvaW50ZXJfdG9fZXNjYXBlZF9zdHJpbmdfMzIgKHAsIHBfb2Zmc2V0LCBhX25ld191cHBlci5pdGVtIC0gMSwgRmFsc2UpLnNhbWVfc3RyaW5nIChzKVxuICAgICAgcm91bmR0cmlwOiAoYV9uZXdfdXBwZXIgPSBWb2lkIGFuZCB0aGVuIG5vdCBzLmhhcyAoJyVVJykpIGltcGxpZXNcbiAgICAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIHAuY291bnQsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl84XzBfcG9pbnRlciAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHA6IE1BTkFHRURfUE9JTlRFUjsgcF9vZmZzZXQ6IElOVEVHRVI7IGFfbmV3X3VwcGVyOiBkZXRhY2hhYmxlIENFTEwgW0lOVEVHRVJdKVxuICAgICAgLS0gV3JpdGUgVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycsIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlLFxuICAgICAgLS0gd2l0aCB0ZXJtaW5hdGluZyB6ZXJvIHRvIGFkZHJlc3MgYHAgKyBwX29mZnNldCcgYW5kIHVwZGF0ZSB0aGUgc2l6ZSBvZiBgcCcgdG8gdGhlXG4gICAgICAtLSBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcy5cbiAgICAgIC0tIElmIGBhX25ld191cHBlcicgaXMgcHJvdmlkZWQsIHRoZSB1cHBlciBpbmRleCBvZiBgcCcgY29udGFpbmluZyB0aGUgemVyby10ZXJtaW5hdGlvblxuICAgICAgLS0gaXMgd3JpdHRlbiB0byBgYV9uZXdfdXBwZXInLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBwX29mZnNldF9ub25fbmVnYXRpdmU6IHBfb2Zmc2V0ID49IDBcbiAgICBsb2NhbFxuICAgICAgbTogSU5URUdFUlxuICAgICAgaSwgbiwgbF9jb3VudDogSU5URUdFUlxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgICAgbF9yZXNpemVkOiBCT09MRUFOXG4gICAgZG9cbiAgICAgICAgLS0gQmFzaWMgYXNzdW1wdGlvbnMgdGhhdCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lLWJ5dGUgY29kZSB1bml0cy5cbiAgICAgIG4gOj0gcy5jb3VudFxuICAgICAgbF9jb3VudCA6PSBwLmNvdW50XG4gICAgICAgIC0tIENoZWNrIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3QgYG4nIGJ5dGVzIGF2YWlsYWJsZSBwbHVzIHRoZSB0ZXJtaW5hdGluZyBudWxsIGNoYXJhY3Rlci5cbiAgICAgIGlmIGxfY291bnQgLSBwX29mZnNldCA8IChuICsgMSkgdGhlblxuICAgICAgICAgIC0tIE9wdGltaXplIHJlc2l6aW5nLCBvbmNlIHdlIGhhdmUgdG8gcmVzaXplLCB3ZSBhY3R1YWxseSBwZXJmb3JtIHRoZSByZXNpemluZ1xuICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgbF9jb3VudCA6PSBwX29mZnNldCArIHV0Zl84X2J5dGVzX2NvdW50IChzLCAxLCBuKSArIDFcbiAgICAgICAgcC5yZXNpemUgKGxfY291bnQpXG4gICAgICAgIGxfcmVzaXplZCA6PSBUcnVlXG4gICAgICBlbmRcblxuICAgICAgICAtLSBGaWxsIGBwJyB3aXRoIHRoZSBjb252ZXJ0ZWQgZGF0YS5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAwXG4gICAgICAgIG0gOj0gcF9vZmZzZXRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gblxuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGMgOj0gcy5jb2RlIChpKVxuICAgICAgICBpZiBjIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgLS0gMHh4eHh4eHguXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF84IChjLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBtIDo9IG0gKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIE1ha2Ugc3VyZSB0aGVyZSBpcyBzdWZmaWNpZW50IHJvb20gZm9yIGFsbCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlcnMgYW5kXG4gICAgICAgICAgICAtLSBhdCBsZWFzdCA1IGJ5dGVzLCBpLmUuIDQgYnl0ZXMgZm9yIHRoZSBtYXhpbXVtIFVURi04IGVuY29kaW5nLFxuICAgICAgICAgICAgLS0gYW5kIG9uZSBieXRlIGZvciB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuIE5vdGUgdGhhdCB3ZSBkbyBub3RcbiAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgIC0tIE5vdGUgdGhhdCBgbiAtIGknIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiByZW1haW5pbmcgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLS0gdG8gcHJvY2VzcyBpbiB0aGUgY3VycmVudCBzdHJpbmcuXG4gICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDUgKyAobiAtIGkpID4gbF9jb3VudCkgdGhlblxuICAgICAgICAgICAgICAtLSBPcHRpbWl6ZSByZXNpemluZywgb25jZSB3ZSBoYXZlIHRvIHJlc2l6ZSwgd2UgYWN0dWFsbHkgcGVyZm9ybSB0aGUgcmVzaXppbmdcbiAgICAgICAgICAgICAgLS0gb25seSBvbmNlLlxuICAgICAgICAgICAgbF9jb3VudCA6PSBtICsgdXRmXzhfYnl0ZXNfY291bnQgKHMsIGksIG4pICsgMVxuICAgICAgICAgICAgcC5yZXNpemUgKGxfY291bnQpXG4gICAgICAgICAgICBsX3Jlc2l6ZWQgOj0gVHJ1ZVxuICAgICAgICAgIGVuZFxuXG4gICAgICAgICAgaWYgYyA8PSAweDdGRiB0aGVuXG4gICAgICAgICAgICAgIC0tIDExMHh4eHh4IDEweHh4eHh4LlxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgfD4+IDYpIHwgMHhDMCkudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDEpXG4gICAgICAgICAgICBtIDo9IG0gKyAyXG4gICAgICAgICAgZWxzZWlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKChjIHw+PiAxMikgfCAweEUwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgICAgcC5wdXRfbmF0dXJhbF84ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDIpXG4gICAgICAgICAgICBtIDo9IG0gKyAzXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBjIDw9IDFGRkZGRiAtIHRoZXJlIGFyZSBubyBoaWdoZXIgY29kZSBwb2ludHNcbiAgICAgICAgICAgICAgLS0gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKChjIHw+PiAxOCkgfCAweEYwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoKGMgfD4+IDEyKSAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMSlcbiAgICAgICAgICAgIHAucHV0X25hdHVyYWxfOCAoKCgoYyB8Pj4gNikgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDIpXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzggKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMylcbiAgICAgICAgICAgIG0gOj0gbSArIDRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIGxfcmVzaXplZCB0aGVuXG4gICAgICAgICAgLS0gYHAnIHdhcyByZXNpemVkIHNvIHdlIGFkanVzdCBpdCB0byBhY2NvbW1vZGF0ZSB1cCB0byB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuXG4gICAgICAgIHAucmVzaXplIChtICsgMSlcbiAgICAgIGVuZFxuICAgICAgcC5wdXRfbmF0dXJhbF84ICgwLCBtKVxuICAgICAgaWYgYV9uZXdfdXBwZXIgLz0gVm9pZCB0aGVuXG4gICAgICAgIGFfbmV3X3VwcGVyLnB1dCAobSlcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhX25ld191cHBlciAvPSBWb2lkIGltcGxpZXMgdXRmXzhfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBwX29mZnNldCwgYV9uZXdfdXBwZXIuaXRlbSAtIDEsIEZhbHNlKS5zYW1lX3N0cmluZ19nZW5lcmFsIChzKVxuICAgICAgcm91bmR0cmlwOiAoYV9uZXdfdXBwZXIgPSBWb2lkIGFuZCB0aGVuIG5vdCBzLmhhcyAoJyVVJykpIGltcGxpZXNcbiAgICAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocCwgcF9vZmZzZXQsIHAuY291bnQsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ190b191dGZfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTUEVDSUFMIFtOQVRVUkFMXzhdXG4gICAgICAtLSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJywgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfMCAocylcbiAgICAgIFJlc3VsdCA6PSBSZXN1bHQuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgwLCBSZXN1bHQuY291bnQgLSAxKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzKSBhcyBsX3JlZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgUmVzdWx0IGFzIGxfc3BlYyBhbGwgbF9zcGVjLml0ZW0gPSBsX3JlZi5jb2RlIChsX3NwZWMuY3Vyc29yX2luZGV4KSBlbmRcbiAgICBlbmRcblxuICB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84XzAgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogU1BFQ0lBTCBbTkFUVVJBTF84XVxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycsIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICBsb2NhbFxuICAgICAgbTogSU5URUdFUlxuICAgICAgaSwgbjogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBuIDo9IHMuY291bnRcblxuICAgICAgICAtLSBGaXJzdCBjb21wdXRlIGhvdyBtYW55IGJ5dGVzIHdlIG5lZWQgdG8gY29udmVydCBgcycgdG8gVVRGLTguXG4gICAgICBtIDo9IHV0Zl84X2J5dGVzX2NvdW50IChzLCAxLCBuKVxuXG4gICAgICAgIC0tIEZpbGwgYFJlc3VsdCcgd2l0aCB0aGUgY29udmVydGVkIGRhdGEuXG4gICAgICBmcm9tXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKDAsIG0gKyAxKVxuICAgICAgICBpIDo9IDBcbiAgICAgICAgbSA6PSAwXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4LlxuICAgICAgICAgIFJlc3VsdC5wdXQgKGMudG9fbmF0dXJhbF84LCBtKVxuICAgICAgICAgIG0gOj0gbSArIDFcbiAgICAgICAgZWxzZWlmIGMgPD0gMHg3RkYgdGhlblxuICAgICAgICAgICAgLS0gMTEweHh4eHggMTB4eHh4eHguXG4gICAgICAgICAgUmVzdWx0LnB1dCAoKChjIHw+PiA2KSB8IDB4QzApLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDEpXG4gICAgICAgICAgbSA6PSBtICsgMlxuICAgICAgICBlbHNlaWYgYyA8PSAweEZGRkYgdGhlblxuICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKGMgfD4+IDEyKSB8IDB4RTApLnRvX25hdHVyYWxfOCwgbSlcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKChjIHw+PiA2KSAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMSlcbiAgICAgICAgICBSZXN1bHQucHV0ICgoKGMgJiAweDNGKSB8IDB4ODApLnRvX25hdHVyYWxfOCwgbSArIDIpXG4gICAgICAgICAgbSA6PSBtICsgM1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBjIDw9IDFGRkZGRiAtIHRoZXJlIGFyZSBubyBoaWdoZXIgY29kZSBwb2ludHNcbiAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgUmVzdWx0LnB1dCAoKChjIHw+PiAxOCkgfCAweEYwKS50b19uYXR1cmFsXzgsIG0pXG4gICAgICAgICAgUmVzdWx0LnB1dCAoKCgoYyB8Pj4gMTIpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAxKVxuICAgICAgICAgIFJlc3VsdC5wdXQgKCgoKGMgfD4+IDYpICYgMHgzRikgfCAweDgwKS50b19uYXR1cmFsXzgsIG0gKyAyKVxuICAgICAgICAgIFJlc3VsdC5wdXQgKCgoYyAmIDB4M0YpIHwgMHg4MCkudG9fbmF0dXJhbF84LCBtICsgMylcbiAgICAgICAgICBtIDo9IG0gKyA0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICBSZXN1bHQucHV0ICgwLCBtKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCB1dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChzKSBhcyBsX3JlZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgUmVzdWx0IGFzIGxfc3BlYyBhbGwgbF9zcGVjLml0ZW0gPSBsX3JlZi5jb2RlIChsX3NwZWMuY3Vyc29yX2luZGV4KSBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBVVEYtOCB0byBVVEYtMzJcblxuICB1dGZfOF8wX3BvaW50ZXJfdG9fZXNjYXBlZF9zdHJpbmdfMzIgKHA6IE1BTkFHRURfUE9JTlRFUik6IFNUUklOR18zMlxuICAgICAgLS0ge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHAnIHdoaWNoIGlzIHplcm8tdGVybWluYXRlZCxcbiAgICAgIC0tIHdoZXJlIGludmFsaWQgVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLlxuICAgIGRvXG4gICAgICAgIC0tIEFsbG9jYXRlIFJlc3VsdCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBieXRlcyBhcyBgcCcuXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKHAuY291bnQpXG4gICAgICB1dGZfOF8wX3BvaW50ZXJfaW50b19lc2NhcGVkX3N0cmluZ18zMiAocCwgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkgYXMgbF9zdHIgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIGxfc3RyIGFzIGxfY2hhciBhbGwgbF9jaGFyLml0ZW0gPSBwLnJlYWRfbmF0dXJhbF84IChsX2NoYXIuY3Vyc29yX2luZGV4IC0gMSkudG9fY2hhcmFjdGVyXzggZW5kXG4gICAgZW5kXG5cbiAgdXRmXzhfMF9wb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHA6IE1BTkFHRURfUE9JTlRFUjsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHAnIHdoaWNoIGlzIHplcm8tdGVybWluYXRlZCxcbiAgICAgIC0tIHdoZXJlIGludmFsaWQgVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLCBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgZG9cbiAgICAgIHV0Zl84XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCAwLCBwLmNvdW50IC0gMSwgVHJ1ZSwgYV9yZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfOF9zdHJpbmdfOCAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpIGFzIGxfc3RyIGFuZCB0aGVuXG4gICAgICAgIGFjcm9zcyBsX3N0ciBhcyBsX2NoYXIgYWxsIGxfY2hhci5pdGVtID0gcC5yZWFkX25hdHVyYWxfOCAobF9jaGFyLmN1cnNvcl9pbmRleCAtIDEpLnRvX2NoYXJhY3Rlcl84IGVuZFxuICAgIGVuZFxuXG4gIHV0Zl84XzBfc3VicG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOKTogU1RSSU5HXzMyXG4gICAgICAtLSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcCcgYmV0d2VlbiBpbmRleGVzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIG9yIHRoZSBmaXJzdCBudWxsIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBpZiBgYV9zdG9wX2F0X251bGwnLCB3aGVyZSBpbnZhbGlkXG4gICAgICAtLSBVVEYtOCBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudFxuICAgIGRvXG4gICAgICAgIC0tIEFsbG9jYXRlIFJlc3VsdCB3aXRoIHRoZSBzYW1lIG51bWJlciBvZiBieXRlcyBhcyBgcCcuXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKHAuY291bnQpXG4gICAgICB1dGZfOF8wX3N1YnBvaW50ZXJfaW50b19lc2NhcGVkX3N0cmluZ18zMiAocCwgc3RhcnRfcG9zLCBlbmRfcG9zLCBhX3N0b3BfYXRfbnVsbCwgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkgYXMgbF9zdHIgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIGxfc3RyIGFzIGxfY2hhciBhbGwgbF9jaGFyLml0ZW0gPSBwLnJlYWRfbmF0dXJhbF84IChzdGFydF9wb3MgKyBsX2NoYXIuY3Vyc29yX2luZGV4IC0gMSkudG9fY2hhcmFjdGVyXzggZW5kXG4gICAgZW5kXG5cbiAgdXRmXzhfMF9zdWJwb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHA6IE1BTkFHRURfUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSOyBhX3N0b3BfYXRfbnVsbDogQk9PTEVBTjsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHAnIGJldHdlZW4gaW5kZXhlcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyBvciB0aGUgZmlyc3QgbnVsbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQgaWYgYGFfc3RvcF9hdF9udWxsJywgd2hlcmUgaW52YWxpZFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLCBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfOH0uY291bnRcbiAgICAgIGMxLCBjMiwgYzMsIGM0OiBOQVRVUkFMXzhcbiAgICAgIGxfbGFzdF9jaGFyOiBDSEFSQUNURVJfMzJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBpIDo9IHN0YXJ0X3Bvc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9wb3NcbiAgICAgIGxvb3BcbiAgICAgICAgYzEgOj0gcC5yZWFkX25hdHVyYWxfOCAoaSlcbiAgICAgICAgaWYgYzEgPSAwIGFuZCBhX3N0b3BfYXRfbnVsbCB0aGVuXG4gICAgICAgICAgICAtLSBXZSBoaXQgb3VyIG51bGwgdGVybWluYXRpbmcgY2hhcmFjdGVyLCB3ZSBjYW4gc3RvcFxuICAgICAgICAgIGkgOj0gZW5kX3BvcyArIDFcbiAgICAgICAgZWxzZWlmIGMxIDw9IDB4N0YgdGhlblxuICAgICAgICAgICAgLS0gMHh4eHh4eHhcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMxLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEUwKSA9IDB4QzAgdGhlblxuICAgICAgICAgIGlmIGkgPCBlbmRfcG9zIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHAucmVhZF9uYXR1cmFsXzggKGkgKyAxKVxuICAgICAgICAgICAgaWYgKGMyICYgMHhDMCkgPSAweDgwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBWYWxpZCBVVEYtOCBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgICAoKGMxLmFzX25hdHVyYWxfMzIgJiAweDFGKSB8PDwgNikgfFxuICAgICAgICAgICAgICAgIChjMi5hc19uYXR1cmFsXzMyICYgMHgzRilcbiAgICAgICAgICAgICAgICApLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZVxuICAgICAgICAgICAgICAgIC0tIGFuZCB0cnkgd2l0aCB0aGUgbmV4dCBvbmUgdG8gc2VlIGlmIGl0IGlzIHRoZSBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC0tIGJ5dGUgb2YgYSB2YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxKVxuICAgICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZWlmIChjMSAmIDB4RjApID0gMHhFMCB0aGVuXG4gICAgICAgICAgaWYgaSArIDEgPCBlbmRfcG9zIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHAucmVhZF9uYXR1cmFsXzggKGkgKyAxKVxuICAgICAgICAgICAgYzMgOj0gcC5yZWFkX25hdHVyYWxfOCAoaSArIDIpXG4gICAgICAgICAgICBpZiAoYzIgJiAweEMwKSA9IDB4ODAgYW5kIChjMyAmIDB4QzApID0gMHg4MCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gVmFsaWQgVVRGLTggc2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgLS0gMTExMHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgbF9sYXN0X2NoYXIgOj0gKCgoYzEuYXNfbmF0dXJhbF8zMiAmIDB4RikgfDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgKChjMi5hc19uYXR1cmFsXzMyICYgMHgzRikgfDw8IDYpIHxcbiAgICAgICAgICAgICAgICAoYzMuYXNfbmF0dXJhbF8zMiAmIDB4M0YpXG4gICAgICAgICAgICAgICAgKS50b19jaGFyYWN0ZXJfMzJcbiAgICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChsX2xhc3RfY2hhcilcbiAgICAgICAgICAgICAgaSA6PSBpICsgM1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZVxuICAgICAgICAgICAgICAgIC0tIGFuZCB0cnkgd2l0aCB0aGUgbmV4dCBvbmUgdG8gc2VlIGlmIGl0IGlzIHRoZSBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC0tIGJ5dGUgb2YgYSB2YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxKVxuICAgICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UuXG4gICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEY4KSA9IDB4RjAgdGhlblxuICAgICAgICAgIGlmIGkgKyAyIDwgZW5kX3BvcyB0aGVuXG4gICAgICAgICAgICBjMiA6PSBwLnJlYWRfbmF0dXJhbF84IChpICsgMSlcbiAgICAgICAgICAgIGMzIDo9IHAucmVhZF9uYXR1cmFsXzggKGkgKyAyKVxuICAgICAgICAgICAgYzQgOj0gcC5yZWFkX25hdHVyYWxfOCAoaSArIDMpXG4gICAgICAgICAgICBpZiAoYzIgJiAweEMwKSA9IDB4ODAgYW5kIChjMyAmIDB4QzApID0gMHg4MCBhbmQgKGM0ICYgMHhDMCkgPSAweDgwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBWYWxpZCBVVEYtOCBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAtLSAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgICAoKGMxLmFzX25hdHVyYWxfMzIgJiAweDcpIHw8PCAxOCkgfFxuICAgICAgICAgICAgICAgICgoYzIuYXNfbmF0dXJhbF8zMiAmIDB4M0YpIHw8PCAxMikgfFxuICAgICAgICAgICAgICAgICgoYzMuYXNfbmF0dXJhbF8zMiAmIDB4M0YpIHw8PCA2KSB8XG4gICAgICAgICAgICAgICAgKGM0LmFzX25hdHVyYWxfMzIgJiAweDNGKVxuICAgICAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgICAgICBpIDo9IGkgKyA0XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZSwgd2UgZXNjYXBlIHRoZSBmaXJzdCBieXRlXG4gICAgICAgICAgICAgICAgLS0gYW5kIHRyeSB3aXRoIHRoZSBuZXh0IG9uZSB0byBzZWUgaWYgaXQgaXMgdGhlIHN0YXJ0aW5nXG4gICAgICAgICAgICAgICAgLS0gYnl0ZSBvZiBhIHZhbGlkIFVURi04IHNlcXVlbmNlLlxuICAgICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBDbGVhcmx5IGludmFsaWQgVVRGLThcbiAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3N0ciBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF9zdHIgYXMgbF9jaGFyIGFsbCBsX2NoYXIuaXRlbSA9IHAucmVhZF9uYXR1cmFsXzggKHN0YXJ0X3BvcyArIGxfY2hhci5jdXJzb3JfaW5kZXggLSAxKS50b19jaGFyYWN0ZXJfOCBlbmRcbiAgICBlbmRcblxuICB1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKHM6IFJFQURBQkxFX1NUUklOR184KTogU1RSSU5HXzMyXG4gICAgICAtLSBTVFJJTkdfMzIgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl84X3N0cmluZ184X2ludG9fc3RyaW5nXzMyIChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl84X3N0cmluZ184IChzKSBpbXBsaWVzIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzhfc3RyaW5nXzhfaW50b19zdHJpbmdfMzIgKHM6IFJFQURBQkxFX1NUUklOR184OyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSBTVFJJTkdfMzIgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycgYXBwZW5kZWQgaW50byBgYV9yZXN1bHQnLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfOH0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR184fS5jb3VudFxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG4gOj0gcy5jb3VudFxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4pXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgZWxzZWlmIGMgPD0gMHhERiB0aGVuXG4gICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBpZiBpIDw9IG4gdGhlblxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoXG4gICAgICAgICAgICAgICgoYyAmIDB4MUYpIHw8PCA2KSB8XG4gICAgICAgICAgICAgIChzLmNvZGUgKGkpICYgMHgzRilcbiAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgYyA8PSAweEVGIHRoZW5cbiAgICAgICAgICAgIC0tIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgKChjICYgMHhGKSB8PDwgMTIpIHxcbiAgICAgICAgICAgICAgKChzLmNvZGUgKGkgLSAxKSAmIDB4M0YpIHw8PCA2KSB8XG4gICAgICAgICAgICAgIChzLmNvZGUgKGkpICYgMHgzRilcbiAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbHNlaWYgYyA8PSAweEY3IHRoZW5cbiAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgaSA6PSBpICsgM1xuICAgICAgICAgIGlmIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgKChjICYgMHg3KSB8PDwgMTgpIHxcbiAgICAgICAgICAgICAgKChzLmNvZGUgKGkgLSAyKSAmIDB4M0YpIHw8PCAxMikgfFxuICAgICAgICAgICAgICAoKHMuY29kZSAoaSAtIDEpICYgMHgzRikgfDw8IDYpIHxcbiAgICAgICAgICAgICAgKHMuY29kZSAoaSkgJiAweDNGKVxuICAgICAgICAgICAgKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl84X3N0cmluZ184IChzKSBpbXBsaWVzIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzhfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfOF9zdHJpbmdfOF90b19lc2NhcGVkX3N0cmluZ18zMiAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBTVFJJTkdfMzJcbiAgICAgIC0tIFNUUklOR18zMiBjb3JyZXNwb25kaW5nIHRvIFVURi04IHNlcXVlbmNlIGBzJywgd2hlcmUgaW52YWxpZCBVVEYtOCBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl84X3N0cmluZ184X2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHMsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogZXNjYXBlZF91dGZfMzJfc3RyaW5nX3RvX3V0Zl84X3N0cmluZ184IChSZXN1bHQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHV0Zl84X3N0cmluZ184X2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHM6IFJFQURBQkxFX1NUUklOR184OyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSBTVFJJTkdfMzIgY29ycmVzcG9uZGluZyB0byBVVEYtOCBzZXF1ZW5jZSBgcycsIHdoZXJlIGludmFsaWQgVVRGLTggc2VxdWVuY2VzIGFyZSBlc2NhcGVkLFxuICAgICAgLS0gYXBwZW5kZWQgaW50byBgYV9yZXN1bHQnLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfOH0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR184fS5jb3VudFxuICAgICAgYzEsIGMyLCBjMywgYzQ6IE5BVFVSQUxfOFxuICAgICAgbF9sYXN0X2NoYXI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG4gOj0gcy5jb3VudFxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4pXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjMSA6PSBzLmNvZGUgKGkpLmFzX25hdHVyYWxfOFxuICAgICAgICBpZiBjMSA8PSAweDdGIHRoZW5cbiAgICAgICAgICAgIC0tIDB4eHh4eHh4XG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjMS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEUwKSA9IDB4QzAgdGhlblxuICAgICAgICAgIGlmIGkgPCBuIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHMuY29kZSAoaSArIDEpLmFzX25hdHVyYWxfOFxuICAgICAgICAgICAgaWYgKGMyICYgMHhDMCkgPSAweDgwIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBWYWxpZCBVVEYtOCBzZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICAtLSAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChcbiAgICAgICAgICAgICAgICAoKGMxLmFzX25hdHVyYWxfMzIgJiAweDFGKSB8PDwgNikgfFxuICAgICAgICAgICAgICAgIChjMi5hc19uYXR1cmFsXzMyICYgMHgzRilcbiAgICAgICAgICAgICAgICApLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIEludmFsaWQgVVRGLTggc2VxdWVuY2UsIHdlIGVzY2FwZSB0aGUgZmlyc3QgYnl0ZVxuICAgICAgICAgICAgICAgIC0tIGFuZCB0cnkgd2l0aCB0aGUgbmV4dCBvbmUgdG8gc2VlIGlmIGl0IGlzIHRoZSBzdGFydGluZ1xuICAgICAgICAgICAgICAgIC0tIGJ5dGUgb2YgYSB2YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBJbnZhbGlkIFVURi04IHNlcXVlbmNlLCB3ZSBlc2NhcGUgdGhlIGZpcnN0IGJ5dGUuXG4gICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiAoYzEgJiAweEYwKSA9IDB4RTAgdGhlblxuICAgICAgICAgIGlmIGkgKyAxIDwgbiB0aGVuXG4gICAgICAgICAgICBjMiA6PSBzLmNvZGUgKGkgKyAxKS5hc19uYXR1cmFsXzhcbiAgICAgICAgICAgIGMzIDo9IHMuY29kZSAoaSArIDIpLmFzX25hdHVyYWxfOFxuICAgICAgICAgICAgaWYgKGMyICYgMHhDMCkgPSAweDgwIGFuZCAoYzMgJiAweEMwKSA9IDB4ODAgdGhlblxuICAgICAgICAgICAgICAgIC0tIFZhbGlkIFVURi04IHNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIC0tIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgIGxfbGFzdF9jaGFyIDo9ICgoKGMxLmFzX25hdHVyYWxfMzIgJiAweEYpIHw8PCAxMikgfFxuICAgICAgICAgICAgICAgICgoYzIuYXNfbmF0dXJhbF8zMiAmIDB4M0YpIHw8PCA2KSB8XG4gICAgICAgICAgICAgICAgKGMzLmFzX25hdHVyYWxfMzIgJiAweDNGKVxuICAgICAgICAgICAgICAgICkudG9fY2hhcmFjdGVyXzMyXG4gICAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAobF9sYXN0X2NoYXIpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDJcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBJbnZhbGlkIFVURi04IHNlcXVlbmNlLCB3ZSBlc2NhcGUgdGhlIGZpcnN0IGJ5dGVcbiAgICAgICAgICAgICAgICAtLSBhbmQgdHJ5IHdpdGggdGhlIG5leHQgb25lIHRvIHNlZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmdcbiAgICAgICAgICAgICAgICAtLSBieXRlIG9mIGEgdmFsaWQgVVRGLTggc2VxdWVuY2UuXG4gICAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZWlmIChjMSAmIDB4RjgpID0gMHhGMCB0aGVuXG4gICAgICAgICAgaWYgaSArIDIgPCBuIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHMuY29kZSAoaSArIDEpLmFzX25hdHVyYWxfOFxuICAgICAgICAgICAgYzMgOj0gcy5jb2RlIChpICsgMikuYXNfbmF0dXJhbF84XG4gICAgICAgICAgICBjNCA6PSBzLmNvZGUgKGkgKyAzKS5hc19uYXR1cmFsXzhcbiAgICAgICAgICAgIGlmIChjMiAmIDB4QzApID0gMHg4MCBhbmQgKGMzICYgMHhDMCkgPSAweDgwIGFuZCAoYzQgJiAweEMwKSA9IDB4ODAgdGhlblxuICAgICAgICAgICAgICAgIC0tIFZhbGlkIFVURi04IHNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIC0tIDExMTEweHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKFxuICAgICAgICAgICAgICAgICgoYzEuYXNfbmF0dXJhbF8zMiAmIDB4NykgfDw8IDE4KSB8XG4gICAgICAgICAgICAgICAgKChjMi5hc19uYXR1cmFsXzMyICYgMHgzRikgfDw8IDEyKSB8XG4gICAgICAgICAgICAgICAgKChjMy5hc19uYXR1cmFsXzMyICYgMHgzRikgfDw8IDYpIHxcbiAgICAgICAgICAgICAgICAoYzQuYXNfbmF0dXJhbF8zMiAmIDB4M0YpXG4gICAgICAgICAgICAgICAgKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgICAgIGkgOj0gaSArIDNcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAtLSBJbnZhbGlkIFVURi04IHNlcXVlbmNlLCB3ZSBlc2NhcGUgdGhlIGZpcnN0IGJ5dGVcbiAgICAgICAgICAgICAgICAtLSBhbmQgdHJ5IHdpdGggdGhlIG5leHQgb25lIHRvIHNlZSBpZiBpdCBpcyB0aGUgc3RhcnRpbmdcbiAgICAgICAgICAgICAgICAtLSBieXRlIG9mIGEgdmFsaWQgVVRGLTggc2VxdWVuY2UuXG4gICAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gSW52YWxpZCBVVEYtOCBzZXF1ZW5jZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMSlcbiAgICAgICAgICBlbmRcblxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBDbGVhcmx5IGludmFsaWQgVVRGLThcbiAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfOF9zdHJpbmdfOCAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFVURi0zMiB0byBVVEYtMTZcblxuICBzdHJpbmdfMzJfdG9fdXRmXzE2IChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIG5vdCB6ZXJvLXRlcm1pbmF0ZWQuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1dGZfMzJfc3RyaW5nX3RvX3V0Zl8xNiAocylcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYXR0YWNoZWQgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAocykgYXMgbF9yZWYgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIFJlc3VsdCBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCAxNikpIGVuZFxuICAgIGVuZFxuXG4gIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IFNQRUNJQUwgW05BVFVSQUxfMTZdXG4gICAgICAtLSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2XzAgKHMpXG4gICAgICBSZXN1bHQgOj0gUmVzdWx0LmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYXR0YWNoZWQgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAocykgYXMgbF9yZWYgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIFJlc3VsdCBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCA4KSkgZW5kXG4gICAgZW5kXG5cbiAgc3RyaW5nXzMyX3RvX3V0Zl8xNl8wIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnIHdpdGggdGVybWluYXRpbmcgemVyby5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2XzAgKHMpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKHMpIGFzIGxfcmVmIGFuZCB0aGVuXG4gICAgICAgIGFjcm9zcyBSZXN1bHQucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50IC0gMSkgYXMgbF9zcGVjIGFsbFxuICAgICAgICAgIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCA4KSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ190b191dGZfMTZfMCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnLCBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSxcbiAgICAgIC0tIHdpdGggdGVybWluYXRpbmcgemVyby5cbiAgICBsb2NhbFxuICAgICAgaTogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgbjogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgbTogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgcDogbGlrZSB7U1RSSU5HXzMyfS5jb3VudFxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG0gOj0gMFxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgcCA6PSBuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAocCArIDEpXG4gICAgICBpbnZhcmlhbnRcbiAgICAgICAgbSA9IFJlc3VsdC5jb3VudFxuICAgICAgICBwICsgMSA9IFJlc3VsdC5jYXBhY2l0eVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAtLSBNYWtlIHN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCByb29tIGZvciBhdCBsZWFzdCAyIGNvZGUgdW5pdHMuXG4gICAgICAgIGlmIHAgPCBtICsgMiB0aGVuXG4gICAgICAgICAgcCA6PSBtICsgKG4gLSBpKSArIDJcbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0LmFsaWFzZWRfcmVzaXplZF9hcmVhIChwICsgMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGMgOj0gcy5jb2RlIChpKVxuICAgICAgICBpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LlxuICAgICAgICAgIFJlc3VsdC5leHRlbmQgKGMudG9fbmF0dXJhbF8xNilcbiAgICAgICAgICBtIDo9IG0gKyAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgUmVzdWx0LmV4dGVuZCAoKDB4RDdDMCArIChjIHw+PiAxMCkpLnRvX25hdHVyYWxfMTYpXG4gICAgICAgICAgUmVzdWx0LmV4dGVuZCAoKDB4REMwMCArIChjICYgMHgzRkYpKS50b19uYXR1cmFsXzE2KVxuICAgICAgICAgIG0gOj0gbSArIDJcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdC5leHRlbmQgKDApXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIHV0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKHMpIGFzIGxfcmVmIGFuZCB0aGVuXG4gICAgICAgIGFjcm9zcyBSZXN1bHQucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50IC0gMSkgYXMgbF9zcGVjIGFsbFxuICAgICAgICAgIGxfc3BlYy5pdGVtID0gKGxfcmVmLmNvZGUgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyIC0gMSkgfCAobF9yZWYuY29kZSAobF9zcGVjLmN1cnNvcl9pbmRleCAqIDIpIHw8PCA4KSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc3RyaW5nXzMyX2ludG9fdXRmXzE2X3BvaW50ZXIgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgcDogTUFOQUdFRF9QT0lOVEVSOyBwX29mZnNldDogSU5URUdFUjsgYV9uZXdfdXBwZXI6IGRldGFjaGFibGUgQ0VMTCBbSU5URUdFUl0pXG4gICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgdG8gYWRkcmVzcyBgcCArIHBfb2Zmc2V0J1xuICAgICAgLS0gYW5kIHVwZGF0ZSB0aGUgc2l6ZSBvZiBgcCcgdG8gdGhlIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBldmVuX3Bfb2Zmc2V0OiAocF9vZmZzZXQgXFxcXCAyKSA9IDBcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGRvXG4gICAgICB1dGZfMzJfc3Vic3RyaW5nX2ludG9fdXRmXzE2X3BvaW50ZXIgKHMsIDEsIHMuY291bnQsIHAsIHBfb2Zmc2V0LCBhX25ld191cHBlcilcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogYV9uZXdfdXBwZXIgLz0gVm9pZCBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAoYV9uZXdfdXBwZXIuaXRlbSAvLyAyKSAtIDEsIEZhbHNlKS5zYW1lX3N0cmluZyAocylcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5oYXMgKCclVScpKSBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHN0cmluZ18zMl9pbnRvX3V0Zl8xNl8wX3BvaW50ZXIgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgcDogTUFOQUdFRF9QT0lOVEVSOyBwX29mZnNldDogSU5URUdFUjsgYV9uZXdfdXBwZXI6IGRldGFjaGFibGUgQ0VMTCBbSU5URUdFUl0pXG4gICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgd2l0aCB0ZXJtaW5hdGluZyB6ZXJvXG4gICAgICAtLSB0byBhZGRyZXNzIGBwICsgcF9vZmZzZXQnIGFuZCB1cGRhdGUgdGhlIHNpemUgb2YgYHAnIHRvIHRoZSBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcy5cbiAgICAgIC0tIElmIGBhX25ld191cHBlcicgaXMgcHJvdmlkZWQsIHRoZSB1cHBlciBpbmRleCBvZiBgcCcgY29udGFpbmluZyB0aGUgemVyby10ZXJtaW5hdGlvblxuICAgICAgLS0gaXMgd3JpdHRlbiB0byBgYV9uZXdfdXBwZXInLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBldmVuX3Bfb2Zmc2V0OiAocF9vZmZzZXQgXFxcXCAyKSA9IDBcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGRvXG4gICAgICB1dGZfMzJfc3Vic3RyaW5nX2ludG9fdXRmXzE2XzBfcG9pbnRlciAocywgMSwgcy5jb3VudCwgcCwgcF9vZmZzZXQsIGFfbmV3X3VwcGVyKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhX25ld191cHBlciAvPSBWb2lkIGltcGxpZXMgdXRmXzE2XzBfc3VicG9pbnRlcl90b19zdHJpbmdfMzIgKHAsIHBfb2Zmc2V0IC8vIDIsIChhX25ld191cHBlci5pdGVtIC8vIDIpIC0gMSwgRmFsc2UpLnNhbWVfc3RyaW5nIChzKVxuICAgICAgcm91bmR0cmlwOiAoYV9uZXdfdXBwZXIgPSBWb2lkIGFuZCB0aGVuIG5vdCBzLmhhcyAoJyVVJykpIGltcGxpZXMgdXRmXzE2XzBfc3VicG9pbnRlcl90b19zdHJpbmdfMzIgKHAsIHBfb2Zmc2V0IC8vIDIsIChwLmNvdW50IC8vIDIpIC0gMSwgVHJ1ZSkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N1YnN0cmluZ19pbnRvX3V0Zl8xNl9wb2ludGVyXG4gICAgICAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7XG4gICAgICBzdGFydF9wb3MsIGVuZF9wb3M6IGxpa2Uge1JFQURBQkxFX1NUUklOR18zMn0uY291bnQ7XG4gICAgICBwOiBNQU5BR0VEX1BPSU5URVI7IHBfb2Zmc2V0OiBJTlRFR0VSOyBhX25ld191cHBlcjogZGV0YWNoYWJsZSBDRUxMIFtJTlRFR0VSXSlcbiAgICAgIC0tIFdyaXRlIFVURi0xNiBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdWJzdHJpbmcgb2YgYHMnLFxuICAgICAgLS0gaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UsIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydF9wb3MnXG4gICAgICAtLSBhbmQgZW5kaW5nIGF0IGluZGV4IGBlbmRfcG9zJyB0byBhZGRyZXNzIGBwICsgcF9vZmZzZXQnIGFuZCB1cGRhdGUgdGhlXG4gICAgICAtLSBzaXplIG9mIGBwJyB0byB0aGUgbnVtYmVyIG9mIHdyaXR0ZW4gYnl0ZXMuXG4gICAgICAtLSBJZiBgYV9uZXdfdXBwZXInIGlzIHByb3ZpZGVkLCB0aGUgdXBwZXIgaW5kZXggb2YgYHAnIGNvbnRhaW5pbmcgdGhlIHplcm8tdGVybWluYXRpb25cbiAgICAgIC0tIGlzIHdyaXR0ZW4gdG8gYGFfbmV3X3VwcGVyJy5cbiAgICAgIC0tIFRoZSBzZXF1ZW5jZSBpcyBub3QgemVyby10ZXJtaW5hdGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBzLmNvdW50XG4gICAgICBldmVuX3Bfb2Zmc2V0OiAocF9vZmZzZXQgXFxcXCAyKSA9IDBcbiAgICAgIHBfb2Zmc2V0X25vbl9uZWdhdGl2ZTogcF9vZmZzZXQgPj0gMFxuICAgIGxvY2FsXG4gICAgICBtOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG0gOj0gcC5jb3VudFxuICAgICAgdXRmXzMyX3N1YnN0cmluZ19pbnRvX3V0Zl8xNl8wX3BvaW50ZXIgKHMsIHN0YXJ0X3BvcywgZW5kX3BvcywgcCwgcF9vZmZzZXQsIGFfbmV3X3VwcGVyKVxuICAgICAgaWYgbSA8IHAuY291bnQgdGhlblxuICAgICAgICAgIC0tIFJlbW92ZSB0aGUgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIuXG4gICAgICAgIHAucmVzaXplIChwLmNvdW50IC0gMilcbiAgICAgICAgaWYgYV9uZXdfdXBwZXIgLz0gVm9pZCB0aGVuXG4gICAgICAgICAgYV9uZXdfdXBwZXIucHV0IChwLmNvdW50IC0gMilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHBfY291bnRfbWF5X2luY3JlYXNlOiBwLmNvdW50ID49IG9sZCBwLmNvdW50XG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX3N0cmluZ18zMiAocCwgcF9vZmZzZXQgLy8gMiwgKGFfbmV3X3VwcGVyLml0ZW0gLy8gMikgLSAxLCBGYWxzZSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5oYXMgKCclVScpKSBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N1YnN0cmluZ19pbnRvX3V0Zl8xNl8wX3BvaW50ZXJcbiAgICAgIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDtcbiAgICAgIHN0YXJ0X3BvcywgZW5kX3BvczogbGlrZSB7UkVBREFCTEVfU1RSSU5HXzMyfS5jb3VudDtcbiAgICAgIHA6IE1BTkFHRURfUE9JTlRFUjsgcF9vZmZzZXQ6IElOVEVHRVI7IGFfbmV3X3VwcGVyOiBkZXRhY2hhYmxlIENFTEwgW0lOVEVHRVJdKVxuICAgICAgLS0gV3JpdGUgVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHN1YnN0cmluZyBvZiBgcycsXG4gICAgICAtLSBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSwgc3RhcnRpbmcgYXQgaW5kZXggYHN0YXJ0X3BvcydcbiAgICAgIC0tIGFuZCBlbmRpbmcgYXQgaW5kZXggYGVuZF9wb3MnIHRvIGFkZHJlc3MgYHAgKyBwX29mZnNldCcgYW5kIHVwZGF0ZSB0aGVcbiAgICAgIC0tIHNpemUgb2YgYHAnIHRvIHRoZSBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcy5cbiAgICAgIC0tIElmIGBhX25ld191cHBlcicgaXMgcHJvdmlkZWQsIHRoZSB1cHBlciBpbmRleCBvZiBgcCcgY29udGFpbmluZyB0aGUgemVyby10ZXJtaW5hdGlvblxuICAgICAgLS0gaXMgd3JpdHRlbiB0byBgYV9uZXdfdXBwZXInLlxuICAgICAgLS0gVGhlIHNlcXVlbmNlIGlzIHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gcy5jb3VudFxuICAgICAgZXZlbl9wX29mZnNldDogKHBfb2Zmc2V0IFxcXFwgMikgPSAwXG4gICAgICBwX29mZnNldF9ub25fbmVnYXRpdmU6IHBfb2Zmc2V0ID49IDBcbiAgICBsb2NhbFxuICAgICAgaTogbGlrZSB7UkVBREFCTEVfU1RSSU5HX0dFTkVSQUx9LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBtLCBsX2NvdW50OiBsaWtlIHtNQU5BR0VEX1BPSU5URVJ9LmNvdW50XG4gICAgICBsX3Jlc2l6ZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UuXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgICAgbF9jb3VudCA6PSBwLmNvdW50XG4gICAgICAgICAgLS0gQ2hlY2sgdGhhdCB0aGVyZSBpcyBhdCBsZWFzdCBgaSAqIDInIGJ5dGVzIGF2YWlsYWJsZSBwbHVzIHRoZSB0ZXJtaW5hdGluZyBudWxsIGNoYXJhY3Rlci5cbiAgICAgICAgaWYgbF9jb3VudCAtIHBfb2Zmc2V0IDwgKGkgKyAxKSAqIDIgIHRoZW5cbiAgICAgICAgICAgIC0tIE9wdGltaXplIHJlc2l6aW5nLCBvbmNlIHdlIGhhdmUgdG8gcmVzaXplLCB3ZSBhY3R1YWxseSBwZXJmb3JtIHRoZSByZXNpemluZ1xuICAgICAgICAgICAgLS0gb25seSBvbmNlLlxuICAgICAgICAgIGxfY291bnQgOj0gcF9vZmZzZXQgKyB1dGZfMTZfYnl0ZXNfY291bnQgKHMsIHN0YXJ0X3BvcywgZW5kX3BvcykgKyAyXG4gICAgICAgICAgcC5yZXNpemUgKGxfY291bnQpXG4gICAgICAgICAgbF9yZXNpemVkIDo9IFRydWVcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gc3RhcnRfcG9zIC0gMVxuICAgICAgICBtIDo9IHBfb2Zmc2V0XG4gICAgICB1bnRpbFxuICAgICAgICBpID49IGVuZF9wb3NcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBjIDo9IHMuY29kZSAoaSlcbiAgICAgICAgaWYgYyA8PSAweEZGRkYgdGhlblxuICAgICAgICAgICAgLS0gQ29kZXBvaW50IGZyb20gQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lOiBvbmUgMTYtYml0IGNvZGUgdW5pdC5cbiAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2IChjLnRvX25hdHVyYWxfMTYsIG0pXG4gICAgICAgICAgbSA6PSBtICsgMlxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBNYWtlIHN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCByb29tIGZvciBhbGwgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFuZFxuICAgICAgICAgICAgLS0gYXQgbGVhc3QgMyBjb2RlIHVuaXRzIG9mIDIgYnl0ZXMgZWFjaCwgaS5lLiAyIGNvZGUgdW5pdCBmb3IgdGhlIHN1cnJvZ2F0ZVxuICAgICAgICAgICAgLS0gcGFpciwgYW5kIG9uZSB1bml0IGZvciB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuIE5vdGUgdGhhdCB3ZSBkbyBub3RcbiAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgIC0tIE5vdGUgdGhhdCBgZW5kX3BvcyAtIGknIHJlcHJlc2VudHMgdGhlIG51bWJlciBvZiByZW1haW5pbmcgY2hhcmFjdGVyc1xuICAgICAgICAgICAgLS0gdG8gcHJvY2VzcyBpbiB0aGUgY3VycmVudCBzdHJpbmcuXG4gICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDYgKyAoZW5kX3BvcyAtIGkpICogMiA+IGxfY291bnQpIHRoZW5cbiAgICAgICAgICAgICAgLS0gT3B0aW1pemUgcmVzaXppbmcsIG9uY2Ugd2UgaGF2ZSB0byByZXNpemUsIHdlIGFjdHVhbGx5IHBlcmZvcm0gdGhlIHJlc2l6aW5nXG4gICAgICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgICAgIGxfY291bnQgOj0gbSArIHV0Zl8xNl9ieXRlc19jb3VudCAocywgaSwgZW5kX3BvcykgKyAyXG4gICAgICAgICAgICBwLnJlc2l6ZSAobF9jb3VudClcbiAgICAgICAgICAgIGxfcmVzaXplZCA6PSBUcnVlXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoKDB4RDdDMCArIChjIHw+PiAxMCkpLnRvX25hdHVyYWxfMTYsIG0pXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoKDB4REMwMCArIChjICYgMHgzRkYpKS50b19uYXR1cmFsXzE2LCBtICsgMilcbiAgICAgICAgICBtIDo9IG0gKyA0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgICAgIC0tIEFkanVzdCBudW1iZXIgb2Ygd3JpdHRlbiBieXRlcyBhbmQgYWRkIHRlcm1pbmF0aW5nIHplcm8gYXQgdGhlIGVuZC5cbiAgICAgIGlmIGxfcmVzaXplZCB0aGVuXG4gICAgICAgICAgLS0gV2UgaGFkIHRvIGFkZCBhIGNvZGUgdW5pdCBvbiA0IGJ5dGVzLiBXZSBhZGp1c3QgdGhlIHNpemUuXG4gICAgICAgIHAucmVzaXplIChtICsgMilcbiAgICAgIGVuZFxuICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoMCwgbSlcbiAgICAgIGlmIGFfbmV3X3VwcGVyIC89IFZvaWQgdGhlblxuICAgICAgICBhX25ld191cHBlci5wdXQgKG0pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHBfY291bnRfbWF5X2luY3JlYXNlOiBwLmNvdW50ID49IG9sZCBwLmNvdW50XG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX3N0cmluZ18zMiAocCwgcF9vZmZzZXQgLy8gMiwgKGFfbmV3X3VwcGVyLml0ZW0gLy8gMikgLSAxLCBGYWxzZSkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5oYXMgKCclVScpKSBpbXBsaWVzIHV0Zl8xNl8wX3N1YnBvaW50ZXJfdG9fc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTE2TEUgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2VcbiAgICBkb1xuICAgICAgICAtLSBXZSB3b3VsZCBuZWVkIGF0IGxlYXN0IDItYnl0ZXMgcGVyIGNoYXJhY3RlcnMgaW4gYHMnLlxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChzLmNvdW50ICogMilcbiAgICAgIHV0Zl8zMl9zdHJpbmdfaW50b191dGZfMTZsZV9zdHJpbmdfOCAocywgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfMTZsZV9zdHJpbmdfOF90b19zdHJpbmdfMzIgKFJlc3VsdCkuc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICB1dGZfMzJfc3RyaW5nX2ludG9fdXRmXzE2bGVfc3RyaW5nXzggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBhX3Jlc3VsdDogU1RSSU5HXzgpXG4gICAgICAtLSBDb3B5IFVURi0xNkxFIHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gYHMnIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgbG9jYWxcbiAgICAgIGk6IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIG46IGxpa2Uge1NUUklOR18zMn0uY291bnRcbiAgICAgIGM6IE5BVFVSQUxfMzJcbiAgICAgIGxfbmF0MTY6IE5BVFVSQUxfMTZcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBXZSB3b3VsZCBuZWVkIGF0IGxlYXN0IDItYnl0ZXMgcGVyIGNoYXJhY3RlcnMgaW4gYHMnLlxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4gKiAyKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoYyAmIDB4MDBGRikudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgJiAweEZGMDApIHw+PiA4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gV3JpdGUgdGhlIGxlYWQgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgbF9uYXQxNiA6PSAoMHhEN0MwICsgKGMgfD4+IDEwKSkudG9fbmF0dXJhbF8xNlxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGxfbmF0MTYgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChsX25hdDE2ICYgMHhGRjAwKSB8Pj4gOCkudG9fY2hhcmFjdGVyXzgpXG5cbiAgICAgICAgICAgIC0tIFdyaXRlIHRoZSB0cmFpbCBzdXJyb2dhdGUgcGFpci5cbiAgICAgICAgICBsX25hdDE2IDo9ICgweERDMDAgKyAoYyAmIDB4M0ZGKSkudG9fbmF0dXJhbF8xNlxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGxfbmF0MTYgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKChsX25hdDE2ICYgMHhGRjAwKSB8Pj4gOCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IHV0Zl8xNmxlX3N0cmluZ184X3RvX3N0cmluZ18zMiAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgZXNjYXBlZF91dGZfMzJfc3Vic3RyaW5nX2ludG9fdXRmXzE2XzBfcG9pbnRlciAoXG4gICAgICAgIHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IGxpa2Uge1JFQURBQkxFX1NUUklOR18zMn0uY291bnQ7XG4gICAgICAgIHA6IE1BTkFHRURfUE9JTlRFUjsgcF9vZmZzZXQ6IElOVEVHRVI7IGFfbmV3X3VwcGVyOiBkZXRhY2hhYmxlIENFTEwgW0lOVEVHRVJdXG4gICAgICApXG4gICAgICAtLSBXcml0ZSBVVEYtMTYgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byB0aGUgc3Vic3RyaW5nIG9mIGBzJyxcbiAgICAgIC0tIGludGVycHJldGVkIGFzIGEgVVRGLTMyIHNlcXVlbmNlLCBzdGFydGluZyBhdCBpbmRleCBgc3RhcnRfcG9zJ1xuICAgICAgLS0gYW5kIGVuZGluZyBhdCBpbmRleCBgZW5kX3BvcycgdG8gYWRkcmVzcyBgcCArIHBfb2Zmc2V0JyBhbmQgdXBkYXRlIHRoZVxuICAgICAgLS0gc2l6ZSBvZiBgcCcgdG8gdGhlIG51bWJlciBvZiB3cml0dGVuIGJ5dGVzLlxuICAgICAgLS0gSWYgYGFfbmV3X3VwcGVyJyBpcyBwcm92aWRlZCwgdGhlIHVwcGVyIGluZGV4IG9mIGBwJyBjb250YWluaW5nIHRoZSB6ZXJvLXRlcm1pbmF0aW9uXG4gICAgICAtLSBpcyB3cml0dGVuIHRvIGBhX25ld191cHBlcicuXG4gICAgICAtLSBUaGUgc2VxdWVuY2UgaXMgbm90IHplcm8tdGVybWluYXRlZC5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgZW5kX3Bvc19zbWFsbF9lbm91Z2g6IGVuZF9wb3MgPD0gcy5jb3VudFxuICAgICAgZXZlbl9wX29mZnNldDogKHBfb2Zmc2V0IFxcXFwgMikgPSAwXG4gICAgICBwX29mZnNldF9ub25fbmVnYXRpdmU6IHBfb2Zmc2V0ID49IDBcbiAgICBsb2NhbFxuICAgICAgaSwgbiwgbSwgbF9jb3VudDogSU5URUdFUlxuICAgICAgYzogTkFUVVJBTF8zMlxuICAgICAgbF9lbmNvZGVkX3ZhbHVlOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTFxuICAgICAgbF9kZWNvZGVkOiBCT09MRUFOXG4gICAgICBsX3Jlc2l6ZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAgIGxfY291bnQgOj0gcC5jb3VudFxuICAgICAgICAgIC0tIENoZWNrIHRoYXQgdGhlcmUgaXMgYXQgbGVhc3QgYGkgKiAyJyBieXRlcyBhdmFpbGFibGUgcGx1cyB0aGUgdGVybWluYXRpbmcgbnVsbCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIGxfY291bnQgLSBwX29mZnNldCA8IChuICsgMSkgKiAyICB0aGVuXG4gICAgICAgICAgICAtLSBPcHRpbWl6ZSByZXNpemluZywgb25jZSB3ZSBoYXZlIHRvIHJlc2l6ZSwgd2UgYWN0dWFsbHkgcGVyZm9ybSB0aGUgcmVzaXppbmdcbiAgICAgICAgICAgIC0tIG9ubHkgb25jZS5cbiAgICAgICAgICBsX2NvdW50IDo9IHBfb2Zmc2V0ICsgdXRmXzE2X2J5dGVzX2NvdW50IChzLCBzdGFydF9wb3MsIGVuZF9wb3MpICsgMlxuICAgICAgICAgIHAucmVzaXplIChsX2NvdW50KVxuICAgICAgICAgIGxfcmVzaXplZCA6PSBUcnVlXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgbSA6PSBwX29mZnNldFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBlbmRfcG9zXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBtaWdodCBiZSBmYWNpbmcgYSBjaGFyYWN0ZXIgdGhhdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICBpZiBpIDwgbiB0aGVuXG4gICAgICAgICAgICBpZiBzLml0ZW0gKGkgKyAxKSA9IGVzY2FwZV9jaGFyYWN0ZXIgdGhlblxuICAgICAgICAgICAgICAgIC0tIFRoZSBgZXNjYXBlX2NoYXJhY3Rlcicgd2FzIGVzY2FwZWQsIGl0IG1lYW50IHRoZXkgcmVhbGx5IHdhbnRlZCBhbiBgZXNjYXBlX2NoYXJhY3RlcicuXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVsc2VpZiBzLml0ZW0gKGkgKyAxKSA9ICd1JyB0aGVuXG4gICAgICAgICAgICAgIGlmIGkgKyA0IDwgbiB0aGVuXG4gICAgICAgICAgICAgICAgbF9lbmNvZGVkX3ZhbHVlIDo9IHMuc3Vic3RyaW5nIChpICsgMiwgaSArIDUpXG4gICAgICAgICAgICAgICAgaWYgaXNfaGV4YV9kZWNpbWFsIChsX2VuY29kZWRfdmFsdWUpIHRoZW5cbiAgICAgICAgICAgICAgICAgIGMgOj0gdG9fbmF0dXJhbF8zMiAobF9lbmNvZGVkX3ZhbHVlKVxuICAgICAgICAgICAgICAgICAgaWYgYyA8IDB4RDgwMCBvciBjID4gMHhERkZGIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAtLSBWYWx1ZSB3YXMgZW5jb2RlZCB3aGVuIGl0IHNob3VsZCBub3QgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgICAgICAgLS0gZG8gbm90aGluZywgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIGNvbnRlbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgIGMgOj0gZXNjYXBlX2NoYXJhY3Rlci5uYXR1cmFsXzMyX2NvZGVcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbF9kZWNvZGVkIDo9IFRydWVcbiAgICAgICAgICAgICAgICAgICAgaSA6PSBpICsgNVxuICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAtLSBOb3QgYW4gaGV4YWRlY2ltYWwgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIC0tIE5vdCBlbm91Z2ggY2hhcmFjdGVycyB0byBtYWtlIGEgMi1ieXRlIHZhbHVlLCBpdCB3YXMgbm90IGVzY2FwZWQuXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBWYWx1ZSB3YXMgbW9zdCBsaWtlbHkgbm90IGVuY29kZWQsIGJlY2F1c2UgaWYgaXQgZGlkLCBpdCB3b3VsZCBiZSB0aGVcbiAgICAgICAgICAgICAgLS0gaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlIHdoaWNoIGNsZWFybHkgZGlkIG5vdCBuZWVkIHRvXG4gICAgICAgICAgICAgIC0tIGJlIGVzY2FwZWRcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gTm90aGluZyBtb3JlIHRvIHJlYWQsIGNsZWFybHkgaXQgd2FzIG5vdCBlbmNvZGVkLlxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcblxuICAgICAgICBpZiBub3QgbF9kZWNvZGVkIHRoZW5cbiAgICAgICAgICBpZiBjIDw9IDB4RkZGRiB0aGVuXG4gICAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2IChjLnRvX25hdHVyYWxfMTYsIG0pXG4gICAgICAgICAgICBtIDo9IG0gKyAyXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBNYWtlIHN1cmUgdGhlcmUgaXMgc3VmZmljaWVudCByb29tIGZvciBhbGwgdGhlIHJlbWFpbmluZyBjaGFyYWN0ZXJzIGFuZFxuICAgICAgICAgICAgICAtLSBhdCBsZWFzdCAzIGNvZGUgdW5pdHMgb2YgMiBieXRlcyBlYWNoLCBpLmUuIDIgY29kZSB1bml0IGZvciB0aGUgc3Vycm9nYXRlXG4gICAgICAgICAgICAgIC0tIHBhaXIsIGFuZCBvbmUgdW5pdCBmb3IgdGhlIHRlcm1pbmF0aW5nIG51bGwgY2hhcmFjdGVyLiBOb3RlIHRoYXQgd2UgZG8gbm90XG4gICAgICAgICAgICAgIC0tIHRha2UgaW50byBhY2NvdW50IGBwX29mZnNldCcgYmVjYXVzZSBgbScgYWxyZWFkeSBpbmNsdWRlcyBpdC5cbiAgICAgICAgICAgICAgLS0gTm90ZSB0aGF0IGBlbmRfcG9zIC0gaScgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHJlbWFpbmluZyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgIC0tIHRvIHByb2Nlc3MgaW4gdGhlIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgICAgICAgaWYgbm90IGxfcmVzaXplZCBhbmQgdGhlbiAobSArIDYgKyAoZW5kX3BvcyAtIGkpICogMiA+IGxfY291bnQpIHRoZW5cbiAgICAgICAgICAgICAgICAtLSBPcHRpbWl6ZSByZXNpemluZywgb25jZSB3ZSBoYXZlIHRvIHJlc2l6ZSwgd2UgYWN0dWFsbHkgcGVyZm9ybSB0aGUgcmVzaXppbmdcbiAgICAgICAgICAgICAgICAtLSBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgIGxfY291bnQgOj0gbSArIHV0Zl8xNl9ieXRlc19jb3VudCAocywgaSwgZW5kX3BvcykgKyAyXG4gICAgICAgICAgICAgIHAucmVzaXplIChsX2NvdW50KVxuICAgICAgICAgICAgICBsX3Jlc2l6ZWQgOj0gVHJ1ZVxuICAgICAgICAgICAgZW5kXG5cbiAgICAgICAgICAgICAgLS0gV3JpdGUgdGhlIGxlYWQgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2ICgoMHhEN0MwICsgKGMgfD4+IDEwKSkudG9fbmF0dXJhbF8xNiwgbSlcblxuICAgICAgICAgICAgICAtLSBXcml0ZSB0aGUgdHJhaWwgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICBwLnB1dF9uYXR1cmFsXzE2ICgoMHhEQzAwICsgKGMgJiAweDNGRikpLnRvX25hdHVyYWxfMTYsIG0gKyAyKVxuXG4gICAgICAgICAgICBtIDo9IG0gKyA0XG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2RlY29kZWQgOj0gRmFsc2VcbiAgICAgICAgICAgIC0tIFNpbXBseSBwdXQgZGVjb2RlZCB2YWx1ZSBkaXJlY3RseSBpbiBzdHJlYW0uXG4gICAgICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoYy50b19uYXR1cmFsXzE2LCBtKVxuICAgICAgICAgIG0gOj0gbSArIDJcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGlmIGxfcmVzaXplZCB0aGVuXG4gICAgICAgICAgLS0gV2UgaGFkIHRvIGFkZCBhIGNvZGUgdW5pdCBvbiA0IGJ5dGVzLiBXZSBhZGp1c3QgdGhlIHNpemUuXG4gICAgICAgIHAucmVzaXplIChtICsgMilcbiAgICAgIGVuZFxuICAgICAgcC5wdXRfbmF0dXJhbF8xNiAoMCwgbSlcbiAgICAgIGlmIGFfbmV3X3VwcGVyIC89IFZvaWQgdGhlblxuICAgICAgICBhX25ld191cHBlci5wdXQgKG0pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHBfY291bnRfbWF5X2luY3JlYXNlOiBwLmNvdW50ID49IG9sZCBwLmNvdW50XG4gICAgICByb3VuZHRyaXA6IGFfbmV3X3VwcGVyIC89IFZvaWQgaW1wbGllcyB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAoYV9uZXdfdXBwZXIuaXRlbSAvLyAyKSAtIDEsIEZhbHNlKS5zYW1lX3N0cmluZ19nZW5lcmFsIChzLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICAgIHJvdW5kdHJpcDogKGFfbmV3X3VwcGVyID0gVm9pZCBhbmQgdGhlbiBub3Qgcy5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykuaGFzICgnJVUnKSkgaW1wbGllc1xuICAgICAgICB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBwX29mZnNldCAvLyAyLCAocC5jb3VudCAvLyAyKSAtIDEsIFRydWUpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTE2TEUgc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBgcycgaW50ZXJwcmV0ZWQgYXMgYSBVVEYtMzIgc2VxdWVuY2UgdGhhdCBjb3VsZCBiZSBlc2NhcGVkLlxuICAgICAgLS0gSWYgYHMnIGNvbnRhaW5zIHRoZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWQgYnkgZWl0aGVyIFwiSEhcIiBvciBcInVISEhIXCIgd2hlcmUgSCBzdGFuZHNcbiAgICAgIC0tIGZvciBhbiBoZXhhZGVjaW1hbCBkaWdpdCwgdGhlbiBgcycgaGFzIGJlZW4gZXNjYXBlZCBhbmQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gd2hhdCBpc1xuICAgICAgLS0gZXhwZWN0ZWQgYnkgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gICAgICAtLSBPdGhlcndpc2UgaXQgd2lsbCBiZSBpZ25vcmVkIGFuZCBpdCB3aWxsIGJlIGxlZnQgYXMgaXMuXG4gICAgICAtLSBTZWUgdGhlIG5vdGUgY2xhdXNlIGZvciB0aGUgY2xhc3MgZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZW5jb2RpbmcuXG4gICAgZG9cbiAgICAgICAgLS0gV2Ugd291bGQgbmVlZCBhdCBsZWFzdCAyLWJ5dGVzIHBlciBjaGFyYWN0ZXJzIGluIGBzJy5cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudCAqIDIpXG4gICAgICBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfaW50b191dGZfMTZsZV9zdHJpbmdfOCAocywgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfMTZsZV9zdHJpbmdfOF90b19lc2NhcGVkX3N0cmluZ18zMiAoUmVzdWx0KS5zYW1lX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGVzY2FwZWRfdXRmXzMyX3N0cmluZ19pbnRvX3V0Zl8xNmxlX3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgYV9yZXN1bHQ6IFNUUklOR184KVxuICAgICAgLS0gQ29weSBVVEYtMTZMRSBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIGBzJyBpbnRlcnByZXRlZCBhcyBhIFVURi0zMiBzZXF1ZW5jZSB0aGF0IGNvdWxkIGJlXG4gICAgICAtLSBlc2NhcGVkIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICAgIC0tIElmIGBzJyBjb250YWlucyB0aGUgYGVzY2FwZV9jaGFyYWN0ZXInIGZvbGxvd2VkIGJ5IGVpdGhlciBcIkhIXCIgb3IgXCJ1SEhISFwiIHdoZXJlIEggc3RhbmRzXG4gICAgICAtLSBmb3IgYW4gaGV4YWRlY2ltYWwgZGlnaXQsIHRoZW4gYHMnIGhhcyBiZWVuIGVzY2FwZWQgYW5kIHdpbGwgYmUgY29udmVydGVkIHRvIHdoYXQgaXNcbiAgICAgIC0tIGV4cGVjdGVkIGJ5IHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICAgICAgLS0gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgaWdub3JlZCBhbmQgaXQgd2lsbCBiZSBsZWZ0IGFzIGlzLlxuICAgICAgLS0gU2VlIHRoZSBub3RlIGNsYXVzZSBmb3IgdGhlIGNsYXNzIGZvciBtb3JlIGRldGFpbHMgb24gdGhlIGVuY29kaW5nLlxuICAgIGxvY2FsXG4gICAgICBpOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBuOiBsaWtlIHtTVFJJTkdfMzJ9LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgICBsX25hdDE2OiBOQVRVUkFMXzE2XG4gICAgICBsX2VuY29kZWRfdmFsdWU6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgICBsX2RlY29kZWQ6IEJPT0xFQU5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBuIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBXZSB3b3VsZCBuZWVkIGF0IGxlYXN0IDItYnl0ZXMgcGVyIGNoYXJhY3RlcnMgaW4gYHMnLlxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIG4gKiAyKVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+PSBuXG4gICAgICBsb29wXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgYyA6PSBzLmNvZGUgKGkpXG4gICAgICAgIGlmIGMgPSBlc2NhcGVfY2hhcmFjdGVyLm5hdHVyYWxfMzJfY29kZSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBtaWdodCBiZSBmYWNpbmcgYSBjaGFyYWN0ZXIgdGhhdCB3YXMgZXNjYXBlZC5cbiAgICAgICAgICBpZiBpIDwgbiB0aGVuXG4gICAgICAgICAgICBpZiBzLml0ZW0gKGkgKyAxKSA9IGVzY2FwZV9jaGFyYWN0ZXIgdGhlblxuICAgICAgICAgICAgICAgIC0tIFRoZSBgZXNjYXBlX2NoYXJhY3Rlcicgd2FzIGVzY2FwZWQsIGl0IG1lYW50IHRoZXkgcmVhbGx5IHdhbnRlZCBhbiBgZXNjYXBlX2NoYXJhY3RlcicuXG4gICAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICAgIGVsc2VpZiBzLml0ZW0gKGkgKyAxKSA9ICd1JyB0aGVuXG4gICAgICAgICAgICAgIGlmIGkgKyA0IDwgbiB0aGVuXG4gICAgICAgICAgICAgICAgbF9lbmNvZGVkX3ZhbHVlIDo9IHMuc3Vic3RyaW5nIChpICsgMiwgaSArIDUpXG4gICAgICAgICAgICAgICAgaWYgaXNfaGV4YV9kZWNpbWFsIChsX2VuY29kZWRfdmFsdWUpIHRoZW5cbiAgICAgICAgICAgICAgICAgIGMgOj0gdG9fbmF0dXJhbF8zMiAobF9lbmNvZGVkX3ZhbHVlKVxuICAgICAgICAgICAgICAgICAgaWYgYyA8IDB4RDgwMCBvciBjID4gMHhERkZGIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAtLSBWYWx1ZSB3YXMgZW5jb2RlZCB3aGVuIGl0IHNob3VsZCBub3QgaGF2ZSBiZWVuXG4gICAgICAgICAgICAgICAgICAgICAgLS0gZG8gbm90aGluZywgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIGNvbnRlbnQgYXMgaXMuXG4gICAgICAgICAgICAgICAgICAgIGMgOj0gZXNjYXBlX2NoYXJhY3Rlci5uYXR1cmFsXzMyX2NvZGVcbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbF9kZWNvZGVkIDo9IFRydWVcbiAgICAgICAgICAgICAgICAgICAgaSA6PSBpICsgNVxuICAgICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAtLSBOb3QgYW4gaGV4YWRlY2ltYWwgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgLS0gTm90IGVub3VnaCBjaGFyYWN0ZXJzIHRvIG1ha2UgYSAyLWJ5dGUgdmFsdWUsIGl0IHdhcyBub3QgZXNjYXBlZC5cbiAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFZhbHVlIHdhcyBtb3N0IGxpa2VseSBub3QgZW5jb2RlZCwgYmVjYXVzZSBpZiBpdCBkaWQsIGl0IHdvdWxkIGJlIHRoZVxuICAgICAgICAgICAgICAtLSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiBhIGJ5dGUgd2hpY2ggY2xlYXJseSBkaWQgbm90IG5lZWQgdG9cbiAgICAgICAgICAgICAgLS0gYmUgZXNjYXBlZFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAtLSBOb3RoaW5nIG1vcmUgdG8gcmVhZCwgY2xlYXJseSBpdCB3YXMgbm90IGVuY29kZWQuXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuXG4gICAgICAgIGlmIG5vdCBsX2RlY29kZWQgdGhlblxuICAgICAgICAgIGlmIGMgPD0gMHhGRkZGIHRoZW5cbiAgICAgICAgICAgICAgLS0gQ29kZXBvaW50IGZyb20gQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lOiBvbmUgMTYtYml0IGNvZGUgdW5pdC5cbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGMgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgJiAweEZGMDApIHw+PiA4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFdyaXRlIHRoZSBsZWFkIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgbF9uYXQxNiA6PSAoMHhEN0MwICsgKGMgfD4+IDEwKSkudG9fbmF0dXJhbF8xNlxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgobF9uYXQxNiAmIDB4MDBGRikudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgobF9uYXQxNiAmIDB4RkYwMCkgfD4+IDgpLnRvX2NoYXJhY3Rlcl84KVxuXG4gICAgICAgICAgICAgICAgLS0gV3JpdGUgdGhlIHRyYWlsIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICAgICAgbF9uYXQxNiA6PSAoMHhEQzAwICsgKGMgJiAweDNGRikpLnRvX25hdHVyYWxfMTZcbiAgICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoKGxfbmF0MTYgJiAweDAwRkYpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGxfbmF0MTYgJiAweEZGMDApIHw+PiA4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfZGVjb2RlZCA6PSBGYWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHB1dCBkZWNvZGVkIHZhbHVlIGRpcmVjdGx5IGluIHN0cmVhbS5cbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKChjICYgMHgwMEZGKS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYyAmIDB4RkYwMCkgfD4+IDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiB1dGZfMTZsZV9zdHJpbmdfOF90b19lc2NhcGVkX3N0cmluZ18zMiAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVVRGLTE2IHRvIFVURi0zMlxuXG4gIHV0Zl8xNl8wX3BvaW50ZXJfdG9fc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVIpOiBTVFJJTkdfMzJcbiAgICAgIC0tIHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgd2hpY2ggaXMgemVyby10ZXJtaW5hdGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIG1pbmltdW1fc2l6ZTogcC5jb3VudCA+PSAyXG4gICAgICB2YWxpZF9jb3VudDogcC5jb3VudCBcXFxcIDIgPSAwXG4gICAgZG9cbiAgICAgICAgLS0gQWxsb2NhdGUgUmVzdWx0IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJ5dGVzIGFzIGBwJy5cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocC5jb3VudClcbiAgICAgIHV0Zl8xNl8wX3BvaW50ZXJfaW50b19zdHJpbmdfMzIgKHAsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2X3N1YnBvaW50ZXIgKHAsIDAsIHAuY291bnQgLy8gMiwgVHJ1ZSkgaW1wbGllc1xuICAgICAgICBhY3Jvc3Mgc3RyaW5nXzMyX3RvX3V0Zl8xNiAoUmVzdWx0KSBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gcC5yZWFkX25hdHVyYWxfMTYgKGxfc3BlYy5jdXJzb3JfaW5kZXggKiAyKSBlbmRcbiAgICBlbmRcblxuICB1dGZfMTZfMF9wb2ludGVyX2ludG9fc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IGFfcmVzdWx0OiBTVFJJTkdfMzIpXG4gICAgICAtLSBDb3B5IHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgd2hpY2ggaXMgemVyby10ZXJtaW5hdGVkXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgbWluaW11bV9zaXplOiBwLmNvdW50ID49IDJcbiAgICAgIHZhbGlkX2NvdW50OiBwLmNvdW50IFxcXFwgMiA9IDBcbiAgICBkb1xuICAgICAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX3N0cmluZ18zMiAocCwgMCwgcC5jb3VudCAvLyAyIC0gMSwgVHJ1ZSwgYV9yZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNl9zdWJwb2ludGVyIChwLCAwLCBwLmNvdW50IC8vIDIsIFRydWUpIGltcGxpZXNcbiAgICAgICAgYWNyb3NzIHN0cmluZ18zMl90b191dGZfMTYgKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3NwZWMgYWxsIGxfc3BlYy5pdGVtID0gcC5yZWFkX25hdHVyYWxfMTYgKGxfc3BlYy50YXJnZXRfaW5kZXggKiAyKSBlbmRcbiAgICBlbmRcblxuICB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOKTogU1RSSU5HXzMyXG4gICAgICAtLSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHAnIGJldHdlZW4gY29kZSB1bml0cyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyBvciB0aGUgZmlyc3QgbnVsbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQgaWYgYGFfc3RvcF9hdF9udWxsJy5cbiAgICByZXF1aXJlXG4gICAgICBtaW5pbXVtX3NpemU6IHAuY291bnQgPj0gMlxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudCAvLyAyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocC5jb3VudClcbiAgICAgIHV0Zl8xNl8wX3N1YnBvaW50ZXJfaW50b19zdHJpbmdfMzIgKHAsIHN0YXJ0X3BvcywgZW5kX3BvcywgYV9zdG9wX2F0X251bGwsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2X3N1YnBvaW50ZXIgKHAsIHN0YXJ0X3BvcywgZW5kX3BvcywgYV9zdG9wX2F0X251bGwpIGltcGxpZXNcbiAgICAgICAgYWNyb3NzIHN0cmluZ18zMl90b191dGZfMTYgKFJlc3VsdCkgYXMgbF9zcGVjIGFsbCBsX3NwZWMuaXRlbSA9IHAucmVhZF9uYXR1cmFsXzE2IChsX3NwZWMudGFyZ2V0X2luZGV4ICogMikgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVI7IGFfc3RvcF9hdF9udWxsOiBCT09MRUFOOyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHAnIGJldHdlZW4gY29kZSB1bml0cyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyBvciB0aGUgZmlyc3QgbnVsbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQgaWYgYGFfc3RvcF9hdF9udWxsJyBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgbWluaW11bV9zaXplOiBwLmNvdW50ID49IDJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAwXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8IHAuY291bnQgLy8gMlxuICAgIGxvY2FsXG4gICAgICBpLCBuOiBJTlRFR0VSXG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgICAtLSBBbGxvY2F0ZSBSZXN1bHQgd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYnl0ZXMgYXMgY29waWVkIGZyb20gYHAnLlxuICAgICAgICBhX3Jlc3VsdC5ncm93IChhX3Jlc3VsdC5jb3VudCArIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBpIDo9IHN0YXJ0X3BvcyAqIDJcbiAgICAgICAgbiA6PSBlbmRfcG9zICogMlxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5cbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBwLnJlYWRfbmF0dXJhbF8xNiAoaSlcbiAgICAgICAgaWYgYyA9IDAgYW5kIGFfc3RvcF9hdF9udWxsIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhpdCBvdXIgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIsIHdlIGNhbiBzdG9wXG4gICAgICAgICAgaSA6PSBuICsgMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGlmIGMgPCAweEQ4MDAgb3IgYyA+PSAweEUwMDAgdGhlblxuICAgICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LlxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgICBpZiBpIDw9IG4gdGhlblxuICAgICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYy5hc19uYXR1cmFsXzMyIHw8PCAxMCkgKyBwLnJlYWRfbmF0dXJhbF8xNiAoaSkgLSAweDM1RkRDMDApLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNl9zdWJwb2ludGVyIChwLCBzdGFydF9wb3MsIGVuZF9wb3MsIGFfc3RvcF9hdF9udWxsKSBpbXBsaWVzXG4gICAgICAgIGFjcm9zcyBzdHJpbmdfMzJfdG9fdXRmXzE2IChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkgYXMgbF9zcGVjIGFsbCBsX3NwZWMuaXRlbSA9IHAucmVhZF9uYXR1cmFsXzE2IChsX3NwZWMudGFyZ2V0X2luZGV4ICogMikgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfcG9pbnRlcl90b19lc2NhcGVkX3N0cmluZ18zMiAocDogTUFOQUdFRF9QT0lOVEVSKTogU1RSSU5HXzMyXG4gICAgICAtLSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHAnIHdoaWNoIGlzIHplcm8tdGVybWluYXRlZCxcbiAgICAgIC0tIHdoZXJlIGludmFsaWQgVVRGLTE2TEUgc2VxdWVuY2VzIGFyZSBlc2NhcGVkLlxuICAgIHJlcXVpcmVcbiAgICAgIG1pbmltdW1fc2l6ZTogcC5jb3VudCA+PSAyXG4gICAgICB2YWxpZF9jb3VudDogcC5jb3VudCBcXFxcIDIgPSAwXG4gICAgZG9cbiAgICAgICAgLS0gQWxsb2NhdGUgUmVzdWx0IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJ5dGVzIGFzIGBwJy5cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocC5jb3VudClcbiAgICAgIHV0Zl8xNl8wX3BvaW50ZXJfaW50b19lc2NhcGVkX3N0cmluZ18zMiAocCwgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKFJlc3VsdCkgYXMgbF91dGYgYW5kIHRoZW5cbiAgICAgICAgYWNyb3NzIGxfdXRmLm5ld19jdXJzb3IuaW5jcmVtZW50ZWQgKDEpIGFzIGxfc3RyIGFsbFxuICAgICAgICAgIChsX3V0Zi5jb2RlIChsX3N0ci5jdXJzb3JfaW5kZXgpIHwgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCArIDEpIHw8PCA4KSkgPSBwLnJlYWRfbmF0dXJhbF8xNiAobF9zdHIuY3Vyc29yX2luZGV4IC0gMSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfcG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IGFfcmVzdWx0OiBTVFJJTkdfMzIpXG4gICAgICAtLSBDb3B5IHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgd2hpY2ggaXMgemVyby10ZXJtaW5hdGVkLFxuICAgICAgLS0gd2hlcmUgaW52YWxpZCBVVEYtMTZMRSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQsIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICByZXF1aXJlXG4gICAgICBtaW5pbXVtX3NpemU6IHAuY291bnQgPj0gMlxuICAgICAgdmFsaWRfY291bnQ6IHAuY291bnQgXFxcXCAyID0gMFxuICAgIGRvXG4gICAgICB1dGZfMTZfMF9zdWJwb2ludGVyX2ludG9fZXNjYXBlZF9zdHJpbmdfMzIgKHAsIDAsIHAuY291bnQgLy8gMiAtIDEsIFRydWUsIGFfcmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3V0ZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF91dGYubmV3X2N1cnNvci5pbmNyZW1lbnRlZCAoMSkgYXMgbF9zdHIgYWxsXG4gICAgICAgICAgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCkgfCAobF91dGYuY29kZSAobF9zdHIuY3Vyc29yX2luZGV4ICsgMSkgfDw8IDgpKSA9IHAucmVhZF9uYXR1cmFsXzE2IChsX3N0ci5jdXJzb3JfaW5kZXggLSAxKVxuICAgICAgICBlbmRcbiAgICBlbmRcblxuICB1dGZfMTZfMF9zdWJwb2ludGVyX3RvX2VzY2FwZWRfc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUjsgYV9zdG9wX2F0X251bGw6IEJPT0xFQU4pOiBTVFJJTkdfMzJcbiAgICAgIC0tIHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgYmV0d2VlbiBjb2RlIHVuaXRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIG9yIHRoZSBmaXJzdCBudWxsIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBpZiBgYV9zdG9wX2F0X251bGwnLCB3aGVyZSBpbnZhbGlkXG4gICAgICAtLSBVVEYtMTZMRSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgcmVxdWlyZVxuICAgICAgbWluaW11bV9zaXplOiBwLmNvdW50ID49IDJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAwXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8IHAuY291bnQgLy8gMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwLCBzdGFydF9wb3MsIGVuZF9wb3MsIGFfc3RvcF9hdF9udWxsLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGF0dGFjaGVkIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoUmVzdWx0KSBhcyBsX3V0ZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF91dGYubmV3X2N1cnNvci5pbmNyZW1lbnRlZCAoMSkgYXMgbF9zdHIgYWxsXG4gICAgICAgICAgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCkgfCAobF91dGYuY29kZSAobF9zdHIuY3Vyc29yX2luZGV4ICsgMSkgfDw8IDgpKSA9IHAucmVhZF9uYXR1cmFsXzE2IChzdGFydF9wb3MgKiAyICsgbF9zdHIuY3Vyc29yX2luZGV4IC0gMSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2XzBfc3VicG9pbnRlcl9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChwOiBNQU5BR0VEX1BPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUjsgYV9zdG9wX2F0X251bGw6IEJPT0xFQU47IGFfcmVzdWx0OiBTVFJJTkdfMzIpXG4gICAgICAtLSBDb3B5IHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcCcgYmV0d2VlbiBjb2RlIHVuaXRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIG9yIHRoZSBmaXJzdCBudWxsIGNoYXJhY3RlciBlbmNvdW50ZXJlZCBpZiBgYV9zdG9wX2F0X251bGwnLCB3aGVyZSBpbnZhbGlkXG4gICAgICAtLSBVVEYtMTZMRSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQsIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICByZXF1aXJlXG4gICAgICBtaW5pbXVtX3NpemU6IHAuY291bnQgPj0gMlxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDBcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICAgIGVuZF9wb3Nfc21hbGxfZW5vdWdoOiBlbmRfcG9zIDwgcC5jb3VudCAvLyAyXG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgICAgLS0gQWxsb2NhdGUgUmVzdWx0IHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGJ5dGVzIGFzIGNvcGllZCBmcm9tIGBwJy5cbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgaSA6PSBzdGFydF9wb3MgKiAyXG4gICAgICAgIG4gOj0gZW5kX3BvcyAqIDJcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuXG4gICAgICBsb29wXG4gICAgICAgIGMxIDo9IHAucmVhZF9uYXR1cmFsXzE2IChpKVxuICAgICAgICBpZiBjMSA9IDAgYW5kIGFfc3RvcF9hdF9udWxsIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGhpdCBvdXIgbnVsbCB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIsIHdlIGNhbiBzdG9wXG4gICAgICAgICAgaSA6PSBuICsgMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGlmIGMxIDwgMHhEODAwIG9yIGMxID49IDB4RTAwMCB0aGVuXG4gICAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMxLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBlbHNlaWYgYzEgPD0gMHhEQkZGIGFuZCB0aGVuIGkgPD0gbiB0aGVuXG4gICAgICAgICAgICAgIC0tIENoZWNrIGlmIGEgbGVhZCBzdXJyb2dhdGUgKHZhbHVlIGJldHdlZW4gMHhEODAwIGFuZCAweERCRkYpIGlzIGZvbGxvd2VkIGJ5IGEgdHJhaWwgc3Vycm9nYXRlLlxuICAgICAgICAgICAgYzIgOj0gcC5yZWFkX25hdHVyYWxfMTYgKGkpXG4gICAgICAgICAgICBpZiBjMiA+PSAweERDMDAgYW5kIGMyIDw9IDB4REZGRiB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3VwcGxlbWVudGFyeSBQbGFuZXM6IHN1cnJvZ2F0ZSBwYWlyIHdpdGggbGVhZCBhbmQgdHJhaWwgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMxIHw8PCAxMCkgKyBjMiAtIDB4MzVGREMwMCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgICAgICBpIDo9IGkgKyAyXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgLS0gRXNjYXBlIGEgbGVhZCBzdXJyb2dhdGUgbm90IGZvbGxvd2VkIGJ5IGEgdHJhaWwgb25lLlxuICAgICAgICAgICAgICBlc2NhcGVfY29kZV9pbnRvIChhX3Jlc3VsdCwgYzEuYXNfbmF0dXJhbF8xNilcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gRXNjYXBlIGEgdHJhaWwgc3Vycm9nYXRlIG5vdCBmb2xsb3dpbmcgYSBsZWFkIG9uZSBvclxuICAgICAgICAgICAgICAtLSBhIGxlYWQgc3Vycm9nYXRlIG5vdCBmb2xsb3dlZCBieSBhIHRyYWlsIG9uZS5cbiAgICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMS5hc19uYXR1cmFsXzE2KVxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBhdHRhY2hlZCBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKSBhcyBsX3V0ZiBhbmQgdGhlblxuICAgICAgICBhY3Jvc3MgbF91dGYubmV3X2N1cnNvci5pbmNyZW1lbnRlZCAoMSkgYXMgbF9zdHIgYWxsXG4gICAgICAgICAgKGxfdXRmLmNvZGUgKGxfc3RyLmN1cnNvcl9pbmRleCkgfCAobF91dGYuY29kZSAobF9zdHIuY3Vyc29yX2luZGV4ICsgMSkgfDw8IDgpKSA9IHAucmVhZF9uYXR1cmFsXzE2IChzdGFydF9wb3MgKiAyICsgbF9zdHIuY3Vyc29yX2luZGV4IC0gMSlcbiAgICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdXRmXzE2X3RvX3N0cmluZ18zMiAoczogU1BFQ0lBTCBbTkFUVVJBTF8xNl0pOiBTVFJJTkdfMzJcbiAgICAgIC0tIHtTVFJJTkdfMzJ9IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIFVURi0xNiBzZXF1ZW5jZSBgcycuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl8xNl9pbnRvX3N0cmluZ18zMiAocywgUmVzdWx0KVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBpc192YWxpZF91dGZfMTYgKHMpIGltcGxpZXMgc3RyaW5nXzMyX3RvX3V0Zl8xNiAoUmVzdWx0KS5pc19lcXVhbCAocylcbiAgICBlbmRcblxuICB1dGZfMTZfaW50b19zdHJpbmdfMzIgKHM6IFNQRUNJQUwgW05BVFVSQUxfMTZdOyBhX3Jlc3VsdDogU1RSSU5HXzMyKVxuICAgICAgLS0gQ29weSB7U1RSSU5HXzMyfSBvYmplY3QgY29ycmVzcG9uZGluZyB0byBVVEYtMTYgc2VxdWVuY2UgYHMnXG4gICAgICAtLSBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgbG9jYWxcbiAgICAgIGk6IGxpa2Uge1NQRUNJQUwgW05BVFVSQUxfMTZdfS5jb3VudFxuICAgICAgbjogbGlrZSB7U1BFQ0lBTCBbTkFUVVJBTF8xNl19LmNvdW50XG4gICAgICBjOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbiA6PSBzLmNvdW50XG4gICAgICAgIGFfcmVzdWx0Lmdyb3cgKGFfcmVzdWx0LmNvdW50ICsgbilcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPj0gblxuICAgICAgbG9vcFxuICAgICAgICBjIDo9IHMgW2ldXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgaWYgYyA8IDB4RDgwMCBvciBjID49IDB4RTAwMCB0aGVuXG4gICAgICAgICAgICAtLSBDb2RlcG9pbnQgZnJvbSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmU6IG9uZSAxNi1iaXQgY29kZSB1bml0LlxuICAgICAgICAgIGFfcmVzdWx0LmV4dGVuZCAoYy50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIFN1cHBsZW1lbnRhcnkgUGxhbmVzOiBzdXJyb2dhdGUgcGFpciB3aXRoIGxlYWQgYW5kIHRyYWlsIHN1cnJvZ2F0ZXMuXG4gICAgICAgICAgaWYgaSA8IG4gdGhlblxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMgfDw8IDEwKSArIHMgW2ldIC0gMHgzNUZEQzAwKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNiAocykgaW1wbGllcyBzdHJpbmdfMzJfdG9fdXRmXzE2IChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkuaXNfZXF1YWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzE2bGVfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IFNUUklOR18zMlxuICAgICAgLS0ge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnLlxuICAgIGRvXG4gICAgICAgIC0tIFRoZXJlIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChzLmNvdW50IHw+PiAxKVxuICAgICAgdXRmXzE2bGVfc3RyaW5nXzhfaW50b19zdHJpbmdfMzIgKHMsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2bGVfc3RyaW5nXzggKHMpIGltcGxpZXMgZXNjYXBlZF91dGZfMzJfc3RyaW5nX3RvX3V0Zl8xNmxlX3N0cmluZ184IChSZXN1bHQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHV0Zl8xNmxlX3N0cmluZ184X2ludG9fc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBUaGVyZSBpcyBhdCBsZWFzdCBoYWxmIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyAobmIgfD4+IDEpKVxuICAgICAgdW50aWxcbiAgICAgICAgaSArIDEgPj0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIC0tIEV4dHJhY3QgdGhlIGZpcnN0IDItYnl0ZXNcbiAgICAgICAgYzEgOj0gcy5jb2RlIChpIC0gMSkgfCAocy5jb2RlIChpKSB8PDwgOClcbiAgICAgICAgaWYgYzEgPCAweEQ4MDAgb3IgYzEgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQsIHRoaXMgaXMgdmFsaWQgVW5pY29kZS5cbiAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKGMxLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGkgOj0gaSArIDJcbiAgICAgICAgICBpZiBpIDw9IG5iIHRoZW5cbiAgICAgICAgICAgIGMyIDo9IHMuY29kZSAoaSAtIDEpIHwgKHMuY29kZSAoaSkgfDw8IDgpXG4gICAgICAgICAgICBhX3Jlc3VsdC5leHRlbmQgKCgoYzEgfDw8IDEwKSArIGMyIC0gMHgzNUZEQzAwKS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGlzX3ZhbGlkX3V0Zl8xNmxlX3N0cmluZ184IChzKSBpbXBsaWVzIGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG4gIHV0Zl8xNmxlX3N0cmluZ184X3RvX2VzY2FwZWRfc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfOCk6IFNUUklOR18zMlxuICAgICAgLS0ge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnLCB3aGVyZSBpbnZhbGlkIFVURi0xNkxFXG4gICAgICAtLSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQuXG4gICAgZG9cbiAgICAgICAgLS0gVGhlcmUgaXMgYXQgbGVhc3QgaGFsZiB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKHMuY291bnQgfD4+IDEpXG4gICAgICB1dGZfMTZsZV9zdHJpbmdfOF9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChzLCBSZXN1bHQpXG4gICAgZW5zdXJlXG4gICAgICByb3VuZHRyaXA6IGVzY2FwZWRfdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAoUmVzdWx0KS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfMTZsZV9zdHJpbmdfOF9pbnRvX2VzY2FwZWRfc3RyaW5nXzMyIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgYV9yZXN1bHQ6IFNUUklOR18zMilcbiAgICAgIC0tIENvcHkge1NUUklOR18zMn0gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2TEUgc2VxdWVuY2UgYHMnLCB3aGVyZSBpbnZhbGlkIFVURi0xNkxFXG4gICAgICAtLSBzZXF1ZW5jZXMgYXJlIGVzY2FwZWQsIGFwcGVuZGVkIGludG8gYGFfcmVzdWx0Jy5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogTkFUVVJBTF8zMlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IHMuY291bnRcbiAgICAgICAgICAtLSBUaGVyZSBpcyBhdCBsZWFzdCBoYWxmIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICAgICAgYV9yZXN1bHQuZ3JvdyAoYV9yZXN1bHQuY291bnQgKyAobmIgfD4+IDEpKVxuICAgICAgdW50aWxcbiAgICAgICAgaSArIDEgPj0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIC0tIEV4dHJhY3QgdGhlIGZpcnN0IDItYnl0ZXNcbiAgICAgICAgYzEgOj0gcy5jb2RlIChpIC0gMSkgfCAocy5jb2RlIChpKSB8PDwgOClcbiAgICAgICAgaWYgYzEgPCAweEQ4MDAgb3IgYzEgPj0gMHhFMDAwIHRoZW5cbiAgICAgICAgICAgIC0tIENvZGVwb2ludCBmcm9tIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZTogb25lIDE2LWJpdCBjb2RlIHVuaXQuXG4gICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kIChjMS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgIGVsc2VpZiBjMSA8PSAweERCRkYgYW5kIGkgKyAyIDw9IG5iIHRoZW5cbiAgICAgICAgICAgIC0tIENoZWNrIGlmIGEgbGVhZCBzdXJyb2dhdGUgaXMgZm9sbG93ZWQgYnkgYSB0cmFpbCBzdXJyb2dhdGUuXG4gICAgICAgICAgYzIgOj0gcy5jb2RlIChpICsgMSkgfCAocy5jb2RlIChpICsgMikgfDw8IDgpXG4gICAgICAgICAgaWYgYzIgPj0gMHhEQzAwIGFuZCBjMiA8PSAweERGRkYgdGhlblxuICAgICAgICAgICAgICAtLSBTdXBwbGVtZW50YXJ5IFBsYW5lczogc3Vycm9nYXRlIHBhaXIgd2l0aCBsZWFkIGFuZCB0cmFpbCBzdXJyb2dhdGVzLlxuICAgICAgICAgICAgYV9yZXN1bHQuZXh0ZW5kICgoKGMxIHw8PCAxMCkgKyBjMiAtIDB4MzVGREMwMCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgLS0gRXNjYXBlIGEgbGVhZCBzdXJyb2dhdGUgbm90IGZvbGxvd2VkIGJ5IGEgdHJhaWwgb25lLlxuICAgICAgICAgICAgZXNjYXBlX2NvZGVfaW50byAoYV9yZXN1bHQsIGMxLmFzX25hdHVyYWxfMTYpXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEVzY2FwZSBhIHRyYWlsIHN1cnJvZ2F0ZSBub3QgZm9sbG93aW5nIGEgbGVhZCBvbmUgb3JcbiAgICAgICAgICAgIC0tIGEgbGVhZCBzdXJyb2dhdGUgbm90IGZvbGxvd2VkIGJ5IGEgdHJhaWwgb25lLlxuICAgICAgICAgIGVzY2FwZV9jb2RlX2ludG8gKGFfcmVzdWx0LCBjMS5hc19uYXR1cmFsXzE2KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBlc2NhcGVkX3V0Zl8zMl9zdHJpbmdfdG9fdXRmXzE2bGVfc3RyaW5nXzggKGFfcmVzdWx0LnN1YnN0cmluZyAob2xkIGFfcmVzdWx0LmNvdW50ICsgMSwgYV9yZXN1bHQuY291bnQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBVVEYtMTYgdG8gVVRGLThcblxuICB1dGZfMTZfdG9fdXRmXzhfc3RyaW5nXzggKHM6IFNQRUNJQUwgW05BVFVSQUxfMTZdKTogU1RSSU5HXzhcbiAgICAgIC0tIFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2IHNlcXVlbmNlIGBzJy5cbiAgICBkb1xuICAgICAgZGVidWcgKFwidG9faW1wbGVtZW50XCIpXG4gICAgICAgIChjcmVhdGUge1JFRkFDVE9SSU5HX0hFTFBFUn0pLnRvX2ltcGxlbWVudCAoXCJDb252ZXJ0IGRpcmVjdGx5IGZyb20gVVRGLTE2IHRvIFVURi04LlwiKVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nXzMyX3RvX3V0Zl84X3N0cmluZ184ICh1dGZfMTZfdG9fc3RyaW5nXzMyIChzKSlcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2IChzKSBpbXBsaWVzIHN0cmluZ18zMl90b191dGZfMTYgKHV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAoUmVzdWx0KSkuaXNfZXF1YWwgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzE2X2ludG9fdXRmXzhfc3RyaW5nXzggKHM6IFNQRUNJQUwgW05BVFVSQUxfMTZdOyBhX3Jlc3VsdDogU1RSSU5HXzgpXG4gICAgICAtLSBDb3B5IFVURi04IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gVVRGLTE2IHNlcXVlbmNlIGBzJyBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgZG9cbiAgICAgIGRlYnVnIChcInRvX2ltcGxlbWVudFwiKVxuICAgICAgICAoY3JlYXRlIHtSRUZBQ1RPUklOR19IRUxQRVJ9KS50b19pbXBsZW1lbnQgKFwiQ29udmVydCBkaXJlY3RseSBmcm9tIFVURi0xNiB0byBVVEYtOC5cIilcbiAgICAgIGVuZFxuICAgICAgc3RyaW5nXzMyX2ludG9fdXRmXzhfc3RyaW5nXzggKHV0Zl8xNl90b19zdHJpbmdfMzIgKHMpLCBhX3Jlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2IChzKSBpbXBsaWVzIHN0cmluZ18zMl90b191dGZfMTYgKHV0Zl84X3N0cmluZ184X3RvX3N0cmluZ18zMiAoYV9yZXN1bHQuc3Vic3RyaW5nIChvbGQgYV9yZXN1bHQuY291bnQgKyAxLCBhX3Jlc3VsdC5jb3VudCkpKS5pc19lcXVhbCAocylcbiAgICBlbmRcblxuICB1dGZfMTZsZV9zdHJpbmdfOF90b191dGZfOF9zdHJpbmdfOCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBTVFJJTkdfOFxuICAgICAgLS0gVVRGLTggc2VxdWVuY2UgY29ycmVzcG9uZGluZyB0byBVVEYtMTZMRSBzZXF1ZW5jZSBgcycuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAocy5jb3VudClcbiAgICAgIHV0Zl8xNmxlX3N0cmluZ184X2ludG9fdXRmXzhfc3RyaW5nXzggKHMsIFJlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2bGVfc3RyaW5nXzggKHMpIGltcGxpZXMgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAodXRmXzhfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChSZXN1bHQpKS5zYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICB1dGZfMTZsZV9zdHJpbmdfOF9pbnRvX3V0Zl84X3N0cmluZ184IChzOiBSRUFEQUJMRV9TVFJJTkdfODsgYV9yZXN1bHQ6IFNUUklOR184KVxuICAgICAgLS0gQ29weSBVVEYtOCBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIFVURi0xNkxFIHNlcXVlbmNlIGBzJyBhcHBlbmRlZCBpbnRvIGBhX3Jlc3VsdCcuXG4gICAgcmVxdWlyZVxuICAgICAgZXZlbl9jb3VudDogKHMuY291bnQgJiAxKSA9IDBcbiAgICBsb2NhbFxuICAgICAgdjogU1BFQ0lBTCBbTkFUVVJBTF8xNl1cbiAgICAgIGk6IGxpa2Uge1NUUklOR184fS5jb3VudFxuICAgICAgbjogbGlrZSB7U1RSSU5HXzh9LmNvdW50XG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbiA6PSBzLmNvdW50XG4gICAgICAgIGNyZWF0ZSB2Lm1ha2VfZW1wdHkgKG4gfD4+IDEpXG4gICAgICB1bnRpbFxuICAgICAgICBpID49IG5cbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMlxuICAgICAgICBjaGVja1xuICAgICAgICAgIHZhbGlkX2luZGV4OiAxIDw9IGkgLSAxIGFuZCBpIDw9IHMuY291bnRcbiAgICAgICAgZW5kXG4gICAgICAgIHYuZXh0ZW5kIChzIFtpIC0gMV0uY29kZS5hc19uYXR1cmFsXzE2IHwgKHMgW2ldLmNvZGUuYXNfbmF0dXJhbF8xNiB8PDwgOCkpXG4gICAgICBlbmRcbiAgICAgIHV0Zl8xNl9pbnRvX3V0Zl84X3N0cmluZ184ICh2LCBhX3Jlc3VsdClcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzE2bGVfc3RyaW5nXzggKHMpIGltcGxpZXMgdXRmXzMyX3N0cmluZ190b191dGZfMTZsZV9zdHJpbmdfOCAodXRmXzhfc3RyaW5nXzhfdG9fc3RyaW5nXzMyIChhX3Jlc3VsdC5zdWJzdHJpbmcgKG9sZCBhX3Jlc3VsdC5jb3VudCArIDEsIGFfcmVzdWx0LmNvdW50KSkpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFVURi04IHRvIFVURi0xNlxuXG4gIHV0Zl84X3N0cmluZ184X3RvX3V0Zl8xNiAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBTUEVDSUFMIFtOQVRVUkFMXzE2XVxuICAgICAgLS0gVVRGLTE2IHNlcXVlbmNlIGNvcnJlc3BvbmRpbmcgdG8gVVRGLTggc2VxdWVuY2UgYHMnLlxuICAgIGRvXG4gICAgICBkZWJ1ZyAoXCJ0b19pbXBsZW1lbnRcIilcbiAgICAgICAgKGNyZWF0ZSB7UkVGQUNUT1JJTkdfSEVMUEVSfSkudG9faW1wbGVtZW50IChcIkNvbnZlcnQgZGlyZWN0bHkgZnJvbSBVVEYtOCB0byBVVEYtMTYuXCIpXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfMzJfdG9fdXRmXzE2ICh1dGZfOF9zdHJpbmdfOF90b19zdHJpbmdfMzIgKHMpKVxuICAgIGVuc3VyZVxuICAgICAgcm91bmR0cmlwOiBpc192YWxpZF91dGZfOF9zdHJpbmdfOCAocykgaW1wbGllcyB1dGZfMTZfdG9fdXRmXzhfc3RyaW5nXzggKFJlc3VsdCkuc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgdXRmXzhfc3RyaW5nXzhfdG9fdXRmXzE2XzAgKHM6IFJFQURBQkxFX1NUUklOR184KTogU1BFQ0lBTCBbTkFUVVJBTF8xNl1cbiAgICAgIC0tIFVURi0xNiBzZXF1ZW5jZSBjb3JyZXNwb25kaW5nIHRvIFVURi04IHNlcXVlbmNlIGBzJyB3aXRoIHRlcm1pbmF0aW5nIHplcm8uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1dGZfOF9zdHJpbmdfOF90b191dGZfMTYgKHMpXG4gICAgICBSZXN1bHQgOj0gUmVzdWx0LmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoMCwgUmVzdWx0LmNvdW50ICsgMSlcbiAgICBlbnN1cmVcbiAgICAgIHJvdW5kdHJpcDogaXNfdmFsaWRfdXRmXzhfc3RyaW5nXzggKHMpIGltcGxpZXMgdXRmXzE2X3RvX3V0Zl84X3N0cmluZ184IChSZXN1bHQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJ5dGUgT3JkZXIgTWFyayAoQk9NKVxuXG4gIHV0Zl84X2JvbV90b19zdHJpbmdfODogU1RSSU5HXzggPSBcIiUvMjM5LyUvMTg3LyUvMTkxL1wiXG4gICAgICAtLSBVVEYtOCBCT00gc2VxdWVuY2UuXG5cbiAgdXRmXzE2YmVfYm9tX3RvX3N0cmluZ184OiBTVFJJTkdfOCA9IFwiJS8yNTQvJS8yNTUvXCJcbiAgICAgIC0tIFVURi0xNkJFIEJPTSBzZXF1ZW5jZS5cblxuICB1dGZfMTZsZV9ib21fdG9fc3RyaW5nXzg6IFNUUklOR184ID0gXCIlLzI1NS8lLzI1NC9cIlxuICAgICAgLS0gVVRGLTE2TEUgQk9NIHNlcXVlbmNlLlxuXG4gIHV0Zl8zMmJlX2JvbV90b19zdHJpbmdfODogU1RSSU5HXzggPSBcIiVVJVUlLzI1NC8lLzI1NS9cIlxuICAgICAgLS0gVVRGLTMyQkUgQk9NIHNlcXVlbmNlLlxuXG4gIHV0Zl8zMmxlX2JvbV90b19zdHJpbmdfODogU1RSSU5HXzggPSBcIiUvMjU1LyUvMjU0LyVVJVVcIlxuICAgICAgLS0gVVRGLTMyTEUgQk9NIHNlcXVlbmNlLlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVzY2FwZV9jb2RlX2ludG8gKGFfc3RyaW5nOiBTVFJJTkdfMzI7IGFfY29kZTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEVzY2FwZSBgYV9jb2RlJyBhcyBkb2N1bWVudGVkIGluIHRoZSBub3RlIGNsYXVzZSBvZiB0aGUgY2xhc3MgaW50byBgYV9zdHJpbmcnLlxuICAgICAgLS0gSWYgYGFfY29kZScgZml0cyBpbnRvIGEgTkFUVVJBTF84LCBpdCB3aWxsIGJlIGp1c3QgdGhlIGBlc2NhcGVfY2hhcmFjdGVyJyBmb2xsb3dlZFxuICAgICAgLS0gYnkgdGhlIDItZGlnaXQgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24sIG90aGVyd2lzZSBgZXNjYXBlX2NoYXJhY3RlcicgZm9sbG93ZWRcbiAgICAgIC0tIGJ5IHRoZSBsZXR0ZXIgYHUnIGZvbGxvd2VkIGJ5IHRoZSA0LWRpZ2l0IGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICAgIGRvXG4gICAgICBhX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyIChlc2NhcGVfY2hhcmFjdGVyKVxuICAgICAgaWYgYV9jb2RlIDw9IHtOQVRVUkFMXzh9Lm1heF92YWx1ZSB0aGVuXG4gICAgICAgIGFfc3RyaW5nLmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYV9jb2RlLmFzX25hdHVyYWxfOC50b19oZXhfc3RyaW5nKVxuICAgICAgZWxzZVxuICAgICAgICBhX3N0cmluZy5hcHBlbmRfY2hhcmFjdGVyICgndScpXG4gICAgICAgIGFfc3RyaW5nLmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYV9jb2RlLnRvX2hleF9zdHJpbmcpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19oZXhhX2RlY2ltYWwgKGFfc3RyaW5nOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBhX3N0cmluZycgYSB2YWxpZCBoZXhhZGVjaW1hbCBzZXF1ZW5jZT9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3RvaV9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3RvaV9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnJlc2V0ICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9uYXR1cmFsXzMyKVxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoYV9zdHJpbmcsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfMzIpXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IuaXNfaW50ZWdyYWxfaW50ZWdlclxuICAgIGVuZFxuXG4gIHRvX25hdHVyYWxfMzIgKGFfaGV4X3N0cmluZzogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGhleGFkZWNpbWFsIHZhbHVlIGBhX2hleF9zdHJpbmcnIHRvIGl0cyBjb3JyZXNwb25kaW5nIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfaGV4YTogaXNfaGV4YV9kZWNpbWFsIChhX2hleF9zdHJpbmcpXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChhX2hleF9zdHJpbmcsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBjdG9pX2NvbnZlcnRvcjogSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byBpbnRlZ2VyIG9yIG5hdHVyYWxcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKEZhbHNlKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKEZhbHNlKVxuICAgIGVuc3VyZVxuICAgICAgY3RvaV9jb252ZXJ0b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6IFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuICBzb3VyY2U6IFwiW1xuICAgICAgRWlmZmVsIFNvZnR3YXJlXG4gICAgICA1OTQ5IEhvbGxpc3RlciBBdmUuLCBHb2xldGEsIENBIDkzMTE3IFVTQVxuICAgICAgVGVsZXBob25lIDgwNS02ODUtMTAwNiwgRmF4IDgwNS02ODUtNjg2OVxuICAgICAgV2Vic2l0ZSBodHRwOi8vd3d3LmVpZmZlbC5jb21cbiAgICAgIEN1c3RvbWVyIHN1cHBvcnQgaHR0cDovL3N1cHBvcnQuZWlmZmVsLmNvbVxuICAgIF1cIlxuXG5lbmRcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==