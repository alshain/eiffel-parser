var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"any.e","content":"class\n  ANY\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    external\n      \"built_in\"\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n  frozen dlo_nothing\n      -- Execute a null action.\n    do\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\n\nend\n"});
__eiffel_builtin.push({"filename":"array.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 14:18:20 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92138 $\"\n\nclass ARRAY [G] inherit\n\n  RESIZABLE [G]\n    redefine\n      full, copy, is_equal, resizable\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as item alias \"[]\"\n    redefine\n      copy, is_equal\n    end\n\n  TO_SPECIAL [G]\n    export\n      {ARRAY} set_area\n    redefine\n      copy, is_equal, item, put, at, valid_index\n    end\n\ncreate\n  make_empty,\n  make,\n  make_filled,\n  make_from_array,\n  make_from_special,\n  make_from_cil\n\nconvert\n  to_cil: {NATIVE_ARRAY [G]},\n  to_special: {SPECIAL [G]},\n  make_from_cil ({NATIVE_ARRAY [G]})\n\nfeature -- Initialization\n\n  make_empty\n      -- Allocate empty array starting at `1'.\n    do\n      lower := 1\n      upper := 0\n      make_empty_area (0)\n    ensure\n      lower_set: lower = 1\n      upper_set: upper = 0\n      items_set: all_default\n    end\n\n  make_filled (a_default_value: G; min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    require\n      valid_bounds: min_index <= max_index + 1\n    local\n      n: INTEGER\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        n := max_index - min_index + 1\n      end\n      make_filled_area (a_default_value, n)\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: filled_with (a_default_value)\n    end\n\n  make (min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    obsolete\n      \" `make' is not void-safe statically. Use `make_empty' or `make_filled' instead. [07-2010]\"\n    require\n      valid_bounds: min_index <= max_index + 1\n      has_default: min_index <= max_index implies ({G}).has_default\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        make_filled_area (({G}).default, max_index - min_index + 1)\n      else\n        make_empty_area (0)\n      end\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: all_default\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Initialize from the items of `a'.\n      -- (Useful in proper descendants of class `ARRAY',\n      -- to initialize an array-like object from a manifest array.)\n    require\n      array_exists: a /= Void\n    do\n      set_area (a.area)\n      lower := a.lower\n      upper := a.upper\n    ensure\n      shared: area = a.area\n      lower_set: lower = a.lower\n      upper_set: upper = a.upper\n    end\n\n  make_from_special (a: SPECIAL [G])\n      -- Initialize Current from items of `a'.\n    require\n      special_attached: a /= Void\n    do\n      set_area (a)\n      lower := 1\n      upper := a.count\n    ensure\n      shared: area = a\n      lower_set: lower = 1\n      upper_set: upper = a.count\n    end\n\n  make_from_cil (na: NATIVE_ARRAY [like item])\n      -- Initialize array from `na'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      na_not_void: na /= Void\n    do\n      create area.make_from_native_array (na)\n      lower := 1\n      upper := area.count\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): G assign put\n      -- Entry at index `i', if in index interval\n    do\n      Result := area.item (i - lower)\n    end\n\n  entry (i: INTEGER): G\n      -- Entry at index `i', if in index interval\n    require\n      valid_key: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  has (v: G): BOOLEAN\n      -- Does `v' appear in array?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      l_area := area\n      nb := upper - lower\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) ~ v\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) = v\n          i := i + 1\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER\n      -- Minimum index\n\n  upper: INTEGER\n      -- Maximum index\n\n  count, capacity: INTEGER\n      -- Number of available indices\n    do\n      Result := upper - lower + 1\n    ensure then\n      consistent_with_bounds: Result = upper - lower + 1\n    end\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n    local\n      i: INTEGER\n    do\n      if object_comparison then\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) ~ v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      else\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) = v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    ensure then\n      same_count: Result.count = count\n      same_bounds:\n        ((Result.lower = lower) and (Result.upper = upper))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif lower = other.lower and then upper = other.upper and then\n        object_comparison = other.object_comparison\n      then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := item (i) ~ other.item (i)\n            i := i + 1\n          end\n        else\n          Result := area.same_items (other.area, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    do\n      if count > 0 then\n        Result := ({G}).has_default and then area.filled_with (({G}).default, 0, upper - lower)\n      else\n        Result := True\n      end\n    ensure\n      definition: Result = (count = 0 or else\n        ((not attached item (upper) as i or else i = ({G}).default) and\n        subarray (lower, upper - 1).all_default))\n    end\n\n  filled_with (v: G): BOOLEAN\n      -- Are all items set to `v'?\n    do\n      Result := area.filled_with (v, 0, upper - lower)\n    ensure\n      definition: Result = (count = 0 or else\n        (item (upper) = v and subarray (lower, upper - 1).filled_with (v)))\n    end\n\n  full: BOOLEAN\n      -- Is structure filled to capacity? (Answer: yes)\n    do\n      Result := True\n    end\n\n  same_items (other: like Current): BOOLEAN\n      -- Do `other' and Current have same items?\n    require\n      other_not_void: other /= Void\n    do\n      if count = other.count then\n        Result := area.same_items (other.area, 0, 0, count)\n      end\n    ensure\n      definition: Result = ((count = other.count) and then\n        (count = 0 or else (item (upper) = other.item (other.upper)\n        and subarray (lower, upper - 1).same_items\n        (other.subarray (other.lower, other.upper - 1)))))\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the array?\n    do\n      Result := (lower <= i) and then (i <= upper)\n    end\n\n  extendible: BOOLEAN\n      -- May items be added?\n      -- (Answer: no, although array may be resized.)\n    do\n      Result := False\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: no.)\n    do\n      Result := False\n    end\n\n  resizable: BOOLEAN\n      -- Can array be resized automatically?\n    do\n      Result := ({G}).has_default\n    end\n\n  valid_index_set: BOOLEAN\n    do\n      Result := index_set.count = count\n    end\n\nfeature -- Element change\n\n  put (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area.put (v, i - lower)\n    end\n\n  enter (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_key: valid_index (i)\n    do\n      area.put (v, i - lower)\n    end\n\n  force (v: like item; i: INTEGER)\n      -- Assign item `v' to `i'-th entry.\n      -- Resize the array if `i' falls out of currently defined bounds; preserve existing items.\n      -- In void-safe mode, if ({G}).has_default does not hold, then you can only insert between\n      -- `lower - 1' or `upper + 1' position in the ARRAY.\n    require\n      has_default_if_too_low:\n        (i < lower - 1 and lower /= {like lower}.min_value) implies ({G}).has_default\n      has_default_if_too_high:\n        (i > upper + 1 and upper /= {like upper}.max_value) implies ({G}).has_default\n    local\n      old_size, new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      l_count, l_offset: INTEGER\n      l_increased_by_one: BOOLEAN\n    do\n      new_lower := lower.min (i)\n      new_upper := upper.max (i)\n      new_size := new_upper - new_lower + 1\n      l_increased_by_one := (i = upper + 1) or (i = lower - 1)\n      if empty_area then\n          -- List is empty. First we create an empty SPECIAL of the right capacity.\n        make_empty_area (new_size.max (additional_space))\n        if not l_increased_by_one then\n            -- We need to fill the SPECIAL for `0' to `new_size - 2' with the default value.\n          area.fill_with (({G}).default, 0, new_size - 2)\n        end\n        area.extend (v)\n      else\n        old_size := area.capacity\n        if new_size > old_size then\n          set_area (area.aliased_resized_area (new_size.max (old_size + additional_space)))\n        end\n        if new_lower < lower then\n            -- We have inserted below the previous `lower'. We need to shift entries to the right\n            -- before we can insert `v'.\n          l_offset := lower - new_lower\n          l_count := capacity\n          if not l_increased_by_one and l_offset > l_count then\n              -- With the `new_lower' given, the data has to move\n              -- beyond the `area''s count which requires us to fill\n              -- the gap between the old data's location and the new one\n              -- with the default value.\n            area.fill_with (({G}).default, l_count, l_offset - 1)\n          end\n          area.move_data (0, l_offset, l_count)\n          if not l_increased_by_one then\n              -- We start at `1' and not `0' because next instruction\n              -- will update the item at position `0'.\n            area.fill_with (({G}).default, 1, l_offset - 1)\n          end\n            -- Insert `v' at the new lower position.\n          area.put (v, 0)\n        else\n          if new_size > area.count then\n              -- We are adding to the new `upper' position. First we fill the non-initialized\n              -- elements if any up to `new_size - 2' (i.e. up the the item prior to `upper').\n            if not l_increased_by_one then\n              area.fill_with (({G}).default, area.count, new_size - 2)\n            end\n              -- Add `v' at upper position.\n            area.extend (v)\n          else\n              -- Here `lower' hasn't changed\n            area.put (v, i - lower)\n          end\n        end\n      end\n      lower := new_lower\n      upper := new_upper\n    ensure\n      inserted: item (i) = v\n      higher_count: count >= old count\n      lower_set: lower = (old lower).min (i)\n      upper_set: upper = (old upper).max (i)\n    end\n\n  fill_with (v: G)\n      -- Set items between `lower' and `upper' with `v'.\n    do\n      area.fill_with (v, 0, upper - lower)\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = old count\n      filled: filled_with (v)\n    end\n\n  subcopy (other: ARRAY [like item]; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy items of `other' within bounds `start_pos' and `end_pos'\n      -- to current array starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: start_pos >= other.lower\n      valid_end_pos: end_pos <= other.upper\n      valid_bounds: start_pos <= end_pos + 1\n      valid_index_pos: index_pos >= lower\n      enough_space: (upper - index_pos) >= (end_pos - start_pos)\n    do\n      area.copy_data (other.area, start_pos - other.lower, index_pos - lower, end_pos - start_pos + 1)\n    ensure\n      -- copied: forall `i' in 0 .. (`end_pos'-`start_pos'),\n      --     item (index_pos + i) = other.item (start_pos + i)\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    do\n      area.do_all_in_bounds (action, 0, count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    do\n      area.do_if_in_bounds (action, test, 0, count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.there_exists_in_bounds (test, 0, count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.for_all_in_bounds (test, 0, count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Removal\n\n  wipe_out\n      -- Make array empty.\n    obsolete\n      \"Not applicable since not `prunable'. Use `discard_items' instead.\"\n    do\n      discard_items\n    end\n\n  discard_items\n      -- Reset all items to default values with reallocation.\n    require\n      has_default: ({G}).has_default\n    do\n      create area.make_filled (({G}).default, capacity)\n    ensure\n      default_items: all_default\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    require\n      has_default: ({G}).has_default\n    do\n      area.fill_with (({G}).default, 0, area.count - 1)\n    ensure\n      stable_lower: lower = old lower\n      stable_upper: upper = old upper\n      default_items: all_default\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all items except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    do\n      if n < count then\n        upper := lower + n - 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_lower: lower = old lower\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all items except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        lower := upper - n + 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_upper: upper = old upper\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_upper: upper = old upper\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_head (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_lower: lower = old lower\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > capacity then\n        conservative_resize_with_default (({G}).default, lower, upper + i - capacity)\n      end\n    end\n\n  conservative_resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \" `conservative_resize' is not void-safe statically. Use `conservative_resize_with_default' instead. [07-2010]\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  conservative_resize_with_default (a_default_value: G; min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    require\n      good_indices: min_index <= max_index\n    local\n      new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      offset: INTEGER\n    do\n      if empty_area then\n        set_area (area.aliased_resized_area_with_default (a_default_value, max_index - min_index + 1))\n        lower := min_index\n        upper := max_index\n      else\n        new_lower := min_index.min (lower)\n        new_upper := max_index.max (upper)\n        new_size := new_upper - new_lower + 1\n        if new_size > area.count then\n          set_area (area.aliased_resized_area_with_default (a_default_value, new_size))\n        end\n        if new_lower < lower then\n          offset := lower - new_lower\n          area.move_data (0, offset, upper - lower + 1)\n          area.fill_with (a_default_value, 0, offset - 1)\n        end\n        lower := new_lower\n        upper := new_upper\n      end\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \"Use `conservative_resize_with_default' instead as future versions will implement `resize' as specified in ELKS.\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area.capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: same_items (old twin)\n    end\n\n  rebase (a_lower: like lower)\n      -- Without changing the actual content of `Current' we set `lower' to `a_lower'\n      -- and `upper' accordingly to `a_lower + count - 1'.\n    local\n      l_old_lower: like lower\n    do\n      l_old_lower := lower\n      lower := a_lower\n      upper := a_lower + (upper - l_old_lower)\n    ensure\n      lower_set: lower = a_lower\n      upper_set: upper = a_lower + old count - 1\n    end\n\nfeature -- Conversion\n\n  to_c: ANY\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    do\n      Result := area\n    end\n\n  to_cil: NATIVE_ARRAY [G]\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := area.native_array\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_special: SPECIAL [G]\n      -- 'area'.\n    do\n      Result := area\n    ensure\n      to_special_not_void: Result /= Void\n    end\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [G]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := lower\n      until\n        i > upper\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area.twin)\n      end\n    ensure then\n      equal_areas: area ~ other.area\n    end\n\n  subarray (start_pos, end_pos: INTEGER): ARRAY [G]\n      -- Array made of items of current array within\n      -- bounds `start_pos' and `end_pos'.\n    require\n      valid_start_pos: valid_index (start_pos)\n      valid_end_pos: end_pos <= upper\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n    do\n      if start_pos <= end_pos then\n        create Result.make_filled (item (start_pos), start_pos, end_pos)\n          -- Only copy elements if needed.\n        Result.subcopy (Current, start_pos, end_pos, start_pos)\n      else\n          -- make empty\n        create Result.make_empty\n        Result.rebase (start_pos)\n      end\n    ensure\n      lower: Result.lower = start_pos\n      upper: Result.upper = end_pos\n      -- copied: forall `i' in `start_pos' .. `end_pos',\n      --     Result.item (i) = item (i)\n    end\n\nfeature {NONE} -- Inapplicable\n\n  prune (v: G)\n      -- Remove first occurrence of `v' if any.\n      -- (Precondition is False.)\n    do\n    end\n\n  extend (v: G)\n      -- Add `v' to structure.\n      -- (Precondition is False.)\n    do\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: BOOLEAN\n      -- Is `area' empty?\n    do\n      Result := area = Void or else area.capacity = 0\n    end\n\ninvariant\n\n  area_exists: area /= Void\n  consistent_size: capacity = upper - lower + 1\n  non_negative_count: count >= 0\n  index_set_has_same_count: valid_index_set\n-- Internal discussion haven't reached an agreement on this invariant\n--  index_set_has_same_bounds: ((index_set.lower = lower) and\n--        (index_set.upper = lower + count - 1))\n\nend\n"});
__eiffel_builtin.push({"filename":"cycle.e","content":"class A1\ninherit\n  B1\nend\n\nclass B1\ninherit\n  A1\nend\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      asa_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\n-- convert\n--   make_from_reference ({INTEGER_32_REF}),\n--   to_real: {REAL_32},\n--   to_double: {REAL_64},\n--   to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil,\n  make_from_separate\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    extern\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFueS5lIiwiYXJyYXkuZSIsImN5Y2xlLmUiLCJpbnRlZ2VyLmUiLCJzdHJpbmcuZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FDREE7QUNBQTtBQ0FBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzXG4gIEFOWVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBjb25mb3Jtc190byAob3RoZXI6IEFOWSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBjb25mb3JtIHRvIHR5cGVcbiAgICAgIC0tIG9mIGBvdGhlcicgKGFzIHBlciBFaWZmZWw6IFRoZSBMYW5ndWFnZSwgY2hhcHRlciAxMyk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgc2FtZV90eXBlIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBpZGVudGljYWwgdG8gdHlwZSBvZiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvbmZvcm1zX3RvIChvdGhlcikgYW5kXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkXG4gICAgICAtLSBlcXVhbCB0byBjdXJyZW50IG9iamVjdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIgfiBDdXJyZW50XG4gICAgICBjb25zaXN0ZW50OiBzdGFuZGFyZF9pc19lcXVhbCAob3RoZXIpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QsIGFuZCBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3R5cGU6IFJlc3VsdCBpbXBsaWVzIHNhbWVfdHlwZSAob3RoZXIpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG90aGVyLnN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBlcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkXG4gICAgICAtLSB0byBvYmplY3RzIGNvbnNpZGVyZWQgZXF1YWw/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkIHRvXG4gICAgICAtLSBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlP1xuICAgICAgLS0gQWx3YXlzIHVzZXMgZGVmYXVsdCBvYmplY3QgY29tcGFyaXNvbiBjcml0ZXJpb24uXG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuc3RhbmRhcmRfaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19kZWVwX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBDdXJyZW50JyBhbmQgYG90aGVyJyBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfZGVlcF9lcXVhbCAoQ3VycmVudClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkXG4gICAgICAtLSBvciBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIGRvXG4gICAgICBpZiBhID0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiID0gVm9pZFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYiAvPSBWb2lkIGFuZCB0aGVuIGEuaXNfZGVlcF9lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2VxdWFsIChhLCBiKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgYm90aF9vcl9ub25lX3ZvaWQ6IChhID0gVm9pZCkgaW1wbGllcyAoUmVzdWx0ID0gKGIgPSBWb2lkKSlcbiAgICAgIHNhbWVfdHlwZTogKFJlc3VsdCBhbmQgKGEgLz0gVm9pZCkpIGltcGxpZXMgKGIgLz0gVm9pZCBhbmQgdGhlbiBhLnNhbWVfdHlwZSAoYikpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIGRlZXBfZXF1YWwgKGIsIGEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgaW86IFNURF9GSUxFU1xuICAgICAgLS0gSGFuZGxlIHRvIHN0YW5kYXJkIGZpbGUgc2V0dXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpb19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gTmV3IHN0cmluZyBjb250YWluaW5nIHRlcnNlIHByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRhZ2dlZF9vdXRcbiAgICBlbnN1cmVcbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdGFnZ2VkX291dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHRhZ2dlZF9vdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcHJpbnQgKG86IGRldGFjaGFibGUgQU5ZKVxuICAgICAgLS0gV3JpdGUgdGVyc2UgZXh0ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYG8nXG4gICAgICAtLSBvbiBzdGFuZGFyZCBvdXRwdXQuXG4gICAgZG9cbiAgICAgIGlmIG8gLz0gVm9pZCB0aGVuXG4gICAgICAgIGlvLnB1dF9zdHJpbmcgKG8ub3V0KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgZGVmYXVsdF9jcmVhdGVcbiAgICAgIC0tIFByb2Nlc3MgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBubyBjcmVhdGlvbiBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG4gIGZyb3plbiBkbG9fbm90aGluZ1xuICAgICAgLS0gRXhlY3V0ZSBhIG51bGwgYWN0aW9uLlxuICAgIGRvXG4gICAgZW5kXG5cbmludmFyaWFudFxuICByZWZsZXhpdmVfZXF1YWxpdHk6IHN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICByZWZsZXhpdmVfY29uZm9ybWFuY2U6IGNvbmZvcm1zX3RvIChDdXJyZW50KVxuXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDEtMjUgMTQ6MTg6MjAgLTA4MDAgKEZyaSwgMjUgSmFuIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTM4ICRcIlxuXG5jbGFzcyBBUlJBWSBbR10gaW5oZXJpdFxuXG4gIFJFU0laQUJMRSBbR11cbiAgICByZWRlZmluZVxuICAgICAgZnVsbCwgY29weSwgaXNfZXF1YWwsIHJlc2l6YWJsZVxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIGl0ZW0gYXMgaXRlbSBhbGlhcyBcIltdXCJcbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtHXVxuICAgIGV4cG9ydFxuICAgICAge0FSUkFZfSBzZXRfYXJlYVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgaXRlbSwgcHV0LCBhdCwgdmFsaWRfaW5kZXhcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2VfZW1wdHksXG4gIG1ha2UsXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fYXJyYXksXG4gIG1ha2VfZnJvbV9zcGVjaWFsLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7TkFUSVZFX0FSUkFZIFtHXX0sXG4gIHRvX3NwZWNpYWw6IHtTUEVDSUFMIFtHXX0sXG4gIG1ha2VfZnJvbV9jaWwgKHtOQVRJVkVfQVJSQVkgW0ddfSlcblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHlcbiAgICAgIC0tIEFsbG9jYXRlIGVtcHR5IGFycmF5IHN0YXJ0aW5nIGF0IGAxJy5cbiAgICBkb1xuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gMFxuICAgICAgbWFrZV9lbXB0eV9hcmVhICgwKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAwXG4gICAgICBpdGVtc19zZXQ6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBhcnJheTsgc2V0IGluZGV4IGludGVydmFsIHRvXG4gICAgICAtLSBgbWluX2luZGV4JyAuLiBgbWF4X2luZGV4Jzsgc2V0IGFsbCB2YWx1ZXMgdG8gZGVmYXVsdC5cbiAgICAgIC0tIChNYWtlIGFycmF5IGVtcHR5IGlmIGBtaW5faW5kZXgnID0gYG1heF9pbmRleCcgKyAxKS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9ib3VuZHM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG46IElOVEVHRVJcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBuIDo9IG1heF9pbmRleCAtIG1pbl9pbmRleCArIDFcbiAgICAgIGVuZFxuICAgICAgbWFrZV9maWxsZWRfYXJlYSAoYV9kZWZhdWx0X3ZhbHVlLCBuKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IG1pbl9pbmRleFxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IG1heF9pbmRleFxuICAgICAgaXRlbXNfc2V0OiBmaWxsZWRfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlKVxuICAgIGVuZFxuXG4gIG1ha2UgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgYXJyYXk7IHNldCBpbmRleCBpbnRlcnZhbCB0b1xuICAgICAgLS0gYG1pbl9pbmRleCcgLi4gYG1heF9pbmRleCc7IHNldCBhbGwgdmFsdWVzIHRvIGRlZmF1bHQuXG4gICAgICAtLSAoTWFrZSBhcnJheSBlbXB0eSBpZiBgbWluX2luZGV4JyA9IGBtYXhfaW5kZXgnICsgMSkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiIGBtYWtlJyBpcyBub3Qgdm9pZC1zYWZlIHN0YXRpY2FsbHkuIFVzZSBgbWFrZV9lbXB0eScgb3IgYG1ha2VfZmlsbGVkJyBpbnN0ZWFkLiBbMDctMjAxMF1cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2JvdW5kczogbWluX2luZGV4IDw9IG1heF9pbmRleCArIDFcbiAgICAgIGhhc19kZWZhdWx0OiBtaW5faW5kZXggPD0gbWF4X2luZGV4IGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBtYWtlX2ZpbGxlZF9hcmVhICgoe0d9KS5kZWZhdWx0LCBtYXhfaW5kZXggLSBtaW5faW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlX2VtcHR5X2FyZWEgKDApXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBtaW5faW5kZXhcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBtYXhfaW5kZXhcbiAgICAgIGl0ZW1zX3NldDogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYXJyYXkgKGE6IEFSUkFZIFtHXSlcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgaXRlbXMgb2YgYGEnLlxuICAgICAgLS0gKFVzZWZ1bCBpbiBwcm9wZXIgZGVzY2VuZGFudHMgb2YgY2xhc3MgYEFSUkFZJyxcbiAgICAgIC0tIHRvIGluaXRpYWxpemUgYW4gYXJyYXktbGlrZSBvYmplY3QgZnJvbSBhIG1hbmlmZXN0IGFycmF5LilcbiAgICByZXF1aXJlXG4gICAgICBhcnJheV9leGlzdHM6IGEgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfYXJlYSAoYS5hcmVhKVxuICAgICAgbG93ZXIgOj0gYS5sb3dlclxuICAgICAgdXBwZXIgOj0gYS51cHBlclxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYS5hcmVhXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gYS5sb3dlclxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IGEudXBwZXJcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3BlY2lhbCAoYTogU1BFQ0lBTCBbR10pXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgZnJvbSBpdGVtcyBvZiBgYScuXG4gICAgcmVxdWlyZVxuICAgICAgc3BlY2lhbF9hdHRhY2hlZDogYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9hcmVhIChhKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYS5jb3VudFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhLmNvdW50XG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAobmE6IE5BVElWRV9BUlJBWSBbbGlrZSBpdGVtXSlcbiAgICAgIC0tIEluaXRpYWxpemUgYXJyYXkgZnJvbSBgbmEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIG5hX25vdF92b2lkOiBuYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZnJvbV9uYXRpdmVfYXJyYXkgKG5hKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYXJlYS5jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IEcgYXNzaWduIHB1dFxuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gbG93ZXIpXG4gICAgZW5kXG5cbiAgZW50cnkgKGk6IElOVEVHRVIpOiBHXG4gICAgICAtLSBFbnRyeSBhdCBpbmRleCBgaScsIGlmIGluIGluZGV4IGludGVydmFsXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpXG4gICAgZW5kXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgdicgYXBwZWFyIGluIGFycmF5P1xuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBuYiA6PSB1cHBlciAtIGxvd2VyXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiBhbmQgdiAvPSBWb2lkIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgfiB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgPSB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgbG93ZXI6IElOVEVHRVJcbiAgICAgIC0tIE1pbmltdW0gaW5kZXhcblxuICB1cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuXG4gIGNvdW50LCBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGF2YWlsYWJsZSBpbmRpY2VzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjb25zaXN0ZW50X3dpdGhfYm91bmRzOiBSZXN1bHQgPSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuZFxuXG4gIG9jY3VycmVuY2VzICh2OiBHKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGB2JyBhcHBlYXJzIGluIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gdXBwZXJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpIH4gdiB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IHVwcGVyXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSA9IHYgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW5kZXhfc2V0OiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBSYW5nZSBvZiBhY2NlcHRhYmxlIGluZGV4ZXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsb3dlciwgdXBwZXIpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICBzYW1lX2JvdW5kczpcbiAgICAgICAgKChSZXN1bHQubG93ZXIgPSBsb3dlcikgYW5kIChSZXN1bHQudXBwZXIgPSB1cHBlcikpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYXJyYXkgbWFkZSBvZiB0aGUgc2FtZSBpdGVtcyBhcyBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlaWYgbG93ZXIgPSBvdGhlci5sb3dlciBhbmQgdGhlbiB1cHBlciA9IG90aGVyLnVwcGVyIGFuZCB0aGVuXG4gICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb25cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIG5vdCBSZXN1bHQgb3IgaSA+IHVwcGVyXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpIH4gb3RoZXIuaXRlbSAoaSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBhcmVhLnNhbWVfaXRlbXMgKG90aGVyLmFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBhbGxfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBzZXQgdG8gZGVmYXVsdCB2YWx1ZXM/XG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAoe0d9KS5oYXNfZGVmYXVsdCBhbmQgdGhlbiBhcmVhLmZpbGxlZF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY291bnQgPSAwIG9yIGVsc2VcbiAgICAgICAgKChub3QgYXR0YWNoZWQgaXRlbSAodXBwZXIpIGFzIGkgb3IgZWxzZSBpID0gKHtHfSkuZGVmYXVsdCkgYW5kXG4gICAgICAgIHN1YmFycmF5IChsb3dlciwgdXBwZXIgLSAxKS5hbGxfZGVmYXVsdCkpXG4gICAgZW5kXG5cbiAgZmlsbGVkX3dpdGggKHY6IEcpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIHNldCB0byBgdic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLmZpbGxlZF93aXRoICh2LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvdW50ID0gMCBvciBlbHNlXG4gICAgICAgIChpdGVtICh1cHBlcikgPSB2IGFuZCBzdWJhcnJheSAobG93ZXIsIHVwcGVyIC0gMSkuZmlsbGVkX3dpdGggKHYpKSlcbiAgICBlbmRcblxuICBmdWxsOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZmlsbGVkIHRvIGNhcGFjaXR5PyAoQW5zd2VyOiB5ZXMpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgc2FtZV9pdGVtcyAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBvdGhlcicgYW5kIEN1cnJlbnQgaGF2ZSBzYW1lIGl0ZW1zP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCAwLCAwLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChjb3VudCA9IG90aGVyLmNvdW50KSBhbmQgdGhlblxuICAgICAgICAoY291bnQgPSAwIG9yIGVsc2UgKGl0ZW0gKHVwcGVyKSA9IG90aGVyLml0ZW0gKG90aGVyLnVwcGVyKVxuICAgICAgICBhbmQgc3ViYXJyYXkgKGxvd2VyLCB1cHBlciAtIDEpLnNhbWVfaXRlbXNcbiAgICAgICAgKG90aGVyLnN1YmFycmF5IChvdGhlci5sb3dlciwgb3RoZXIudXBwZXIgLSAxKSkpKSlcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgYXJyYXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobG93ZXIgPD0gaSkgYW5kIHRoZW4gKGkgPD0gdXBwZXIpXG4gICAgZW5kXG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIGFkZGVkP1xuICAgICAgLS0gKEFuc3dlcjogbm8sIGFsdGhvdWdoIGFycmF5IG1heSBiZSByZXNpemVkLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiBuby4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgIGVuZFxuXG4gIHJlc2l6YWJsZTogQk9PTEVBTlxuICAgICAgLS0gQ2FuIGFycmF5IGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXhfc2V0OiBCT09MRUFOXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpbmRleF9zZXQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBlbnRlciAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBmb3JjZSAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQXNzaWduIGl0ZW0gYHYnIHRvIGBpJy10aCBlbnRyeS5cbiAgICAgIC0tIFJlc2l6ZSB0aGUgYXJyYXkgaWYgYGknIGZhbGxzIG91dCBvZiBjdXJyZW50bHkgZGVmaW5lZCBib3VuZHM7IHByZXNlcnZlIGV4aXN0aW5nIGl0ZW1zLlxuICAgICAgLS0gSW4gdm9pZC1zYWZlIG1vZGUsIGlmICh7R30pLmhhc19kZWZhdWx0IGRvZXMgbm90IGhvbGQsIHRoZW4geW91IGNhbiBvbmx5IGluc2VydCBiZXR3ZWVuXG4gICAgICAtLSBgbG93ZXIgLSAxJyBvciBgdXBwZXIgKyAxJyBwb3NpdGlvbiBpbiB0aGUgQVJSQVkuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHRfaWZfdG9vX2xvdzpcbiAgICAgICAgKGkgPCBsb3dlciAtIDEgYW5kIGxvd2VyIC89IHtsaWtlIGxvd2VyfS5taW5fdmFsdWUpIGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICAgIGhhc19kZWZhdWx0X2lmX3Rvb19oaWdoOlxuICAgICAgICAoaSA+IHVwcGVyICsgMSBhbmQgdXBwZXIgLz0ge2xpa2UgdXBwZXJ9Lm1heF92YWx1ZSkgaW1wbGllcyAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGxvY2FsXG4gICAgICBvbGRfc2l6ZSwgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIG5ld19sb3dlciwgbmV3X3VwcGVyOiBJTlRFR0VSXG4gICAgICBsX2NvdW50LCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lOiBCT09MRUFOXG4gICAgZG9cbiAgICAgIG5ld19sb3dlciA6PSBsb3dlci5taW4gKGkpXG4gICAgICBuZXdfdXBwZXIgOj0gdXBwZXIubWF4IChpKVxuICAgICAgbmV3X3NpemUgOj0gbmV3X3VwcGVyIC0gbmV3X2xvd2VyICsgMVxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lIDo9IChpID0gdXBwZXIgKyAxKSBvciAoaSA9IGxvd2VyIC0gMSlcbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICAgIC0tIExpc3QgaXMgZW1wdHkuIEZpcnN0IHdlIGNyZWF0ZSBhbiBlbXB0eSBTUEVDSUFMIG9mIHRoZSByaWdodCBjYXBhY2l0eS5cbiAgICAgICAgbWFrZV9lbXB0eV9hcmVhIChuZXdfc2l6ZS5tYXggKGFkZGl0aW9uYWxfc3BhY2UpKVxuICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG5lZWQgdG8gZmlsbCB0aGUgU1BFQ0lBTCBmb3IgYDAnIHRvIGBuZXdfc2l6ZSAtIDInIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIG5ld19zaXplIC0gMilcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuZXh0ZW5kICh2KVxuICAgICAgZWxzZVxuICAgICAgICBvbGRfc2l6ZSA6PSBhcmVhLmNhcGFjaXR5XG4gICAgICAgIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlblxuICAgICAgICAgIHNldF9hcmVhIChhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuZXdfc2l6ZS5tYXggKG9sZF9zaXplICsgYWRkaXRpb25hbF9zcGFjZSkpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgICAgLS0gV2UgaGF2ZSBpbnNlcnRlZCBiZWxvdyB0aGUgcHJldmlvdXMgYGxvd2VyJy4gV2UgbmVlZCB0byBzaGlmdCBlbnRyaWVzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgLS0gYmVmb3JlIHdlIGNhbiBpbnNlcnQgYHYnLlxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxvd2VyIC0gbmV3X2xvd2VyXG4gICAgICAgICAgbF9jb3VudCA6PSBjYXBhY2l0eVxuICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgYW5kIGxfb2Zmc2V0ID4gbF9jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdpdGggdGhlIGBuZXdfbG93ZXInIGdpdmVuLCB0aGUgZGF0YSBoYXMgdG8gbW92ZVxuICAgICAgICAgICAgICAtLSBiZXlvbmQgdGhlIGBhcmVhJydzIGNvdW50IHdoaWNoIHJlcXVpcmVzIHVzIHRvIGZpbGxcbiAgICAgICAgICAgICAgLS0gdGhlIGdhcCBiZXR3ZWVuIHRoZSBvbGQgZGF0YSdzIGxvY2F0aW9uIGFuZCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAtLSB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIGxfY291bnQsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBhcmVhLm1vdmVfZGF0YSAoMCwgbF9vZmZzZXQsIGxfY291bnQpXG4gICAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIHN0YXJ0IGF0IGAxJyBhbmQgbm90IGAwJyBiZWNhdXNlIG5leHQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgLS0gd2lsbCB1cGRhdGUgdGhlIGl0ZW0gYXQgcG9zaXRpb24gYDAnLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDEsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEluc2VydCBgdicgYXQgdGhlIG5ldyBsb3dlciBwb3NpdGlvbi5cbiAgICAgICAgICBhcmVhLnB1dCAodiwgMClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIG5ld19zaXplID4gYXJlYS5jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIGFyZSBhZGRpbmcgdG8gdGhlIG5ldyBgdXBwZXInIHBvc2l0aW9uLiBGaXJzdCB3ZSBmaWxsIHRoZSBub24taW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgLS0gZWxlbWVudHMgaWYgYW55IHVwIHRvIGBuZXdfc2l6ZSAtIDInIChpLmUuIHVwIHRoZSB0aGUgaXRlbSBwcmlvciB0byBgdXBwZXInKS5cbiAgICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgdGhlblxuICAgICAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgYXJlYS5jb3VudCwgbmV3X3NpemUgLSAyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIC0tIEFkZCBgdicgYXQgdXBwZXIgcG9zaXRpb24uXG4gICAgICAgICAgICBhcmVhLmV4dGVuZCAodilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEhlcmUgYGxvd2VyJyBoYXNuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGxvd2VyIDo9IG5ld19sb3dlclxuICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgICBoaWdoZXJfY291bnQ6IGNvdW50ID49IG9sZCBjb3VudFxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IChvbGQgbG93ZXIpLm1pbiAoaSlcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAob2xkIHVwcGVyKS5tYXggKGkpXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoICh2OiBHKVxuICAgICAgLS0gU2V0IGl0ZW1zIGJldHdlZW4gYGxvd2VyJyBhbmQgYHVwcGVyJyB3aXRoIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5maWxsX3dpdGggKHYsIDAsIHVwcGVyIC0gbG93ZXIpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfZGVmaW5pdGlvbjogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYpXG4gICAgZW5kXG5cbiAgc3ViY29weSAob3RoZXI6IEFSUkFZIFtsaWtlIGl0ZW1dOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgaXRlbXMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIHRvIGN1cnJlbnQgYXJyYXkgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogc3RhcnRfcG9zID49IG90aGVyLmxvd2VyXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IG90aGVyLnVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiBpbmRleF9wb3MgPj0gbG93ZXJcbiAgICAgIGVub3VnaF9zcGFjZTogKHVwcGVyIC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBkb1xuICAgICAgYXJlYS5jb3B5X2RhdGEgKG90aGVyLmFyZWEsIHN0YXJ0X3BvcyAtIG90aGVyLmxvd2VyLCBpbmRleF9wb3MgLSBsb3dlciwgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgZW5zdXJlXG4gICAgICAtLSBjb3BpZWQ6IGZvcmFsbCBgaScgaW4gMCAuLiAoYGVuZF9wb3MnLWBzdGFydF9wb3MnKSxcbiAgICAgIC0tICAgICBpdGVtIChpbmRleF9wb3MgKyBpKSA9IG90aGVyLml0ZW0gKHN0YXJ0X3BvcyArIGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uLCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZG9faWYgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9faWZfaW5fYm91bmRzIChhY3Rpb24sIHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLnRoZXJlX2V4aXN0c19pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBmb3JfYWxsICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGFsbCBpdGVtcz9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuZm9yX2FsbF9pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBkb19hbGxfd2l0aF9pbmRleCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0csIElOVEVHRVJdXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIHJlY2VpdmVzIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl0sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIGFuZCBgdGVzdCcgcmVjZWl2ZSB0aGUgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2xfYXJlYS5pdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2xfYXJlYS5pdGVtIChpKSwgal0pXG4gICAgICAgIGVuZFxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICB3aXBlX291dFxuICAgICAgLS0gTWFrZSBhcnJheSBlbXB0eS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJOb3QgYXBwbGljYWJsZSBzaW5jZSBub3QgYHBydW5hYmxlJy4gVXNlIGBkaXNjYXJkX2l0ZW1zJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGRpc2NhcmRfaXRlbXNcbiAgICBlbmRcblxuICBkaXNjYXJkX2l0ZW1zXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMgd2l0aCByZWFsbG9jYXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgoe0d9KS5kZWZhdWx0LCBjYXBhY2l0eSlcbiAgICBlbnN1cmVcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCBhcmVhLmNvdW50IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHN0YWJsZV9sb3dlcjogbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIHN0YWJsZV91cHBlcjogdXBwZXIgPSBvbGQgdXBwZXJcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyICsgbiAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBsb3dlciA6PSB1cHBlciAtIG4gKyAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBpdGVtcztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICB1cHBlciA6PSBsb3dlciAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhICgwKVxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IChvbGQgY291bnQgLSBuKS5tYXggKDApXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGl0ZW1zO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyIC0gMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKDApXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCAtIG4pLm1heCAoMClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhdCBsZWFzdCBgaScuXG4gICAgZG9cbiAgICAgIGlmIGkgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0ICgoe0d9KS5kZWZhdWx0LCBsb3dlciwgdXBwZXIgKyBpIC0gY2FwYWNpdHkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjb25zZXJ2YXRpdmVfcmVzaXplIChtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBhcnJheSBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gaW5kaWNlcyBkb3duIHRvIGBtaW5faW5kZXgnIGFuZCB1cCB0byBgbWF4X2luZGV4Jy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgaXRlbS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCIgYGNvbnNlcnZhdGl2ZV9yZXNpemUnIGlzIG5vdCB2b2lkLXNhZmUgc3RhdGljYWxseS4gVXNlIGBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCcgaW5zdGVhZC4gWzA3LTIwMTBdXCJcbiAgICByZXF1aXJlXG4gICAgICBnb29kX2luZGljZXM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXhcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoKHtHfSkuZGVmYXVsdCwgbWluX2luZGV4LCBtYXhfaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBub19sb3dfbG9zdDogbG93ZXIgPSBtaW5faW5kZXggb3IgZWxzZSBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgbm9faGlnaF9sb3N0OiB1cHBlciA9IG1heF9pbmRleCBvciBlbHNlIHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2UgYXJyYXkgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGluZGljZXMgZG93biB0byBgbWluX2luZGV4JyBhbmQgdXAgdG8gYG1heF9pbmRleCcuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBuZXdfbG93ZXIsIG5ld191cHBlcjogSU5URUdFUlxuICAgICAgb2Zmc2V0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbWF4X2luZGV4IC0gbWluX2luZGV4ICsgMSkpXG4gICAgICAgIGxvd2VyIDo9IG1pbl9pbmRleFxuICAgICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGVsc2VcbiAgICAgICAgbmV3X2xvd2VyIDo9IG1pbl9pbmRleC5taW4gKGxvd2VyKVxuICAgICAgICBuZXdfdXBwZXIgOj0gbWF4X2luZGV4Lm1heCAodXBwZXIpXG4gICAgICAgIG5ld19zaXplIDo9IG5ld191cHBlciAtIG5ld19sb3dlciArIDFcbiAgICAgICAgaWYgbmV3X3NpemUgPiBhcmVhLmNvdW50IHRoZW5cbiAgICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbmV3X3NpemUpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgIG9mZnNldCA6PSBsb3dlciAtIG5ld19sb3dlclxuICAgICAgICAgIGFyZWEubW92ZV9kYXRhICgwLCBvZmZzZXQsIHVwcGVyIC0gbG93ZXIgKyAxKVxuICAgICAgICAgIGFyZWEuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIDAsIG9mZnNldCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBsb3dlciA6PSBuZXdfbG93ZXJcbiAgICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vX2xvd19sb3N0OiBsb3dlciA9IG1pbl9pbmRleCBvciBlbHNlIGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBub19oaWdoX2xvc3Q6IHVwcGVyID0gbWF4X2luZGV4IG9yIGVsc2UgdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICByZXNpemUgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIGFycmF5IHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBpbmRpY2VzIGRvd24gdG8gYG1pbl9pbmRleCcgYW5kIHVwIHRvIGBtYXhfaW5kZXgnLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBpdGVtLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQnIGluc3RlYWQgYXMgZnV0dXJlIHZlcnNpb25zIHdpbGwgaW1wbGVtZW50IGByZXNpemUnIGFzIHNwZWNpZmllZCBpbiBFTEtTLlwiXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKCh7R30pLmRlZmF1bHQsIG1pbl9pbmRleCwgbWF4X2luZGV4KVxuICAgIGVuc3VyZVxuICAgICAgbm9fbG93X2xvc3Q6IGxvd2VyID0gbWluX2luZGV4IG9yIGVsc2UgbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIG5vX2hpZ2hfbG9zdDogdXBwZXIgPSBtYXhfaW5kZXggb3IgZWxzZSB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGFyZWEuY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9pdGVtczogc2FtZV9pdGVtcyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgcmViYXNlIChhX2xvd2VyOiBsaWtlIGxvd2VyKVxuICAgICAgLS0gV2l0aG91dCBjaGFuZ2luZyB0aGUgYWN0dWFsIGNvbnRlbnQgb2YgYEN1cnJlbnQnIHdlIHNldCBgbG93ZXInIHRvIGBhX2xvd2VyJ1xuICAgICAgLS0gYW5kIGB1cHBlcicgYWNjb3JkaW5nbHkgdG8gYGFfbG93ZXIgKyBjb3VudCAtIDEnLlxuICAgIGxvY2FsXG4gICAgICBsX29sZF9sb3dlcjogbGlrZSBsb3dlclxuICAgIGRvXG4gICAgICBsX29sZF9sb3dlciA6PSBsb3dlclxuICAgICAgbG93ZXIgOj0gYV9sb3dlclxuICAgICAgdXBwZXIgOj0gYV9sb3dlciArICh1cHBlciAtIGxfb2xkX2xvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IGFfbG93ZXJcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhX2xvd2VyICsgb2xkIGNvdW50IC0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jOiBBTllcbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFcbiAgICBlbmRcblxuICB0b19jaWw6IE5BVElWRV9BUlJBWSBbR11cbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLm5hdGl2ZV9hcnJheVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3NwZWNpYWw6IFNQRUNJQUwgW0ddXG4gICAgICAtLSAnYXJlYScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhXG4gICAgZW5zdXJlXG4gICAgICB0b19zcGVjaWFsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtHXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbR11cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbG93ZXJcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiB1cHBlclxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBSZWluaXRpYWxpemUgYnkgY29weWluZyBhbGwgdGhlIGl0ZW1zIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYGNsb25lJy4pXG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgc2V0X2FyZWEgKG90aGVyLmFyZWEudHdpbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBlcXVhbF9hcmVhczogYXJlYSB+IG90aGVyLmFyZWFcbiAgICBlbmRcblxuICBzdWJhcnJheSAoc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogQVJSQVkgW0ddXG4gICAgICAtLSBBcnJheSBtYWRlIG9mIGl0ZW1zIG9mIGN1cnJlbnQgYXJyYXkgd2l0aGluXG4gICAgICAtLSBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IHZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IHVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgIGRvXG4gICAgICBpZiBzdGFydF9wb3MgPD0gZW5kX3BvcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKGl0ZW0gKHN0YXJ0X3BvcyksIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICAgICAgICAtLSBPbmx5IGNvcHkgZWxlbWVudHMgaWYgbmVlZGVkLlxuICAgICAgICBSZXN1bHQuc3ViY29weSAoQ3VycmVudCwgc3RhcnRfcG9zLCBlbmRfcG9zLCBzdGFydF9wb3MpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gbWFrZSBlbXB0eVxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHlcbiAgICAgICAgUmVzdWx0LnJlYmFzZSAoc3RhcnRfcG9zKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcjogUmVzdWx0Lmxvd2VyID0gc3RhcnRfcG9zXG4gICAgICB1cHBlcjogUmVzdWx0LnVwcGVyID0gZW5kX3Bvc1xuICAgICAgLS0gY29waWVkOiBmb3JhbGwgYGknIGluIGBzdGFydF9wb3MnIC4uIGBlbmRfcG9zJyxcbiAgICAgIC0tICAgICBSZXN1bHQuaXRlbSAoaSkgPSBpdGVtIChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBwcnVuZSAodjogRylcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2JyBpZiBhbnkuXG4gICAgICAtLSAoUHJlY29uZGl0aW9uIGlzIEZhbHNlLilcbiAgICBkb1xuICAgIGVuZFxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBgdicgdG8gc3RydWN0dXJlLlxuICAgICAgLS0gKFByZWNvbmRpdGlvbiBpcyBGYWxzZS4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBlbXB0eV9hcmVhOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYXJlYScgZW1wdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhID0gVm9pZCBvciBlbHNlIGFyZWEuY2FwYWNpdHkgPSAwXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGFyZWFfZXhpc3RzOiBhcmVhIC89IFZvaWRcbiAgY29uc2lzdGVudF9zaXplOiBjYXBhY2l0eSA9IHVwcGVyIC0gbG93ZXIgKyAxXG4gIG5vbl9uZWdhdGl2ZV9jb3VudDogY291bnQgPj0gMFxuICBpbmRleF9zZXRfaGFzX3NhbWVfY291bnQ6IHZhbGlkX2luZGV4X3NldFxuLS0gSW50ZXJuYWwgZGlzY3Vzc2lvbiBoYXZlbid0IHJlYWNoZWQgYW4gYWdyZWVtZW50IG9uIHRoaXMgaW52YXJpYW50XG4tLSAgaW5kZXhfc2V0X2hhc19zYW1lX2JvdW5kczogKChpbmRleF9zZXQubG93ZXIgPSBsb3dlcikgYW5kXG4tLSAgICAgICAgKGluZGV4X3NldC51cHBlciA9IGxvd2VyICsgY291bnQgLSAxKSlcblxuZW5kXG4iLCJjbGFzcyBBMVxuaW5oZXJpdFxuICBCMVxuZW5kXG5cbmNsYXNzIEIxXG5pbmhlcml0XG4gIEExXG5lbmRcbiIsImV4cGFuZGVkIGNsYXNzIElOVEVHRVJfMzIgaW5oZXJpdFxuXG4gIElOVEVHRVJfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIG9wcG9zaXRlLFxuICAgICAgaWRlbnRpdHksXG4gICAgICBhc2FfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbCxcbiAgICAgIHRvX2RvdWJsZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl84LFxuICAgICAgdG9fY2hhcmFjdGVyXzMyLFxuICAgICAgYml0X2FuZCxcbiAgICAgIGJpdF9vcixcbiAgICAgIGJpdF94b3IsXG4gICAgICBiaXRfbm90LFxuICAgICAgYml0X3NoaWZ0X2xlZnQsXG4gICAgICBiaXRfc2hpZnRfcmlnaHRcbiAgICBlbmRcblxuY3JlYXRlXG4gIGRlZmF1bHRfY3JlYXRlLFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlXG5cbi0tIGNvbnZlcnRcbi0tICAgbWFrZV9mcm9tX3JlZmVyZW5jZSAoe0lOVEVHRVJfMzJfUkVGfSksXG4tLSAgIHRvX3JlYWw6IHtSRUFMXzMyfSxcbi0tICAgdG9fZG91YmxlOiB7UkVBTF82NH0sXG4tLSAgIHRvX2ludGVnZXJfNjQ6IHtJTlRFR0VSXzY0fVxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogSU5URUdFUl8zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IElOVEVHRVJfMzIpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBJTlRFR0VSXzMyXG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBJTlRFR0VSXzMyXG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fcmVhbDogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fZG91YmxlOiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDggYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3hvciAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X25vdDogSU5URUdFUl8zMlxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5lbmRcbiIsImNsYXNzXG4gIFNUUklOR1xuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR18zMlxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgZW5kXG5cbiAgU1RSSU5HX0dFTkVSQUxcbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaGFzLCBpbmRleF9vZiwgbGFzdF9pbmRleF9vZiwgb2NjdXJyZW5jZXNcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWxcbiAgICBlbmRcblxuICBJTkRFWEFCTEUgW0NIQVJBQ1RFUl8zMiwgSU5URUdFUl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBwcnVuZV9hbGwsXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgUkVTSVpBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dCwgaXRlbSwgYXQsIHB1dCwgdmFsaWRfaW5kZXhcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGVuZFxuXG4gIE1JU01BVENIX0NPUlJFQ1RPUlxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2UsXG4gIG1ha2VfZW1wdHksXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fc3RyaW5nLFxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsLFxuICBtYWtlX2Zyb21fc2VwYXJhdGVcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgbWFrZV9mcm9tX2NpbCAoe1NZU1RFTV9TVFJJTkd9KSxcbiAgYXNfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOCwgU1RSSU5HXzh9XG5cbmZlYXR1cmUgLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBzMzIgdGhlblxuICAgICAgICBtYWtlX2Zyb21fc3RyaW5nIChzMzIpXG4gICAgICBlbHNlXG4gICAgICAgIG1ha2UgKHMuY291bnQpXG4gICAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9jaWwgKGFfc3lzdGVtX3N0cmluZzogZGV0YWNoYWJsZSBTWVNURU1fU1RSSU5HKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBDdXJyZW50IHdpdGggYGFfc3lzdGVtX3N0cmluZycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGFfc3lzdGVtX3N0cmluZy5sZW5ndGggKyBkb3RuZXRfY29udmVydG9yLmVzY2FwZV9jb3VudCAoYV9zeXN0ZW1fc3RyaW5nKVxuICAgICAgZW5kXG4gICAgICBtYWtlIChsX2NvdW50KVxuICAgICAgaWYgbF9jb3VudCA+IDAgYW5kIHRoZW4gYV9zeXN0ZW1fc3RyaW5nIC89IFZvaWQgdGhlblxuICAgICAgICBzZXRfY291bnQgKGxfY291bnQpXG4gICAgICAgIGRvdG5ldF9jb252ZXJ0b3IucmVhZF9zeXN0ZW1fc3RyaW5nX2ludG8gKGFfc3lzdGVtX3N0cmluZywgQ3VycmVudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBjb250ZW50cyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdHJpbmdfaW50byAoQ3VycmVudClcbiAgICBlbnN1cmVcbiAgICAgIG5vX3plcm9fYnl0ZTogbm90IGhhcyAoJyUvMC8nKVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgICAgLS0gY29ycmVjdF9jb3VudDogdGhlIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgY291bnRcbiAgICAgIC0tICAgICAgIGlzIE5VTExcbiAgICBlbmRcblxuICBmcm9tX2Nfc3Vic3RyaW5nIChjX3N0cmluZzogUE9JTlRFUjsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gc3Vic3RyaW5nIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgICAgc3RhcnRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIGVuZF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPD0gZW5kX3BvcyArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlcl9hbmRfY291bnQgKGNfc3RyaW5nICsgKHN0YXJ0X3BvcyAtIDEpLCBsX2NvdW50KVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG8gKEN1cnJlbnQsIDEsIGxfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgLS0gY2hhcmFjdGVyczogZm9yIGFsbCBpIGluIDEuLmNvdW50LCBpdGVtIChpKSBlcXVhbHNcbiAgICAgIC0tICAgICAgIEFTQ0lJIGNoYXJhY3RlciBhdCBhZGRyZXNzIGNfc3RyaW5nICsgKGkgLSAxKVxuICAgIGVuZFxuXG4gIGFkYXB0IChzOiBTVFJJTkdfMzIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9iamVjdCBvZiBhIHR5cGUgY29uZm9ybWluZyB0byB0aGUgdHlwZSBvZiBgcycsXG4gICAgICAtLSBpbml0aWFsaXplZCB3aXRoIGF0dHJpYnV0ZXMgZnJvbSBgcydcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBSZXN1bHQuc2hhcmUgKHMpXG4gICAgZW5zdXJlXG4gICAgICBhZGFwdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNoYXJlZF9pbXBsZW1lbnRhdGlvbjogUmVzdWx0LnNoYXJlZF93aXRoIChzKVxuICAgIGVuZFxuXG4gIHJlbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG1ha2UnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkb1xuICAgICAgbWFrZSAobilcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5X3N0cmluZzogY291bnQgPSAwXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMiBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKVxuICAgIGVuZFxuXG4gIGNvZGUgKGk6IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLm5hdHVyYWxfMzJfY29kZS5hc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgYXJlYTogU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gU3RvcmFnZSBmb3IgY2hhcmFjdGVyc1xuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBleHRlbmRpYmxlOiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gTWF5IG5ldyBpdGVtcyBiZSBhZGRlZD8gKEFuc3dlcjogeWVzLilcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/IChBbnN3ZXI6IHllcy4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvbjogQk9PTEVBTiA9IEZhbHNlXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXQgKHQ6IFJFQURBQkxFX1NUUklOR18zMjsgbjEsIG4yOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGN1cnJlbnQgc3RyaW5nIHRvIHN1YnN0cmluZyBvZiBgdCcgZnJvbSBpbmRpY2VzIGBuMSdcbiAgICAgIC0tIHRvIGBuMicsIG9yIHRvIGVtcHR5IHN0cmluZyBpZiBubyBzdWNoIHN1YnN0cmluZy5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIHM6IFJFQURBQkxFX1NUUklOR18zMlxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKVxuICAgICAgLS0gQ29weSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmRcbiAgICAgIC0tIGBlbmRfcG9zJyB0byBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgICAgZW5vdWdoX3NwYWNlOiAoY291bnQgLSBpbmRleF9wb3MpID49IChlbmRfcG9zIC0gc3RhcnRfcG9zKVxuICAgIGxvY2FsXG4gICAgICBsX290aGVyX2FyZWEsIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGVuZF9wb3MgPj0gc3RhcnRfcG9zIHRoZW5cbiAgICAgICAgbF9vdGhlcl9hcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaWYgbF9hcmVhIC89IGxfb3RoZXJfYXJlYSB0aGVuXG4gICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9vdGhlcl9hcmVhLCBzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGNvcGllZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGluZGV4X3BvcyAtIDEpICtcbiAgICAgICAgb2xkIG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSArXG4gICAgICAgIG9sZCBzdWJzdHJpbmcgKGluZGV4X3BvcyArIChlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCcgdG8gYGVuZF9pbmRleCcgd2l0aCBgcycuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bGxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGRpZmY6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBzX2NvdW50OiBJTlRFR0VSXG4gICAgICBvbGRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBvbGRfY291bnQgOj0gY291bnRcbiAgICAgIGRpZmYgOj0gc19jb3VudCAtIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBuZXdfc2l6ZSA6PSBkaWZmICsgb2xkX2NvdW50XG4gICAgICBpZiBkaWZmID4gMCB0aGVuXG4gICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgdGhlIHN0cmluZy5cbiAgICAgICAgZ3JvdyAobmV3X3NpemUpXG4gICAgICBlbmRcblxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgLS18IFdlIG1vdmUgdGhlIGVuZCBvZiB0aGUgc3RyaW5nIGZvcndhcmQgKGlmIGRpZmYgaXMgPiAwKSwgYmFja3dhcmQgKGlmIGRpZmYgPCAwKSxcbiAgICAgICAgLS18IGFuZCBub3RoaW5nIG90aGVyd2lzZS5cbiAgICAgIGlmIGRpZmYgLz0gMCB0aGVuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChlbmRfaW5kZXgsIGVuZF9pbmRleCArIGRpZmYsIG9sZF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgIGVuZFxuICAgICAgICAtLXwgU2V0IG5ldyBjb3VudFxuICAgICAgc2V0X2NvdW50IChuZXdfc2l6ZSlcbiAgICAgICAgLS18IFdlIGNvcHkgdGhlIHN1YnN0cmluZy5cbiAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBzdGFydF9pbmRleCAtIDEsIHNfY291bnQpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnQgLSBlbmRfaW5kZXggKyBzdGFydF9pbmRleCAtIDFcbiAgICAgIHJlcGxhY2VkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIChzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgK1xuICAgICAgICAgIHMgKyBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nX2FsbCAob3JpZ2luYWwsIG5ldzogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGV4dGVyblxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9ibGFua1xuICAgICAgLS0gUmVwbGFjZSBhbGwgY3VycmVudCBjaGFyYWN0ZXJzIHdpdGggYmxhbmtzLlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgYWxsX2JsYW5rOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKCcgJykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGZpbGxfYmxhbmtcbiAgICAgIC0tIEZpbGwgd2l0aCBgY2FwYWNpdHknIGJsYW5rIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGZpbGxfY2hhcmFjdGVyICgnICcpXG4gICAgZW5zdXJlXG4gICAgICBmaWxsZWQ6IGZ1bGxcbiAgICAgIHNhbWVfc2l6ZTogKGNvdW50ID0gY2FwYWNpdHkpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICAtLSBhbGxfYmxhbms6IEZvciBldmVyeSBgaScgaW4gYGNvdW50Jy4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYEJsYW5rJ1xuICAgIGVuZFxuXG4gIGZpbGxfd2l0aCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBjaGFyYWN0ZXIgd2l0aCBgYycuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbF9jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgYXJlYS5maWxsX3dpdGggKGMsIDAsIGxfY291bnQgLSAxKVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBmaWxsZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIHJlcGxhY2VfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkJ1wiXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoYylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgbG9jYWxcbiAgICAgIG5iOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGVmdF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIG5iLCBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbmJfc3BhY2UgPiBuYiBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChuYl9zcGFjZSkpXG4gICAgICBsb29wXG4gICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudCB2YWx1ZS5cbiAgICAgICAgbmIgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmJfc3BhY2UsIDAsIG5iKVxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGkgOj0gbmJcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwXG4gICAgICBsb29wXG4gICAgICAgIGMgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGMpIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIGFyZSBkb25lLlxuICAgICAgICAgIGkgOj0gLTFcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50LlxuICAgICAgICBjb3VudCA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2hhcmUgKG90aGVyOiBTVFJJTkdfMzIpXG4gICAgICAtLSBNYWtlIGN1cnJlbnQgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcicuXG4gICAgICAtLSBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmdcbiAgICAgIC0tIHdpbGwgYWxzbyBhZmZlY3QgYG90aGVyJywgYW5kIGNvbnZlcnNlbHkuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICBjb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZF9jb3VudDogb3RoZXIuY291bnQgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IG90aGVyLmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbiAgcHV0IChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgYGMnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAoYywgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHB1dF9jb2RlICh2OiBOQVRVUkFMXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknIGJ5IGNoYXJhY3RlciBvZiBjb2RlIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYudG9fY2hhcmFjdGVyXzMyLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgcHJlcGVuZCAobF9zMzIpXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7U1RSSU5HX0dFTkVSQUx9IChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJlY2VkZSwgcHJlcGVuZF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFkZCBgYycgYXQgZnJvbnQuXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCAxLCBjb3VudClcbiAgICAgIGxfYXJlYS5wdXQgKGMsIDApXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCAxKVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgY291bnRcbiAgICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgb2YgY3VycmVudC5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIGxfc19jb3VudCwgY291bnQpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgYmVnaW5uaW5nLlxuICAgICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgMCwgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpICsgQ3VycmVudCkpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBiJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYi5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgZCcgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGQub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGkub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgcHJlcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIGxfczMyIHRoZW5cbiAgICAgICAgYXBwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgb2xkIHMuY291bnRcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCBsX2NvdW50LCBsX3NfY291bnQpXG4gICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKEN1cnJlbnQgKyBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkpKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoY291bnQgKyBzLmNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoQ3VycmVudClcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhcHBlbmRlZDogcyAvPSBWb2lkIGltcGxpZXNcbiAgICAgICAgKGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCB0d2luICsgb2xkIHMudHdpbikpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzggKGk6IElOVEVHRVJfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzE2IChpOiBJTlRFR0VSXzE2KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl8xNlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzE2fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl82NH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfOCAoaTogTkFUVVJBTF84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMTYgKGk6IE5BVFVSQUxfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMzIgKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzMyXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfNjQgKGk6IE5BVFVSQUxfNjQpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzY0XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgcicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHIub3V0KVxuICAgIGVuZFxuXG4gIGFwcGVuZF9kb3VibGUgKGQ6IERPVUJMRSlcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2NoYXJhY3RlciwgZXh0ZW5kIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBBcHBlbmQgYGMnIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgY3VycmVudF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjdXJyZW50X2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBjdXJyZW50X2NvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGN1cnJlbnRfY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBhcmVhLnB1dCAoYywgY3VycmVudF9jb3VudClcbiAgICAgIGNvdW50IDo9IGN1cnJlbnRfY291bnQgKyAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpdGVtX2luc2VydGVkOiBpdGVtIChjb3VudCkgPSBjXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgc3RhYmxlX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgY291bnQgLSAxKSB+IChvbGQgdHdpbilcbiAgICBlbmRcblxuICBhcHBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBiJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoYi5vdXQpXG4gICAgZW5kXG5cbiAgaW5zZXJ0IChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBBZGQgYHMnIHRvIGxlZnQgb2YgcG9zaXRpb24gYGknIGluIGN1cnJlbnQgc3RyaW5nLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBpbnNlcnRfc3RyaW5nJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudCArIDFcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYHMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX3NfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gSW5zZXJ0IGBzJyBpZiBgcycgaXMgbm90IGVtcHR5LCBvdGhlcndpc2UgaXMgdXNlbGVzcy5cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHBvcyA6PSBpIC0gMVxuXG4gICAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIGxfc19jb3VudCwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgICAtLSBDb3B5IHN0cmluZyBgcycgYXQgaW5kZXggYHBvcycuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBwb3MsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBjJyBhdCBpbmRleCBgaScsIHNoaWZ0aW5nIGNoYXJhY3RlcnMgYmV0d2VlbiByYW5rc1xuICAgICAgLS0gYGknIGFuZCBgY291bnQnIHJpZ2h0d2FyZHMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgbmV3X3NpemUgOj0gMSArIGNvdW50XG4gICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcblxuICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICBwb3MgOj0gaSAtIDFcbiAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgLS0gRmlyc3Qgc2hpZnQgZnJvbSBgcy5jb3VudCcgcG9zaXRpb24gYWxsIGNoYXJhY3RlcnMgc3RhcnRpbmcgYXQgaW5kZXggYHBvcycuXG4gICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAocG9zLCBwb3MgKyAxLCBjb3VudCAtIHBvcylcblxuICAgICAgICAtLSBJbnNlcnQgbmV3IGNoYXJhY3RlclxuICAgICAgbF9hcmVhLnB1dCAoYywgcG9zKVxuXG4gICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG9uZV9tb3JlX2NoYXJhY3RlcjogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSBjXG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVtb3ZhbFxuXG4gIHJlbW92ZSAoaTogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBgaSctdGggY2hhcmFjdGVyLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdC5cbiAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAoaSwgaSAtIDEsIGxfY291bnQgLSBpKVxuICAgICAgICAtLSBVcGRhdGUgY29udGVudC5cbiAgICAgIGNvdW50IDo9IGxfY291bnQgLSAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IDBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF90YWlsIChjb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKG4ubWluIChjb3VudCkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3N1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBmcm9tIGBzdGFydF9pbmRleCdcbiAgICAgIC0tIHRvIGBlbmRfaW5kZXgnIGluY2x1c2l2ZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxfaW50ZXJ2YWw6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbmJfcmVtb3ZlZDogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYl9yZW1vdmVkIDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbmJfcmVtb3ZlZCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAoc3RhcnRfaW5kZXggKyBuYl9yZW1vdmVkIC0gMSwgc3RhcnRfaW5kZXggLSAxLCBsX2NvdW50IC0gZW5kX2luZGV4KVxuICAgICAgICBjb3VudCA6PSBsX2NvdW50IC0gbmJfcmVtb3ZlZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICsgb2xkIHN1YnN0cmluZyAoZW5kX2luZGV4ICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBuID4gbF9jb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IDBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVsc2VcbiAgICAgICAga2VlcF9oZWFkIChsX2NvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgY291bnQgLSBuLm1pbiAoY291bnQpKSlcbiAgICBlbmRcblxuICBwcnVuZSAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnLCBpZiBhbnkuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBjb3VudGVyIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGNvdW50ZXIgPiBjb3VudCBvciBlbHNlIChpdGVtIChjb3VudGVyKSA9IGMpXG4gICAgICBsb29wXG4gICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgY291bnRlciA8PSBjb3VudCB0aGVuXG4gICAgICAgIHJlbW92ZSAoY291bnRlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9jaGFyOiBDSEFSQUNURVJfMzJcbiAgICBkb1xuICAgICAgICAtLSBUcmF2ZXJzZSBzdHJpbmcgYW5kIHNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnRcbiAgICAgICAgLS0gZWFjaCB0aW1lIHdlIGZpbmQgYW4gb2NjdXJyZW5jZSBvZiBgYycuXG4gICAgICBmcm9tXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgbF9jaGFyIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICBpZiBsX2NoYXIgLz0gYyB0aGVuXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9jaGFyLCBqKVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgY291bnQgOj0galxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgY2hhbmdlZF9jb3VudDogY291bnQgPSAob2xkIGNvdW50KSAtIChvbGQgb2NjdXJyZW5jZXMgKGMpKVxuICAgICAgLS0gcmVtb3ZlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgLz0gYGMnXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsX2xlYWRpbmcgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgbGVhZGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoMSkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfdHJhaWxpbmcgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgdHJhaWxpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKGNvdW50KSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoY291bnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB3aXBlX291dFxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG4gIGNsZWFyX2FsbFxuICAgICAgLS0gUmVzZXQgYWxsIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB3aXBlX291dCcgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBjb3VudCA6PSAwXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgaXNfZW1wdHk6IGNvdW50ID0gMFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGFkYXB0X3NpemVcbiAgICAgIC0tIEFkYXB0IHRoZSBzaXplIHRvIGFjY29tbW9kYXRlIGBjb3VudCcgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgcmVzaXplIChjb3VudClcbiAgICBlbmRcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgY2hhcmFjdGVyLlxuICAgIGRvXG4gICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgnJS8wMDAvJywgbmV3c2l6ZSArIDEpXG4gICAgZW5kXG5cbiAgZ3JvdyAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIEVuc3VyZSB0aGF0IHRoZSBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgbmV3c2l6ZScuXG4gICAgZG9cbiAgICAgIGlmIG5ld3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3c2l6ZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfc3RyaW5nOiBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b191cHBlclxuICAgIGVuZFxuXG4gIGxlZnRfanVzdGlmeVxuICAgICAgLS0gTGVmdCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aXRkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlIHNwYWNlcy5cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBsZWZ0X2FkanVzdFxuXG4gICAgICAgIC0tIEdldCBuZXcgY291bnRcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgLS0gYGxlZnRfYWRqdXN0JyBkaWQgcmVtb3ZlIHNvbWUgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAtLSBzb21lIHdoaXRlIHNwYWNlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjZW50ZXJfanVzdGlmeVxuICAgICAgLS0gQ2VudGVyIGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYiwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxlZnRfbmJfc3BhY2UsIHJpZ2h0X25iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgPSBuYiBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChsZWZ0X25iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA6PSBsZWZ0X25iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAtMSBvciBlbHNlIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgIGxvb3BcbiAgICAgICAgcmlnaHRfbmJfc3BhY2UgOj0gcmlnaHRfbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFdlIGVuY291cmFnZSB0aGF0IG1vcmUgc3BhY2VzIHdpbGwgYmUgcHV0IHRvIHRoZSBsZWZ0LCB3aGVuXG4gICAgICAgIC0tIG51bWJlciBvZiBzcGFjZXMgaXMgbm90IGV2ZW4uXG4gICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlICsgcmlnaHRfbmJfc3BhY2VcbiAgICAgIGlmIGxfb2Zmc2V0IFxcXFwgMiA9IDAgdGhlblxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMlxuICAgICAgZWxzZVxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMiAtIDFcbiAgICAgIGVuZFxuICAgICAgaWYgbF9vZmZzZXQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgbGVmdCAoZGVwZW5kaW5nIG9uIHNpZ24gb2ZcbiAgICAgICAgICAtLSBgbF9vZmZzZXQnIGJ5IGBsX29mZnNldCcgcG9zaXRpb24uXG4gICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCxcbiAgICAgICAgICBuYiAtIGxlZnRfbmJfc3BhY2UgLSByaWdodF9uYl9zcGFjZSlcblxuICAgICAgICBpZiBsX29mZnNldCA8IDAgdGhlblxuICAgICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaWxsIHJpZ2h0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBuYiAtIHJpZ2h0X25iX3NwYWNlIC0gbF9vZmZzZXQsIG5iIC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9qdXN0aWZ5XG4gICAgICAtLSBSaWdodCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBuYl9zcGFjZSA6PSBuYiAtIGlcbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGkpLCBpICsgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpICsgMVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbmJfc3BhY2UgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgbmJfc3BhY2UgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9qdXN0aWZ5IChwaXZvdDogQ0hBUkFDVEVSXzMyOyBwb3NpdGlvbjogSU5URUdFUilcbiAgICAgIC0tIEp1c3RpZnkgYSBzdHJpbmcgYmFzZWQgb24gYSBgcGl2b3QnXG4gICAgICAtLSBhbmQgdGhlIGBwb3NpdGlvbicgaXQgbmVlZHMgdG8gYmUgaW5cbiAgICAgIC0tIHRoZSBmaW5hbCBzdHJpbmcuXG4gICAgICAtLSBUaGlzIHdpbGwgZ3JvdyB0aGUgc3RyaW5nIGlmIG5lY2Vzc2FyeVxuICAgICAgLS0gdG8gZ2V0IHRoZSBwaXZvdCBpbiB0aGUgY29ycmVjdCBwbGFjZS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9wb3NpdGlvbjogcG9zaXRpb24gPD0gY2FwYWNpdHlcbiAgICAgIHBvc2l0aXZlX3Bvc2l0aW9uOiBwb3NpdGlvbiA+PSAxXG4gICAgICBwaXZvdF9ub3Rfc3BhY2U6IHBpdm90IC89ICcgJ1xuICAgICAgbm90X2VtcHR5OiBub3QgaXNfZW1wdHlcbiAgICBsb2NhbFxuICAgICAgbF9pbmRleF9vZl9waXZvdCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9pbmRleF9vZl9waXZvdCA6PSBpbmRleF9vZiAocGl2b3QsIDEpXG4gICAgICBpZiBsX2luZGV4X29mX3Bpdm90IC89IDAgdGhlblxuICAgICAgICBpZiBsX2luZGV4X29mX3Bpdm90IDwgcG9zaXRpb24gdGhlblxuICAgICAgICAgICAgLS0gV2UgbmVlZCB0byByZXNpemUgQ3VycmVudCBzbyB0aGF0IHdlIGNhbiBzaGlmdCBDdXJyZW50IGJ5XG4gICAgICAgICAgICAtLSBgbF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uJy5cbiAgICAgICAgICBsX25ld19zaXplIDo9IGNvdW50ICsgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90XG4gICAgICAgICAgZ3JvdyAobF9uZXdfc2l6ZSlcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCwgY291bnQpXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCAwLCBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3QgLSAxKVxuICAgICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gU2ltcGx5IHNoaWZ0IGNvbnRlbnQgdG8gdGhlIGxlZnQgYW5kIHJlc2V0IHRyYWlsaW5nIHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobF9pbmRleF9vZl9waXZvdCAtIHBvc2l0aW9uLCAwLCBjb3VudCAtIGxfaW5kZXhfb2ZfcGl2b3QgKyBwb3NpdGlvbilcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uLCBjb3VudCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fbG93ZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX2xvd2VyKVxuICAgIGVuZFxuXG4gIHRvX3VwcGVyXG4gICAgICAtLSBDb252ZXJ0IHRvIHVwcGVyIGNhc2UuXG4gICAgZG9cbiAgICAgIHRvX3VwcGVyX2FyZWEgKGFyZWEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBsZW5ndGhfYW5kX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBhc191cHBlcilcbiAgICBlbmRcblxuICBsaW5lYXJfcmVwcmVzZW50YXRpb246IExJTkVBUiBbQ0hBUkFDVEVSXzMyXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbQ0hBUkFDVEVSXzMyXVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2M6IEFOWVxuICAgICAgLS0gQSByZWZlcmVuY2UgdG8gYSBDIGZvcm0gb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICAtLSBVc2VmdWwgb25seSBmb3IgaW50ZXJmYWNpbmcgd2l0aCBDIHNvZnR3YXJlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLnB1dCAoJyVVJywgY291bnQpXG4gICAgICBSZXN1bHQgOj0gbF9hcmVhXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5taXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvclxuICAgICAgLS0gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgIC0tIFwiSGVsbG8gd29ybGRcIiAtPiBcImRscm93IG9sbGVIXCIuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzMyXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGNvdW50IC0gMVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPD0galxuICAgICAgICBsb29wXG4gICAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgICAgYS5wdXQgKGEuaXRlbSAoaiksIGkpXG4gICAgICAgICAgYS5wdXQgKGMsIGopXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgaXRlbScgKGBpJykgPSBvbGQgYGl0ZW0nIChgY291bnQnKzEtYGknKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkb1xuICAgICAgaWYgKDEgPD0gc3RhcnRfaW5kZXgpIGFuZCAoc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4KSBhbmQgKGVuZF9pbmRleCA8PSBjb3VudCkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuYXJlYS5jb3B5X2RhdGEgKGFyZWEsIHN0YXJ0X2luZGV4IC0gMSwgMCwgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbXVsdGlwbHkgKG46IElOVEVHRVIpXG4gICAgICAtLSBEdXBsaWNhdGUgYSBzdHJpbmcgd2l0aGluIGl0c2VsZlxuICAgICAgLS0gKFwiaGVsbG9cIikubXVsdGlwbHkoMykgPT4gXCJoZWxsb2hlbGxvaGVsbG9cIlxuICAgIHJlcXVpcmVcbiAgICAgIG1lYW5pbmdmdWxfbXVsdGlwbGllcjogbiA+PSAxXG4gICAgbG9jYWxcbiAgICAgIHM6IGxpa2UgQ3VycmVudFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBzIDo9IHR3aW5cbiAgICAgIGdyb3cgKG4gKiBjb3VudClcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMVxuICAgICAgbG9vcFxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBmcm96ZW4gc2V0X2NvdW50IChudW1iZXI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgYGNvdW50JyB0byBgbnVtYmVyJyBvZiBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjb3VudCA6PSBudW1iZXJcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgbmV3X3N0cmluZyAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IGluc3RhbmNlIG9mIGN1cnJlbnQgd2l0aCBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBUcmFuc2Zvcm1hdGlvblxuXG4gIGNvcnJlY3RfbWlzbWF0Y2hcbiAgICAgIC0tIEF0dGVtcHQgdG8gY29ycmVjdCBvYmplY3QgbWlzbWF0Y2ggZHVyaW5nIHJldHJpZXZlIHVzaW5nIGBtaXNtYXRjaF9pbmZvcm1hdGlvbicuXG4gICAgZG9cbiAgICAgICAgLS0gTm90aGluZyB0byBiZSBkb25lIGJlY2F1c2Ugd2Ugb25seSBhZGRlZCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB0aGF0IHdpbGxcbiAgICAgICAgLS0gYmUgcmVjb21wdXRlZCBuZXh0IHRpbWUgd2UgcXVlcnkgYGhhc2hfY29kZScuXG5cbiAgICAgICAgLS0gSW4gLk5FVCwgd2UgaGF2ZSBhIG1pc21hdGNoIHRoYXQgaXMgdHJpZ2dlcmVkIGR1ZSB0byB0aGUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAgICAgLS0gU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXSBhcyBhIC5ORVQgYXJyYXkgb2YgVUludDE2LlxuICAgICAgaWYgYXJlYSA9IFZvaWQgYW5kIHRoZW4gYXR0YWNoZWQge2xpa2UgYXJlYX0gbWlzbWF0Y2hfaW5mb3JtYXRpb24uaXRlbSAoXCJhcmVhXCIpIGFzIGxfYXJlYSB0aGVuXG4gICAgICAgIGFyZWEgOj0gbF9hcmVhXG4gICAgICBlbmRcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgY29tcGFyZV9jaGFyYWN0ZXI6IG5vdCBvYmplY3RfY29tcGFyaXNvblxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==