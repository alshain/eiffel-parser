var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"abstract_special.e","content":"note\n  description: \"Ancestor of SPECIAL to perform queries on SPECIAL without knowing its actual generic type.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-04-12 16:54:50 -0700 (Fri, 12 Apr 2013) $\"\n  revision: \"$Revision: 92440 $\"\n\ndeferred class\n  ABSTRACT_SPECIAL\n\ninherit\n  DEBUG_OUTPUT\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Count of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    deferred\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      create Result.make (12)\n      Result.append_string (\"count=\")\n      Result.append_integer (count)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"any.e","content":"class\n  ANY\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    external\n      \"built_in\"\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n  frozen dlo_nothing\n      -- Execute a null action.\n    do\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\n\nend\n"});
__eiffel_builtin.push({"filename":"array.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 14:18:20 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92138 $\"\n\nclass ARRAY [G] inherit\n\n  RESIZABLE [G]\n    redefine\n      full, copy, is_equal, resizable\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as item alias \"[]\"\n    redefine\n      copy, is_equal\n    end\n\n  TO_SPECIAL [G]\n    export\n      {ARRAY} set_area\n    redefine\n      copy, is_equal, item, put, at, valid_index\n    end\n\ncreate\n  make_empty,\n  make,\n  make_filled,\n  make_from_array,\n  make_from_special,\n  make_from_cil\n\nconvert\n  to_cil: {NATIVE_ARRAY [G]},\n  to_special: {SPECIAL [G]},\n  make_from_cil ({NATIVE_ARRAY [G]})\n\nfeature -- Initialization\n\n  make_empty\n      -- Allocate empty array starting at `1'.\n    do\n      lower := 1\n      upper := 0\n      make_empty_area (0)\n    ensure\n      lower_set: lower = 1\n      upper_set: upper = 0\n      items_set: all_default\n    end\n\n  make_filled (a_default_value: G; min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    require\n      valid_bounds: min_index <= max_index + 1\n    local\n      n: INTEGER\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        n := max_index - min_index + 1\n      end\n      make_filled_area (a_default_value, n)\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: filled_with (a_default_value)\n    end\n\n  make (min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    obsolete\n      \" `make' is not void-safe statically. Use `make_empty' or `make_filled' instead. [07-2010]\"\n    require\n      valid_bounds: min_index <= max_index + 1\n      has_default: min_index <= max_index implies ({G}).has_default\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        make_filled_area (({G}).default, max_index - min_index + 1)\n      else\n        make_empty_area (0)\n      end\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: all_default\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Initialize from the items of `a'.\n      -- (Useful in proper descendants of class `ARRAY',\n      -- to initialize an array-like object from a manifest array.)\n    require\n      array_exists: a /= Void\n    do\n      set_area (a.area)\n      lower := a.lower\n      upper := a.upper\n    ensure\n      shared: area = a.area\n      lower_set: lower = a.lower\n      upper_set: upper = a.upper\n    end\n\n  make_from_special (a: SPECIAL [G])\n      -- Initialize Current from items of `a'.\n    require\n      special_attached: a /= Void\n    do\n      set_area (a)\n      lower := 1\n      upper := a.count\n    ensure\n      shared: area = a\n      lower_set: lower = 1\n      upper_set: upper = a.count\n    end\n\n  make_from_cil (na: NATIVE_ARRAY [like item])\n      -- Initialize array from `na'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      na_not_void: na /= Void\n    do\n      create area.make_from_native_array (na)\n      lower := 1\n      upper := area.count\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): G assign put\n      -- Entry at index `i', if in index interval\n    do\n      Result := area.item (i - lower)\n    end\n\n  entry (i: INTEGER): G\n      -- Entry at index `i', if in index interval\n    require\n      valid_key: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  has (v: G): BOOLEAN\n      -- Does `v' appear in array?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      l_area := area\n      nb := upper - lower\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) ~ v\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) = v\n          i := i + 1\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER\n      -- Minimum index\n\n  upper: INTEGER\n      -- Maximum index\n\n  count, capacity: INTEGER\n      -- Number of available indices\n    do\n      Result := upper - lower + 1\n    ensure then\n      consistent_with_bounds: Result = upper - lower + 1\n    end\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n    local\n      i: INTEGER\n    do\n      if object_comparison then\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) ~ v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      else\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) = v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    ensure then\n      same_count: Result.count = count\n      same_bounds:\n        ((Result.lower = lower) and (Result.upper = upper))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif lower = other.lower and then upper = other.upper and then\n        object_comparison = other.object_comparison\n      then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := item (i) ~ other.item (i)\n            i := i + 1\n          end\n        else\n          Result := area.same_items (other.area, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    do\n      if count > 0 then\n        Result := ({G}).has_default and then area.filled_with (({G}).default, 0, upper - lower)\n      else\n        Result := True\n      end\n    ensure\n      definition: Result = (count = 0 or else\n        ((not attached item (upper) as i or else i = ({G}).default) and\n        subarray (lower, upper - 1).all_default))\n    end\n\n  filled_with (v: G): BOOLEAN\n      -- Are all items set to `v'?\n    do\n      Result := area.filled_with (v, 0, upper - lower)\n    ensure\n      definition: Result = (count = 0 or else\n        (item (upper) = v and subarray (lower, upper - 1).filled_with (v)))\n    end\n\n  full: BOOLEAN\n      -- Is structure filled to capacity? (Answer: yes)\n    do\n      Result := True\n    end\n\n  same_items (other: like Current): BOOLEAN\n      -- Do `other' and Current have same items?\n    require\n      other_not_void: other /= Void\n    do\n      if count = other.count then\n        Result := area.same_items (other.area, 0, 0, count)\n      end\n    ensure\n      definition: Result = ((count = other.count) and then\n        (count = 0 or else (item (upper) = other.item (other.upper)\n        and subarray (lower, upper - 1).same_items\n        (other.subarray (other.lower, other.upper - 1)))))\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the array?\n    do\n      Result := (lower <= i) and then (i <= upper)\n    end\n\n  extendible: BOOLEAN\n      -- May items be added?\n      -- (Answer: no, although array may be resized.)\n    do\n      Result := False\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: no.)\n    do\n      Result := False\n    end\n\n  resizable: BOOLEAN\n      -- Can array be resized automatically?\n    do\n      Result := ({G}).has_default\n    end\n\n  valid_index_set: BOOLEAN\n    do\n      Result := index_set.count = count\n    end\n\nfeature -- Element change\n\n  put (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area.put (v, i - lower)\n    end\n\n  enter (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_key: valid_index (i)\n    do\n      area.put (v, i - lower)\n    end\n\n  force (v: like item; i: INTEGER)\n      -- Assign item `v' to `i'-th entry.\n      -- Resize the array if `i' falls out of currently defined bounds; preserve existing items.\n      -- In void-safe mode, if ({G}).has_default does not hold, then you can only insert between\n      -- `lower - 1' or `upper + 1' position in the ARRAY.\n    require\n      has_default_if_too_low:\n        (i < lower - 1 and lower /= {like lower}.min_value) implies ({G}).has_default\n      has_default_if_too_high:\n        (i > upper + 1 and upper /= {like upper}.max_value) implies ({G}).has_default\n    local\n      old_size, new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      l_count, l_offset: INTEGER\n      l_increased_by_one: BOOLEAN\n    do\n      new_lower := lower.min (i)\n      new_upper := upper.max (i)\n      new_size := new_upper - new_lower + 1\n      l_increased_by_one := (i = upper + 1) or (i = lower - 1)\n      if empty_area then\n          -- List is empty. First we create an empty SPECIAL of the right capacity.\n        make_empty_area (new_size.max (additional_space))\n        if not l_increased_by_one then\n            -- We need to fill the SPECIAL for `0' to `new_size - 2' with the default value.\n          area.fill_with (({G}).default, 0, new_size - 2)\n        end\n        area.extend (v)\n      else\n        old_size := area.capacity\n        if new_size > old_size then\n          set_area (area.aliased_resized_area (new_size.max (old_size + additional_space)))\n        end\n        if new_lower < lower then\n            -- We have inserted below the previous `lower'. We need to shift entries to the right\n            -- before we can insert `v'.\n          l_offset := lower - new_lower\n          l_count := capacity\n          if not l_increased_by_one and l_offset > l_count then\n              -- With the `new_lower' given, the data has to move\n              -- beyond the `area''s count which requires us to fill\n              -- the gap between the old data's location and the new one\n              -- with the default value.\n            area.fill_with (({G}).default, l_count, l_offset - 1)\n          end\n          area.move_data (0, l_offset, l_count)\n          if not l_increased_by_one then\n              -- We start at `1' and not `0' because next instruction\n              -- will update the item at position `0'.\n            area.fill_with (({G}).default, 1, l_offset - 1)\n          end\n            -- Insert `v' at the new lower position.\n          area.put (v, 0)\n        else\n          if new_size > area.count then\n              -- We are adding to the new `upper' position. First we fill the non-initialized\n              -- elements if any up to `new_size - 2' (i.e. up the the item prior to `upper').\n            if not l_increased_by_one then\n              area.fill_with (({G}).default, area.count, new_size - 2)\n            end\n              -- Add `v' at upper position.\n            area.extend (v)\n          else\n              -- Here `lower' hasn't changed\n            area.put (v, i - lower)\n          end\n        end\n      end\n      lower := new_lower\n      upper := new_upper\n    ensure\n      inserted: item (i) = v\n      higher_count: count >= old count\n      lower_set: lower = (old lower).min (i)\n      upper_set: upper = (old upper).max (i)\n    end\n\n  fill_with (v: G)\n      -- Set items between `lower' and `upper' with `v'.\n    do\n      area.fill_with (v, 0, upper - lower)\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = old count\n      filled: filled_with (v)\n    end\n\n  subcopy (other: ARRAY [like item]; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy items of `other' within bounds `start_pos' and `end_pos'\n      -- to current array starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: start_pos >= other.lower\n      valid_end_pos: end_pos <= other.upper\n      valid_bounds: start_pos <= end_pos + 1\n      valid_index_pos: index_pos >= lower\n      enough_space: (upper - index_pos) >= (end_pos - start_pos)\n    do\n      area.copy_data (other.area, start_pos - other.lower, index_pos - lower, end_pos - start_pos + 1)\n    ensure\n      -- copied: forall `i' in 0 .. (`end_pos'-`start_pos'),\n      --     item (index_pos + i) = other.item (start_pos + i)\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    do\n      area.do_all_in_bounds (action, 0, count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    do\n      area.do_if_in_bounds (action, test, 0, count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.there_exists_in_bounds (test, 0, count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.for_all_in_bounds (test, 0, count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Removal\n\n  wipe_out\n      -- Make array empty.\n    obsolete\n      \"Not applicable since not `prunable'. Use `discard_items' instead.\"\n    do\n      discard_items\n    end\n\n  discard_items\n      -- Reset all items to default values with reallocation.\n    require\n      has_default: ({G}).has_default\n    do\n      create area.make_filled (({G}).default, capacity)\n    ensure\n      default_items: all_default\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    require\n      has_default: ({G}).has_default\n    do\n      area.fill_with (({G}).default, 0, area.count - 1)\n    ensure\n      stable_lower: lower = old lower\n      stable_upper: upper = old upper\n      default_items: all_default\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all items except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    do\n      if n < count then\n        upper := lower + n - 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_lower: lower = old lower\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all items except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        lower := upper - n + 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_upper: upper = old upper\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_upper: upper = old upper\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_head (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_lower: lower = old lower\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > capacity then\n        conservative_resize_with_default (({G}).default, lower, upper + i - capacity)\n      end\n    end\n\n  conservative_resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \" `conservative_resize' is not void-safe statically. Use `conservative_resize_with_default' instead. [07-2010]\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  conservative_resize_with_default (a_default_value: G; min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    require\n      good_indices: min_index <= max_index\n    local\n      new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      offset: INTEGER\n    do\n      if empty_area then\n        set_area (area.aliased_resized_area_with_default (a_default_value, max_index - min_index + 1))\n        lower := min_index\n        upper := max_index\n      else\n        new_lower := min_index.min (lower)\n        new_upper := max_index.max (upper)\n        new_size := new_upper - new_lower + 1\n        if new_size > area.count then\n          set_area (area.aliased_resized_area_with_default (a_default_value, new_size))\n        end\n        if new_lower < lower then\n          offset := lower - new_lower\n          area.move_data (0, offset, upper - lower + 1)\n          area.fill_with (a_default_value, 0, offset - 1)\n        end\n        lower := new_lower\n        upper := new_upper\n      end\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \"Use `conservative_resize_with_default' instead as future versions will implement `resize' as specified in ELKS.\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area.capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: same_items (old twin)\n    end\n\n  rebase (a_lower: like lower)\n      -- Without changing the actual content of `Current' we set `lower' to `a_lower'\n      -- and `upper' accordingly to `a_lower + count - 1'.\n    local\n      l_old_lower: like lower\n    do\n      l_old_lower := lower\n      lower := a_lower\n      upper := a_lower + (upper - l_old_lower)\n    ensure\n      lower_set: lower = a_lower\n      upper_set: upper = a_lower + old count - 1\n    end\n\nfeature -- Conversion\n\n  to_c: ANY\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    do\n      Result := area\n    end\n\n  to_cil: NATIVE_ARRAY [G]\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := area.native_array\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_special: SPECIAL [G]\n      -- 'area'.\n    do\n      Result := area\n    ensure\n      to_special_not_void: Result /= Void\n    end\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [G]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := lower\n      until\n        i > upper\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area.twin)\n      end\n    ensure then\n      equal_areas: area ~ other.area\n    end\n\n  subarray (start_pos, end_pos: INTEGER): ARRAY [G]\n      -- Array made of items of current array within\n      -- bounds `start_pos' and `end_pos'.\n    require\n      valid_start_pos: valid_index (start_pos)\n      valid_end_pos: end_pos <= upper\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n    do\n      if start_pos <= end_pos then\n        create Result.make_filled (item (start_pos), start_pos, end_pos)\n          -- Only copy elements if needed.\n        Result.subcopy (Current, start_pos, end_pos, start_pos)\n      else\n          -- make empty\n        create Result.make_empty\n        Result.rebase (start_pos)\n      end\n    ensure\n      lower: Result.lower = start_pos\n      upper: Result.upper = end_pos\n      -- copied: forall `i' in `start_pos' .. `end_pos',\n      --     Result.item (i) = item (i)\n    end\n\nfeature {NONE} -- Inapplicable\n\n  prune (v: G)\n      -- Remove first occurrence of `v' if any.\n      -- (Precondition is False.)\n    do\n    end\n\n  extend (v: G)\n      -- Add `v' to structure.\n      -- (Precondition is False.)\n    do\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: BOOLEAN\n      -- Is `area' empty?\n    do\n      Result := area = Void or else area.capacity = 0\n    end\n\ninvariant\n\n  area_exists: area /= Void\n  consistent_size: capacity = upper - lower + 1\n  non_negative_count: count >= 0\n  index_set_has_same_count: valid_index_set\n-- Internal discussion haven't reached an agreement on this invariant\n--  index_set_has_same_bounds: ((index_set.lower = lower) and\n--        (index_set.upper = lower + count - 1))\n\nend\n"});
__eiffel_builtin.push({"filename":"bag.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bag, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BAG [G] inherit\n\n  COLLECTION [G]\n    redefine\n      extend\n    end\n\nfeature -- Measurement\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      non_negative_occurrences: Result >= 0\n    end\n\nfeature -- Element change\n\n  extend (v: G)\n      -- Add a new occurrence of `v'.\n    deferred\n    ensure then\n        -- Commented due to the expensive nature of the check when inserting a new item\n        -- in a containers with many items.\n      -- one_more_occurrence: occurrences (v) = old (occurrences (v)) + 1\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"boolean.e","content":"note\n  description: \"Truth values, with the boolean operations\"\n  external_name: \"System.Boolean\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nfrozen expanded class BOOLEAN\n\ninherit\n  BOOLEAN_REF\n    redefine\n      conjuncted,\n      conjuncted_semistrict,\n      disjuncted,\n      disjuncted_semistrict,\n      disjuncted_exclusive,\n      implication,\n      negated\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({BOOLEAN_REF})\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: BOOLEAN): BOOLEAN\n      -- Boolean conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  implication alias \"implies\" (other: BOOLEAN): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    external\n      \"built_in\"\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    external\n      \"built_in\"\n    end\n\n  disjuncted alias \"or\" (other: BOOLEAN): BOOLEAN\n      -- Boolean disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: BOOLEAN): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    external\n      \"built_in\"\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: BOOLEAN): BOOLEAN\n      -- Boolean exclusive or with `other'\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"boolean_ref.e","content":"note\n  description: \"References to objects containing a boolean value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass BOOLEAN_REF inherit\n\n  HASHABLE\n    redefine\n      out\n    end\n\nfeature -- Access\n\n  item: BOOLEAN\n      -- Boolean value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      if item then\n        Result := 1\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: BOOLEAN_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: BOOLEAN_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n      same_item: Result.item = item\n    end\n\n  to_integer: INTEGER\n      -- 1 if `True'\n      -- 0 if `False'\n    do\n      if item then\n        Result := 1\n      end\n    ensure\n      not_item_implies_zero: not item implies Result = 0\n      item_implies_one: item implies Result = 1\n    end\n\nfeature -- Element change\n\n  set_item (b: BOOLEAN)\n      -- Make `b' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  conjuncted alias \"and\" (other: like Current): BOOLEAN\n      -- Boolean conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and other.item\n    ensure\n      de_morgan: Result = not (not Current or not other)\n      commutative: Result = (other and Current)\n      consistent_with_semi_strict: Result implies (Current and then other)\n    end\n\n  conjuncted_semistrict alias \"and then\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict conjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item and then other.item\n    ensure\n      de_morgan: Result = not (not Current or else not other)\n    end\n\n  implication alias \"implies\" (other: like Current): BOOLEAN\n      -- Boolean implication of `other'\n      -- (semi-strict)\n    require\n      other_exists: other /= Void\n    do\n      Result := item implies other.item\n    ensure\n      definition: Result = (not Current or else other)\n    end\n\n  negated alias \"not\": BOOLEAN\n      -- Negation\n    do\n      Result := not item\n    end\n\n  disjuncted alias \"or\" (other: like Current): BOOLEAN\n      -- Boolean disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or other.item\n    ensure\n      de_morgan: Result = not (not Current and not other)\n      commutative: Result = (other or Current)\n      consistent_with_semi_strict: Result implies (Current or else other)\n    end\n\n  disjuncted_semistrict alias \"or else\" (other: like Current): BOOLEAN\n      -- Boolean semi-strict disjunction with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item or else other.item\n    ensure\n      de_morgan: Result = not (not Current and then not other)\n    end\n\n  disjuncted_exclusive alias \"xor\" (other: like Current): BOOLEAN\n      -- Boolean exclusive or with `other'\n    require\n      other_exists: other /= Void\n    do\n      Result := item xor other.item\n    ensure\n      definition: Result = ((Current or other) and not (Current and other))\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of boolean\n    do\n      Result := \"False\"\n      if item then\n        Result := \"True\"\n      end\n    end\n\ninvariant\n  involutive_negation: (not (not Current)).item = item\n  non_contradiction: not ((not Current) and Current)\n  completeness: (not Current) or Current\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"bounded.e","content":"note\n  description: \"Bounded data structures, with a notion of capacity.\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: bounded, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOUNDED [G] inherit\n\n  FINITE [G]\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Number of items that may be stored\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure full?\n    do\n      Result := (count = capacity)\n    end\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed?\n    deferred\n    end\n\ninvariant\n\n  valid_count: count <= capacity\n  full_definition: full = (count = capacity)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"box.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class BOX [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  full: BOOLEAN\n      -- Is structure filled to capacity?\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"character_32.e","content":"note\n  description: \"Unicode characters, with comparison operations\"\n  assembly: \"mscorlib\"\n  external_name: \"System.UInt32\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_32\n\ninherit\n  CHARACTER_32_REF\n    redefine\n      code,\n      natural_32_code,\n      to_character_8\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_32_REF})\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"character_32_ref.e","content":"note\n  description: \"References to objects containing a unicode character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  CHARACTER_32_REF\n\ninherit\n  COMPARABLE\n    redefine\n      is_equal, out\n    end\n\n  HASHABLE\n    redefine\n      is_equal, out\n    end\n\nfeature -- Access\n\n  item: CHARACTER_32\n      -- Unicode character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := natural_32_code.as_integer_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.natural_32_code\n    ensure\n      natural_32_code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  min_value: NATURAL_32 = 0\n  max_value: NATURAL_32 = 4294967295\n      -- Bounds for integer representation of CHARACTER_32\n\n  max_unicode_value: NATURAL_32 = 0x10FFFD\n      -- Maximum Unicode characters.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: NATURAL_32): CHARACTER_32\n      -- Add `incr' to the code of `item'.\n    require\n      valid_increment: (item.natural_32_code.to_natural_64 + incr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code + incr).to_character_32\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: NATURAL_32): CHARACTER_32\n      -- Subtract `decr' from the code of `item'.\n    require\n      valid_decrement: (item.natural_32_code.to_integer_64 - decr).is_valid_character_32_code\n    do\n      Result := (item.natural_32_code - decr).to_character_32\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_32): INTEGER_64\n      -- Difference between the codes of `item' and `other'.\n    do\n      Result := item.natural_32_code.to_integer_64 - other.natural_32_code.to_integer_64\n    ensure\n      valid_non_negative_result: Result >= 0 implies ((other + Result.to_natural_32) = item)\n      valid_negative_result: Result < 0 implies (other = (item + Result.to_natural_32))\n    end\n\n  next: CHARACTER_32\n      -- Next character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 + 1).is_valid_character_32_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_32\n      -- Previous character.\n    require\n      valid_character: (item.natural_32_code.to_natural_64 - 1).is_valid_character_32_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_32)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of wide character.\n    do\n      create Result.make (6)\n      Result.append_character ('U')\n      Result.append_character ('+')\n      Result.append_string (natural_32_code.to_hex_string)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_32_REF\n      -- Associated reference of Current.\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Convert current to CHARACTER_8.\n    require\n      is_character_8_compatible: is_character_8\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Convert current to CHARACTER_32.\n    do\n      Result := item\n    end\n\n  as_upper, upper: CHARACTER_32\n      -- Uppercase value of `item'.\n      -- Returns `item' if not `is_lower'.\n    do\n      Result := properties.to_upper (item)\n    end\n\n  as_lower, lower: CHARACTER_32\n      -- Lowercase value of `item'.\n      -- Returns `item' if not `is_upper'.\n    do\n      Result := properties.to_lower (item)\n    end\n\nfeature -- Status report\n\n  is_character_8: BOOLEAN\n      -- Can current be represented on a CHARACTER_8?\n    do\n      Result := natural_32_code <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'.\n    do\n      Result := properties.is_alpha (item)\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := properties.is_upper (item)\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := properties.is_lower (item)\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789.\n    do\n      Result := '0' <= item and item <= '9'\n    end\n\n  is_unicode_digit: BOOLEAN\n      -- Is `item' a decimal digit as expected for Unicode characters?\n    do\n      Result := properties.is_digit (item)\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' a hexadecimal digit as expected for ASCII characters?\n      -- A digit is one of 0123456789ABCDEFabcedf.\n    do\n      Result := properties.is_hexa_digit (item)\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := properties.is_space (item)\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := properties.is_punctuation (item)\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := properties.is_alpha (item) or properties.is_digit (item)\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := properties.is_control (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  properties: CHARACTER_PROPERTY\n      -- Property for Unicode characters.\n    once\n      create Result.make\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8.e","content":"note\n  description: \"Characters, with comparison operations and an ASCII code\"\n  external_name: \"System.Char\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class\n  CHARACTER_8\n\ninherit\n  CHARACTER_8_REF\n    redefine\n      code,\n      to_character_32\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({CHARACTER_8_REF}),\n  to_character_32: {CHARACTER_32}\n\nfeature -- Access\n\n  code: INTEGER\n      -- Associated integer value\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"character_8_ref.e","content":"note\n  description: \"References to objects containing a character value\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass CHARACTER_8_REF inherit\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      out, is_equal\n    end\n\nfeature -- Access\n\n  item: CHARACTER_8\n      -- Character value\n    external\n      \"built_in\"\n    end\n\n  code: INTEGER\n      -- Associated integer value\n    obsolete\n      \"Use `natural_32_code' instead.\"\n    do\n      Result := item.code\n    ensure\n      code_non_negatif: Result >= 0\n      code_in_range: Result >= min_value and Result <= max_value\n    end\n\n  natural_32_code: NATURAL_32\n      -- Associated natural value\n    do\n      Result := item.code.to_natural_32\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := natural_32_code.hash_code\n    end\n\n  min_value: INTEGER = 0\n  max_value: INTEGER = 255\n  max_ascii_value: INTEGER = 127\n      -- Bounds for integer representation of characters (ASCII)\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is `other' greater than current character?\n    do\n      Result := natural_32_code < other.natural_32_code\n    ensure then\n      definition: Result = (natural_32_code < other.natural_32_code)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Basic routines\n\n  plus alias \"+\" (incr: INTEGER): CHARACTER_8\n      -- Add `incr' to the code of `item'\n    require\n      valid_increment: (item.code + incr).is_valid_character_8_code\n    do\n      Result := (item.code + incr).to_character_8\n    ensure\n      valid_result: Result |-| item = incr\n    end\n\n  minus alias \"-\" (decr: INTEGER): CHARACTER_8\n      -- Subtract `decr' from the code of `item'\n    require\n      valid_decrement: (item.code - decr).is_valid_character_8_code\n    do\n      Result := (item.code - decr).to_character_8\n    ensure\n      valid_result: item |-| Result = decr\n    end\n\n  difference alias \"|-|\" (other: CHARACTER_8): INTEGER\n      -- Difference between the codes of `item' and `other'\n    do\n      Result := item.code - other.code\n    ensure\n      valid_result: other + Result = item\n    end\n\n  next: CHARACTER_8\n      -- Next character\n    require\n      valid_character: (item.code + 1).is_valid_character_8_code\n    do\n      Result := item + 1\n    ensure\n      valid_result: Result |-| item = 1\n    end\n\n  previous: CHARACTER_8\n      -- Previous character\n    require\n      valid_character: (item.code - 1).is_valid_character_8_code\n    do\n      Result := item - 1\n    ensure\n      valid_result: Result |-| item = -1\n    end\n\nfeature -- Element change\n\n  set_item (c: CHARACTER_8)\n      -- Make `c' the `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of character\n    do\n      create Result.make (1)\n      Result.append_character (item)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: CHARACTER_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: CHARACTER_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version\n    do\n      Result := item\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version\n    do\n      Result := item.to_character_32\n    end\n\n  as_upper, upper: CHARACTER_8\n      -- Uppercase value of `item'\n      -- Returns `item' if not `is_lower'\n    do\n      if is_lower then\n        Result := (item.code - ('a').code + ('A').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\n  as_lower, lower: CHARACTER_8\n      -- Lowercase value of `item'\n      -- Returns `item' if not `is_upper'\n    do\n      if is_upper then\n        Result := (item.code - ('A').code + ('a').code).to_character_8\n      else\n        Result := item\n      end\n    end\n\nfeature -- Status report\n\n  is_alpha: BOOLEAN\n      -- Is `item' alphabetic?\n      -- Alphabetic is `is_upper' or `is_lower'\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag)) > 0\n    end\n\n  is_upper: BOOLEAN\n      -- Is `item' uppercase?\n    do\n      Result := (character_types (item.code) & is_upper_flag) > 0\n    end\n\n  is_lower: BOOLEAN\n      -- Is `item' lowercase?\n    do\n      Result := (character_types (item.code) & is_lower_flag) > 0\n    end\n\n  is_digit: BOOLEAN\n      -- Is `item' a digit?\n      -- A digit is one of 0123456789\n    do\n      Result := (character_types (item.code) & is_digit_flag) > 0\n    end\n\n  is_hexa_digit: BOOLEAN\n      -- Is `item' an hexadecimal digit?\n      -- A digit is one of 0123456789ABCDEFabcedf\n    do\n      Result := (character_types (item.code) & (is_hexa_digit_flag | is_digit_flag)) > 0\n    end\n\n  is_space: BOOLEAN\n      -- Is `item' a white space?\n    do\n      Result := (character_types (item.code) & is_white_space_flag) > 0\n    end\n\n  is_punctuation: BOOLEAN\n      -- Is `item' a punctuation?\n    do\n      Result := (character_types (item.code) & is_punctuation_flag) > 0\n    end\n\n  is_alpha_numeric: BOOLEAN\n      -- Is `item' alphabetic or a digit?\n    do\n      Result := (character_types (item.code) & (is_upper_flag | is_lower_flag | is_digit_flag)) > 0\n    end\n\n  is_printable: BOOLEAN\n      -- Is `item' a printable character including space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag | is_space_flag)) > 0\n    end\n\n  is_graph: BOOLEAN\n      -- Is `item' a printable character except space?\n    do\n      Result := (character_types (item.code) &\n        (is_upper_flag | is_lower_flag | is_digit_flag | is_punctuation_flag)) > 0\n    end\n\n  is_control: BOOLEAN\n      -- Is `item' a control character?\n    do\n      Result := (character_types (item.code) & is_control_flag) > 0\n    end\n\nfeature {NONE} -- Implementation\n\n  character_types (a_code: INTEGER): NATURAL_8\n      -- Associated type for character of code `a_code'\n    do\n        -- For character whose code is above 256, it is as if\n        -- we had no information about it.\n      if a_code < 256 then\n        Result := internal_character_types.item (a_code)\n      end\n    end\n\n  internal_character_types: SPECIAL [NATURAL_8]\n      -- Array which stores the various type for the ASCII characters\n    once\n      create Result.make_empty (256)\n      Result.extend (is_control_flag)             -- 0  null\n      Result.extend (is_control_flag)                         -- 1  start of heading\n      Result.extend (is_control_flag)                         -- 2  start of text\n      Result.extend (is_control_flag)                         -- 3  end of text\n      Result.extend (is_control_flag)                         -- 4  end of transmission\n      Result.extend (is_control_flag)                         -- 5  enquiry\n      Result.extend (is_control_flag)                         -- 6  acknowledge\n      Result.extend (is_control_flag)                         -- 7  bell\n      Result.extend (is_control_flag)                         -- 8  backspace\n      Result.extend (is_control_flag | is_white_space_flag)   -- 9  horizontal tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 10 NL line feed, new line\n      Result.extend (is_control_flag | is_white_space_flag)   -- 11 vertical tab\n      Result.extend (is_control_flag | is_white_space_flag)   -- 12 NP form feed, new page\n      Result.extend (is_control_flag | is_white_space_flag)   -- 13 carriage return=CR\n      Result.extend (is_control_flag)                         -- 14 shift out\n      Result.extend (is_control_flag)                         -- 15 shift in\n      Result.extend (is_control_flag)                         -- 16\n      Result.extend (is_control_flag)                         -- 17\n      Result.extend (is_control_flag)                         -- 18\n      Result.extend (is_control_flag)                         -- 19\n      Result.extend (is_control_flag)                         -- 20\n      Result.extend (is_control_flag)                         -- 21\n      Result.extend (is_control_flag)                         -- 22\n      Result.extend (is_control_flag)                         -- 23\n      Result.extend (is_control_flag)                         -- 24\n      Result.extend (is_control_flag)                         -- 25\n      Result.extend (is_control_flag)                         -- 26\n      Result.extend (is_control_flag)                         -- 27 Escape\n      Result.extend (is_control_flag)                         -- 28 file separator\n      Result.extend (is_control_flag)                         -- 29 group separator\n      Result.extend (is_control_flag)                         -- 30 record separator\n      Result.extend (is_control_flag)                         -- 31 unit separator\n      Result.extend (is_white_space_flag | is_space_flag)     -- 32 Space\n      Result.extend (is_punctuation_flag)                     -- 33 !\n      Result.extend (is_punctuation_flag)                     -- 34 \"\n      Result.extend (is_punctuation_flag)                     -- 35 #\n      Result.extend (is_punctuation_flag)                     -- 36 $\n      Result.extend (is_punctuation_flag)                     -- 37 %\n      Result.extend (is_punctuation_flag)                     -- 38 &\n      Result.extend (is_punctuation_flag)                     -- 39 '\n      Result.extend (is_punctuation_flag)                     -- 40 (\n      Result.extend (is_punctuation_flag)                     -- 41 )\n      Result.extend (is_punctuation_flag)                     -- 42 *\n      Result.extend (is_punctuation_flag)                     -- 43 +\n      Result.extend (is_punctuation_flag)                     -- 44 ,\n      Result.extend (is_punctuation_flag)                     -- 45 -\n      Result.extend (is_punctuation_flag)                     -- 46 .\n      Result.extend (is_punctuation_flag)                     -- 47 /\n      Result.extend (is_digit_flag)                           -- 48 0\n      Result.extend (is_digit_flag)                           -- 49 1\n      Result.extend (is_digit_flag)                           -- 50 2\n      Result.extend (is_digit_flag)                           -- 51 3\n      Result.extend (is_digit_flag)                           -- 52 4\n      Result.extend (is_digit_flag)                           -- 53 5\n      Result.extend (is_digit_flag)                           -- 54 6\n      Result.extend (is_digit_flag)                           -- 55 7\n      Result.extend (is_digit_flag)                           -- 56 8\n      Result.extend (is_digit_flag)                           -- 57 9\n      Result.extend (is_punctuation_flag)                     -- 58 :\n      Result.extend (is_punctuation_flag)                     -- 59 ;\n      Result.extend (is_punctuation_flag)                     -- 60 <\n      Result.extend (is_punctuation_flag)                     -- 61 =\n      Result.extend (is_punctuation_flag)                     -- 62 >\n      Result.extend (is_punctuation_flag)                     -- 63 ?\n      Result.extend (is_punctuation_flag)                     -- 64 @\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 65 A\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 66 B\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 67 C\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 68 D\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 69 E\n      Result.extend (is_upper_flag | is_hexa_digit_flag)      -- 70 F\n      Result.extend (is_upper_flag)                           -- 71 G\n      Result.extend (is_upper_flag)                           -- 72 H\n      Result.extend (is_upper_flag)                           -- 73 I\n      Result.extend (is_upper_flag)                           -- 74 J\n      Result.extend (is_upper_flag)                           -- 75 K\n      Result.extend (is_upper_flag)                           -- 76 L\n      Result.extend (is_upper_flag)                           -- 77 M\n      Result.extend (is_upper_flag)                           -- 78 N\n      Result.extend (is_upper_flag)                           -- 79 O\n      Result.extend (is_upper_flag)                           -- 80 P\n      Result.extend (is_upper_flag)                           -- 81 Q\n      Result.extend (is_upper_flag)                           -- 82 R\n      Result.extend (is_upper_flag)                           -- 83 S\n      Result.extend (is_upper_flag)                           -- 84 T\n      Result.extend (is_upper_flag)                           -- 85 U\n      Result.extend (is_upper_flag)                           -- 86 V\n      Result.extend (is_upper_flag)                           -- 87 W\n      Result.extend (is_upper_flag)                           -- 88 X\n      Result.extend (is_upper_flag)                           -- 89 Y\n      Result.extend (is_upper_flag)                           -- 90 Z\n      Result.extend (is_punctuation_flag)                     -- 91 [\n      Result.extend (is_punctuation_flag)                     -- 92 \\\n      Result.extend (is_punctuation_flag)                     -- 93 ]\n      Result.extend (is_punctuation_flag)                     -- 94 ^\n      Result.extend (is_punctuation_flag)                     -- 95 _\n      Result.extend (is_punctuation_flag)                     -- 96 `\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 97 a\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 98 b\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 99 c\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 100  d\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 101  e\n      Result.extend (is_lower_flag | is_hexa_digit_flag)      -- 102  f\n      Result.extend (is_lower_flag)                           -- 103  g\n      Result.extend (is_lower_flag)                           -- 104  h\n      Result.extend (is_lower_flag)                           -- 105  i\n      Result.extend (is_lower_flag)                           -- 106  j\n      Result.extend (is_lower_flag)                           -- 107  k\n      Result.extend (is_lower_flag)                           -- 108  l\n      Result.extend (is_lower_flag)                           -- 109  m\n      Result.extend (is_lower_flag)                           -- 110  n\n      Result.extend (is_lower_flag)                           -- 111  o\n      Result.extend (is_lower_flag)                           -- 112  p\n      Result.extend (is_lower_flag)                           -- 113  q\n      Result.extend (is_lower_flag)                           -- 114  r\n      Result.extend (is_lower_flag)                           -- 115  s\n      Result.extend (is_lower_flag)                           -- 116  t\n      Result.extend (is_lower_flag)                           -- 117  u\n      Result.extend (is_lower_flag)                           -- 118  v\n      Result.extend (is_lower_flag)                           -- 119  w\n      Result.extend (is_lower_flag)                           -- 120  x\n      Result.extend (is_lower_flag)                           -- 121  y\n      Result.extend (is_lower_flag)                           -- 122  z\n      Result.extend (is_punctuation_flag)                     -- 123  {\n      Result.extend (is_punctuation_flag)                     -- 124  |\n      Result.extend (is_punctuation_flag)                     -- 125  }\n      Result.extend (is_punctuation_flag)                     -- 126  ~\n      Result.extend (is_control_flag)                         -- 127  DEL\n      Result.fill_with (0, 128, 255)              -- extended ASCII\n    ensure\n      internal_character_types_not_void: Result /= Void\n    end\n\n  is_upper_flag: NATURAL_8 = 0x01\n\n  is_lower_flag: NATURAL_8 = 0x02\n\n  is_digit_flag: NATURAL_8 = 0x04\n\n  is_white_space_flag: NATURAL_8 = 0x08\n\n  is_punctuation_flag: NATURAL_8 = 0x10\n\n  is_control_flag: NATURAL_8 = 0x20\n\n  is_hexa_digit_flag: NATURAL_8 = 0x40\n\n  is_space_flag: NATURAL_8 = 0x80;\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"collection.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: collection, access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class COLLECTION [G] inherit\n\n  CONTAINER [G]\n\nfeature -- Status report\n\n  extendible: BOOLEAN\n      -- May new items be added?\n    deferred\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed?\n    deferred\n    end\n\n  is_inserted (v: G): BOOLEAN\n      -- Has `v' been inserted by the most recent insertion?\n      -- (By default, the value returned is equivalent to calling\n      -- `has (v)'. However, descendants might be able to provide more\n      -- efficient implementations.)\n    do\n      Result := has (v)\n    end\n\nfeature -- Element change\n\n  put, extend (v: G)\n      -- Ensure that structure includes `v'.\n    require\n      extendible: extendible\n    deferred\n    ensure\n      item_inserted: is_inserted (v)\n    end\n\n  fill (other: CONTAINER [G])\n      -- Fill with as many items of `other' as possible.\n      -- The representations of `other' and current structure\n      -- need not be the same.\n    require\n      other_not_void: other /= Void\n      extendible: extendible\n    local\n      lin_rep: LINEAR [G]\n    do\n      lin_rep := other.linear_representation\n      from\n        lin_rep.start\n      until\n        not extendible or else lin_rep.off\n      loop\n        extend (lin_rep.item)\n        lin_rep.forth\n      end\n    end\n\nfeature -- Removal\n\n  prune (v: G)\n      -- Remove one occurrence of `v' if any.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    require\n      prunable: prunable\n    deferred\n    end\n\n  prune_all (v: G)\n      -- Remove all occurrences of `v'.\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n      --|Default implementation, usually inefficient.\n    require\n      prunable: prunable\n    do\n      from\n      until not has (v) loop\n        prune (v)\n      end\n    ensure\n      no_more_occurrences: not has (v)\n    end\n\n  wipe_out\n      -- Remove all items.\n    require\n      prunable: prunable\n    deferred\n    ensure\n      wiped_out: is_empty\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"comparable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class COMPARABLE inherit\n\n  PART_COMPARABLE\n    redefine\n      is_less, is_less_equal,\n      is_greater, is_greater_equal,\n      is_equal\n    end\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    deferred\n    ensure then\n      asymmetric: Result implies not (other < Current)\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    do\n      Result := not (other < Current)\n    ensure then\n      definition: Result = ((Current < other) or (Current ~ other))\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    do\n      Result := other < Current\n    ensure then\n      definition: Result = (other < Current)\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    do\n      Result := not (Current < other)\n    ensure then\n      definition: Result = (other <= Current)\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := (not (Current < other) and not (other < Current))\n    ensure then\n      trichotomy: Result = (not (Current < other) and not (other < Current))\n    end\n\n  three_way_comparison (other: like Current): INTEGER\n      -- If current object equal to `other', 0;\n      -- if smaller, -1; if greater, 1\n    require\n      other_exists: other /= Void\n    do\n      if Current < other then\n        Result := -1\n      elseif other < Current then\n        Result := 1\n      end\n    ensure\n      equal_zero: (Result = 0) = (Current ~ other)\n      smaller_negative: (Result = -1) = (Current < other)\n      greater_positive: (Result = 1) = (Current > other)\n    end\n\n  max (other: like Current): like Current\n      -- The greater of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current >= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_smaller: Current >= other implies Result = Current\n      other_if_smaller: Current < other implies Result = other\n    end\n\n  min (other: like Current): like Current\n      -- The smaller of current object and `other'\n    require\n      other_exists: other /= Void\n    do\n      if Current <= other then\n        Result := Current\n      else\n        Result := other\n      end\n    ensure\n      current_if_not_greater: Current <= other implies Result = Current\n      other_if_greater: Current > other implies Result = other\n    end\n\ninvariant\n\n  irreflexive_comparison: not (Current < Current)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"container.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: access;\n  access: membership;\n  contents: generic;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class\n  CONTAINER [G]\n\nfeature -- Access\n\n  has (v: G): BOOLEAN\n      -- Does structure include `v'?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    deferred\n    ensure\n      not_found_in_empty: Result implies not is_empty\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is there no element?\n    deferred\n    end\n\n  empty: BOOLEAN\n      -- Is there no element?\n    obsolete\n      \"ELKS 2000: Use `is_empty' instead\"\n    do\n      Result := is_empty\n    end\n\n  object_comparison: BOOLEAN\n      -- Must search operations use `equal' rather than `='\n      -- for comparing references? (Default: no, use `='.)\n\n  changeable_comparison_criterion: BOOLEAN\n      -- May `object_comparison' be changed?\n      -- (Answer: yes by default.)\n    do\n      Result := True\n    end\n\nfeature -- Status setting\n\n  compare_objects\n      -- Ensure that future search operations will use `equal'\n      -- rather than `=' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := True\n    ensure\n      object_comparison\n    end\n\n  compare_references\n      -- Ensure that future search operations will use `='\n      -- rather than `equal' for comparing references.\n    require\n      changeable_comparison_criterion: changeable_comparison_criterion\n    do\n      object_comparison := False\n    ensure\n      reference_comparison: not object_comparison\n    end\n\nfeature -- Conversion\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    deferred\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"cycle.e","content":"class A1\ninherit\n  B1\nend\n\nclass B1\ninherit\n  A1\nend\n"});
__eiffel_builtin.push({"filename":"debug_output.e","content":"note\n  description: \"Objects that provide an output in debugger\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-17 11:46:15 -0800 (Thu, 17 Jan 2013) $\"\n  revision: \"$Revision: 92124 $\"\n\ndeferred class\n  DEBUG_OUTPUT\n\nfeature -- Status report\n\n  debug_output: READABLE_STRING_GENERAL\n      -- String that should be displayed in debugger to represent `Current'.\n    deferred\n    ensure\n      result_not_void: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"finite.e","content":"note\n  description: \"Structures with a finite item count\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: finite, storage;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class FINITE [G] inherit\n\n  BOX [G]\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of items\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    do\n      Result := (count = 0)\n    end\n\ninvariant\n  empty_definition: is_empty = (count = 0)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"hashable.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  HASHABLE\n\nfeature -- Access\n\n  hash_code: INTEGER\n      -- Hash code value\n    deferred\n    ensure\n      good_hash_value: Result >= 0\n    end\n\nfeature -- Status report\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True by default.)\n    do\n      Result := True\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class INDEXABLE [G, H -> INTEGER] inherit\n\n  TABLE [G, INTEGER]\n    rename\n      valid_key as valid_index,\n      force as put\n    end\n\n  READABLE_INDEXABLE [G]\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      asa_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\n-- convert\n--   make_from_reference ({INTEGER_32_REF}),\n--   to_real: {REAL_32},\n--   to_double: {REAL_64},\n--   to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nend\n"});
__eiffel_builtin.push({"filename":"integer_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  INTEGER_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\"\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: INTEGER_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := item & 0x7FFFFFFF\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: INTEGER_32 = -2147483648\n  Max_value: INTEGER_32 = 2147483647\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: INTEGER_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := item >= 0\n    ensure\n      in_bounds: Result = (item >= 0 and\n        item.to_natural_32 >= {CHARACTER_32}.Min_value and\n        item.to_natural_32 <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  abs: INTEGER_32\n      -- Absolute value\n    do\n      Result := abs_ref.item\n    ensure\n      non_negative: Result >= 0\n      same_absolute_value: (Result = item) or (Result = -item)\n    end\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    do\n      create Result\n      Result.set_item (- item)\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: INTEGER_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: INTEGER_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      item_non_negative: item >= 0\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    require\n      item_non_negative: item >= 0\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_small: item >= {INTEGER_8}.Min_value\n      not_too_big: item <= {INTEGER_8}.Max_value\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_small: item >= {INTEGER_16}.Min_value\n      not_too_big: item <= {INTEGER_16}.Max_value\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer, frozen to_integer_32: INTEGER_32\n      -- Return `item'.\n    do\n      Result := item\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_double\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER_32): INTEGER\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & (1 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): INTEGER_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | (1 |<< n)\n      else\n        Result := item & (1 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: INTEGER_32): INTEGER_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (11)\n      Result.append_integer (item)\n    end\n\nfeature {NONE} -- Implementation\n\n  abs_ref: like Current\n      -- Absolute value\n    do\n      if item >= 0 then\n        Result := Current\n      else\n        Result := -Current\n      end\n    ensure\n      result_exists: Result /= Void\n      same_absolute_value: (Result ~ Current) or (Result ~ -Current)\n    end\n\ninvariant\n\n  sign_times_abs: sign * abs = item\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"iterable.e","content":"note\n  description: \"Structure that can be iterated over using `across...loop...end'.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  ITERABLE [G]\n\nfeature -- Access\n\n  new_cursor: ITERATION_CURSOR [G]\n      -- Fresh cursor associated with current structure\n    deferred\n    ensure\n      result_attached: Result /= Void\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"mismatch_corrector.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  MISMATCH_CORRECTOR\n\nfeature -- Correction\n\n  correct_mismatch\n      -- Attempt to correct object mismatch using `mismatch_information'.\n    local\n      l_msg: STRING\n      l_exc: EXCEPTIONS\n    do\n        -- If it is not redefined then we raise an exception.\n      create l_msg.make_from_string (\"Mismatch: \")\n      create l_exc\n      l_msg.append (generating_type)\n      l_exc.raise_retrieval_exception (l_msg)\n    end\n\n  mismatch_information: MISMATCH_INFORMATION\n      -- Original attribute values of mismatched object\n    once\n      create Result\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32.e","content":"note\n  description: \"Unsigned integer values coded on 32 bits.\"\n  external_name: \"System.UInt32\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_32 inherit\n\n  NATURAL_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_32_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_64: {INTEGER_64},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_32): NATURAL_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_32): NATURAL_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_32): NATURAL_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_32): NATURAL_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_32): NATURAL_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_32): NATURAL_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_32): NATURAL_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_32_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 32 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_32_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_32\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n        -- Clear sign bit.\n      Result := (item & 0x7FFFFFFF).to_integer_32\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_32 = 0\n  Max_value: NATURAL_32 = 4294967295\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_32)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := item <= {CHARACTER_8}.Max_value.to_natural_32\n    ensure\n      in_bounds: Result = (\n        item >= {CHARACTER_8}.Min_value.to_natural_32 and\n        item <= {CHARACTER_8}.Max_value.to_natural_32)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\nfeature {NONE} -- Initialization\n\n  make_from_reference (v: NATURAL_32_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: v /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_32_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    require\n      not_too_big: item <= {NATURAL_8}.Max_value\n    do\n      Result := as_natural_8\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    require\n      not_too_big: item <= {NATURAL_16}.Max_value\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_32\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    require\n      not_too_big: item <= {INTEGER_16}.Max_value.to_natural_32\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    require\n      not_too_big: item <= {INTEGER_32}.Max_value.to_natural_32\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i: INTEGER\n      a_digit, val: NATURAL_32\n    do\n      from\n        i := (create {PLATFORM}).Integer_32_bits // 4\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 0xF)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_valid_count: Result.count = (create {PLATFORM}).Integer_32_bits // 4\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item.to_integer_32\n      if tmp <= 9 then\n        Result := (tmp + ('0').code).to_character_8\n      else\n        Result := (('A').code + (tmp - 10)).to_character_8\n      end\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Returns corresponding CHARACTER_32 to `item' value.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_32\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_32: n <= 32\n      n_greater_or_equal_to_minus_32: n >= -32\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_32: n <= 32\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      Result := item & ((1).to_natural_32 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_32\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_32: n < 32\n    do\n      if b then\n        Result := item | ((1).to_natural_32 |<< n)\n      else\n        Result := item & ((1).to_natural_32 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_32): NATURAL_32\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (20)\n      Result.append_natural_32 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"natural_8.e","content":"note\n  description: \"Integer values coded on 8 bits\"\n  external_name: \"System.Byte\"\n  assembly: \"mscorlib\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-10-30 08:32:46 -0700 (Tue, 30 Oct 2012) $\"\n  revision: \"$Revision: 92022 $\"\n\nfrozen expanded class NATURAL_8 inherit\n\n  NATURAL_8_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      identity,\n      as_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real_32,\n      to_real_64,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\nconvert\n  make_from_reference ({NATURAL_8_REF}),\n  to_real_32: {REAL_32},\n  to_real_64: {REAL_64},\n  to_integer_16: {INTEGER_16},\n  to_integer_32: {INTEGER_32},\n  to_integer_64: {INTEGER_64},\n  to_natural_16: {NATURAL_16},\n  to_natural_32: {NATURAL_32},\n  to_natural_64: {NATURAL_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: NATURAL_8): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: NATURAL_8): NATURAL_8\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: NATURAL_8): NATURAL_8\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: NATURAL_8): NATURAL_8\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: NATURAL_8): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": NATURAL_8\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: NATURAL_8): NATURAL_8\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: NATURAL_8): NATURAL_8\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: NATURAL_8): NATURAL_8\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: NATURAL_8): NATURAL_8\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: NATURAL_8\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\nend\n"});
__eiffel_builtin.push({"filename":"natural_8_ref.e","content":"note\n  description: \"References to objects containing an integer value coded on 8 bits\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-19 14:26:14 -0700 (Mon, 19 May 2014) $\"\n  revision: \"$Revision: 95117 $\"\n\nclass\n  NATURAL_8_REF\n\ninherit\n  NUMERIC\n    rename\n      quotient as integer_quotient alias \"//\",\n      opposite as unapplicable_opposite\n    redefine\n      out, is_equal\n    end\n\n  COMPARABLE\n    redefine\n      out, is_equal\n    end\n\n  HASHABLE\n    redefine\n      is_hashable, out, is_equal\n    end\n\nfeature -- Access\n\n  item: NATURAL_8\n      -- Integer value\n    external\n      \"built_in\"\n    end\n\n  hash_code: INTEGER\n      -- Hash code value\n    do\n      Result := item\n    end\n\n  sign: INTEGER\n      -- Sign value (0, -1 or 1)\n    do\n      if item > 0 then\n        Result := 1\n      elseif item < 0 then\n        Result := -1\n      end\n    ensure\n      three_way: Result = three_way_comparison (zero)\n    end\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    do\n      create Result\n      Result.set_item (1)\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    do\n      create Result\n      Result.set_item (0)\n    end\n\n  ascii_char: CHARACTER_8\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use to_character_8 instead.\"\n    require\n      valid_character_code: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  Min_value: NATURAL_8 = 0\n  Max_value: NATURAL_8 = 255\n      -- Minimum and Maximum value hold in `item'.\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current integer less than `other'?\n    do\n      Result := item < other.item\n    end\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object and identical to it?\n    do\n      Result := other.item = item\n    end\n\nfeature -- Element change\n\n  set_item (i: NATURAL_8)\n      -- Make `i' the `item' value.\n    external\n      \"built_in\"\n    ensure\n      item_set: item = i\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    do\n      Result := other.item /= 0\n    ensure then\n      value: Result = (other.item /= 0)\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    do\n      if attached {INTEGER_32_REF} other as integer_value then\n        Result := integer_value.item >= 0 or item /= 0\n      elseif attached {REAL_32_REF} other as real_value then\n        Result := real_value.item >= 0.0 or item /= 0\n      elseif attached {REAL_64_REF} other as double_value then\n        Result := double_value.item >= 0.0 or item /= 0\n      end\n    ensure then\n      safe_values: ((other.conforms_to (0) and item /= 0) or\n        (other.conforms_to (0.0) and item > 0)) implies Result\n    end\n\n  is_hashable: BOOLEAN\n      -- May current object be hashed?\n      -- (True if it is not its type's default.)\n    do\n      Result := item /= 0\n    end\n\n  is_valid_character_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    obsolete\n      \"Use `is_valid_character_8_code' instead.\"\n    do\n      Result := is_valid_character_8_code\n    end\n\n  is_valid_character_8_code: BOOLEAN\n      -- Does current object represent a CHARACTER_8?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_8}.Min_value and item <= {CHARACTER_8}.Max_value)\n    end\n\n  is_valid_character_32_code: BOOLEAN\n      -- Does current object represent a CHARACTER_32?\n    do\n      Result := True\n    ensure\n      in_bounds: Result = (item >= {CHARACTER_32}.Min_value and item <= {CHARACTER_32}.Max_value)\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other'\n    do\n      create Result\n      Result.set_item (item + other.item)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    do\n      create Result\n      Result.set_item (item - other.item)\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    do\n      create Result\n      Result.set_item (item * other.item)\n    end\n\n  quotient alias \"/\" (other: like Current): REAL_64\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      Result := item / other.item\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    do\n      create Result\n      Result.set_item (+ item)\n    end\n\n  unapplicable_opposite: like Current\n      -- Unary minus\n    do\n      Result := Current\n    ensure then\n      not_applicable: False\n    end\n\n  integer_quotient alias \"//\" (other: like Current): like Current\n      -- Integer division of Current by `other'\n    do\n      create Result\n      Result.set_item (item // other.item)\n    end\n\n  integer_remainder alias \"\\\\\" (other: like Current): like Current\n      -- Remainder of the integer division of Current by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    do\n      create Result\n      Result.set_item (item \\\\ other.item)\n    ensure\n      result_exists: Result /= Void\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    do\n      Result := item ^ other\n    end\n\n  interval alias \"|..|\" (other: INTEGER): INTEGER_INTERVAL\n      -- Interval from current element to `other'\n      -- (empty if `other' less than current integer)\n    do\n      create Result.make (item, other)\n    end\n\nfeature {NONE} -- Conversion\n\n  make_from_reference (v: NATURAL_8_REF)\n      -- Initialize `Current' with `v.item'.\n    require\n      v_not_void: V /= Void\n    do\n      set_item (v.item)\n    ensure\n      item_set: item = v.item\n    end\n\nfeature -- Conversion\n\n  to_reference: NATURAL_8_REF\n      -- Associated reference of Current\n    do\n      create Result\n      Result.set_item (item)\n    ensure\n      to_reference_not_void: Result /= Void\n    end\n\n  frozen to_boolean: BOOLEAN\n      -- True if not `zero'.\n    do\n      Result := item /= 0\n    end\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item.as_natural_8\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := item.as_natural_16\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := item.as_natural_32\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := item.as_natural_64\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    do\n      Result := item.as_integer_8\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := item.as_integer_16\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := item.as_integer_32\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := item.as_integer_64\n    end\n\n  frozen to_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    do\n      Result := item\n    end\n\n  frozen to_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    do\n      Result := as_natural_16\n    end\n\n  frozen to_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    do\n      Result := as_natural_32\n    end\n\n  frozen to_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    do\n      Result := as_natural_64\n    end\n\n  frozen to_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    require\n      not_too_big: item <= {INTEGER_8}.Max_value.to_natural_8\n    do\n      Result := as_integer_8\n    end\n\n  frozen to_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    do\n      Result := as_integer_16\n    end\n\n  frozen to_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    do\n      Result := as_integer_32\n    end\n\n  frozen to_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    do\n      Result := as_integer_64\n    end\n\n  to_real_32: REAL_32\n      -- Convert `item' into a REAL_32\n    do\n      Result := item.to_real_32\n    end\n\n  to_real_64: REAL_64\n      -- Convert `item' into a REAL_64\n    do\n      Result := item.to_real_64\n    end\n\n  to_hex_string: STRING\n      -- Convert `item' into an hexadecimal string.\n    local\n      i, val: INTEGER\n      a_digit: INTEGER\n    do\n      from\n        i := 2\n        create Result.make (i)\n        Result.fill_blank\n        val := item\n      until\n        i = 0\n      loop\n        a_digit := (val & 15)\n        Result.put (a_digit.to_hex_character, i)\n        val := val |>> 4\n        i := i - 1\n      end\n    ensure\n      result_not_void: Result /= Void\n      result_valid_count: Result.count = 2\n    end\n\n  to_hex_character: CHARACTER\n      -- Convert `item' into an hexadecimal character.\n    require\n      in_bounds: 0 <= item and item <= 15\n    local\n      tmp: INTEGER\n    do\n      tmp := item\n      Result := tmp.to_hex_character\n    ensure\n      valid_character: (\"0123456789ABCDEF\").has (Result)\n    end\n\n  to_character: CHARACTER\n      -- Returns corresponding ASCII character to `item' value.\n    obsolete\n      \"Use `to_character_8' instead.\"\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    require\n      valid_character: is_valid_character_8_code\n    do\n      Result := item.to_character_8\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    require\n      valid_character: is_valid_character_32_code\n    do\n      Result := item.to_character_32\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: like Current): like Current\n      -- Bitwise and between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_and (i.item))\n    ensure\n      bitwise_and_not_void: Result /= Void\n    end\n\n  bit_or alias \"|\" (i: like Current): like Current\n      -- Bitwise or between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_or (i.item))\n    ensure\n      bitwise_or_not_void: Result /= Void\n    end\n\n  bit_xor (i: like Current): like Current\n      -- Bitwise xor between Current' and `i'.\n    require\n      i_not_void: i /= Void\n    do\n      create Result\n      Result.set_item (item.bit_xor (i.item))\n    ensure\n      bitwise_xor_not_void: Result /= Void\n    end\n\n  bit_not: like Current\n      -- One's complement of Current.\n    do\n      create Result\n      Result.set_item (item.bit_not)\n    ensure\n      bit_not_not_void: Result /= Void\n    end\n\n  frozen bit_shift (n: INTEGER): NATURAL_8\n      -- Shift Current from `n' position to right if `n' positive,\n      -- to left otherwise.\n    require\n      n_less_or_equal_to_8: n <= 8\n      n_greater_or_equal_to_minus_8: n >= -8\n    do\n      if n > 0 then\n        Result := bit_shift_right (n).item\n      else\n        Result := bit_shift_left (- n).item\n      end\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to left.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_left (n))\n    ensure\n      bit_shift_left_not_void: Result /= Void\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): like Current\n      -- Shift Current from `n' position to right.\n    require\n      n_nonnegative: n >= 0\n      n_less_or_equal_to_8: n <= 8\n    do\n      create Result\n      Result.set_item (item.bit_shift_right (n))\n    ensure\n      bit_shift_right_not_void: Result /= Void\n    end\n\n  frozen bit_test (n: INTEGER): BOOLEAN\n      -- Test `n'-th position of Current.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      Result := item & ((1).to_natural_8 |<< n) /= 0\n    end\n\n  frozen set_bit (b: BOOLEAN; n: INTEGER): NATURAL_8\n      -- Copy of current with `n'-th position\n      -- set to 1 if `b', 0 otherwise.\n    require\n      n_nonnegative: n >= 0\n      n_less_than_8: n < 8\n    do\n      if b then\n        Result := item | ((1).to_natural_8 |<< n)\n      else\n        Result := item & ((1).to_natural_8 |<< n).bit_not\n      end\n    end\n\n  frozen set_bit_with_mask (b: BOOLEAN; m: NATURAL_8): NATURAL_8\n      -- Copy of current with all 1 bits of m set to 1\n      -- if `b', 0 otherwise.\n    do\n      if b then\n        Result := item | m\n      else\n        Result := item & m.bit_not\n      end\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation of integer value\n    do\n      create Result.make (3)\n      Result.append_natural_8 (item)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"numeric.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n\n  NUMERIC\n\ninherit\n  DEBUG_OUTPUT\n    rename\n      debug_output as out\n    end\n\nfeature -- Access\n\n  one: like Current\n      -- Neutral element for \"*\" and \"/\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  zero: like Current\n      -- Neutral element for \"+\" and \"-\"\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\nfeature -- Status report\n\n  divisible (other: like Current): BOOLEAN\n      -- May current object be divided by `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  exponentiable (other: NUMERIC): BOOLEAN\n      -- May current object be elevated to the power `other'?\n    obsolete\n      \"[2008_04_01] Will be removed since not used.\"\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: like Current): like Current\n      -- Sum with `other' (commutative).\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n      commutative: Result ~ (other + Current)\n    end\n\n  minus alias \"-\" (other: like Current): like Current\n      -- Result of subtracting `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  product alias \"*\" (other: like Current): like Current\n      -- Product by `other'\n    require\n      other_exists: other /= Void\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  quotient alias \"/\" (other: like Current): like Current\n      -- Division by `other'\n    require\n      other_exists: other /= Void\n      good_divisor: divisible (other)\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  identity alias \"+\": like Current\n      -- Unary plus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\n  opposite alias \"-\": like Current\n      -- Unary minus\n    deferred\n    ensure\n      result_exists: Result /= Void\n    end\n\ninvariant\n\n--  neutral_addition: equal (Current + zero, Current);\n--  self_subtraction: equal (Current - Current, zero);\n--  neutral_multiplication: equal (Current * one, Current);\n--  self_division: divisible (Current) implies equal (Current / Current, one)\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"part_comparable.e","content":"note\n  description: \"Objects that may be compared according to a partial order relation\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class\n  PART_COMPARABLE\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is current object less than `other'?\n    require\n      other_exists: other /= Void\n    deferred\n    end\n\n  is_less_equal alias \"<=\" (other: like Current): BOOLEAN\n      -- Is current object less than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (Current < other) or (Current ~ other)\n    end\n\n  is_greater alias \">\" (other: like Current): BOOLEAN\n      -- Is current object greater than `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := other < Current\n    end\n\n  is_greater_equal alias \">=\" (other: like Current): BOOLEAN\n      -- Is current object greater than or equal to `other'?\n    require\n      other_exists: other /= Void\n    do\n      Result := (other < Current) or (Current ~ other)\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_indexable.e","content":"note\n  description: \"Tables whose keys are integers in a contiguous interval\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: indexable, access;\n  access: index, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class READABLE_INDEXABLE [G]\n\ninherit\n  ITERABLE [G]\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): G\n      -- Entry at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  new_cursor: INDEXABLE_ITERATION_CURSOR [G]\n      -- <Precursor>\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nfeature -- Measurement\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    deferred\n    ensure\n      not_void: Result /= Void\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' a valid index?\n    deferred\n    ensure\n      only_if_in_index_set:\n        Result implies ((i >= index_set.lower) and (i <= index_set.upper))\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n\n\n\n"});
__eiffel_builtin.push({"filename":"readable_string_32.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:21:19 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95060 $\"\n\ndeferred class\n  READABLE_STRING_32\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    redefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    end\n\n  READABLE_INDEXABLE [CHARACTER_32]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_readable_string_8: {READABLE_STRING_8},\n  as_string_8: {STRING_8},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_32; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_32)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    deferred\n    ensure\n      not_shared_implementation: Current /= s\n      initialized: same_string_general (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_32_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c'.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_32): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_32; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    end\n\n  last_index_of (c: CHARACTER_32; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_32\n      -- New STRING_32 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_32\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_32}\n    do\n      if same_type (create {STRING_32}.make_empty) and then attached {STRING_32} Current as l_s32 then\n        Result := l_s32\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_32}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_32]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n        nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n      do\n        if other = Current then\n          Result := True\n        else\n          nb := count\n          if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n          end\n        end\n\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_32): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER_32\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_32): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = False\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = True\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN\n      -- <Precursor>\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      from\n        Result := True\n        i := area_lower\n        nb := count + i\n        l_area := area\n      until\n        i = nb or not Result\n      loop\n        Result := l_area.item (i).code <= {CHARACTER_8}.max_value\n        i := i + 1\n      end\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_prop: like character_properties\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n        l_prop := character_properties\n      until\n        i > n or not l_prop.is_space (l_area.item (i))\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_32): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    end\n\n  starts_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_32): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := True\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        Result := is_case_insensitive_equal_general (true_constant)\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        Result := is_case_insensitive_equal_general (false_constant)\n      end\n    end\n\nfeature {READABLE_STRING_32} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_32)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (as_string_8)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies same_string_general (Result)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_32_SEARCHER\n      -- String searcher specialized for READABLE_STRING_32 instances\n    once\n      create Result.make\n    end\n\nfeature {NONE} -- Implementation\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_lower (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version when available.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n      c1, c2: CHARACTER_32\n      l_prop: like character_properties\n    do\n      from\n        i := start_index\n        l_prop := character_properties\n      until\n        i > end_index\n      loop\n        c1 := a.item (i)\n        c2 := l_prop.to_upper (c1)\n          -- Let's avoid a write access if not needed.\n        if c1 /= c2 then\n          a.put (c2, i)\n        end\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-05-14 22:22:02 -0700 (Wed, 14 May 2014) $\"\n  revision: \"$Revision: 95061 $\"\n\ndeferred class\n  READABLE_STRING_8\n\ninherit\n  READABLE_STRING_GENERAL\n    rename\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    redefine\n      copy, is_equal, out\n    end\n\n  READABLE_INDEXABLE [CHARACTER_8]\n    redefine\n      copy, is_equal, out\n    end\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  as_string_8: {STRING_8},\n  as_readable_string_32: {READABLE_STRING_32},\n  as_string_32: {STRING_32}\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    do\n      count := 0\n      internal_hash_code := 0\n      create area.make_filled ('%/000/', n + 1)\n    end\n\n  make_filled (c: CHARACTER_8; n: INTEGER)\n      -- Create string of length `n' filled with `c'.\n    require\n      valid_count: n >= 0\n    do\n      make (n)\n      fill_character (c)\n    ensure\n      count_set: count = n\n      area_allocated: capacity >= n\n      filled: occurrences (c) = count\n    end\n\n  make_from_string (s: READABLE_STRING_8)\n      -- Initialize from the characters of `s'.\n    require\n      string_exists: s /= Void\n    do\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n      if Current /= s then\n        create area.make_empty (count + 1)\n        area.copy_data (s.area, s.area_lower, 0, count + 1)\n      end\n    ensure\n      not_shared_implementation: Current /= s implies not shared_with (s)\n      initialized: same_string (s)\n    end\n\n  make_from_c (c_string: POINTER)\n      -- Initialize from contents of `c_string',\n      -- a string created by some C function\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n      l_count := c_string_provider.count\n      create area.make_filled ('%/000/', l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into_character_8_area (area, 1, l_count)\n    end\n\n  make_from_c_pointer (c_string: POINTER)\n      -- Create new instance from contents of `c_string',\n      -- a string created by some C function\n    obsolete\n      \"Use `make_from_c' instead.\"\n    require\n      c_string_exists: c_string /= default_pointer\n    do\n      make_from_c (c_string)\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    deferred\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8\n      -- Character at position `i'.\n    deferred\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n    obsolete\n      \"For consistency with Unicode string handling, use `code (i)' instead.\"\n    require\n      index_small_enough: i <= count\n      index_large_enough: i > 0\n    deferred\n    end\n\n  shared_with (other: READABLE_STRING_8): BOOLEAN\n      -- Does string share the text of `other'?\n    do\n      Result := (other /= Void) and then (area = other.area)\n    end\n\n  index_of (c: CHARACTER_8; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      a: like area\n      i, nb, l_lower_area: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          l_lower_area := area_lower\n          i := start_index - 1 + l_lower_area\n          nb := nb + l_lower_area\n          a := area\n        until\n          i = nb or else a.item (i) = c\n        loop\n          i := i + 1\n        end\n        if i < nb then\n            -- We add +1 due to the area starting at 0 and not at 1\n            -- and substract `area_lower'\n          Result := i + 1 - l_lower_area\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: CHARACTER_8; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c',\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    local\n      a: like area\n      i, l_lower_area: INTEGER\n    do\n      from\n        l_lower_area := area_lower\n        i := start_index_from_end - 1 + l_lower_area\n        a := area\n      until\n        i < l_lower_area or else a.item (i) = c\n      loop\n        i := i - 1\n      end\n        -- We add +1 due to the area starting at 0 and not at 1.\n      Result := i + 1 - l_lower_area\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_pos, end_pos)\n    end\n\n  string: STRING_8\n      -- New STRING_8 having same character sequence as `Current'.\n    do\n      create Result.make_from_string (Current)\n    ensure\n      string_not_void: Result /= Void\n      string_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  string_representation: STRING_8\n      -- Similar to `string' but only create a new object if `Current' is not of dynamic type {STRING_8}\n    do\n      if same_type (create {STRING_8}.make_empty) and then attached {STRING_8} Current as l_s8 then\n        Result := l_s8\n      else\n        Result := string\n      end\n    ensure\n      Result_not_void: Result /= Void\n      correct_type: Result.same_type (create {STRING_8}.make_empty)\n      first_item: count > 0 implies Result.item (1) = item (1)\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).string\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.substring_index (Current, other, start_index, count)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- <Precursor>\n    do\n      Result := string_searcher.fuzzy_index (Current, other, start, count, fuzz)\n    end\n\nfeature -- Measurement\n\n  capacity: INTEGER\n      -- Allocated space\n    do\n      Result := area.count - 1\n    end\n\n  count: INTEGER\n      -- Actual number of characters making up the string\n\n  occurrences (c: CHARACTER_8): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n      a: SPECIAL [CHARACTER_8]\n    do\n      from\n        i := area_lower\n        nb := count + i\n        a := area\n      until\n        i = nb\n      loop\n        if a.item (i) = c then\n          Result := Result + 1\n        end\n        i := i + 1\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (1, count)\n    ensure then\n      index_set_not_void: Result /= Void\n      index_set_count: Result.count = count\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is string made of same character sequence as `other'\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n      l_hash, l_other_hash: like internal_hash_code\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n            -- Let's compare the content if and only if the hash_code are the same or not yet computed.\n          l_hash := internal_hash_code\n          l_other_hash := other.internal_hash_code\n          if l_hash = 0 or else l_other_hash = 0 or else l_hash = l_other_hash then\n            Result := area.same_items (other.area, other.area_lower, area_lower, nb)\n          end\n        end\n      end\n    end\n\n  is_case_insensitive_equal (other: READABLE_STRING_8): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_area, l_other_area: like area\n      c1,c2: CHARACTER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_area := area\n          l_other_area := other.area\n          Result := True\n          i := area_lower + index_pos - 1\n          j := other.area_lower + start_pos - 1\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := l_area.item (i)\n          c2 := l_other_area.item (j)\n          if c1 /= c2 and then c1.as_lower /= c2.as_lower then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: l_area.upper - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  same_string (other: READABLE_STRING_8): BOOLEAN\n      -- Do `Current' and `other' have same character sequence?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      definition: Result = (string ~ other.string)\n    end\n\n  same_characters (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        Result := area.same_items (other.area, other.area_lower + start_pos - 1, area_lower + index_pos - 1, nb)\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  is_less alias \"<\" (other: like Current): BOOLEAN\n      -- Is string lexicographically lower than `other'?\n    local\n      other_count: INTEGER\n      current_count: INTEGER\n    do\n      if other /= Current then\n        other_count := other.count\n        current_count := count\n        if other_count = current_count then\n          Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n        else\n          if current_count < other_count then\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, current_count) >= 0\n          else\n            Result := str_strict_cmp (other.area, area, other.area_lower, area_lower, other_count) > 0\n          end\n        end\n      end\n    end\n\nfeature -- Status report\n\n  is_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_string_32: BOOLEAN = False\n      -- <Precursor>\n\n  is_valid_as_string_8: BOOLEAN = True\n      -- <Precursor>\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- <Precursor>\n    local\n      i, n: INTEGER\n      l_area: like area\n    do\n      from\n        l_area := area\n        i := area_lower + start_index - 1\n        n := area_lower + end_index - 1\n      until\n        i > n or not l_area.item (i).is_space\n      loop\n        i := i + 1\n      end\n      Result := i > n\n    end\n\n  has (c: CHARACTER_8): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := area_lower\n          l_area := area\n          nb := nb + i\n        until\n          i = nb or else (l_area.item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i < nb)\n      end\n    ensure\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  starts_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_lower + i\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_8): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j, nb: INTEGER\n      l_area, l_s_area: like area\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            l_area := area\n            l_s_area := s.area\n            j := area_upper + 1\n            i := s.area_upper + 1\n            nb := s.area_lower\n            Result := True\n          until\n            i = nb\n          loop\n            i := i - 1\n            j := j - 1\n            if l_area.item (j) /= l_s_area.item (i) then\n              Result := False\n              i := nb -- Jump out of loop\n            end\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  valid_code (v: NATURAL_32): BOOLEAN\n      -- Is `v' a valid code for a CHARACTER_32?\n    do\n      Result := v <= {CHARACTER_8}.max_value.to_natural_32\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    local\n      nb: INTEGER\n      l_area: like area\n      i: INTEGER\n    do\n      nb := count\n      if nb = 4 then\n          -- Check if this is `true_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 't' and then\n          l_area.item (i + 1).lower = 'r' and then\n          l_area.item (i + 2).lower = 'u' and then\n          l_area.item (i + 3).lower = 'e'\n      elseif nb = 5 then\n          -- Check if this is `false_constant'\n        l_area := area\n        i := area_lower\n        Result := l_area.item (i).lower = 'f' and then\n          l_area.item (i + 1).lower = 'a' and then\n          l_area.item (i + 2).lower = 'l' and then\n          l_area.item (i + 3).lower = 's' and then\n          l_area.item (i + 4).lower = 'e'\n      end\n    end\n\nfeature {READABLE_STRING_8} -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying the characters of `other'.\n      -- (This is also used by `twin'.)\n    local\n      old_area: like area\n    do\n      if other /= Current then\n        old_area := area\n        standard_copy (other)\n          -- Note: <= is needed as all Eiffel string should have an\n          -- extra character to insert null character at the end.\n        if old_area = Void or else old_area = other.area or else old_area.count <= count then\n            -- Prevent copying of large `area' if only a few characters are actually used.\n          area := area.resized_area (count + 1)\n        else\n          old_area.copy_data (area, 0, 0, count)\n          area := old_area\n        end\n        internal_hash_code := 0\n      end\n    ensure then\n      new_result_count: count = other.count\n      -- same_characters: For every `i' in 1..`count', `item' (`i') = `other'.`item' (`i')\n    end\n\nfeature {NONE} -- Element change\n\n  fill_character (c: CHARACTER_8)\n      -- Fill with `capacity' characters all equal to `c'.\n    local\n      l_cap: like capacity\n    do\n      l_cap := capacity\n      if l_cap /= 0 then\n        area.fill_with (c, 0, l_cap - 1)\n        count := l_cap\n        internal_hash_code := 0\n      end\n    ensure\n      filled: count = capacity\n      same_size: capacity = old capacity\n      -- all_char: For every `i' in 1..`capacity', `item' (`i') = `c'\n    end\n\nfeature -- Conversion\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    deferred\n    ensure\n      same_count: Result.count = count\n      -- reversed: For every `i' in 1..`count', `Result'.`item' (`i') = `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    end\n\nfeature -- Output\n\n  out: STRING\n      -- Printable representation\n    do\n      create Result.make (count)\n      Result.append (Current)\n    ensure then\n      out_not_void: Result /= Void\n      same_items: same_type (\"\") implies Result.same_string (Current)\n    end\n\nfeature {NONE} -- Implementation\n\n  string_searcher: STRING_8_SEARCHER\n      -- String searcher specialized for READABLE_STRING_8 instances\n    once\n      create Result.make\n    end\n\n  str_strict_cmp (this, other: like area; this_index, other_index, n: INTEGER): INTEGER\n      -- Compare `n' characters from `this' starting at `this_index' with\n      -- `n' characters from and `other' starting at `other_index'.\n      -- 0 if equal, < 0 if `this' < `other',\n      -- > 0 if `this' > `other'\n    require\n      this_not_void: this /= Void\n      other_not_void: other /= Void\n      n_non_negative: n >= 0\n      n_valid: n <= (this.upper - this_index + 1) and n <= (other.upper - other_index + 1)\n    local\n      i, j, nb, l_current_code, l_other_code: INTEGER\n    do\n      from\n        i := this_index\n        nb := i + n\n        j := other_index\n      until\n        i = nb\n      loop\n        l_current_code := this.item (i).code\n        l_other_code := other.item (j).code\n        if l_current_code /= l_other_code then\n          Result := l_current_code - l_other_code\n          i := nb - 1 -- Jump out of loop\n        end\n        i := i + 1\n        j := j + 1\n      end\n    end\n\n  to_lower_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their lower version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).lower, i)\n        i := i + 1\n      end\n    end\n\n  to_upper_area (a: like area; start_index, end_index: INTEGER)\n      -- Replace all characters in `a' between `start_index' and `end_index'\n      -- with their upper version.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      i: INTEGER\n    do\n      from\n        i := start_index\n      until\n        i > end_index\n      loop\n        a.put (a.item (i).upper, i)\n        i := i + 1\n      end\n    end\n\n  mirror_area (a: like area; start_index, end_index: INTEGER)\n      -- Mirror all characters in `a' between `start_index' and `end_index'.\n    require\n      a_not_void: a /= Void\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < a.count\n    local\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      from\n        i := end_index\n      until\n        i <= j\n      loop\n        c := a.item (i)\n        a.put (a.item (j), i)\n        a.put (c, j)\n        i := i - 1\n        j := j + 1\n      end\n    end\n\nfeature\n  {READABLE_STRING_8, READABLE_STRING_32,\n  STRING_8_SEARCHER, STRING_32_SEARCHER,\n  HEXADECIMAL_STRING_TO_INTEGER_CONVERTER,\n  STRING_TO_INTEGER_CONVERTOR,\n  STRING_TO_REAL_CONVERTOR} -- Implementation\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters\n\n  area_lower: INTEGER\n      -- Minimum index\n    do\n    ensure\n      area_lower_non_negative: Result >= 0\n      area_lower_valid: Result <= area.upper\n    end\n\n  area_upper: INTEGER\n      -- Maximum index\n    do\n      Result := area_lower + count - 1\n    ensure\n      area_upper_valid: Result <= area.upper\n      area_upper_in_bound: area_lower <= Result + 1\n    end\n\ninvariant\n  area_not_void: area /= Void\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"readable_string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes. Read-only interface.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 06:27:01 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94630 $\"\n\ndeferred class\n  READABLE_STRING_GENERAL\n\ninherit\n  COMPARABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    end\n\n  HASHABLE\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\n  STRING_HANDLER\n    export\n      {READABLE_STRING_GENERAL} copy, standard_copy, deep_copy\n    undefine\n      is_equal\n    end\n\nfeature {NONE} -- Initialization\n\n  make (n: INTEGER)\n    require\n      non_negative_size: n >= 0\n    deferred\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\n  make_empty\n      -- Create empty string.\n    do\n      make (0)\n    ensure\n      empty: count = 0\n      area_allocated: capacity >= 0\n    end\n\nfeature -- Access\n\n  code (i: INTEGER): NATURAL_32\n      -- Code at position `i'\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  item alias \"[]\" (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    require\n      valid_index: valid_index (i)\n    deferred\n    end\n\n  index_of (c: like item; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else item (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has (c)\n      found_if_present: substring (start_index, count).has (c) implies item (Result) = c\n      none_before: substring (start_index, count).has (c) implies\n        not substring (start_index, Result - 1).has (c)\n    end\n\n  last_index_of (c: like item; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else item (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has (c)\n      found_if_present: substring (1, start_index_from_end).has (c) implies item (Result) = c\n      none_after: substring (1, start_index_from_end).has (c) implies\n        not substring (Result + 1, start_index_from_end).has (c)\n    end\n\n  index_of_code (c: like code; start_index: INTEGER): INTEGER\n      -- Position of first occurrence of `c' at or after `start_index';\n      -- 0 if none.\n    require\n      start_large_enough: start_index >= 1\n      start_small_enough: start_index <= count + 1\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if start_index <= nb then\n        from\n          i := start_index\n        until\n          i > nb or else code (i) = c\n        loop\n          i := i + 1\n        end\n        if i <= nb then\n          Result := i\n        end\n      end\n    ensure\n      valid_result: Result = 0 or (start_index <= Result and Result <= count)\n      zero_if_absent: (Result = 0) = not substring (start_index, count).has_code (c)\n      found_if_present: substring (start_index, count).has_code (c) implies code (Result) = c\n      none_before: substring (start_index, count).has_code (c) implies\n        not substring (start_index, Result - 1).has_code (c)\n    end\n\n  last_index_of_code (c: like code; start_index_from_end: INTEGER): INTEGER\n      -- Position of last occurrence of `c'.\n      -- 0 if none.\n    require\n      start_index_small_enough: start_index_from_end <= count\n      start_index_large_enough: start_index_from_end >= 1\n    do\n      from\n        Result := start_index_from_end\n      until\n        Result <= 0 or else code (Result) = c\n      loop\n        Result := Result - 1\n      end\n    ensure\n      valid_result: 0 <= Result and Result <= start_index_from_end\n      zero_if_absent: (Result = 0) = not substring (1, start_index_from_end).has_code (c)\n      found_if_present: substring (1, start_index_from_end).has_code (c) implies code (Result) = c\n      none_after: substring (1, start_index_from_end).has_code (c) implies\n        not substring (Result + 1, start_index_from_end).has_code (c)\n    end\n\n  false_constant: STRING_8 = \"false\"\n      -- Constant string \"false\"\n\n  true_constant: STRING_8 = \"true\"\n      -- Constant string \"true\"\n\n  hash_code: INTEGER\n      -- Hash code value\n    local\n      i, nb: INTEGER\n    do\n      Result := internal_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + item (i).code\n          i := i + 1\n        end\n        internal_hash_code := Result\n      end\n    end\n\n  case_insensitive_hash_code: INTEGER\n      -- Hash code value of the lower case version of `Current'.\n    local\n      l_props: like character_properties\n      i, nb: INTEGER\n    do\n      Result := internal_case_insensitive_hash_code\n      if Result = 0 then\n          -- The magic number `8388593' below is the greatest prime lower than\n          -- 2^23 so that this magic number shifted to the left does not exceed 2^31.\n        from\n          i := 1\n          nb := count\n          l_props := character_properties\n        until\n          i > nb\n        loop\n          Result := ((Result \\\\ 8388593) |<< 8) + l_props.to_lower (item (i)).code\n          i := i + 1\n        end\n        internal_case_insensitive_hash_code := Result\n      end\n    ensure\n      consistent: Result = as_lower.hash_code\n    end\n\nfeature -- Status report\n\n  is_immutable: BOOLEAN\n      -- Can the character sequence of `Current' be not changed?\n    do\n      Result := False\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the string?\n    do\n      Result := (i > 0) and (i <= count)\n    ensure\n      definition: Result = (1 <= i and i <= count)\n    end\n\n  valid_code (v: like code): BOOLEAN\n      -- Is `v' a valid code for Current?\n    deferred\n    end\n\n  is_string_8: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_8?\n    deferred\n    end\n\n  is_string_32: BOOLEAN\n      -- Is `Current' a sequence of CHARACTER_32?\n    deferred\n    end\n\n  is_valid_as_string_8: BOOLEAN\n      -- Is `Current' convertible to a sequence of CHARACTER_8 without information loss?\n    deferred\n    end\n\n  is_empty: BOOLEAN\n      -- Is structure empty?\n    deferred\n    end\n\n  is_whitespace: BOOLEAN\n      -- Is structure containing only whitespace characters?\n    do\n      Result := is_substring_whitespace (1, count)\n    end\n\n  is_substring_whitespace (start_index, end_index: INTEGER): BOOLEAN\n      -- Is substring between `start_index' and `end_index' containing only whitespace characters?\n    require\n      start_index_big_enough: 1 <= start_index\n      end_index_small_enough: end_index <= count\n      consistent_indexes: start_index - 1 <= end_index\n    deferred\n    end\n\n  has (c: like item): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (item (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then item (1) = c implies Result\n      recurse: (count > 0 and then item (1) /= c) implies\n        (Result = substring (2, count).has (c))\n    end\n\n  has_code (c: like code): BOOLEAN\n      -- Does string include `c'?\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb or else (code (i) = c)\n        loop\n          i := i + 1\n        end\n        Result := (i <= nb)\n      end\n    ensure then\n      false_if_empty: count = 0 implies not Result\n      true_if_first: count > 0 and then code (1) = c implies Result\n      recurse: (count > 0 and then code (1) /= c) implies\n        (Result = substring (2, count).has_code (c))\n    end\n\n  is_number_sequence: BOOLEAN\n      -- Does `Current' represent a number sequence?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_no_limitation)\n    ensure\n      syntax_and_range:\n        -- Result is true if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  Current can be produced by \"Integer_literal\":\n        --\n        -- Integer_literal = [Space] [Sign] Integer [Space]\n        -- Space  = \" \" | \" \" Space\n        -- Sign   = \"+\" | \"-\"\n        -- Integer  = Digit | Digit Integer\n        -- Digit  = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n    end\n\n  is_real_sequence: BOOLEAN\n      -- Does `Current' represent a real sequence?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following condition is satisfied:\n        --\n        -- In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n    end\n\n  is_real, is_real_32: BOOLEAN\n      -- Does `Current' represent a REAL_32?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_real)\n      Result := l_convertor.is_integral_real\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type REAL.\n    end\n\n  is_double, is_real_64: BOOLEAN\n      -- Does `Current' represent a REAL_64?\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_double)\n      Result := l_convertor.is_integral_double\n    ensure\n      syntax_and_range:\n        -- 'Result' is True if and only if the following two\n        -- conditions are satisfied:\n        --\n        -- 1. In the following BNF grammar, the value of\n        --  'Current' can be produced by \"Real_literal\":\n        --\n        -- Real_literal = Mantissa [Exponent_part]\n        -- Exponent_part = \"E\" Exponent\n        --         | \"e\" Exponent\n        -- Exponent   = Integer_literal\n        -- Mantissa   = Decimal_literal\n        -- Decimal_literal = Integer_literal [\".\" [Integer]] | \".\" Integer\n        -- Integer_literal = [Sign] Integer\n        -- Sign     = \"+\" | \"-\"\n        -- Integer    = Digit | Digit Integer\n        -- Digit    = \"0\"|\"1\"|\"2\"|\"3\"|\"4\"|\"5\"|\"6\"|\"7\"|\"8\"|\"9\"\n        --\n        -- 2. The numerical value represented by 'Current'\n        --  is within the range that can be represented\n        --  by an instance of type DOUBLE.\n    end\n\n  is_boolean: BOOLEAN\n      -- Does `Current' represent a BOOLEAN?\n    deferred\n    ensure\n      is_boolean: Result = (true_constant.same_string_general (as_lower) or\n        false_constant.same_string_general (as_lower))\n    end\n\n  is_integer_8: BOOLEAN\n      -- Does `Current' represent an INTEGER_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_8)\n    end\n\n  is_integer_16: BOOLEAN\n      -- Does `Current' represent an INTEGER_16?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_16)\n    end\n\n  is_integer, is_integer_32: BOOLEAN\n      -- Does `Current' represent an INTEGER_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_32)\n    end\n\n  is_integer_64: BOOLEAN\n      -- Does `Current' represent an INTEGER_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_integer_64)\n    end\n\n  is_natural_8: BOOLEAN\n      -- Does `Current' represent a NATURAL_8?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_8)\n    end\n\n  is_natural_16: BOOLEAN\n      -- Does `Current' represent a NATURAL_16?\n\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_16)\n    end\n\n  is_natural, is_natural_32: BOOLEAN\n      -- Does `Current' represent a NATURAL_32?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_32)\n    end\n\n  is_natural_64: BOOLEAN\n      -- Does `Current' represent a NATURAL_64?\n    do\n      Result := is_valid_integer_or_natural ({NUMERIC_INFORMATION}.type_natural_64)\n    end\n\nfeature -- Measurement\n\n  count: INTEGER\n      -- Number of characters in Current\n    deferred\n    ensure\n      count_non_negative: Result >= 0\n    end\n\n  capacity: INTEGER\n      -- Number of characters allocated in Current\n    deferred\n    ensure\n      capacity_non_negative: Result >= 0\n    end\n\n  occurrences (c: CHARACTER_32): INTEGER\n      -- Number of times `c' appears in the string\n    local\n      i, nb: INTEGER\n    do\n      nb := count\n      if nb > 0 then\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          if item (i) = c then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    ensure then\n      zero_if_empty: count = 0 implies Result = 0\n      recurse_if_not_found_at_first_position:\n        (count > 0 and then item (1) /= c) implies\n          Result = substring (2, count).occurrences (c)\n      recurse_if_found_at_first_position:\n        (count > 0 and then item (1) = c) implies\n          Result = 1 + substring (2, count).occurrences (c)\n    end\n\nfeature -- Comparison\n\n  is_case_insensitive_equal (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Is string made of same character sequence as `other' regardless of casing\n      -- (possibly with a different capacity)?\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_caseless_characters (other, 1, nb, 1)\n        end\n      end\n    ensure\n      symmetric: Result implies other.is_case_insensitive_equal (Current)\n      consistent: attached {like Current} other as l_other implies (standard_is_equal (l_other) implies Result)\n      valid_result: as_lower ~ other.as_lower implies Result\n    end\n\n  same_caseless_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- caseless identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n      l_prop: like character_properties\n      c1,c2: like item\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          l_prop := character_properties\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          c1 := item (i)\n          c2 := other.item (j)\n          if c1 /= c2 and then l_prop.to_lower (c1) /= l_prop.to_lower (c2) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).is_case_insensitive_equal (other.substring (start_pos, end_pos))\n    end\n\n  has_substring (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `Current' contain `other'?\n    require\n      other_not_void: other /= Void\n    do\n      if other = Current then\n        Result := True\n      elseif other.count <= count then\n        Result := substring_index (other, 1) > 0\n      end\n    ensure\n      false_if_too_small: count < other.count implies not Result\n      true_if_initial: (count >= other.count and then\n        other.same_string (substring (1, other.count))) implies Result\n      recurse: (count >= other.count and then\n        not other.same_string (substring (1, other.count))) implies\n        (Result = substring (2, count).has_substring (other))\n    end\n\n  same_string (other: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does `other' represent the same string as `Current'?\n    require\n      other_not_void: other /= Void\n    local\n      nb: INTEGER\n    do\n      if other = Current then\n        Result := True\n      else\n        nb := count\n        if nb = other.count then\n          Result := nb = 0 or else same_characters (other, 1, nb, 1)\n        end\n      end\n    end\n\n  same_characters (other: READABLE_STRING_GENERAL; start_pos, end_pos, index_pos: INTEGER): BOOLEAN\n      -- Are characters of `other' within bounds `start_pos' and `end_pos'\n      -- identical to characters of current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n    local\n      i, j, nb: INTEGER\n    do\n      nb := end_pos - start_pos + 1\n      if nb <= count - index_pos + 1 then\n        from\n          Result := True\n          i := index_pos\n          j := start_pos\n          nb := nb + i\n        until\n          i = nb\n        loop\n          if item (i) /= other.item (j) then\n            Result := False\n            i := nb - 1 -- Jump out of the loop\n          end\n          i := i + 1\n          j := j + 1\n        variant\n          increasing_index: nb - i + 1\n        end\n      end\n    ensure\n      same_characters: Result = substring (index_pos, index_pos + end_pos - start_pos).same_string (other.substring (start_pos, end_pos))\n    end\n\n  starts_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string begin with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        if i <= count then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code (i) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (1, s.count))\n    end\n\n  ends_with (s: READABLE_STRING_GENERAL): BOOLEAN\n      -- Does string finish with `s'?\n    require\n      argument_not_void: s /= Void\n    local\n      i, j: INTEGER\n    do\n      if Current = s then\n        Result := True\n      else\n        i := s.count\n        j := count\n        if i <= j then\n          from\n            Result := True\n          until\n            i = 0\n          loop\n            if code(j) /= s.code (i) then\n              Result := False\n              i := 1 -- Jump out of loop\n            end\n            i := i - 1\n            j := j - 1\n          end\n        end\n      end\n    ensure\n      definition: Result = s.same_string (substring (count - s.count + 1, count))\n    end\n\n  substring_index_in_bounds (other: READABLE_STRING_GENERAL; start_pos, end_pos: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start_pos'\n      -- and to or before `end_pos';\n      -- 0 if none.\n    require\n      other_nonvoid: other /= Void\n      other_notempty: not other.is_empty\n      start_pos_large_enough: start_pos >= 1\n      start_pos_small_enough: start_pos <= count\n      end_pos_large_enough: end_pos >= start_pos\n      end_pos_small_enough: end_pos <= count\n    deferred\n    ensure\n      correct_place: Result > 0 implies other.same_string (substring (Result, Result + other.count - 1))\n      -- forall x : start_pos..Result\n      --  not substring (x, x+other.count -1).is_equal (other)\n    end\n\n  substring_index (other: READABLE_STRING_GENERAL; start_index: INTEGER): INTEGER\n      -- Index of first occurrence of other at or after start_index;\n      -- 0 if none\n    require\n      other_not_void: other /= Void\n      valid_start_index: start_index >= 1 and start_index <= count + 1\n    deferred\n    ensure\n      valid_result: Result = 0 or else\n        (start_index <= Result and Result <= count - other.count + 1)\n      zero_if_absent: (Result = 0) =\n        not substring (start_index, count).has_substring (other)\n      at_this_index: Result >= start_index implies\n        other.same_string (substring (Result, Result + other.count - 1))\n      none_before: Result > start_index implies\n        not substring (start_index, Result + other.count - 2).has_substring (other)\n    end\n\n  fuzzy_index (other: READABLE_STRING_GENERAL; start: INTEGER; fuzz: INTEGER): INTEGER\n      -- Position of first occurrence of `other' at or after `start'\n      -- with 0..`fuzz' mismatches between the string and `other'.\n      -- 0 if there are no fuzzy matches\n    require\n      other_exists: other /= Void\n      other_not_empty: not other.is_empty\n      start_large_enough: start >= 1\n      start_small_enough: start <= count\n      acceptable_fuzzy: fuzz <= other.count\n    deferred\n    end\n\nfeature -- Conversion\n\n  frozen to_cil: SYSTEM_STRING\n      -- Create an instance of SYSTEM_STRING using characters\n      -- of Current between indices `1' and `count'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := dotnet_convertor.from_string_to_system_string (Current)\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_string_8: STRING_8\n      -- Convert `Current' as a STRING_8.\n    require\n      is_valid_as_string_8: is_valid_as_string_8\n    do\n      Result := as_string_8\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_8_conversion: STRING_8\n      -- Equivalent to `as_string_8' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the target recipient of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update recipient of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_readable_string_8: READABLE_STRING_8\n      --\n    obsolete\n      \"Use explicit conversion `to_string_8' instead.\"\n    do\n      Result := as_string_8\n    end\n\n  as_string_8: STRING_8\n      -- Convert `Current' as a STRING_8. If a code of `Current' is\n      -- not a valid code for a STRING_8 it is replaced with the null\n      -- character.\n    local\n      i, nb: INTEGER\n      l_code: like code\n    do\n      if attached {STRING_8} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          l_code := code (i)\n          if Result.valid_code (l_code) then\n            Result.put_code (l_code, i)\n          else\n            Result.put_code (0, i)\n          end\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_8_not_void: Result /= Void\n      identity: (conforms_to (\"\") and Result = Current) or (not conforms_to (\"\") and Result /= Current)\n    end\n\n  as_string_32_conversion: STRING_32\n      -- Equivalent to `as_string_32' with a different name.\n      -- To be used for migrating existing code to Unicode\n      -- when you get a compiler error but cannot or do not have\n      -- the time yet to address the source of the string to be\n      -- a READABLE_STRING_32 or descendants.\n    obsolete\n      \"Update target of call to use READABLE_STRING_32 and descendants instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_readable_string_32: READABLE_STRING_32\n      --\n    obsolete\n      \"Use explicit conversion `to_string_32' instead.\"\n    do\n      Result := as_string_32\n    end\n\n  as_string_32, to_string_32: STRING_32\n      -- Convert `Current' as a STRING_32.\n    local\n      i, nb: INTEGER\n    do\n      if attached {STRING_32} Current as l_result then\n        Result := l_result\n      else\n        nb := count\n        create Result.make (nb)\n        Result.set_count (nb)\n        from\n          i := 1\n        until\n          i > nb\n        loop\n          Result.put_code (code (i), i)\n          i := i + 1\n        end\n      end\n    ensure\n      as_string_32_not_void: Result /= Void\n      identity: (conforms_to (create {STRING_32}.make_empty) and Result = Current) or (not conforms_to (create {STRING_32}.make_empty) and Result /= Current)\n    end\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    deferred\n    ensure\n      as_lower_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_lower\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    deferred\n    ensure\n      as_upper_attached: Result /= Void\n      length: Result.count = count\n      anchor: count > 0 implies Result.item (1) = item (1).as_upper\n      recurse: count > 1 implies Result.substring (2, count) ~ substring (2, count).as_upper\n    end\n\n  to_integer_8: INTEGER_8\n      -- 8-bit integer value\n    require\n      is_integer_8: is_integer_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_8\n    end\n\n  to_integer_16: INTEGER_16\n      -- 16-bit integer value\n    require\n      is_integer_16: is_integer_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_16\n    end\n\n  to_integer, to_integer_32: INTEGER_32\n      -- 32-bit integer value\n    require\n      is_integer: is_integer_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer\n    end\n\n  to_integer_64: INTEGER_64\n      -- 64-bit integer value\n    require\n      is_integer_64: is_integer_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_integer_64\n    end\n\n  to_natural_8: NATURAL_8\n      -- 8-bit natural value\n    require\n      is_natural_8: is_natural_8\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_8\n    end\n\n  to_natural_16: NATURAL_16\n      -- 16-bit natural value\n    require\n      is_natural_16: is_natural_16\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_16\n    end\n\n  to_natural, to_natural_32: NATURAL_32\n      -- 32-bit natural value\n    require\n      is_natural: is_natural_32\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_32\n    end\n\n  to_natural_64: NATURAL_64\n      -- 64-bit natural value\n    require\n      is_natural_64: is_natural_64\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_natural_64\n    end\n\n  to_real, to_real_32: REAL\n      -- Real value;\n      -- for example, when applied to \"123.0\", will yield 123.0\n    require\n      represents_a_real: is_real\n    do\n      Result := to_double.truncated_to_real\n    end\n\n  to_double, to_real_64: DOUBLE\n      -- \"Double\" value;\n      -- for example, when applied to \"123.0\", will yield 123.0 (double)\n    require\n      represents_a_double: is_double\n    local\n      l_convertor: like ctor_convertor\n    do\n      l_convertor := ctor_convertor\n      l_convertor.parse_string_with_type (Current, {NUMERIC_INFORMATION}.type_no_limitation)\n      Result := l_convertor.parsed_double\n    end\n\n  to_boolean: BOOLEAN\n      -- Boolean value;\n      -- \"True\" yields `True', \"False\" yields `False'\n      -- (case-insensitive)\n    require\n      is_boolean: is_boolean\n    do\n      check true_constant.count = 4 end\n      if count = 4 then\n        Result := True\n      end\n    ensure\n      to_boolean: (Result = as_lower.same_string (true_constant)) or\n        (not Result = as_lower.same_string (false_constant))\n    end\n\nfeature -- Conversion\n\n  split (a_separator: CHARACTER_32): LIST [like Current]\n      -- Split on `a_separator'.\n    local\n      l_list: ARRAYED_LIST [like Current]\n      part: like Current\n      i, j, c: INTEGER\n    do\n      c := count\n        -- Worse case allocation: every character is a separator\n      create l_list.make (c + 1)\n      if c > 0 then\n        from\n          i := 1\n        until\n          i > c\n        loop\n          j := index_of (a_separator, i)\n          if j = 0 then\n              -- No separator was found, we will\n              -- simply create a list with a copy of\n              -- Current in it.\n            j := c + 1\n          end\n          part := substring (i, j - 1)\n          l_list.extend (part)\n          i := j + 1\n        end\n        if j = c then\n          check\n            last_character_is_a_separator: item (j) = a_separator\n          end\n            -- A separator was found at the end of the string\n          l_list.extend (new_string (0))\n        end\n      else\n          -- Extend empty string, since Current is empty.\n        l_list.extend (new_string (0))\n      end\n      Result := l_list\n      check\n        l_list.count = occurrences (a_separator) + 1\n      end\n    ensure\n      Result /= Void\n    end\n\nfeature -- Element change\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    deferred\n    ensure\n      plus_not_void: Result /= Void\n      new_count: Result.count = count + s.count\n      initial: elks_checking implies Result.substring (1, count) ~ Current\n      final: elks_checking implies Result.substring (count + 1, count + s.count).same_string (s)\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    deferred\n    ensure\n      substring_not_void: Result /= Void\n      substring_count: Result.count = end_index - start_index + 1 or Result.count = 0\n      first_code: Result.count > 0 implies Result.item (1) = item (start_index)\n      recurse: Result.count > 0 implies\n        Result.substring (2, Result.count) ~ substring (start_index + 1, end_index)\n    end\n\n  head (n: INTEGER): like Current\n      -- Prefix, retaining first `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (1, n)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\n  tail (n: INTEGER): like Current\n      -- Suffix, retaining last `n' characters (or as many as available).\n    require\n      non_negative_argument: n >= 0\n    do\n      if n > count then\n        Result := twin\n      else\n        Result := substring (count - n + 1, count)\n      end\n    ensure\n      same_count: count = old (count)\n      new_count: Result.count = n.min (count)\n    end\n\nfeature {NONE} -- Assertion helper\n\n  elks_checking: BOOLEAN = False\n      -- Are ELKS checkings verified? Must be True when changing implementation of STRING_GENERAL or descendant.\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    require\n      n_non_negative: n >= 0\n    deferred\n    ensure\n      new_string_not_void: Result /= Void\n      new_string_empty: Result.is_empty\n      new_string_area_big_enough: Result.capacity >= n\n    end\n\n  is_valid_integer_or_natural (type: INTEGER) : BOOLEAN\n      -- Is `Current' a valid number according to given `type'?\n    local\n      l_convertor: like ctoi_convertor\n    do\n      l_convertor := ctoi_convertor\n      l_convertor.reset (type)\n      l_convertor.parse_string_with_type (Current, type)\n      Result := l_convertor.is_integral_integer\n    end\n\n  string_searcher: STRING_SEARCHER\n      -- Facilities to search string in another string.\n    deferred\n    ensure\n      string_searcher_not_void: Result /= Void\n    end\n\n  c_string_provider: C_STRING\n      -- To create Eiffel strings from C string.\n    once\n      create Result.make_empty (0)\n    ensure\n      c_string_provider_not_void: Result /= Void\n    end\n\n  ctoi_convertor: STRING_TO_INTEGER_CONVERTOR\n      -- Convertor used to convert string to integer or natural\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctoi_convertor_not_void: Result /= Void\n    end\n\n  ctor_convertor: STRING_TO_REAL_CONVERTOR\n      -- Convertor used to convert string to real or double\n    once\n      create Result.make\n      Result.set_leading_separators (\" \")\n      Result.set_trailing_separators (\" \")\n      Result.set_leading_separators_acceptable (True)\n      Result.set_trailing_separators_acceptable (True)\n    ensure\n      ctor_convertor_not_void: Result /= Void\n    end\n\n  dotnet_convertor: SYSTEM_STRING_FACTORY\n      -- Convertor used to convert from and to SYSTEM_STRING.\n    once\n      create Result\n    ensure\n      dotnet_convertor_not_void: Result /= Void\n    end\n\n  character_properties: CHARACTER_PROPERTY\n      -- Access to Unicode character properties\n    once\n      create Result.make\n    end\n\nfeature {READABLE_STRING_GENERAL} -- Implementation\n\n  internal_hash_code: INTEGER\n      -- Cache for `hash_code'.\n\n  internal_case_insensitive_hash_code: INTEGER;\n      -- Cash for `case_insensitive_hash_code'.\n\n\nfeature -- Access: Cursor\n\n  new_character_32_cursor: STRING_ITERATION_CURSOR\n      -- Fresh cursor for this string that iterates over code points (see `code')\n      -- exposed as {CHARACTER_32}.\n    do\n      create Result.make (Current)\n      Result.start\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"resizable.e","content":"note\n  description: \"Finite structures whose item count is subject to change\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: storage;\n  size: resizable;\n  date: \"$Date: 2012-07-23 14:02:19 -0700 (Mon, 23 Jul 2012) $\"\n  revision: \"$Revision: 91989 $\"\n\ndeferred class RESIZABLE [G] inherit\n\n  BOUNDED [G]\n\nfeature -- Measurement\n\n  Growth_percentage: INTEGER = 50\n      -- Percentage by which structure will grow automatically\n\n  Minimal_increase: INTEGER = 5\n      -- Minimal number of additional items\n\n  additional_space: INTEGER\n      -- Proposed number of additional items\n      --| Result is a reasonable value, resulting from a space-time tradeoff.\n    do\n        -- To prevent overflow we do not use `growth_percentage' but its known value.\n      Result := (capacity // 2).max (Minimal_increase)\n    ensure\n      At_least_one: Result >= 1\n    end\n\nfeature -- Status report\n\n  resizable: BOOLEAN\n      -- May `capacity' be changed? (Answer: yes.)\n    do\n      Result := True\n    end\n\nfeature -- Resizing\n\n  automatic_grow\n      -- Change the capacity to accommodate at least\n      -- `Growth_percentage' more items.\n      --| Trades space for time:\n      --| allocates fairly large chunks of memory but not very often.\n    require\n      resizable: resizable\n    do\n      grow (capacity + additional_space)\n    ensure\n      increased_capacity: capacity >= old capacity + old additional_space\n    end\n\n  grow (i: INTEGER)\n      -- Ensure that capacity is at least `i'.\n    require\n      resizable: resizable\n    deferred\n    ensure\n      new_capacity: capacity >= i\n    end\n\n  trim\n      -- Decrease `capacity' to the minimum value.\n      -- Apply to reduce allocated storage.\n    deferred\n    ensure\n      same_count: count = old count\n      minimal_capacity: capacity = count\n    end\n\ninvariant\n\n  increase_by_at_least_one: Minimal_increase >= 1\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"special.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-03-04 15:01:25 -0800 (Mon, 04 Mar 2013) $\"\n  revision: \"$Revision: 92178 $\"\n\nfrozen class\n  SPECIAL [T]\n\ninherit\n  ABSTRACT_SPECIAL\n    redefine\n      debug_output\n    end\n\n  READABLE_INDEXABLE [T]\n\ncreate\n  make_empty,\n  make_filled,\n  make_from_native_array\n\nfeature {NONE} -- Initialization\n\n  make_empty (n: INTEGER)\n      -- Create a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    external\n      \"built_in\"\n    ensure\n      capacity_set: capacity = n\n      count_set: count = 0\n    end\n\n  make_filled (v: T; n: INTEGER)\n      -- Create a special object for `n' entries initialized with `v'.\n    require\n      non_negative_argument: n >= 0\n    do\n      make_empty (n)\n      fill_with (v, 0, n - 1)\n    ensure\n      capacity_set: capacity = n\n      count_set: count = n\n      filled: filled_with (v, 0, n - 1)\n    end\n\n  make_from_native_array (an_array: like native_array)\n      -- Create a special object from `an_array'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      an_array_not_void: an_array /= Void\n    do\n    end\n\nfeature -- Access\n\n  item alias \"[]\" (i: INTEGER): T assign put\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    external\n      \"built_in\"\n    end\n\n  at alias \"@\" (i: INTEGER): T\n      -- Item at `i'-th position\n      -- (indices begin at 0)\n    require\n      valid_index: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  index_of (v: T; start_position: INTEGER): INTEGER\n      -- Index of first occurrence of item identical to `v'.\n      -- -1 if none.\n      -- (Use object equality for comparison.)\n    require\n      valid_start_position: start_position >= 0\n    local\n      nb: INTEGER\n    do\n      from\n        Result := start_position\n        nb := count\n      until\n        Result >= nb or else item (Result) ~ v\n      loop\n        Result := Result + 1\n      end\n      if Result >= nb then\n        Result := -1\n      end\n    ensure\n      found_or_not_found: Result = -1 or else (Result >= 0 and then Result < count)\n    end\n\n  item_address (i: INTEGER): POINTER\n      -- Address of element at position `i'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    do\n      Result := base_address + i * element_size\n    ensure\n      element_address_not_null: Result /= default_pointer\n    end\n\n  base_address: POINTER\n      -- Address of element at position `0'.\n      -- Use only when interfacing with C externals when Current is guaranteed to not move in memory.\n    require\n      not_dotnet: not {PLATFORM}.is_dotnet\n    external\n      \"built_in\"\n    ensure\n      base_address_not_null: Result /= default_pointer\n    end\n\n  native_array: NATIVE_ARRAY [T]\n      -- Only for compatibility with .NET\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      create Result\n    end\n\n  to_array: ARRAY [T]\n      -- Build an array representation of Current from `1' to `count'.\n    do\n      create Result.make_from_special (Current)\n    ensure\n      to_array_attached: Result /= Void\n      to_array_lower_set: Result.lower = 1\n      to_array_upper_set: Result.upper = count\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- <Precursor>\n    do\n      create Result.make (lower, upper)\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER = 0\n      -- Minimum index of Current\n\n  upper: INTEGER\n      -- Maximum index of Current\n    do\n      Result := count - 1\n    ensure\n      definition: lower <= Result + 1\n    end\n\n  count: INTEGER\n      -- Count of special area\n    external\n      \"built_in\"\n    end\n\n  capacity: INTEGER\n      -- Capacity of special area\n    external\n      \"built_in\"\n    end\n\nfeature -- Status report\n\n  filled_with (v: T; start_index, end_index: INTEGER): BOOLEAN\n      -- Are all items between index `start_index' and `end_index'\n      -- set to `v'?\n      -- (Use reference equality for comparison.)\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    local\n      i: INTEGER\n    do\n      from\n        Result := True\n        i := start_index\n      until\n        i > end_index or else not Result\n      loop\n        Result := item (i) = v\n        i := i + 1\n      end\n    end\n\n  same_items (other: like Current; source_index, destination_index, n: INTEGER): BOOLEAN\n      -- Are the `n' elements of `other' from `source_index' position the same as\n      -- the `n' elements of `Current' from `destination_index'?\n      -- (Use reference equality for comparison.)\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= count\n    local\n      i, j, nb: INTEGER\n    do\n      Result := True\n      if other /= Current then\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          if other.item (i) /= item (j) then\n            Result := False\n            i := nb - 1\n          end\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      valid_on_empty_area: (n = 0) implies Result\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := (0 <= i) and (i < count)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i < count\n    external\n      \"built_in\"\n    ensure\n      inserted: item (i) = v\n      same_count: count = old count\n      same_capacity: capacity = old capacity\n    end\n\n  force (v: T; i: INTEGER)\n      -- If `i' is equal to `count' increase `count' by one and insert `v' at index `count',\n      -- otherwise replace `i'-th item by `v'.\n      -- (Indices begin at 0.)\n    require\n      index_large_enough: i >= 0\n      index_small_enough: i <= count\n      not_full: i = count implies count < capacity\n    do\n      if i < count then\n        put (v, i)\n      else\n        extend (v)\n      end\n    ensure\n      count_updated: count = (i + 1).max (old count)\n      same_capacity: capacity = old capacity\n      inserted: item (i) = v\n    end\n\n  extend (v: T)\n      -- Add `v' at index `count'.\n    require\n      count_small_enough: count < capacity\n    external\n      \"built_in\"\n    ensure\n      count_increased: count = old count + 1\n      same_capacity: capacity = old capacity\n      inserted: item (count - 1) = v\n    end\n\n  extend_filled (v: T)\n      -- Set items between `count' and `capacity - 1' with `v'.\n    do\n      fill_with (v, count, capacity - 1)\n    ensure\n      same_capacity: capacity = old capacity\n      count_increased: count = capacity\n      filled: filled_with (v, old count, capacity - 1)\n    end\n\n  fill_with (v: T; start_index, end_index: INTEGER)\n      -- Set items between `start_index' and `end_index' with `v'.\n    require\n      start_index_non_negative: start_index >= 0\n      start_index_in_bound: start_index <= count\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < capacity\n    local\n      i, nb: INTEGER\n      l_count: like count\n    do\n      from\n        i := start_index\n        l_count := count.min (end_index + 1)\n        nb := l_count\n      until\n        i = nb\n      loop\n        put (v, i)\n        i := i + 1\n      end\n      from\n        i := l_count\n        nb := end_index + 1\n      until\n        i = nb\n      loop\n        extend (v)\n        i := i + 1\n      end\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = (old count).max (end_index + 1)\n      filled: filled_with (v, start_index, end_index)\n    end\n\n  fill_with_default (start_index, end_index: INTEGER)\n      -- Clear items between `start_index' and `end_index'.\n    require\n      is_self_initializing: ({T}).has_default\n      start_index_non_negative: start_index >= 0\n      start_index_not_too_big: start_index <= end_index + 1\n      end_index_valid: end_index < count\n    do\n      fill_with (({T}).default, start_index, end_index)\n    ensure\n      filled: filled_with (({T}).default, start_index, end_index)\n    end\n\n  insert_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Insert `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index' and shift elements between `destination_index' and `count'\n      -- to the right. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: count + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      l_remaining_items, l_offset, l_nb_items_left: INTEGER\n      l_source_index, l_end_index, l_destination_index: INTEGER\n    do\n      l_remaining_items := count - destination_index\n      if l_remaining_items = 0 then\n          -- It is being added at the end of Current, therefore we can simply extend.\n        copy_data (other, source_index, destination_index, n)\n      elseif n <= l_remaining_items then\n          -- Simple case where we can perform a move of the existing items to the end\n          -- and then copy the elements of `other'.\n        move_data (destination_index, destination_index + n, l_remaining_items)\n        copy_data (other, source_index, destination_index, n)\n      else\n          -- Because we cannot have uninitialized items, we cannot move all the remaining items beyond count\n          -- instead we copy by chunks of `l_remaining_items'.\n        from\n          l_source_index := source_index\n          l_destination_index := destination_index\n          l_end_index := source_index + n\n          l_nb_items_left := n\n          l_offset := l_remaining_items\n        until\n          l_source_index >= l_end_index\n        loop\n          move_data (l_destination_index, l_destination_index + l_offset, l_remaining_items)\n          copy_data (other, l_source_index, l_destination_index, l_offset)\n          l_destination_index := l_destination_index + l_offset\n          l_source_index := l_source_index + l_offset\n            -- Compute how many more items we have to copy.\n          l_nb_items_left := l_nb_items_left - l_remaining_items\n          l_offset := l_offset.min (l_nb_items_left)\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = old count + n\n    end\n\n  copy_data (other: SPECIAL [T]; source_index, destination_index, n: INTEGER)\n      -- Copy `n' elements of `other' from `source_index' position to Current at\n      -- `destination_index'. Other elements of Current remain unchanged.\n    require\n      other_not_void: other /= Void\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= other.count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n      same_type: other.conforms_to (Current)\n    local\n      i, j, nb: INTEGER\n    do\n      if other = Current then\n        move_data (source_index, destination_index, n)\n      else\n        from\n          i := source_index\n          j := destination_index\n          nb := source_index + n\n        until\n          i = nb\n        loop\n          force (other.item (i), j)\n          i := i + 1\n          j := j + 1\n        end\n      end\n    ensure\n      copied: same_items (other, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  move_data (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    do\n      if source_index = destination_index then\n      elseif source_index > destination_index then\n        if destination_index + n < source_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      else\n        if source_index + n < destination_index then\n          non_overlapping_move (source_index, destination_index, n)\n        else\n          overlapping_move (source_index, destination_index, n)\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      if source_index < destination_index then\n          -- We shift from left to right starting from the end\n          -- due to possible overlapping.\n        from\n          i := source_index + n - 1\n          nb := source_index - 1\n          l_offset := destination_index - source_index\n          if (destination_index + n >= count) then\n              -- Initialize elements above `count' to a dummy item.\n            fill_with (item (source_index), count, destination_index + n - 1)\n          end\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          put (item (i), i + l_offset)\n          i := i - 1\n        end\n      else\n          -- We shift from right to left.\n        from\n          i := source_index\n          nb := source_index + n\n          l_offset := source_index - destination_index\n          check\n            l_offset_positive: l_offset > 0\n          end\n        until\n          i = nb\n        loop\n          force (item (i), i - l_offset)\n          i := i + 1\n        end\n      end\n    ensure\n      moved: same_items (old twin, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\n  non_overlapping_move (source_index, destination_index, n: INTEGER)\n      -- Move `n' elements of Current from `source_start' position to `destination_index'.\n      -- Other elements remain unchanged.\n    require\n      source_index_non_negative: source_index >= 0\n      destination_index_non_negative: destination_index >= 0\n      destination_index_in_bound: destination_index <= count\n      n_non_negative: n >= 0\n      different_source_and_target: source_index /= destination_index\n      non_overlapping:\n        (source_index < destination_index implies source_index + n < destination_index) or\n        (source_index > destination_index implies destination_index + n < source_index)\n      n_is_small_enough_for_source: source_index + n <= count\n      n_is_small_enough_for_destination: destination_index + n <= capacity\n    local\n      i, nb: INTEGER\n      l_offset: INTEGER\n    do\n      from\n        i := source_index\n        nb := source_index + n\n        l_offset := destination_index - source_index\n      until\n        i = nb\n      loop\n        force (item (i), i + l_offset)\n        i := i + 1\n      end\n    ensure\n      moved: same_items (Current, source_index, destination_index, n)\n      count_updated: count = (old count).max (destination_index + n)\n    end\n\nfeature -- Resizing\n\n  keep_head (n: INTEGER)\n      -- Keep the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, 0, 0, n)\n    end\n\n  keep_tail (n: INTEGER)\n      -- Keep the last `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      overlapping_move (count - n, 0, n)\n      set_count (n)\n    ensure\n      count_updated: count = n\n      kept: same_items (old twin, n, 0, n)\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove the first `n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_tail (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, n, 0, count)\n    end\n\n  remove_tail (n: INTEGER)\n      -- Keep the first  `count - n' entries.\n    require\n      non_negative_argument: n >= 0\n      less_than_count: n <= count\n    do\n      keep_head (count - n)\n    ensure\n      count_updated: count = old count - n\n      kept: same_items (old twin, 0, 0, count)\n    end\n\n  resized_area (n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n'\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      Result.copy_data (Current, 0, 0, n.min (count))\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Create a copy of Current with a count of `n' where not yet initialized\n      -- entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      create Result.make_empty (n)\n      if n > count then\n        Result.copy_data (Current, 0, 0, count)\n        Result.fill_with (a_default_value, count, n - 1)\n      else\n        Result.copy_data (Current, 0, 0, n)\n      end\n    ensure\n      Result_not_void: Result /= Void\n      Result_different_from_current: Result /= Current\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (Current, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area (n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy\n    require\n      n_non_negative: n >= 0\n    external\n      \"built_in\"\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n.min (old count)\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\n  aliased_resized_area_with_default (a_default_value: T; n: INTEGER): like Current\n      -- Try to resize `Current' with a count of `n', if not\n      -- possible a new copy. Non yet initialized entries are set to `a_default_value'.\n    require\n      n_non_negative: n >= 0\n    do\n      Result := aliased_resized_area (n)\n      Result.fill_with (a_default_value, Result.count, n - 1)\n    ensure\n      Result_not_void: Result /= Void\n      new_count: Result.count = n\n      new_capacity: Result.capacity = n\n      preserved: Result.same_items (old twin, 0, 0, n.min (old count))\n    end\n\nfeature -- Removal\n\n  replace_all (v: T)\n      -- Replace all items with `v'.\n    local\n      i: INTEGER\n    do\n      from\n        i := count - 1\n      until\n        i < 0\n      loop\n        put (v, i)\n        i := i - 1\n      end\n    ensure\n      cleared: filled_with (v, 0, upper)\n    end\n\n  wipe_out\n      -- Reset count to zero.\n    do\n      set_count (0)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = 0\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    obsolete\n      \"Because of the new precondition, it is recommended to use `fill_with' instead.\"\n    require\n      has_default: ({T}).has_default\n    do\n      fill_with_default (0, upper)\n    ensure\n      same_capacity: capacity = old capacity\n      count_reset: count = old count\n    end\n\nfeature -- Iteration\n\n  do_all_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_if_in_bounds (action: PROCEDURE [ANY, TUPLE [T]]; test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i)]) then\n          action.call ([item (i)])\n        end\n        i := i + 1\n      end\n    end\n\n  there_exists_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n      until\n        i > nb or Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  for_all_in_bounds (test: FUNCTION [ANY, TUPLE [T], BOOLEAN]; start_index, end_index: INTEGER): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    local\n      i, nb: INTEGER\n    do\n      from\n        i := start_index\n        nb := end_index\n        Result := True\n      until\n        i > nb or not Result\n      loop\n        Result := test.item ([item (i)])\n        i := i + 1\n      end\n    end\n\n  do_all_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        action.call ([item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index_in_bounds (action: PROCEDURE [ANY, TUPLE [T, INTEGER]]; test: FUNCTION [ANY, TUPLE [T, INTEGER], BOOLEAN]; start_index, end_index: INTEGER)\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    local\n      i, j, nb: INTEGER\n    do\n      from\n        i := start_index\n        j := lower\n        nb := end_index\n      until\n        i > nb\n      loop\n        if test.item ([item (i), j]) then\n          action.call ([item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Output\n\n  debug_output: STRING\n      -- String that should be displayed in debugger to represent `Current'.\n    do\n      Result := Precursor\n      Result.append_string (\", capacity=\")\n      Result.append_integer (capacity)\n    end\n\nfeature {NONE} -- Implementation\n\n  element_size: INTEGER\n      -- Size of elements\n    external\n      \"built_in\"\n    ensure\n      element_size_non_negative: Result >= 0\n    end\n\n  set_count (n: INTEGER)\n      -- Set `count' with `n'.\n    require\n      n_non_negative: n >= 0\n      valid_new_count: n <= count\n    external\n      \"built_in\"\n    ensure\n      count_set: count = n\n      capacity_preserved: capacity = old capacity\n    end\n\ninvariant\n  count_less_than_capacity: count <= capacity\n\nnote\n  copyright: \"Copyright (c) 1984-2013, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    extern\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_8.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-26 14:49:40 -0700 (Wed, 26 Mar 2014) $\"\n  revision: \"$Revision: 94721 $\"\n\nclass\n  STRING_8\n\ninherit\n  READABLE_STRING_8\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    redefine\n      area\n    end\n\n  STRING_GENERAL\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general,\n      item as character_32_item,\n      has as character_32_has,\n      index_of as character_32_index_of,\n      last_index_of as character_32_last_index_of,\n      occurrences as character_32_occurrences\n    undefine\n      copy, is_equal, out\n    redefine\n      append_string_general,\n      prepend_string_general\n    end\n\n  INDEXABLE [CHARACTER_8, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_8]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_8]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_32: {READABLE_STRING_32, STRING_32}\n\nfeature -- Initialization\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_8): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_8 assign put\n      -- Character at position `i'.\n    do\n      Result := area.item (i - 1)\n    end\n\n  character_32_item (i: INTEGER): CHARACTER_32\n      -- Character at position `i'.\n    do\n        -- We should be using `area.item (i - 1).to_character_32'\n        -- but some descendants of STRING that have their content encoded\n        -- in UTF-8 for example relies on `code' to get the corresponding\n        -- CHARACTER_32 by reading more than one byte. Once they have\n        -- been updated to use `character_32_item' we can revert the code\n        -- back to using `area' directly.\n      Result := code (i).to_character_32\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Numeric code of character at position `i'.\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Numeric code of character at position `i'.\n      -- Use `code' instead for consistency with Unicode handling.\n      --| Not obsolete because old code using just ASCII is safe.\n    do\n      Result := area.item (i - 1).code\n    end\n\n  area: SPECIAL [CHARACTER_8]\n      -- Storage for characters.\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_8; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_8\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_8; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_8)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    local\n      l_first_pos, l_next_pos: INTEGER\n      l_orig_count, l_new_count, l_new_lower, l_count, i, l_index_count: INTEGER\n      l_src_index, l_dest_index, l_prev_index, l_copy_delta: INTEGER\n      l_area, l_new_area: like area\n      l_offset: INTEGER\n      l_string_searcher: like string_searcher\n      l_index_list: SPECIAL [INTEGER]\n    do\n      if not is_empty then\n        l_count := count\n        l_string_searcher := string_searcher\n        l_string_searcher.initialize_deltas (original)\n        l_orig_count := original.count\n        l_new_count := new.count\n        if l_orig_count >= l_new_count then\n          l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, 1, l_count)\n          if l_first_pos > 0 then\n            if l_orig_count = l_new_count then\n                -- String will not be resized, simply perform character substitution\n              from\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_first_pos = 0\n              loop\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1, l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_first_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_new_count, l_count)\n                else\n                  l_first_pos := 0\n                end\n              end\n            elseif l_orig_count > l_new_count then\n                -- New string is smaller than previous string, we can optimize\n                -- substitution by only moving block between two occurrences of `orginal'.\n              from\n                l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                l_area := area\n                l_new_area := new.area\n                l_new_lower := new.area_lower\n              until\n                l_next_pos = 0\n              loop\n                  -- Copy new string into Current\n                l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                  -- Shift characters between `l_first_pos' and `l_next_pos'\n                l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                  l_first_pos + l_new_count - 1 - l_offset, l_next_pos - l_first_pos - l_orig_count)\n                l_first_pos := l_next_pos\n                l_offset := l_offset + (l_orig_count - l_new_count)\n                if l_first_pos + l_new_count <= l_count then\n                  l_next_pos := l_string_searcher.substring_index_with_deltas (Current, original, l_first_pos + l_orig_count, l_count)\n                else\n                  l_next_pos := 0\n                end\n              end\n                -- Perform final substitution:\n                -- Copy new string into Current\n              l_area.copy_data (l_new_area, l_new_lower, l_first_pos - 1 - l_offset, l_new_count)\n                -- Shift characters between `l_first_pos' and the end of the string\n              l_area.overlapping_move (l_first_pos + l_orig_count - 1,\n                l_first_pos + l_new_count - 1 - l_offset, l_count + 1 - l_first_pos - l_orig_count)\n                  -- Perform last substitution\n              l_offset := l_offset + (l_orig_count - l_new_count)\n\n                -- Update `count'\n              set_count (l_count - l_offset)\n            end\n              -- String was modified we need to recompute the `hash_code'.\n            internal_hash_code := 0\n          end\n        elseif attached l_string_searcher.substring_index_list_with_deltas (Current, original, 1, l_count) as l_list then\n            -- Get the number of substitution to be performed by getting a list\n            -- of location where `original' appears.\n          l_index_list := l_list.area\n          l_index_count := l_index_list.count\n            -- Store the index of the last character up to which we need to move\n            -- characters in the reallocated string.\n          l_prev_index := l_count\n            -- Resize Current with the appropriate number of characters\n          l_copy_delta := l_new_count - l_orig_count\n          l_count := l_count + (l_index_count * l_copy_delta)\n          l_area := area.resized_area_with_default ('%U', l_count + 1)\n          area := l_area\n            -- Perform the substitution starting from the end.\n          from\n            i := l_index_count\n            l_new_lower := new.area_lower\n            l_new_area := new.area\n          until\n            i = 0\n          loop\n            i := i - 1\n            l_src_index := l_index_list.item (i)\n            l_dest_index := l_src_index + i * l_copy_delta\n              -- Shift non-matching characters to the right of the newly replaced string.\n            l_area.overlapping_move (l_src_index + l_orig_count - 1, l_dest_index + l_new_count - 1, l_prev_index - l_src_index - l_orig_count + 1)\n              -- Store new end of string where characters will be moved.\n            l_prev_index := l_src_index - 1\n\n              -- Copy `new' to its appropriate position\n            l_area.copy_data (l_new_area, l_new_lower, l_dest_index - 1, l_new_count)\n          end\n            -- Update the new `count' which also resets the `hash_code'.\n          set_count (l_count)\n        end\n      end\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_8)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_area.item (nb_space).is_space\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0 or else not l_area.item (i).is_space\n      loop\n        nb_space := nb_space + 1\n        i := i - 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_8)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_8; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_8, i - 1)\n      internal_hash_code := 0\n    end\n\n  precede, prepend_character (c: CHARACTER_8)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        prepend (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  prepend (s: READABLE_STRING_8)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_8)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_8} s as l_s8 then\n        append (l_s8)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_8)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_8; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_8)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_8\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_8)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_8)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append (b.out)\n    end\n\n  insert (s: READABLE_STRING_8; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_8; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_8; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_8)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_8)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_8\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_8)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_8)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n    do\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_area.item (left_nb_space).is_space\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_area.item (i).is_space\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_8; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_8]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_8]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_8\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n      -- Nothing to be done because we only added `internal_hash_code' that will\n      -- be recomputed next time we query `hash_code'.\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: SPECIAL [CHARACTER_8]\n      -- Empty `area' to avoid useless creation of empty areas when wiping out a STRING.\n    obsolete\n      \"Simply create `area' directly.\"\n    do\n      create Result.make_empty (1)\n      Result.extend ('%U')\n    ensure\n      empty_area_not_void: Result /= Void\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_general.e","content":"note\n  description: \"Common ancestors to all STRING classes.\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2014-03-19 07:36:10 -0700 (Wed, 19 Mar 2014) $\"\n  revision: \"$Revision: 94633 $\"\n\ndeferred class\n  STRING_GENERAL\n\ninherit\n  READABLE_STRING_GENERAL\n    export\n      {ANY} copy, standard_copy, deep_copy\n    end\n\nconvert\n  as_string_32: {READABLE_STRING_32, STRING_32},\n  to_cil: {SYSTEM_STRING}\n\nfeature -- Settings\n\n  put_code (v: like code; i: INTEGER)\n      -- Put code `v' at position `i'.\n    require\n      valid_code: valid_code (v)\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      inserted: code (i) = v\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\nfeature {STRING_HANDLER} -- Settings\n\n  set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    require\n      valid_count: 0 <= number and number <= capacity\n    deferred\n    ensure\n      new_count: count = number\n    end\n\n  set_internal_hash_code (v: like internal_hash_code)\n      -- Set `internal_hash_code' with `v'.\n    require\n      v_nonnegative: v >= 0\n    do\n      internal_hash_code := v\n    ensure\n      internal_hash_code_set: internal_hash_code = v\n    end\n\nfeature -- Element change\n\n  append_code (c: like code)\n      -- Append `c' at end.\n    require\n      valid_code: valid_code (c)\n    local\n      current_count: INTEGER\n    do\n      current_count := count + 1\n      if current_count > capacity then\n        resize (current_count)\n      end\n      set_count (current_count)\n      put_code (c, current_count)\n    ensure then\n      item_inserted: code (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (to_string_32 + s))\n    end\n\n  append_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n        from\n          i := start_index\n        until\n          i > end_index\n        loop\n          append_code (s.code (i))\n          i := i + 1\n        end\n        set_count (l_new_size)\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      appended: elks_checking implies same_string (old (to_string_32 + s.substring (start_index, end_index)))\n    end\n\n  prepend (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := 1\n        until\n          i > l_s_count\n        loop\n          put_code (s.code (i), i)\n          i := i + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s.to_string_32 + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_GENERAL; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      compatible_strings: is_string_8 implies s.is_valid_as_string_8\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n      i, j: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size)\n        end\n          -- Copy `Current' at the end starting from the end since it will probably overlap.\n        set_count (l_new_size)\n        from\n          i := l_count\n        until\n          i = 0\n        loop\n          put_code (code (i), i + l_s_count)\n          i := i - 1\n        end\n          -- Copy `s' at the beginning of Current.\n        from\n          i := start_index\n          j := 1\n        until\n          i > end_index\n        loop\n          put_code (s.code (i), j)\n          i := i + 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index).to_string_32 + Current))\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (1, n.min (count)))\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    deferred\n    ensure\n      new_count: count = n.min (old count)\n      kept: elks_checking implies Current ~ (old substring (count - n.min(count) + 1, count))\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (1).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (old count - count + 1, old count))\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    deferred\n    ensure\n      valid_count: count <= old count\n      new_count: not is_empty implies not item (count).is_space\n      kept: elks_checking implies Current ~ ((old twin).substring (1, count))\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\n  adjust\n      -- Remove leading and/or trailing whitespace.\n    do\n      left_adjust\n      right_adjust\n    ensure\n      valid_count: count <= old count\n      new_count_left: not is_empty implies not item (1).is_space\n      new_count_right: not is_empty implies not item (count).is_space\n      kept: elks_checking implies (old twin).has_substring (Current)\n      only_spaces_removed_before: elks_checking implies (old twin).is_substring_whitespace (1, (old twin).substring_index (Current, 1) - 1)\n      only_spaces_removed_after: elks_checking implies (old twin).is_substring_whitespace ((old twin).substring_index (Current, 1) + count, old count)\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    require\n      valid_index: valid_index (i)\n    deferred\n    ensure\n      new_count: count = old count - 1\n      removed: elks_checking implies\n        to_string_32 ~ (old substring (1, i - 1).to_string_32 + old substring (i + 1, count).to_string_32)\n    end\n\nfeature -- Resizing\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    require\n      new_size_large_enough: newsize >= count\n    deferred\n    ensure\n      same_count: count = old count\n      capacity_large_enough: capacity >= newsize\n      same_content: elks_checking implies same_string (old twin)\n    end\n\ninvariant\n  mutable: not is_immutable\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"string_handler.e","content":"note\n  description: \"Objects that can access `set_count' from STRING\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass\n  STRING_HANDLER\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"table.e","content":"note\n  description: \"Containers whose items are accessible through keys\"\n  library: \"Free implementation of ELKS library\"\n  legal: \"See notice at end of class.\"\n  status: \"See notice at end of class.\"\n  names: table, access;\n  access: key, membership;\n  contents: generic;\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\ndeferred class TABLE [G, H] inherit\n\n  BAG [G]\n    rename\n      put as bag_put\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (k: H): G assign force\n      -- Entry of key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\nfeature -- Status report\n\n  valid_key (k: H): BOOLEAN\n      -- Is `k' a valid key?\n    deferred\n    end\n\nfeature -- Element change\n\n  put (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    end\n\n  force (v: G; k: H)\n      -- Associate value `v' with key `k'.\n    require\n      valid_key: valid_key (k)\n    deferred\n    ensure\n      inserted: item (k) = v\n    end\n\nfeature {NONE} -- Inapplicable\n\n  bag_put (v: G)\n    do\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
__eiffel_builtin.push({"filename":"to_special.e","content":"note\n  description: \"References to special objects, for direct access to arrays and strings\"\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2012-05-23 21:13:10 -0700 (Wed, 23 May 2012) $\"\n  revision: \"$Revision: 91981 $\"\n\nclass TO_SPECIAL [T]\n\ncreate\n  make_empty_area,\n  make_filled_area\n\nfeature -- Access\n\n  area: SPECIAL [T]\n      -- Special data zone\n\nfeature {NONE} -- Initialization\n\n  make_empty_area (n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_empty (n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = 0\n    end\n\n  make_filled_area (a_default_value: T; n: INTEGER)\n      -- Creates a special object for `n' entries.\n    require\n      non_negative_argument: n >= 0\n    do\n      create area.make_filled (a_default_value, n)\n    ensure\n      area_allocated: area /= Void\n      capacity_set: area.capacity = n\n      count_set: area.count = n\n      area_filled: area.filled_with (a_default_value, 0, n - 1)\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): T assign put\n      -- Entry at index `i', if in index interval\n    require\n      valid_index: valid_index (i)\n    do\n      Result := area.item (i)\n    end\n\nfeature -- Status report\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of Current?\n    do\n      Result := area.valid_index (i)\n    end\n\nfeature -- Element change\n\n  put (v: T; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_index: valid_index (i)\n    do\n      area.put (v, i)\n    ensure\n      inserted: item (i) = v\n    end\n\nfeature {NONE} -- Element change\n\n  set_area (other: like area)\n      -- Make `other' the new `area'\n    do\n      area := other\n    ensure\n      area_set: area = other\n    end\n\nnote\n  copyright: \"Copyright (c) 1984-2012, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFic3RyYWN0X3NwZWNpYWwuZSIsImFueS5lIiwiYXJyYXkuZSIsImJhZy5lIiwiYm9vbGVhbi5lIiwiYm9vbGVhbl9yZWYuZSIsImJvdW5kZWQuZSIsImJveC5lIiwiY2hhcmFjdGVyXzMyLmUiLCJjaGFyYWN0ZXJfMzJfcmVmLmUiLCJjaGFyYWN0ZXJfOC5lIiwiY2hhcmFjdGVyXzhfcmVmLmUiLCJjb2xsZWN0aW9uLmUiLCJjb21wYXJhYmxlLmUiLCJjb250YWluZXIuZSIsImN5Y2xlLmUiLCJkZWJ1Z19vdXRwdXQuZSIsImZpbml0ZS5lIiwiaGFzaGFibGUuZSIsImluZGV4YWJsZS5lIiwiaW50ZWdlci5lIiwiaW50ZWdlcl8zMl9yZWYuZSIsIml0ZXJhYmxlLmUiLCJtaXNtYXRjaF9jb3JyZWN0b3IuZSIsIm5hdHVyYWxfMzIuZSIsIm5hdHVyYWxfMzJfcmVmLmUiLCJuYXR1cmFsXzguZSIsIm5hdHVyYWxfOF9yZWYuZSIsIm51bWVyaWMuZSIsInBhcnRfY29tcGFyYWJsZS5lIiwicmVhZGFibGVfaW5kZXhhYmxlLmUiLCJyZWFkYWJsZV9zdHJpbmdfMzIuZSIsInJlYWRhYmxlX3N0cmluZ184LmUiLCJyZWFkYWJsZV9zdHJpbmdfZ2VuZXJhbC5lIiwicmVzaXphYmxlLmUiLCJzcGVjaWFsLmUiLCJzdHJpbmcuZSIsInN0cmluZ184LmUiLCJzdHJpbmdfZ2VuZXJhbC5lIiwic3RyaW5nX2hhbmRsZXIuZSIsInRhYmxlLmUiLCJ0b19zcGVjaWFsLmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQ0RBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUE7QUNBQTtBQ0FBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQW5jZXN0b3Igb2YgU1BFQ0lBTCB0byBwZXJmb3JtIHF1ZXJpZXMgb24gU1BFQ0lBTCB3aXRob3V0IGtub3dpbmcgaXRzIGFjdHVhbCBnZW5lcmljIHR5cGUuXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTA0LTEyIDE2OjU0OjUwIC0wNzAwIChGcmksIDEyIEFwciAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjQ0MCAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgQUJTVFJBQ1RfU1BFQ0lBTFxuXG5pbmhlcml0XG4gIERFQlVHX09VVFBVVFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIENvdW50IG9mIHNwZWNpYWwgYXJlYVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIENhcGFjaXR5IG9mIHNwZWNpYWwgYXJlYVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIEN1cnJlbnQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBkZWJ1Z19vdXRwdXQ6IFNUUklOR1xuICAgICAgLS0gU3RyaW5nIHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBpbiBkZWJ1Z2dlciB0byByZXByZXNlbnQgYEN1cnJlbnQnLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEyKVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmcgKFwiY291bnQ9XCIpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXIgKGNvdW50KVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMywgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsImNsYXNzXG4gIEFOWVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBjb25mb3Jtc190byAob3RoZXI6IEFOWSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBjb25mb3JtIHRvIHR5cGVcbiAgICAgIC0tIG9mIGBvdGhlcicgKGFzIHBlciBFaWZmZWw6IFRoZSBMYW5ndWFnZSwgY2hhcHRlciAxMyk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgc2FtZV90eXBlIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBpZGVudGljYWwgdG8gdHlwZSBvZiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvbmZvcm1zX3RvIChvdGhlcikgYW5kXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkXG4gICAgICAtLSBlcXVhbCB0byBjdXJyZW50IG9iamVjdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIgfiBDdXJyZW50XG4gICAgICBjb25zaXN0ZW50OiBzdGFuZGFyZF9pc19lcXVhbCAob3RoZXIpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QsIGFuZCBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3R5cGU6IFJlc3VsdCBpbXBsaWVzIHNhbWVfdHlwZSAob3RoZXIpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG90aGVyLnN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBlcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkXG4gICAgICAtLSB0byBvYmplY3RzIGNvbnNpZGVyZWQgZXF1YWw/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkIHRvXG4gICAgICAtLSBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlP1xuICAgICAgLS0gQWx3YXlzIHVzZXMgZGVmYXVsdCBvYmplY3QgY29tcGFyaXNvbiBjcml0ZXJpb24uXG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuc3RhbmRhcmRfaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19kZWVwX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBDdXJyZW50JyBhbmQgYG90aGVyJyBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfZGVlcF9lcXVhbCAoQ3VycmVudClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkXG4gICAgICAtLSBvciBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIGRvXG4gICAgICBpZiBhID0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiID0gVm9pZFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYiAvPSBWb2lkIGFuZCB0aGVuIGEuaXNfZGVlcF9lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2VxdWFsIChhLCBiKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgYm90aF9vcl9ub25lX3ZvaWQ6IChhID0gVm9pZCkgaW1wbGllcyAoUmVzdWx0ID0gKGIgPSBWb2lkKSlcbiAgICAgIHNhbWVfdHlwZTogKFJlc3VsdCBhbmQgKGEgLz0gVm9pZCkpIGltcGxpZXMgKGIgLz0gVm9pZCBhbmQgdGhlbiBhLnNhbWVfdHlwZSAoYikpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIGRlZXBfZXF1YWwgKGIsIGEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgaW86IFNURF9GSUxFU1xuICAgICAgLS0gSGFuZGxlIHRvIHN0YW5kYXJkIGZpbGUgc2V0dXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpb19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gTmV3IHN0cmluZyBjb250YWluaW5nIHRlcnNlIHByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRhZ2dlZF9vdXRcbiAgICBlbnN1cmVcbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdGFnZ2VkX291dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHRhZ2dlZF9vdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcHJpbnQgKG86IGRldGFjaGFibGUgQU5ZKVxuICAgICAgLS0gV3JpdGUgdGVyc2UgZXh0ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYG8nXG4gICAgICAtLSBvbiBzdGFuZGFyZCBvdXRwdXQuXG4gICAgZG9cbiAgICAgIGlmIG8gLz0gVm9pZCB0aGVuXG4gICAgICAgIGlvLnB1dF9zdHJpbmcgKG8ub3V0KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgZGVmYXVsdF9jcmVhdGVcbiAgICAgIC0tIFByb2Nlc3MgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBubyBjcmVhdGlvbiBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG4gIGZyb3plbiBkbG9fbm90aGluZ1xuICAgICAgLS0gRXhlY3V0ZSBhIG51bGwgYWN0aW9uLlxuICAgIGRvXG4gICAgZW5kXG5cbmludmFyaWFudFxuICByZWZsZXhpdmVfZXF1YWxpdHk6IHN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICByZWZsZXhpdmVfY29uZm9ybWFuY2U6IGNvbmZvcm1zX3RvIChDdXJyZW50KVxuXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDEtMjUgMTQ6MTg6MjAgLTA4MDAgKEZyaSwgMjUgSmFuIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTM4ICRcIlxuXG5jbGFzcyBBUlJBWSBbR10gaW5oZXJpdFxuXG4gIFJFU0laQUJMRSBbR11cbiAgICByZWRlZmluZVxuICAgICAgZnVsbCwgY29weSwgaXNfZXF1YWwsIHJlc2l6YWJsZVxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIGl0ZW0gYXMgaXRlbSBhbGlhcyBcIltdXCJcbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtHXVxuICAgIGV4cG9ydFxuICAgICAge0FSUkFZfSBzZXRfYXJlYVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgaXRlbSwgcHV0LCBhdCwgdmFsaWRfaW5kZXhcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2VfZW1wdHksXG4gIG1ha2UsXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fYXJyYXksXG4gIG1ha2VfZnJvbV9zcGVjaWFsLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7TkFUSVZFX0FSUkFZIFtHXX0sXG4gIHRvX3NwZWNpYWw6IHtTUEVDSUFMIFtHXX0sXG4gIG1ha2VfZnJvbV9jaWwgKHtOQVRJVkVfQVJSQVkgW0ddfSlcblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHlcbiAgICAgIC0tIEFsbG9jYXRlIGVtcHR5IGFycmF5IHN0YXJ0aW5nIGF0IGAxJy5cbiAgICBkb1xuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gMFxuICAgICAgbWFrZV9lbXB0eV9hcmVhICgwKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAwXG4gICAgICBpdGVtc19zZXQ6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBhcnJheTsgc2V0IGluZGV4IGludGVydmFsIHRvXG4gICAgICAtLSBgbWluX2luZGV4JyAuLiBgbWF4X2luZGV4Jzsgc2V0IGFsbCB2YWx1ZXMgdG8gZGVmYXVsdC5cbiAgICAgIC0tIChNYWtlIGFycmF5IGVtcHR5IGlmIGBtaW5faW5kZXgnID0gYG1heF9pbmRleCcgKyAxKS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9ib3VuZHM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG46IElOVEVHRVJcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBuIDo9IG1heF9pbmRleCAtIG1pbl9pbmRleCArIDFcbiAgICAgIGVuZFxuICAgICAgbWFrZV9maWxsZWRfYXJlYSAoYV9kZWZhdWx0X3ZhbHVlLCBuKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IG1pbl9pbmRleFxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IG1heF9pbmRleFxuICAgICAgaXRlbXNfc2V0OiBmaWxsZWRfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlKVxuICAgIGVuZFxuXG4gIG1ha2UgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgYXJyYXk7IHNldCBpbmRleCBpbnRlcnZhbCB0b1xuICAgICAgLS0gYG1pbl9pbmRleCcgLi4gYG1heF9pbmRleCc7IHNldCBhbGwgdmFsdWVzIHRvIGRlZmF1bHQuXG4gICAgICAtLSAoTWFrZSBhcnJheSBlbXB0eSBpZiBgbWluX2luZGV4JyA9IGBtYXhfaW5kZXgnICsgMSkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiIGBtYWtlJyBpcyBub3Qgdm9pZC1zYWZlIHN0YXRpY2FsbHkuIFVzZSBgbWFrZV9lbXB0eScgb3IgYG1ha2VfZmlsbGVkJyBpbnN0ZWFkLiBbMDctMjAxMF1cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2JvdW5kczogbWluX2luZGV4IDw9IG1heF9pbmRleCArIDFcbiAgICAgIGhhc19kZWZhdWx0OiBtaW5faW5kZXggPD0gbWF4X2luZGV4IGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBtYWtlX2ZpbGxlZF9hcmVhICgoe0d9KS5kZWZhdWx0LCBtYXhfaW5kZXggLSBtaW5faW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlX2VtcHR5X2FyZWEgKDApXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBtaW5faW5kZXhcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBtYXhfaW5kZXhcbiAgICAgIGl0ZW1zX3NldDogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYXJyYXkgKGE6IEFSUkFZIFtHXSlcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgaXRlbXMgb2YgYGEnLlxuICAgICAgLS0gKFVzZWZ1bCBpbiBwcm9wZXIgZGVzY2VuZGFudHMgb2YgY2xhc3MgYEFSUkFZJyxcbiAgICAgIC0tIHRvIGluaXRpYWxpemUgYW4gYXJyYXktbGlrZSBvYmplY3QgZnJvbSBhIG1hbmlmZXN0IGFycmF5LilcbiAgICByZXF1aXJlXG4gICAgICBhcnJheV9leGlzdHM6IGEgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfYXJlYSAoYS5hcmVhKVxuICAgICAgbG93ZXIgOj0gYS5sb3dlclxuICAgICAgdXBwZXIgOj0gYS51cHBlclxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYS5hcmVhXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gYS5sb3dlclxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IGEudXBwZXJcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3BlY2lhbCAoYTogU1BFQ0lBTCBbR10pXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgZnJvbSBpdGVtcyBvZiBgYScuXG4gICAgcmVxdWlyZVxuICAgICAgc3BlY2lhbF9hdHRhY2hlZDogYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9hcmVhIChhKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYS5jb3VudFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhLmNvdW50XG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAobmE6IE5BVElWRV9BUlJBWSBbbGlrZSBpdGVtXSlcbiAgICAgIC0tIEluaXRpYWxpemUgYXJyYXkgZnJvbSBgbmEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIG5hX25vdF92b2lkOiBuYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZnJvbV9uYXRpdmVfYXJyYXkgKG5hKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYXJlYS5jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IEcgYXNzaWduIHB1dFxuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gbG93ZXIpXG4gICAgZW5kXG5cbiAgZW50cnkgKGk6IElOVEVHRVIpOiBHXG4gICAgICAtLSBFbnRyeSBhdCBpbmRleCBgaScsIGlmIGluIGluZGV4IGludGVydmFsXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpXG4gICAgZW5kXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgdicgYXBwZWFyIGluIGFycmF5P1xuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBuYiA6PSB1cHBlciAtIGxvd2VyXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiBhbmQgdiAvPSBWb2lkIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgfiB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgPSB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgbG93ZXI6IElOVEVHRVJcbiAgICAgIC0tIE1pbmltdW0gaW5kZXhcblxuICB1cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuXG4gIGNvdW50LCBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGF2YWlsYWJsZSBpbmRpY2VzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjb25zaXN0ZW50X3dpdGhfYm91bmRzOiBSZXN1bHQgPSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuZFxuXG4gIG9jY3VycmVuY2VzICh2OiBHKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGB2JyBhcHBlYXJzIGluIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gdXBwZXJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpIH4gdiB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IHVwcGVyXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSA9IHYgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW5kZXhfc2V0OiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBSYW5nZSBvZiBhY2NlcHRhYmxlIGluZGV4ZXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsb3dlciwgdXBwZXIpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICBzYW1lX2JvdW5kczpcbiAgICAgICAgKChSZXN1bHQubG93ZXIgPSBsb3dlcikgYW5kIChSZXN1bHQudXBwZXIgPSB1cHBlcikpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYXJyYXkgbWFkZSBvZiB0aGUgc2FtZSBpdGVtcyBhcyBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlaWYgbG93ZXIgPSBvdGhlci5sb3dlciBhbmQgdGhlbiB1cHBlciA9IG90aGVyLnVwcGVyIGFuZCB0aGVuXG4gICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb25cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIG5vdCBSZXN1bHQgb3IgaSA+IHVwcGVyXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpIH4gb3RoZXIuaXRlbSAoaSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBhcmVhLnNhbWVfaXRlbXMgKG90aGVyLmFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBhbGxfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBzZXQgdG8gZGVmYXVsdCB2YWx1ZXM/XG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAoe0d9KS5oYXNfZGVmYXVsdCBhbmQgdGhlbiBhcmVhLmZpbGxlZF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY291bnQgPSAwIG9yIGVsc2VcbiAgICAgICAgKChub3QgYXR0YWNoZWQgaXRlbSAodXBwZXIpIGFzIGkgb3IgZWxzZSBpID0gKHtHfSkuZGVmYXVsdCkgYW5kXG4gICAgICAgIHN1YmFycmF5IChsb3dlciwgdXBwZXIgLSAxKS5hbGxfZGVmYXVsdCkpXG4gICAgZW5kXG5cbiAgZmlsbGVkX3dpdGggKHY6IEcpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIHNldCB0byBgdic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLmZpbGxlZF93aXRoICh2LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvdW50ID0gMCBvciBlbHNlXG4gICAgICAgIChpdGVtICh1cHBlcikgPSB2IGFuZCBzdWJhcnJheSAobG93ZXIsIHVwcGVyIC0gMSkuZmlsbGVkX3dpdGggKHYpKSlcbiAgICBlbmRcblxuICBmdWxsOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZmlsbGVkIHRvIGNhcGFjaXR5PyAoQW5zd2VyOiB5ZXMpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgc2FtZV9pdGVtcyAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBvdGhlcicgYW5kIEN1cnJlbnQgaGF2ZSBzYW1lIGl0ZW1zP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCAwLCAwLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChjb3VudCA9IG90aGVyLmNvdW50KSBhbmQgdGhlblxuICAgICAgICAoY291bnQgPSAwIG9yIGVsc2UgKGl0ZW0gKHVwcGVyKSA9IG90aGVyLml0ZW0gKG90aGVyLnVwcGVyKVxuICAgICAgICBhbmQgc3ViYXJyYXkgKGxvd2VyLCB1cHBlciAtIDEpLnNhbWVfaXRlbXNcbiAgICAgICAgKG90aGVyLnN1YmFycmF5IChvdGhlci5sb3dlciwgb3RoZXIudXBwZXIgLSAxKSkpKSlcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgYXJyYXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobG93ZXIgPD0gaSkgYW5kIHRoZW4gKGkgPD0gdXBwZXIpXG4gICAgZW5kXG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIGFkZGVkP1xuICAgICAgLS0gKEFuc3dlcjogbm8sIGFsdGhvdWdoIGFycmF5IG1heSBiZSByZXNpemVkLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiBuby4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgIGVuZFxuXG4gIHJlc2l6YWJsZTogQk9PTEVBTlxuICAgICAgLS0gQ2FuIGFycmF5IGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXhfc2V0OiBCT09MRUFOXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpbmRleF9zZXQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBlbnRlciAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBmb3JjZSAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQXNzaWduIGl0ZW0gYHYnIHRvIGBpJy10aCBlbnRyeS5cbiAgICAgIC0tIFJlc2l6ZSB0aGUgYXJyYXkgaWYgYGknIGZhbGxzIG91dCBvZiBjdXJyZW50bHkgZGVmaW5lZCBib3VuZHM7IHByZXNlcnZlIGV4aXN0aW5nIGl0ZW1zLlxuICAgICAgLS0gSW4gdm9pZC1zYWZlIG1vZGUsIGlmICh7R30pLmhhc19kZWZhdWx0IGRvZXMgbm90IGhvbGQsIHRoZW4geW91IGNhbiBvbmx5IGluc2VydCBiZXR3ZWVuXG4gICAgICAtLSBgbG93ZXIgLSAxJyBvciBgdXBwZXIgKyAxJyBwb3NpdGlvbiBpbiB0aGUgQVJSQVkuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHRfaWZfdG9vX2xvdzpcbiAgICAgICAgKGkgPCBsb3dlciAtIDEgYW5kIGxvd2VyIC89IHtsaWtlIGxvd2VyfS5taW5fdmFsdWUpIGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICAgIGhhc19kZWZhdWx0X2lmX3Rvb19oaWdoOlxuICAgICAgICAoaSA+IHVwcGVyICsgMSBhbmQgdXBwZXIgLz0ge2xpa2UgdXBwZXJ9Lm1heF92YWx1ZSkgaW1wbGllcyAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGxvY2FsXG4gICAgICBvbGRfc2l6ZSwgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIG5ld19sb3dlciwgbmV3X3VwcGVyOiBJTlRFR0VSXG4gICAgICBsX2NvdW50LCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lOiBCT09MRUFOXG4gICAgZG9cbiAgICAgIG5ld19sb3dlciA6PSBsb3dlci5taW4gKGkpXG4gICAgICBuZXdfdXBwZXIgOj0gdXBwZXIubWF4IChpKVxuICAgICAgbmV3X3NpemUgOj0gbmV3X3VwcGVyIC0gbmV3X2xvd2VyICsgMVxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lIDo9IChpID0gdXBwZXIgKyAxKSBvciAoaSA9IGxvd2VyIC0gMSlcbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICAgIC0tIExpc3QgaXMgZW1wdHkuIEZpcnN0IHdlIGNyZWF0ZSBhbiBlbXB0eSBTUEVDSUFMIG9mIHRoZSByaWdodCBjYXBhY2l0eS5cbiAgICAgICAgbWFrZV9lbXB0eV9hcmVhIChuZXdfc2l6ZS5tYXggKGFkZGl0aW9uYWxfc3BhY2UpKVxuICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG5lZWQgdG8gZmlsbCB0aGUgU1BFQ0lBTCBmb3IgYDAnIHRvIGBuZXdfc2l6ZSAtIDInIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIG5ld19zaXplIC0gMilcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuZXh0ZW5kICh2KVxuICAgICAgZWxzZVxuICAgICAgICBvbGRfc2l6ZSA6PSBhcmVhLmNhcGFjaXR5XG4gICAgICAgIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlblxuICAgICAgICAgIHNldF9hcmVhIChhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuZXdfc2l6ZS5tYXggKG9sZF9zaXplICsgYWRkaXRpb25hbF9zcGFjZSkpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgICAgLS0gV2UgaGF2ZSBpbnNlcnRlZCBiZWxvdyB0aGUgcHJldmlvdXMgYGxvd2VyJy4gV2UgbmVlZCB0byBzaGlmdCBlbnRyaWVzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgLS0gYmVmb3JlIHdlIGNhbiBpbnNlcnQgYHYnLlxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxvd2VyIC0gbmV3X2xvd2VyXG4gICAgICAgICAgbF9jb3VudCA6PSBjYXBhY2l0eVxuICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgYW5kIGxfb2Zmc2V0ID4gbF9jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdpdGggdGhlIGBuZXdfbG93ZXInIGdpdmVuLCB0aGUgZGF0YSBoYXMgdG8gbW92ZVxuICAgICAgICAgICAgICAtLSBiZXlvbmQgdGhlIGBhcmVhJydzIGNvdW50IHdoaWNoIHJlcXVpcmVzIHVzIHRvIGZpbGxcbiAgICAgICAgICAgICAgLS0gdGhlIGdhcCBiZXR3ZWVuIHRoZSBvbGQgZGF0YSdzIGxvY2F0aW9uIGFuZCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAtLSB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIGxfY291bnQsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBhcmVhLm1vdmVfZGF0YSAoMCwgbF9vZmZzZXQsIGxfY291bnQpXG4gICAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIHN0YXJ0IGF0IGAxJyBhbmQgbm90IGAwJyBiZWNhdXNlIG5leHQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgLS0gd2lsbCB1cGRhdGUgdGhlIGl0ZW0gYXQgcG9zaXRpb24gYDAnLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDEsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEluc2VydCBgdicgYXQgdGhlIG5ldyBsb3dlciBwb3NpdGlvbi5cbiAgICAgICAgICBhcmVhLnB1dCAodiwgMClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIG5ld19zaXplID4gYXJlYS5jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIGFyZSBhZGRpbmcgdG8gdGhlIG5ldyBgdXBwZXInIHBvc2l0aW9uLiBGaXJzdCB3ZSBmaWxsIHRoZSBub24taW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgLS0gZWxlbWVudHMgaWYgYW55IHVwIHRvIGBuZXdfc2l6ZSAtIDInIChpLmUuIHVwIHRoZSB0aGUgaXRlbSBwcmlvciB0byBgdXBwZXInKS5cbiAgICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgdGhlblxuICAgICAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgYXJlYS5jb3VudCwgbmV3X3NpemUgLSAyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIC0tIEFkZCBgdicgYXQgdXBwZXIgcG9zaXRpb24uXG4gICAgICAgICAgICBhcmVhLmV4dGVuZCAodilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEhlcmUgYGxvd2VyJyBoYXNuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGxvd2VyIDo9IG5ld19sb3dlclxuICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgICBoaWdoZXJfY291bnQ6IGNvdW50ID49IG9sZCBjb3VudFxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IChvbGQgbG93ZXIpLm1pbiAoaSlcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAob2xkIHVwcGVyKS5tYXggKGkpXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoICh2OiBHKVxuICAgICAgLS0gU2V0IGl0ZW1zIGJldHdlZW4gYGxvd2VyJyBhbmQgYHVwcGVyJyB3aXRoIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5maWxsX3dpdGggKHYsIDAsIHVwcGVyIC0gbG93ZXIpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfZGVmaW5pdGlvbjogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYpXG4gICAgZW5kXG5cbiAgc3ViY29weSAob3RoZXI6IEFSUkFZIFtsaWtlIGl0ZW1dOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgaXRlbXMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIHRvIGN1cnJlbnQgYXJyYXkgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogc3RhcnRfcG9zID49IG90aGVyLmxvd2VyXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IG90aGVyLnVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiBpbmRleF9wb3MgPj0gbG93ZXJcbiAgICAgIGVub3VnaF9zcGFjZTogKHVwcGVyIC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBkb1xuICAgICAgYXJlYS5jb3B5X2RhdGEgKG90aGVyLmFyZWEsIHN0YXJ0X3BvcyAtIG90aGVyLmxvd2VyLCBpbmRleF9wb3MgLSBsb3dlciwgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgZW5zdXJlXG4gICAgICAtLSBjb3BpZWQ6IGZvcmFsbCBgaScgaW4gMCAuLiAoYGVuZF9wb3MnLWBzdGFydF9wb3MnKSxcbiAgICAgIC0tICAgICBpdGVtIChpbmRleF9wb3MgKyBpKSA9IG90aGVyLml0ZW0gKHN0YXJ0X3BvcyArIGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uLCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZG9faWYgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9faWZfaW5fYm91bmRzIChhY3Rpb24sIHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLnRoZXJlX2V4aXN0c19pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBmb3JfYWxsICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGFsbCBpdGVtcz9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuZm9yX2FsbF9pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBkb19hbGxfd2l0aF9pbmRleCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0csIElOVEVHRVJdXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIHJlY2VpdmVzIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl0sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIGFuZCBgdGVzdCcgcmVjZWl2ZSB0aGUgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2xfYXJlYS5pdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2xfYXJlYS5pdGVtIChpKSwgal0pXG4gICAgICAgIGVuZFxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICB3aXBlX291dFxuICAgICAgLS0gTWFrZSBhcnJheSBlbXB0eS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJOb3QgYXBwbGljYWJsZSBzaW5jZSBub3QgYHBydW5hYmxlJy4gVXNlIGBkaXNjYXJkX2l0ZW1zJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGRpc2NhcmRfaXRlbXNcbiAgICBlbmRcblxuICBkaXNjYXJkX2l0ZW1zXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMgd2l0aCByZWFsbG9jYXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgoe0d9KS5kZWZhdWx0LCBjYXBhY2l0eSlcbiAgICBlbnN1cmVcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCBhcmVhLmNvdW50IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHN0YWJsZV9sb3dlcjogbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIHN0YWJsZV91cHBlcjogdXBwZXIgPSBvbGQgdXBwZXJcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyICsgbiAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBsb3dlciA6PSB1cHBlciAtIG4gKyAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBpdGVtcztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICB1cHBlciA6PSBsb3dlciAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhICgwKVxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IChvbGQgY291bnQgLSBuKS5tYXggKDApXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGl0ZW1zO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyIC0gMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKDApXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCAtIG4pLm1heCAoMClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhdCBsZWFzdCBgaScuXG4gICAgZG9cbiAgICAgIGlmIGkgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0ICgoe0d9KS5kZWZhdWx0LCBsb3dlciwgdXBwZXIgKyBpIC0gY2FwYWNpdHkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjb25zZXJ2YXRpdmVfcmVzaXplIChtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBhcnJheSBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gaW5kaWNlcyBkb3duIHRvIGBtaW5faW5kZXgnIGFuZCB1cCB0byBgbWF4X2luZGV4Jy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgaXRlbS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCIgYGNvbnNlcnZhdGl2ZV9yZXNpemUnIGlzIG5vdCB2b2lkLXNhZmUgc3RhdGljYWxseS4gVXNlIGBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCcgaW5zdGVhZC4gWzA3LTIwMTBdXCJcbiAgICByZXF1aXJlXG4gICAgICBnb29kX2luZGljZXM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXhcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoKHtHfSkuZGVmYXVsdCwgbWluX2luZGV4LCBtYXhfaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBub19sb3dfbG9zdDogbG93ZXIgPSBtaW5faW5kZXggb3IgZWxzZSBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgbm9faGlnaF9sb3N0OiB1cHBlciA9IG1heF9pbmRleCBvciBlbHNlIHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2UgYXJyYXkgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGluZGljZXMgZG93biB0byBgbWluX2luZGV4JyBhbmQgdXAgdG8gYG1heF9pbmRleCcuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBuZXdfbG93ZXIsIG5ld191cHBlcjogSU5URUdFUlxuICAgICAgb2Zmc2V0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbWF4X2luZGV4IC0gbWluX2luZGV4ICsgMSkpXG4gICAgICAgIGxvd2VyIDo9IG1pbl9pbmRleFxuICAgICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGVsc2VcbiAgICAgICAgbmV3X2xvd2VyIDo9IG1pbl9pbmRleC5taW4gKGxvd2VyKVxuICAgICAgICBuZXdfdXBwZXIgOj0gbWF4X2luZGV4Lm1heCAodXBwZXIpXG4gICAgICAgIG5ld19zaXplIDo9IG5ld191cHBlciAtIG5ld19sb3dlciArIDFcbiAgICAgICAgaWYgbmV3X3NpemUgPiBhcmVhLmNvdW50IHRoZW5cbiAgICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbmV3X3NpemUpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgIG9mZnNldCA6PSBsb3dlciAtIG5ld19sb3dlclxuICAgICAgICAgIGFyZWEubW92ZV9kYXRhICgwLCBvZmZzZXQsIHVwcGVyIC0gbG93ZXIgKyAxKVxuICAgICAgICAgIGFyZWEuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIDAsIG9mZnNldCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBsb3dlciA6PSBuZXdfbG93ZXJcbiAgICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vX2xvd19sb3N0OiBsb3dlciA9IG1pbl9pbmRleCBvciBlbHNlIGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBub19oaWdoX2xvc3Q6IHVwcGVyID0gbWF4X2luZGV4IG9yIGVsc2UgdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICByZXNpemUgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIGFycmF5IHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBpbmRpY2VzIGRvd24gdG8gYG1pbl9pbmRleCcgYW5kIHVwIHRvIGBtYXhfaW5kZXgnLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBpdGVtLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQnIGluc3RlYWQgYXMgZnV0dXJlIHZlcnNpb25zIHdpbGwgaW1wbGVtZW50IGByZXNpemUnIGFzIHNwZWNpZmllZCBpbiBFTEtTLlwiXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKCh7R30pLmRlZmF1bHQsIG1pbl9pbmRleCwgbWF4X2luZGV4KVxuICAgIGVuc3VyZVxuICAgICAgbm9fbG93X2xvc3Q6IGxvd2VyID0gbWluX2luZGV4IG9yIGVsc2UgbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIG5vX2hpZ2hfbG9zdDogdXBwZXIgPSBtYXhfaW5kZXggb3IgZWxzZSB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGFyZWEuY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9pdGVtczogc2FtZV9pdGVtcyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgcmViYXNlIChhX2xvd2VyOiBsaWtlIGxvd2VyKVxuICAgICAgLS0gV2l0aG91dCBjaGFuZ2luZyB0aGUgYWN0dWFsIGNvbnRlbnQgb2YgYEN1cnJlbnQnIHdlIHNldCBgbG93ZXInIHRvIGBhX2xvd2VyJ1xuICAgICAgLS0gYW5kIGB1cHBlcicgYWNjb3JkaW5nbHkgdG8gYGFfbG93ZXIgKyBjb3VudCAtIDEnLlxuICAgIGxvY2FsXG4gICAgICBsX29sZF9sb3dlcjogbGlrZSBsb3dlclxuICAgIGRvXG4gICAgICBsX29sZF9sb3dlciA6PSBsb3dlclxuICAgICAgbG93ZXIgOj0gYV9sb3dlclxuICAgICAgdXBwZXIgOj0gYV9sb3dlciArICh1cHBlciAtIGxfb2xkX2xvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IGFfbG93ZXJcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhX2xvd2VyICsgb2xkIGNvdW50IC0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jOiBBTllcbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFcbiAgICBlbmRcblxuICB0b19jaWw6IE5BVElWRV9BUlJBWSBbR11cbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLm5hdGl2ZV9hcnJheVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3NwZWNpYWw6IFNQRUNJQUwgW0ddXG4gICAgICAtLSAnYXJlYScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhXG4gICAgZW5zdXJlXG4gICAgICB0b19zcGVjaWFsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtHXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbR11cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbG93ZXJcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiB1cHBlclxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBSZWluaXRpYWxpemUgYnkgY29weWluZyBhbGwgdGhlIGl0ZW1zIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYGNsb25lJy4pXG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgc2V0X2FyZWEgKG90aGVyLmFyZWEudHdpbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBlcXVhbF9hcmVhczogYXJlYSB+IG90aGVyLmFyZWFcbiAgICBlbmRcblxuICBzdWJhcnJheSAoc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogQVJSQVkgW0ddXG4gICAgICAtLSBBcnJheSBtYWRlIG9mIGl0ZW1zIG9mIGN1cnJlbnQgYXJyYXkgd2l0aGluXG4gICAgICAtLSBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IHZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IHVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgIGRvXG4gICAgICBpZiBzdGFydF9wb3MgPD0gZW5kX3BvcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKGl0ZW0gKHN0YXJ0X3BvcyksIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICAgICAgICAtLSBPbmx5IGNvcHkgZWxlbWVudHMgaWYgbmVlZGVkLlxuICAgICAgICBSZXN1bHQuc3ViY29weSAoQ3VycmVudCwgc3RhcnRfcG9zLCBlbmRfcG9zLCBzdGFydF9wb3MpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gbWFrZSBlbXB0eVxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHlcbiAgICAgICAgUmVzdWx0LnJlYmFzZSAoc3RhcnRfcG9zKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcjogUmVzdWx0Lmxvd2VyID0gc3RhcnRfcG9zXG4gICAgICB1cHBlcjogUmVzdWx0LnVwcGVyID0gZW5kX3Bvc1xuICAgICAgLS0gY29waWVkOiBmb3JhbGwgYGknIGluIGBzdGFydF9wb3MnIC4uIGBlbmRfcG9zJyxcbiAgICAgIC0tICAgICBSZXN1bHQuaXRlbSAoaSkgPSBpdGVtIChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBwcnVuZSAodjogRylcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2JyBpZiBhbnkuXG4gICAgICAtLSAoUHJlY29uZGl0aW9uIGlzIEZhbHNlLilcbiAgICBkb1xuICAgIGVuZFxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBgdicgdG8gc3RydWN0dXJlLlxuICAgICAgLS0gKFByZWNvbmRpdGlvbiBpcyBGYWxzZS4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBlbXB0eV9hcmVhOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYXJlYScgZW1wdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhID0gVm9pZCBvciBlbHNlIGFyZWEuY2FwYWNpdHkgPSAwXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGFyZWFfZXhpc3RzOiBhcmVhIC89IFZvaWRcbiAgY29uc2lzdGVudF9zaXplOiBjYXBhY2l0eSA9IHVwcGVyIC0gbG93ZXIgKyAxXG4gIG5vbl9uZWdhdGl2ZV9jb3VudDogY291bnQgPj0gMFxuICBpbmRleF9zZXRfaGFzX3NhbWVfY291bnQ6IHZhbGlkX2luZGV4X3NldFxuLS0gSW50ZXJuYWwgZGlzY3Vzc2lvbiBoYXZlbid0IHJlYWNoZWQgYW4gYWdyZWVtZW50IG9uIHRoaXMgaW52YXJpYW50XG4tLSAgaW5kZXhfc2V0X2hhc19zYW1lX2JvdW5kczogKChpbmRleF9zZXQubG93ZXIgPSBsb3dlcikgYW5kXG4tLSAgICAgICAgKGluZGV4X3NldC51cHBlciA9IGxvd2VyICsgY291bnQgLSAxKSlcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGJhZywgYWNjZXNzO1xuICBhY2Nlc3M6IG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQkFHIFtHXSBpbmhlcml0XG5cbiAgQ09MTEVDVElPTiBbR11cbiAgICByZWRlZmluZVxuICAgICAgZXh0ZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBvY2N1cnJlbmNlcyAodjogRyk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgdicgYXBwZWFycyBpbiBzdHJ1Y3R1cmVcbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9vY2N1cnJlbmNlczogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBhIG5ldyBvY2N1cnJlbmNlIG9mIGB2Jy5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICAgIC0tIENvbW1lbnRlZCBkdWUgdG8gdGhlIGV4cGVuc2l2ZSBuYXR1cmUgb2YgdGhlIGNoZWNrIHdoZW4gaW5zZXJ0aW5nIGEgbmV3IGl0ZW1cbiAgICAgICAgLS0gaW4gYSBjb250YWluZXJzIHdpdGggbWFueSBpdGVtcy5cbiAgICAgIC0tIG9uZV9tb3JlX29jY3VycmVuY2U6IG9jY3VycmVuY2VzICh2KSA9IG9sZCAob2NjdXJyZW5jZXMgKHYpKSArIDFcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlRydXRoIHZhbHVlcywgd2l0aCB0aGUgYm9vbGVhbiBvcGVyYXRpb25zXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uQm9vbGVhblwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIEJPT0xFQU5cblxuaW5oZXJpdFxuICBCT09MRUFOX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBjb25qdW5jdGVkLFxuICAgICAgY29uanVuY3RlZF9zZW1pc3RyaWN0LFxuICAgICAgZGlzanVuY3RlZCxcbiAgICAgIGRpc2p1bmN0ZWRfc2VtaXN0cmljdCxcbiAgICAgIGRpc2p1bmN0ZWRfZXhjbHVzaXZlLFxuICAgICAgaW1wbGljYXRpb24sXG4gICAgICBuZWdhdGVkXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtCT09MRUFOX1JFRn0pXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGNvbmp1bmN0ZWQgYWxpYXMgXCJhbmRcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGNvbmp1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjb25qdW5jdGVkX3NlbWlzdHJpY3QgYWxpYXMgXCJhbmQgdGhlblwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gc2VtaS1zdHJpY3QgY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGltcGxpY2F0aW9uIGFsaWFzIFwiaW1wbGllc1wiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gaW1wbGljYXRpb24gb2YgYG90aGVyJ1xuICAgICAgLS0gKHNlbWktc3RyaWN0KVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBuZWdhdGVkIGFsaWFzIFwibm90XCI6IEJPT0xFQU5cbiAgICAgIC0tIE5lZ2F0aW9uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWQgYWxpYXMgXCJvclwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZGlzanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGRpc2p1bmN0ZWRfc2VtaXN0cmljdCBhbGlhcyBcIm9yIGVsc2VcIiAob3RoZXI6IEJPT0xFQU4pOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHNlbWktc3RyaWN0IGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkX2V4Y2x1c2l2ZSBhbGlhcyBcInhvclwiIChvdGhlcjogQk9PTEVBTik6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZXhjbHVzaXZlIG9yIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhIGJvb2xlYW4gdmFsdWVcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzcyBCT09MRUFOX1JFRiBpbmhlcml0XG5cbiAgSEFTSEFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogQk9PTEVBTlxuICAgICAgLS0gQm9vbGVhbiB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGRvXG4gICAgICBpZiBpdGVtIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IEJPT0xFQU5fUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogQk9PTEVBTl9SRUZcbiAgICAgIC0tIEFzc29jaWF0ZWQgcmVmZXJlbmNlIG9mIEN1cnJlbnRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9pdGVtOiBSZXN1bHQuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuICB0b19pbnRlZ2VyOiBJTlRFR0VSXG4gICAgICAtLSAxIGlmIGBUcnVlJ1xuICAgICAgLS0gMCBpZiBgRmFsc2UnXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3RfaXRlbV9pbXBsaWVzX3plcm86IG5vdCBpdGVtIGltcGxpZXMgUmVzdWx0ID0gMFxuICAgICAgaXRlbV9pbXBsaWVzX29uZTogaXRlbSBpbXBsaWVzIFJlc3VsdCA9IDFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChiOiBCT09MRUFOKVxuICAgICAgLS0gTWFrZSBgYicgdGhlIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIGNvbmp1bmN0ZWQgYWxpYXMgXCJhbmRcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIGFuZCBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZV9tb3JnYW46IFJlc3VsdCA9IG5vdCAobm90IEN1cnJlbnQgb3Igbm90IG90aGVyKVxuICAgICAgY29tbXV0YXRpdmU6IFJlc3VsdCA9IChvdGhlciBhbmQgQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnRfd2l0aF9zZW1pX3N0cmljdDogUmVzdWx0IGltcGxpZXMgKEN1cnJlbnQgYW5kIHRoZW4gb3RoZXIpXG4gICAgZW5kXG5cbiAgY29uanVuY3RlZF9zZW1pc3RyaWN0IGFsaWFzIFwiYW5kIHRoZW5cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gc2VtaS1zdHJpY3QgY29uanVuY3Rpb24gd2l0aCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIGFuZCB0aGVuIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlX21vcmdhbjogUmVzdWx0ID0gbm90IChub3QgQ3VycmVudCBvciBlbHNlIG5vdCBvdGhlcilcbiAgICBlbmRcblxuICBpbXBsaWNhdGlvbiBhbGlhcyBcImltcGxpZXNcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gaW1wbGljYXRpb24gb2YgYG90aGVyJ1xuICAgICAgLS0gKHNlbWktc3RyaWN0KVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBpbXBsaWVzIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChub3QgQ3VycmVudCBvciBlbHNlIG90aGVyKVxuICAgIGVuZFxuXG4gIG5lZ2F0ZWQgYWxpYXMgXCJub3RcIjogQk9PTEVBTlxuICAgICAgLS0gTmVnYXRpb25cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCBpdGVtXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZCBhbGlhcyBcIm9yXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBvciBvdGhlci5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBkZV9tb3JnYW46IFJlc3VsdCA9IG5vdCAobm90IEN1cnJlbnQgYW5kIG5vdCBvdGhlcilcbiAgICAgIGNvbW11dGF0aXZlOiBSZXN1bHQgPSAob3RoZXIgb3IgQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnRfd2l0aF9zZW1pX3N0cmljdDogUmVzdWx0IGltcGxpZXMgKEN1cnJlbnQgb3IgZWxzZSBvdGhlcilcbiAgICBlbmRcblxuICBkaXNqdW5jdGVkX3NlbWlzdHJpY3QgYWxpYXMgXCJvciBlbHNlXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBCb29sZWFuIHNlbWktc3RyaWN0IGRpc2p1bmN0aW9uIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBvciBlbHNlIG90aGVyLml0ZW1cbiAgICBlbnN1cmVcbiAgICAgIGRlX21vcmdhbjogUmVzdWx0ID0gbm90IChub3QgQ3VycmVudCBhbmQgdGhlbiBub3Qgb3RoZXIpXG4gICAgZW5kXG5cbiAgZGlzanVuY3RlZF9leGNsdXNpdmUgYWxpYXMgXCJ4b3JcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gZXhjbHVzaXZlIG9yIHdpdGggYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSB4b3Igb3RoZXIuaXRlbVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChDdXJyZW50IG9yIG90aGVyKSBhbmQgbm90IChDdXJyZW50IGFuZCBvdGhlcikpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBib29sZWFuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBcIkZhbHNlXCJcbiAgICAgIGlmIGl0ZW0gdGhlblxuICAgICAgICBSZXN1bHQgOj0gXCJUcnVlXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgaW52b2x1dGl2ZV9uZWdhdGlvbjogKG5vdCAobm90IEN1cnJlbnQpKS5pdGVtID0gaXRlbVxuICBub25fY29udHJhZGljdGlvbjogbm90ICgobm90IEN1cnJlbnQpIGFuZCBDdXJyZW50KVxuICBjb21wbGV0ZW5lc3M6IChub3QgQ3VycmVudCkgb3IgQ3VycmVudFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJCb3VuZGVkIGRhdGEgc3RydWN0dXJlcywgd2l0aCBhIG5vdGlvbiBvZiBjYXBhY2l0eS5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBib3VuZGVkLCBzdG9yYWdlO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgQk9VTkRFRCBbR10gaW5oZXJpdFxuXG4gIEZJTklURSBbR11cblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBOdW1iZXIgb2YgaXRlbXMgdGhhdCBtYXkgYmUgc3RvcmVkXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZnVsbDogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGZ1bGw/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY291bnQgPSBjYXBhY2l0eSlcbiAgICBlbmRcblxuICByZXNpemFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgY2FwYWNpdHknIGJlIGNoYW5nZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgdmFsaWRfY291bnQ6IGNvdW50IDw9IGNhcGFjaXR5XG4gIGZ1bGxfZGVmaW5pdGlvbjogZnVsbCA9IChjb3VudCA9IGNhcGFjaXR5KVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogc3RvcmFnZTtcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIEJPWCBbR10gaW5oZXJpdFxuXG4gIENPTlRBSU5FUiBbR11cblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZnVsbDogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RydWN0dXJlIGZpbGxlZCB0byBjYXBhY2l0eT9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlVuaWNvZGUgY2hhcmFjdGVycywgd2l0aCBjb21wYXJpc29uIG9wZXJhdGlvbnNcIlxuICBhc3NlbWJseTogXCJtc2NvcmxpYlwiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlVJbnQzMlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0xMC0zMCAwODozMjo0NiAtMDcwMCAoVHVlLCAzMCBPY3QgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIwMjIgJFwiXG5cbmZyb3plbiBleHBhbmRlZCBjbGFzc1xuICBDSEFSQUNURVJfMzJcblxuaW5oZXJpdFxuICBDSEFSQUNURVJfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvZGUsXG4gICAgICBuYXR1cmFsXzMyX2NvZGUsXG4gICAgICB0b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Q0hBUkFDVEVSXzMyX1JFRn0pXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZTogSU5URUdFUlxuICAgICAgLS0gQXNzb2NpYXRlZCBpbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jaGFyYWN0ZXJfODogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfOFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhIHVuaWNvZGUgY2hhcmFjdGVyIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3NcbiAgQ0hBUkFDVEVSXzMyX1JFRlxuXG5pbmhlcml0XG4gIENPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfZXF1YWwsIG91dFxuICAgIGVuZFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFVuaWNvZGUgY2hhcmFjdGVyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGNvZGU6IElOVEVHRVJcbiAgICAgIC0tIEFzc29jaWF0ZWQgaW50ZWdlciB2YWx1ZVxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbmF0dXJhbF8zMl9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgbmF0dXJhbF8zMl9jb2RlOiBOQVRVUkFMXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIG5hdHVyYWwgdmFsdWVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0ubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5zdXJlXG4gICAgICBuYXR1cmFsXzMyX2NvZGVfaW5fcmFuZ2U6IFJlc3VsdCA+PSBtaW5fdmFsdWUgYW5kIFJlc3VsdCA8PSBtYXhfdmFsdWVcbiAgICBlbmRcblxuICBtaW5fdmFsdWU6IE5BVFVSQUxfMzIgPSAwXG4gIG1heF92YWx1ZTogTkFUVVJBTF8zMiA9IDQyOTQ5NjcyOTVcbiAgICAgIC0tIEJvdW5kcyBmb3IgaW50ZWdlciByZXByZXNlbnRhdGlvbiBvZiBDSEFSQUNURVJfMzJcblxuICBtYXhfdW5pY29kZV92YWx1ZTogTkFUVVJBTF8zMiA9IDB4MTBGRkZEXG4gICAgICAtLSBNYXhpbXVtIFVuaWNvZGUgY2hhcmFjdGVycy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgZ3JlYXRlciB0aGFuIGN1cnJlbnQgY2hhcmFjdGVyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChuYXR1cmFsXzMyX2NvZGUgPCBvdGhlci5uYXR1cmFsXzMyX2NvZGUpXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyByb3V0aW5lc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKGluY3I6IE5BVFVSQUxfMzIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFkZCBgaW5jcicgdG8gdGhlIGNvZGUgb2YgYGl0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luY3JlbWVudDogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgKyBpbmNyKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0ubmF0dXJhbF8zMl9jb2RlICsgaW5jcikudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IGluY3JcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAoZGVjcjogTkFUVVJBTF8zMik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gU3VidHJhY3QgYGRlY3InIGZyb20gdGhlIGNvZGUgb2YgYGl0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2RlY3JlbWVudDogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjQgLSBkZWNyKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0ubmF0dXJhbF8zMl9jb2RlIC0gZGVjcikudG9fY2hhcmFjdGVyXzMyXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IGl0ZW0gfC18IFJlc3VsdCA9IGRlY3JcbiAgICBlbmRcblxuICBkaWZmZXJlbmNlIGFsaWFzIFwifC18XCIgKG90aGVyOiBDSEFSQUNURVJfMzIpOiBJTlRFR0VSXzY0XG4gICAgICAtLSBEaWZmZXJlbmNlIGJldHdlZW4gdGhlIGNvZGVzIG9mIGBpdGVtJyBhbmQgYG90aGVyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX2ludGVnZXJfNjQgLSBvdGhlci5uYXR1cmFsXzMyX2NvZGUudG9faW50ZWdlcl82NFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfbm9uX25lZ2F0aXZlX3Jlc3VsdDogUmVzdWx0ID49IDAgaW1wbGllcyAoKG90aGVyICsgUmVzdWx0LnRvX25hdHVyYWxfMzIpID0gaXRlbSlcbiAgICAgIHZhbGlkX25lZ2F0aXZlX3Jlc3VsdDogUmVzdWx0IDwgMCBpbXBsaWVzIChvdGhlciA9IChpdGVtICsgUmVzdWx0LnRvX25hdHVyYWxfMzIpKVxuICAgIGVuZFxuXG4gIG5leHQ6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gTmV4dCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5uYXR1cmFsXzMyX2NvZGUudG9fbmF0dXJhbF82NCArIDEpLmlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICsgMVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgfC18IGl0ZW0gPSAxXG4gICAgZW5kXG5cbiAgcHJldmlvdXM6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gUHJldmlvdXMgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKGl0ZW0ubmF0dXJhbF8zMl9jb2RlLnRvX25hdHVyYWxfNjQgLSAxKS5pc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAtIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gLTFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBNYWtlIGBjJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIHdpZGUgY2hhcmFjdGVyLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDYpXG4gICAgICBSZXN1bHQuYXBwZW5kX2NoYXJhY3RlciAoJ1UnKVxuICAgICAgUmVzdWx0LmFwcGVuZF9jaGFyYWN0ZXIgKCcrJylcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nIChuYXR1cmFsXzMyX2NvZGUudG9faGV4X3N0cmluZylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh2OiBDSEFSQUNURVJfMzJfUkVGKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBgQ3VycmVudCcgd2l0aCBgdi5pdGVtJy5cbiAgICByZXF1aXJlXG4gICAgICB2X25vdF92b2lkOiB2IC89IFZvaWRcbiAgICBkb1xuICAgICAgc2V0X2l0ZW0gKHYuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gdi5pdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX3JlZmVyZW5jZTogQ0hBUkFDVEVSXzMyX1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtKVxuICAgIGVuc3VyZVxuICAgICAgdG9fcmVmZXJlbmNlX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQ29udmVydCBjdXJyZW50IHRvIENIQVJBQ1RFUl84LlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2NoYXJhY3Rlcl84X2NvbXBhdGlibGU6IGlzX2NoYXJhY3Rlcl84XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENvbnZlcnQgY3VycmVudCB0byBDSEFSQUNURVJfMzIuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgYXNfdXBwZXIsIHVwcGVyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFVwcGVyY2FzZSB2YWx1ZSBvZiBgaXRlbScuXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX2xvd2VyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMudG9fdXBwZXIgKGl0ZW0pXG4gICAgZW5kXG5cbiAgYXNfbG93ZXIsIGxvd2VyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIExvd2VyY2FzZSB2YWx1ZSBvZiBgaXRlbScuXG4gICAgICAtLSBSZXR1cm5zIGBpdGVtJyBpZiBub3QgYGlzX3VwcGVyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMudG9fbG93ZXIgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGlzX2NoYXJhY3Rlcl84OiBCT09MRUFOXG4gICAgICAtLSBDYW4gY3VycmVudCBiZSByZXByZXNlbnRlZCBvbiBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmF0dXJhbF8zMl9jb2RlIDw9IHtDSEFSQUNURVJfOH0ubWF4X3ZhbHVlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpc19hbHBoYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWM/XG4gICAgICAtLSBBbHBoYWJldGljIGlzIGBpc191cHBlcicgb3IgYGlzX2xvd2VyJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfYWxwaGEgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfdXBwZXI6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyB1cHBlcmNhc2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3VwcGVyIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2xvd2VyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgbG93ZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gcHJvcGVydGllcy5pc19sb3dlciAoaXRlbSlcbiAgICBlbmRcblxuICBpc19kaWdpdDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgZGVjaW1hbCBkaWdpdCBhcyBleHBlY3RlZCBmb3IgQVNDSUkgY2hhcmFjdGVycz9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODkuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAnMCcgPD0gaXRlbSBhbmQgaXRlbSA8PSAnOSdcbiAgICBlbmRcblxuICBpc191bmljb2RlX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBkZWNpbWFsIGRpZ2l0IGFzIGV4cGVjdGVkIGZvciBVbmljb2RlIGNoYXJhY3RlcnM/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2RpZ2l0IChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX2hleGFfZGlnaXQ6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIGhleGFkZWNpbWFsIGRpZ2l0IGFzIGV4cGVjdGVkIGZvciBBU0NJSSBjaGFyYWN0ZXJzP1xuICAgICAgLS0gQSBkaWdpdCBpcyBvbmUgb2YgMDEyMzQ1Njc4OUFCQ0RFRmFiY2VkZi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfaGV4YV9kaWdpdCAoaXRlbSlcbiAgICBlbmRcblxuICBpc19zcGFjZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgd2hpdGUgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX3NwYWNlIChpdGVtKVxuICAgIGVuZFxuXG4gIGlzX3B1bmN0dWF0aW9uOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBwdW5jdHVhdGlvbj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfcHVuY3R1YXRpb24gKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfYWxwaGFfbnVtZXJpYzogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWMgb3IgYSBkaWdpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHByb3BlcnRpZXMuaXNfYWxwaGEgKGl0ZW0pIG9yIHByb3BlcnRpZXMuaXNfZGlnaXQgKGl0ZW0pXG4gICAgZW5kXG5cbiAgaXNfY29udHJvbDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgY29udHJvbCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBwcm9wZXJ0aWVzLmlzX2NvbnRyb2wgKGl0ZW0pXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgcHJvcGVydGllczogQ0hBUkFDVEVSX1BST1BFUlRZXG4gICAgICAtLSBQcm9wZXJ0eSBmb3IgVW5pY29kZSBjaGFyYWN0ZXJzLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiQ2hhcmFjdGVycywgd2l0aCBjb21wYXJpc29uIG9wZXJhdGlvbnMgYW5kIGFuIEFTQ0lJIGNvZGVcIlxuICBleHRlcm5hbF9uYW1lOiBcIlN5c3RlbS5DaGFyXCJcbiAgYXNzZW1ibHk6IFwibXNjb3JsaWJcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMTAtMzAgMDg6MzI6NDYgLTA3MDAgKFR1ZSwgMzAgT2N0IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMDIyICRcIlxuXG5mcm96ZW4gZXhwYW5kZWQgY2xhc3NcbiAgQ0hBUkFDVEVSXzhcblxuaW5oZXJpdFxuICBDSEFSQUNURVJfOF9SRUZcbiAgICByZWRlZmluZVxuICAgICAgY29kZSxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7Q0hBUkFDVEVSXzhfUkVGfSksXG4gIHRvX2NoYXJhY3Rlcl8zMjoge0NIQVJBQ1RFUl8zMn1cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvblxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZXMgdG8gb2JqZWN0cyBjb250YWluaW5nIGEgY2hhcmFjdGVyIHZhbHVlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDE0LTA1LTE5IDE0OjI2OjE0IC0wNzAwIChNb24sIDE5IE1heSAyMDE0KSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5NTExNyAkXCJcblxuY2xhc3MgQ0hBUkFDVEVSXzhfUkVGIGluaGVyaXRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIENoYXJhY3RlciB2YWx1ZVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBjb2RlOiBJTlRFR0VSXG4gICAgICAtLSBBc3NvY2lhdGVkIGludGVnZXIgdmFsdWVcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYG5hdHVyYWxfMzJfY29kZScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5jb2RlXG4gICAgZW5zdXJlXG4gICAgICBjb2RlX25vbl9uZWdhdGlmOiBSZXN1bHQgPj0gMFxuICAgICAgY29kZV9pbl9yYW5nZTogUmVzdWx0ID49IG1pbl92YWx1ZSBhbmQgUmVzdWx0IDw9IG1heF92YWx1ZVxuICAgIGVuZFxuXG4gIG5hdHVyYWxfMzJfY29kZTogTkFUVVJBTF8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBuYXR1cmFsIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmNvZGUudG9fbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuYXR1cmFsXzMyX2NvZGUuaGFzaF9jb2RlXG4gICAgZW5kXG5cbiAgbWluX3ZhbHVlOiBJTlRFR0VSID0gMFxuICBtYXhfdmFsdWU6IElOVEVHRVIgPSAyNTVcbiAgbWF4X2FzY2lpX3ZhbHVlOiBJTlRFR0VSID0gMTI3XG4gICAgICAtLSBCb3VuZHMgZm9yIGludGVnZXIgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVycyAoQVNDSUkpXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGNoYXJhY3Rlcj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5hdHVyYWxfMzJfY29kZSA8IG90aGVyLm5hdHVyYWxfMzJfY29kZVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAobmF0dXJhbF8zMl9jb2RlIDwgb3RoZXIubmF0dXJhbF8zMl9jb2RlKVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgcm91dGluZXNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChpbmNyOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIEFkZCBgaW5jcicgdG8gdGhlIGNvZGUgb2YgYGl0ZW0nXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5jcmVtZW50OiAoaXRlbS5jb2RlICsgaW5jcikuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGl0ZW0uY29kZSArIGluY3IpLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCB8LXwgaXRlbSA9IGluY3JcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAoZGVjcjogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBTdWJ0cmFjdCBgZGVjcicgZnJvbSB0aGUgY29kZSBvZiBgaXRlbSdcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9kZWNyZW1lbnQ6IChpdGVtLmNvZGUgLSBkZWNyKS5pc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoaXRlbS5jb2RlIC0gZGVjcikudG9fY2hhcmFjdGVyXzhcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogaXRlbSB8LXwgUmVzdWx0ID0gZGVjclxuICAgIGVuZFxuXG4gIGRpZmZlcmVuY2UgYWxpYXMgXCJ8LXxcIiAob3RoZXI6IENIQVJBQ1RFUl84KTogSU5URUdFUlxuICAgICAgLS0gRGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBjb2RlcyBvZiBgaXRlbScgYW5kIGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uY29kZSAtIG90aGVyLmNvZGVcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogb3RoZXIgKyBSZXN1bHQgPSBpdGVtXG4gICAgZW5kXG5cbiAgbmV4dDogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIE5leHQgY2hhcmFjdGVyXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5jb2RlICsgMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSArIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gMVxuICAgIGVuZFxuXG4gIHByZXZpb3VzOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUHJldmlvdXMgY2hhcmFjdGVyXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoaXRlbS5jb2RlIC0gMSkuaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAtIDFcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0IHwtfCBpdGVtID0gLTFcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIE1ha2UgYGMnIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgY2hhcmFjdGVyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSlcbiAgICAgIFJlc3VsdC5hcHBlbmRfY2hhcmFjdGVyIChpdGVtKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IENIQVJBQ1RFUl84X1JFRilcbiAgICAgIC0tIEluaXRpYWxpemUgYEN1cnJlbnQnIHdpdGggYHYuaXRlbScuXG4gICAgcmVxdWlyZVxuICAgICAgdl9ub3Rfdm9pZDogdiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9pdGVtICh2Lml0ZW0pXG4gICAgZW5zdXJlXG4gICAgICBpdGVtX3NldDogaXRlbSA9IHYuaXRlbVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19yZWZlcmVuY2U6IENIQVJBQ1RFUl84X1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG4gIGFzX3VwcGVyLCB1cHBlcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFVwcGVyY2FzZSB2YWx1ZSBvZiBgaXRlbSdcbiAgICAgIC0tIFJldHVybnMgYGl0ZW0nIGlmIG5vdCBgaXNfbG93ZXInXG4gICAgZG9cbiAgICAgIGlmIGlzX2xvd2VyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgLSAoJ2EnKS5jb2RlICsgKCdBJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFzX2xvd2VyLCBsb3dlcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIExvd2VyY2FzZSB2YWx1ZSBvZiBgaXRlbSdcbiAgICAgIC0tIFJldHVybnMgYGl0ZW0nIGlmIG5vdCBgaXNfdXBwZXInXG4gICAgZG9cbiAgICAgIGlmIGlzX3VwcGVyIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IChpdGVtLmNvZGUgLSAoJ0EnKS5jb2RlICsgKCdhJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19hbHBoYTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGFscGhhYmV0aWM/XG4gICAgICAtLSBBbHBoYWJldGljIGlzIGBpc191cHBlcicgb3IgYGlzX2xvd2VyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX3VwcGVyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgdXBwZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3VwcGVyX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2xvd2VyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgbG93ZXJjYXNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX2xvd2VyX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYSBkaWdpdD9cbiAgICAgIC0tIEEgZGlnaXQgaXMgb25lIG9mIDAxMjM0NTY3ODlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjaGFyYWN0ZXJfdHlwZXMgKGl0ZW0uY29kZSkgJiBpc19kaWdpdF9mbGFnKSA+IDBcbiAgICBlbmRcblxuICBpc19oZXhhX2RpZ2l0OiBCT09MRUFOXG4gICAgICAtLSBJcyBgaXRlbScgYW4gaGV4YWRlY2ltYWwgZGlnaXQ/XG4gICAgICAtLSBBIGRpZ2l0IGlzIG9uZSBvZiAwMTIzNDU2Nzg5QUJDREVGYWJjZWRmXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgKGlzX2hleGFfZGlnaXRfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcpKSA+IDBcbiAgICBlbmRcblxuICBpc19zcGFjZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgd2hpdGUgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfd2hpdGVfc3BhY2VfZmxhZykgPiAwXG4gICAgZW5kXG5cbiAgaXNfcHVuY3R1YXRpb246IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHB1bmN0dWF0aW9uP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmIGlzX3B1bmN0dWF0aW9uX2ZsYWcpID4gMFxuICAgIGVuZFxuXG4gIGlzX2FscGhhX251bWVyaWM6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhbHBoYWJldGljIG9yIGEgZGlnaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgKGlzX3VwcGVyX2ZsYWcgfCBpc19sb3dlcl9mbGFnIHwgaXNfZGlnaXRfZmxhZykpID4gMFxuICAgIGVuZFxuXG4gIGlzX3ByaW50YWJsZTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBpbmNsdWRpbmcgc3BhY2U/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICZcbiAgICAgICAgKGlzX3VwcGVyX2ZsYWcgfCBpc19sb3dlcl9mbGFnIHwgaXNfZGlnaXRfZmxhZyB8IGlzX3B1bmN0dWF0aW9uX2ZsYWcgfCBpc19zcGFjZV9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfZ3JhcGg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpdGVtJyBhIHByaW50YWJsZSBjaGFyYWN0ZXIgZXhjZXB0IHNwYWNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKGNoYXJhY3Rlcl90eXBlcyAoaXRlbS5jb2RlKSAmXG4gICAgICAgIChpc191cHBlcl9mbGFnIHwgaXNfbG93ZXJfZmxhZyB8IGlzX2RpZ2l0X2ZsYWcgfCBpc19wdW5jdHVhdGlvbl9mbGFnKSkgPiAwXG4gICAgZW5kXG5cbiAgaXNfY29udHJvbDogQk9PTEVBTlxuICAgICAgLS0gSXMgYGl0ZW0nIGEgY29udHJvbCBjaGFyYWN0ZXI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAoY2hhcmFjdGVyX3R5cGVzIChpdGVtLmNvZGUpICYgaXNfY29udHJvbF9mbGFnKSA+IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBjaGFyYWN0ZXJfdHlwZXMgKGFfY29kZTogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gQXNzb2NpYXRlZCB0eXBlIGZvciBjaGFyYWN0ZXIgb2YgY29kZSBgYV9jb2RlJ1xuICAgIGRvXG4gICAgICAgIC0tIEZvciBjaGFyYWN0ZXIgd2hvc2UgY29kZSBpcyBhYm92ZSAyNTYsIGl0IGlzIGFzIGlmXG4gICAgICAgIC0tIHdlIGhhZCBubyBpbmZvcm1hdGlvbiBhYm91dCBpdC5cbiAgICAgIGlmIGFfY29kZSA8IDI1NiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlcm5hbF9jaGFyYWN0ZXJfdHlwZXMuaXRlbSAoYV9jb2RlKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW50ZXJuYWxfY2hhcmFjdGVyX3R5cGVzOiBTUEVDSUFMIFtOQVRVUkFMXzhdXG4gICAgICAtLSBBcnJheSB3aGljaCBzdG9yZXMgdGhlIHZhcmlvdXMgdHlwZSBmb3IgdGhlIEFTQ0lJIGNoYXJhY3RlcnNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDI1NilcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgLS0gMCAgbnVsbFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxICBzdGFydCBvZiBoZWFkaW5nXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDIgIHN0YXJ0IG9mIHRleHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMyAgZW5kIG9mIHRleHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNCAgZW5kIG9mIHRyYW5zbWlzc2lvblxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1ICBlbnF1aXJ5XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDYgIGFja25vd2xlZGdlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDcgIGJlbGxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gOCAgYmFja3NwYWNlXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDkgIGhvcml6b250YWwgdGFiXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEwIE5MIGxpbmUgZmVlZCwgbmV3IGxpbmVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZyB8IGlzX3doaXRlX3NwYWNlX2ZsYWcpICAgLS0gMTEgdmVydGljYWwgdGFiXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcgfCBpc193aGl0ZV9zcGFjZV9mbGFnKSAgIC0tIDEyIE5QIGZvcm0gZmVlZCwgbmV3IHBhZ2VcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZyB8IGlzX3doaXRlX3NwYWNlX2ZsYWcpICAgLS0gMTMgY2FycmlhZ2UgcmV0dXJuPUNSXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDE0IHNoaWZ0IG91dFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNSBzaGlmdCBpblxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxNlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxN1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxOFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxOVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyMlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyM1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfY29udHJvbF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAtLSAyNyBFc2NhcGVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjggZmlsZSBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMjkgZ3JvdXAgc2VwYXJhdG9yXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDMwIHJlY29yZCBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2NvbnRyb2xfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMzEgdW5pdCBzZXBhcmF0b3JcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3doaXRlX3NwYWNlX2ZsYWcgfCBpc19zcGFjZV9mbGFnKSAgICAgLS0gMzIgU3BhY2VcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzMgIVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNCBcIlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzNSAjXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM2ICRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMzcgJVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAzOCAmXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDM5ICdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDAgKFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0MSApXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQyICpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDMgK1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NCAsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDQ1IC1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNDYgLlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA0NyAvXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDQ4IDBcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNDkgMVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MCAyXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDUxIDNcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTIgNFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1MyA1XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU0IDZcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2RpZ2l0X2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNTUgN1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfZGlnaXRfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA1NiA4XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19kaWdpdF9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDU3IDlcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNTggOlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA1OSA7XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYwIDxcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjEgPVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA2MiA+XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDYzID9cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gNjQgQFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2NSBBXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY2IEJcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNjcgQ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA2OCBEXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDY5IEVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gNzAgRlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3MSBHXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDcyIEhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzMgSVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NCBKXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc1IEtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzYgTFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA3NyBNXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDc4IE5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gNzkgT1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MCBQXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDgxIFFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODIgUlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4MyBTXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg0IFRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODUgVVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4NiBWXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDg3IFdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3VwcGVyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gODggWFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfdXBwZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSA4OSBZXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc191cHBlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDkwIFpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTEgW1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5MiBcXFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5MyBdXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDk0IF5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gOTUgX1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSA5NiBgXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDk3IGFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gOTggYlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSA5OSBjXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnIHwgaXNfaGV4YV9kaWdpdF9mbGFnKSAgICAgIC0tIDEwMCAgZFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZyB8IGlzX2hleGFfZGlnaXRfZmxhZykgICAgICAtLSAxMDEgIGVcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcgfCBpc19oZXhhX2RpZ2l0X2ZsYWcpICAgICAgLS0gMTAyICBmXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwMyAgZ1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDQgIGhcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA1ICBpXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwNiAgalxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMDcgIGtcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTA4ICBsXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEwOSAgbVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTAgIG5cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTExICBvXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExMiAgcFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTMgIHFcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE0ICByXG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExNSAgc1xuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTYgIHRcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTE3ICB1XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDExOCAgdlxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMTkgIHdcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX2xvd2VyX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gMTIwICB4XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19sb3dlcl9mbGFnKSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyMSAgeVxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfbG93ZXJfZmxhZykgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSAxMjIgIHpcbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTIzICB7XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19wdW5jdHVhdGlvbl9mbGFnKSAgICAgICAgICAgICAgICAgICAgIC0tIDEyNCAgfFxuICAgICAgUmVzdWx0LmV4dGVuZCAoaXNfcHVuY3R1YXRpb25fZmxhZykgICAgICAgICAgICAgICAgICAgICAtLSAxMjUgIH1cbiAgICAgIFJlc3VsdC5leHRlbmQgKGlzX3B1bmN0dWF0aW9uX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgLS0gMTI2ICB+XG4gICAgICBSZXN1bHQuZXh0ZW5kIChpc19jb250cm9sX2ZsYWcpICAgICAgICAgICAgICAgICAgICAgICAgIC0tIDEyNyAgREVMXG4gICAgICBSZXN1bHQuZmlsbF93aXRoICgwLCAxMjgsIDI1NSkgICAgICAgICAgICAgIC0tIGV4dGVuZGVkIEFTQ0lJXG4gICAgZW5zdXJlXG4gICAgICBpbnRlcm5hbF9jaGFyYWN0ZXJfdHlwZXNfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgaXNfdXBwZXJfZmxhZzogTkFUVVJBTF84ID0gMHgwMVxuXG4gIGlzX2xvd2VyX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MDJcblxuICBpc19kaWdpdF9mbGFnOiBOQVRVUkFMXzggPSAweDA0XG5cbiAgaXNfd2hpdGVfc3BhY2VfZmxhZzogTkFUVVJBTF84ID0gMHgwOFxuXG4gIGlzX3B1bmN0dWF0aW9uX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MTBcblxuICBpc19jb250cm9sX2ZsYWc6IE5BVFVSQUxfOCA9IDB4MjBcblxuICBpc19oZXhhX2RpZ2l0X2ZsYWc6IE5BVFVSQUxfOCA9IDB4NDBcblxuICBpc19zcGFjZV9mbGFnOiBOQVRVUkFMXzggPSAweDgwO1xuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IGNvbGxlY3Rpb24sIGFjY2VzcztcbiAgYWNjZXNzOiBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNy0yMyAxNDowMjoxOSAtMDcwMCAoTW9uLCAyMyBKdWwgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODkgJFwiXG5cbmRlZmVycmVkIGNsYXNzIENPTExFQ1RJT04gW0ddIGluaGVyaXRcblxuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBwcnVuYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIHJlbW92ZWQ/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc19pbnNlcnRlZCAodjogRyk6IEJPT0xFQU5cbiAgICAgIC0tIEhhcyBgdicgYmVlbiBpbnNlcnRlZCBieSB0aGUgbW9zdCByZWNlbnQgaW5zZXJ0aW9uP1xuICAgICAgLS0gKEJ5IGRlZmF1bHQsIHRoZSB2YWx1ZSByZXR1cm5lZCBpcyBlcXVpdmFsZW50IHRvIGNhbGxpbmdcbiAgICAgIC0tIGBoYXMgKHYpJy4gSG93ZXZlciwgZGVzY2VuZGFudHMgbWlnaHQgYmUgYWJsZSB0byBwcm92aWRlIG1vcmVcbiAgICAgIC0tIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbnMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaGFzICh2KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0LCBleHRlbmQgKHY6IEcpXG4gICAgICAtLSBFbnN1cmUgdGhhdCBzdHJ1Y3R1cmUgaW5jbHVkZXMgYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9pbnNlcnRlZDogaXNfaW5zZXJ0ZWQgKHYpXG4gICAgZW5kXG5cbiAgZmlsbCAob3RoZXI6IENPTlRBSU5FUiBbR10pXG4gICAgICAtLSBGaWxsIHdpdGggYXMgbWFueSBpdGVtcyBvZiBgb3RoZXInIGFzIHBvc3NpYmxlLlxuICAgICAgLS0gVGhlIHJlcHJlc2VudGF0aW9ucyBvZiBgb3RoZXInIGFuZCBjdXJyZW50IHN0cnVjdHVyZVxuICAgICAgLS0gbmVlZCBub3QgYmUgdGhlIHNhbWUuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIGV4dGVuZGlibGU6IGV4dGVuZGlibGVcbiAgICBsb2NhbFxuICAgICAgbGluX3JlcDogTElORUFSIFtHXVxuICAgIGRvXG4gICAgICBsaW5fcmVwIDo9IG90aGVyLmxpbmVhcl9yZXByZXNlbnRhdGlvblxuICAgICAgZnJvbVxuICAgICAgICBsaW5fcmVwLnN0YXJ0XG4gICAgICB1bnRpbFxuICAgICAgICBub3QgZXh0ZW5kaWJsZSBvciBlbHNlIGxpbl9yZXAub2ZmXG4gICAgICBsb29wXG4gICAgICAgIGV4dGVuZCAobGluX3JlcC5pdGVtKVxuICAgICAgICBsaW5fcmVwLmZvcnRoXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcHJ1bmUgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgb25lIG9jY3VycmVuY2Ugb2YgYHYnIGlmIGFueS5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgcmVxdWlyZVxuICAgICAgcHJ1bmFibGU6IHBydW5hYmxlXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKHY6IEcpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGB2Jy5cbiAgICAgIC0tIChSZWZlcmVuY2Ugb3Igb2JqZWN0IGVxdWFsaXR5LFxuICAgICAgLS0gYmFzZWQgb24gYG9iamVjdF9jb21wYXJpc29uJy4pXG4gICAgICAtLXxEZWZhdWx0IGltcGxlbWVudGF0aW9uLCB1c3VhbGx5IGluZWZmaWNpZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbCBub3QgaGFzICh2KSBsb29wXG4gICAgICAgIHBydW5lICh2KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub19tb3JlX29jY3VycmVuY2VzOiBub3QgaGFzICh2KVxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGl0ZW1zLlxuICAgIHJlcXVpcmVcbiAgICAgIHBydW5hYmxlOiBwcnVuYWJsZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB3aXBlZF9vdXQ6IGlzX2VtcHR5XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBDT01QQVJBQkxFIGluaGVyaXRcblxuICBQQVJUX0NPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcywgaXNfbGVzc19lcXVhbCxcbiAgICAgIGlzX2dyZWF0ZXIsIGlzX2dyZWF0ZXJfZXF1YWwsXG4gICAgICBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBvYmplY3QgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgYXN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgbm90IChvdGhlciA8IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfbGVzc19lcXVhbCBhbGlhcyBcIjw9XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCAob3RoZXIgPCBDdXJyZW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoKEN1cnJlbnQgPCBvdGhlcikgb3IgKEN1cnJlbnQgfiBvdGhlcikpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlciBhbGlhcyBcIj5cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgb2JqZWN0IGdyZWF0ZXIgdGhhbiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIgPCBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IChvdGhlciA8IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlcl9lcXVhbCBhbGlhcyBcIj49XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5vdCAoQ3VycmVudCA8IG90aGVyKVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAob3RoZXIgPD0gQ3VycmVudClcbiAgICBlbmRcblxuICBpc19lcXVhbCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBvdGhlcicgYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgIC0tIGFzIGN1cnJlbnQgb2JqZWN0IGFuZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobm90IChDdXJyZW50IDwgb3RoZXIpIGFuZCBub3QgKG90aGVyIDwgQ3VycmVudCkpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHRyaWNob3RvbXk6IFJlc3VsdCA9IChub3QgKEN1cnJlbnQgPCBvdGhlcikgYW5kIG5vdCAob3RoZXIgPCBDdXJyZW50KSlcbiAgICBlbmRcblxuICB0aHJlZV93YXlfY29tcGFyaXNvbiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IElOVEVHRVJcbiAgICAgIC0tIElmIGN1cnJlbnQgb2JqZWN0IGVxdWFsIHRvIGBvdGhlcicsIDA7XG4gICAgICAtLSBpZiBzbWFsbGVyLCAtMTsgaWYgZ3JlYXRlciwgMVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50IDwgb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVsc2VpZiBvdGhlciA8IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBlcXVhbF96ZXJvOiAoUmVzdWx0ID0gMCkgPSAoQ3VycmVudCB+IG90aGVyKVxuICAgICAgc21hbGxlcl9uZWdhdGl2ZTogKFJlc3VsdCA9IC0xKSA9IChDdXJyZW50IDwgb3RoZXIpXG4gICAgICBncmVhdGVyX3Bvc2l0aXZlOiAoUmVzdWx0ID0gMSkgPSAoQ3VycmVudCA+IG90aGVyKVxuICAgIGVuZFxuXG4gIG1heCAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVGhlIGdyZWF0ZXIgb2YgY3VycmVudCBvYmplY3QgYW5kIGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA+PSBvdGhlciB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBvdGhlclxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjdXJyZW50X2lmX25vdF9zbWFsbGVyOiBDdXJyZW50ID49IG90aGVyIGltcGxpZXMgUmVzdWx0ID0gQ3VycmVudFxuICAgICAgb3RoZXJfaWZfc21hbGxlcjogQ3VycmVudCA8IG90aGVyIGltcGxpZXMgUmVzdWx0ID0gb3RoZXJcbiAgICBlbmRcblxuICBtaW4gKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRoZSBzbWFsbGVyIG9mIGN1cnJlbnQgb2JqZWN0IGFuZCBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPD0gb3RoZXIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gQ3VycmVudFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gb3RoZXJcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY3VycmVudF9pZl9ub3RfZ3JlYXRlcjogQ3VycmVudCA8PSBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IEN1cnJlbnRcbiAgICAgIG90aGVyX2lmX2dyZWF0ZXI6IEN1cnJlbnQgPiBvdGhlciBpbXBsaWVzIFJlc3VsdCA9IG90aGVyXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGlycmVmbGV4aXZlX2NvbXBhcmlzb246IG5vdCAoQ3VycmVudCA8IEN1cnJlbnQpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBhY2Nlc3M7XG4gIGFjY2VzczogbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBDT05UQUlORVIgW0ddXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJ1Y3R1cmUgaW5jbHVkZSBgdic/XG4gICAgICAtLSAoUmVmZXJlbmNlIG9yIG9iamVjdCBlcXVhbGl0eSxcbiAgICAgIC0tIGJhc2VkIG9uIGBvYmplY3RfY29tcGFyaXNvbicuKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBub3RfZm91bmRfaW5fZW1wdHk6IFJlc3VsdCBpbXBsaWVzIG5vdCBpc19lbXB0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19lbXB0eTogQk9PTEVBTlxuICAgICAgLS0gSXMgdGhlcmUgbm8gZWxlbWVudD9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGVtcHR5OiBCT09MRUFOXG4gICAgICAtLSBJcyB0aGVyZSBubyBlbGVtZW50P1xuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMDogVXNlIGBpc19lbXB0eScgaW5zdGVhZFwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc19lbXB0eVxuICAgIGVuZFxuXG4gIG9iamVjdF9jb21wYXJpc29uOiBCT09MRUFOXG4gICAgICAtLSBNdXN0IHNlYXJjaCBvcGVyYXRpb25zIHVzZSBgZXF1YWwnIHJhdGhlciB0aGFuIGA9J1xuICAgICAgLS0gZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzPyAoRGVmYXVsdDogbm8sIHVzZSBgPScuKVxuXG4gIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IEJPT0xFQU5cbiAgICAgIC0tIE1heSBgb2JqZWN0X2NvbXBhcmlzb24nIGJlIGNoYW5nZWQ/XG4gICAgICAtLSAoQW5zd2VyOiB5ZXMgYnkgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHNldHRpbmdcblxuICBjb21wYXJlX29iamVjdHNcbiAgICAgIC0tIEVuc3VyZSB0aGF0IGZ1dHVyZSBzZWFyY2ggb3BlcmF0aW9ucyB3aWxsIHVzZSBgZXF1YWwnXG4gICAgICAtLSByYXRoZXIgdGhhbiBgPScgZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzLlxuICAgIHJlcXVpcmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBkb1xuICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gVHJ1ZVxuICAgIGVuc3VyZVxuICAgICAgb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuICBjb21wYXJlX3JlZmVyZW5jZXNcbiAgICAgIC0tIEVuc3VyZSB0aGF0IGZ1dHVyZSBzZWFyY2ggb3BlcmF0aW9ucyB3aWxsIHVzZSBgPSdcbiAgICAgIC0tIHJhdGhlciB0aGFuIGBlcXVhbCcgZm9yIGNvbXBhcmluZyByZWZlcmVuY2VzLlxuICAgIHJlcXVpcmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBkb1xuICAgICAgb2JqZWN0X2NvbXBhcmlzb24gOj0gRmFsc2VcbiAgICBlbnN1cmVcbiAgICAgIHJlZmVyZW5jZV9jb21wYXJpc29uOiBub3Qgb2JqZWN0X2NvbXBhcmlzb25cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0ddXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuZW5kXG4iLCJjbGFzcyBBMVxuaW5oZXJpdFxuICBCMVxuZW5kXG5cbmNsYXNzIEIxXG5pbmhlcml0XG4gIEExXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiT2JqZWN0cyB0aGF0IHByb3ZpZGUgYW4gb3V0cHV0IGluIGRlYnVnZ2VyXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEzLTAxLTE3IDExOjQ2OjE1IC0wODAwIChUaHUsIDE3IEphbiAyMDEzKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjEyNCAkXCJcblxuZGVmZXJyZWQgY2xhc3NcbiAgREVCVUdfT1VUUFVUXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRlYnVnX291dHB1dDogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUxcbiAgICAgIC0tIFN0cmluZyB0aGF0IHNob3VsZCBiZSBkaXNwbGF5ZWQgaW4gZGVidWdnZXIgdG8gcmVwcmVzZW50IGBDdXJyZW50Jy5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiU3RydWN0dXJlcyB3aXRoIGEgZmluaXRlIGl0ZW0gY291bnRcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBmaW5pdGUsIHN0b3JhZ2U7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDctMjMgMTQ6MDI6MTkgLTA3MDAgKE1vbiwgMjMgSnVsIDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTg5ICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBGSU5JVEUgW0ddIGluaGVyaXRcblxuICBCT1ggW0ddXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGl0ZW1zXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfZW1wdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBlbXB0eT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChjb3VudCA9IDApXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBlbXB0eV9kZWZpbml0aW9uOiBpc19lbXB0eSA9IChjb3VudCA9IDApXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBIQVNIQUJMRVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGdvb2RfaGFzaF92YWx1ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfaGFzaGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBoYXNoZWQ/XG4gICAgICAtLSAoVHJ1ZSBieSBkZWZhdWx0LilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlRhYmxlcyB3aG9zZSBrZXlzIGFyZSBpbnRlZ2VycyBpbiBhIGNvbnRpZ3VvdXMgaW50ZXJ2YWxcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIG5hbWVzOiBpbmRleGFibGUsIGFjY2VzcztcbiAgYWNjZXNzOiBpbmRleCwgbWVtYmVyc2hpcDtcbiAgY29udGVudHM6IGdlbmVyaWM7XG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzcyBJTkRFWEFCTEUgW0csIEggLT4gSU5URUdFUl0gaW5oZXJpdFxuXG4gIFRBQkxFIFtHLCBJTlRFR0VSXVxuICAgIHJlbmFtZVxuICAgICAgdmFsaWRfa2V5IGFzIHZhbGlkX2luZGV4LFxuICAgICAgZm9yY2UgYXMgcHV0XG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtHXVxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuXG5cblxuIiwiZXhwYW5kZWQgY2xhc3MgSU5URUdFUl8zMiBpbmhlcml0XG5cbiAgSU5URUdFUl8zMl9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgb3Bwb3NpdGUsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzYV9uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsLFxuICAgICAgdG9fZG91YmxlLFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuLS0gY29udmVydFxuLS0gICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7SU5URUdFUl8zMl9SRUZ9KSxcbi0tICAgdG9fcmVhbDoge1JFQUxfMzJ9LFxuLS0gICB0b19kb3VibGU6IHtSRUFMXzY0fSxcbi0tICAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzMyXG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDMyIGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBJTlRFR0VSXzMyX1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgICAtLSBDbGVhciBzaWduIGJpdC5cbiAgICAgIFJlc3VsdCA6PSBpdGVtICYgMHg3RkZGRkZGRlxuICAgIGVuZFxuXG4gIHNpZ246IElOVEVHRVJcbiAgICAgIC0tIFNpZ24gdmFsdWUgKDAsIC0xIG9yIDEpXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IDFcbiAgICAgIGVsc2VpZiBpdGVtIDwgMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAtMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0aHJlZV93YXk6IFJlc3VsdCA9IHRocmVlX3dheV9jb21wYXJpc29uICh6ZXJvKVxuICAgIGVuZFxuXG4gIG9uZTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiKlwiIGFuZCBcIi9cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDEpXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKDApXG4gICAgZW5kXG5cbiAgYXNjaWlfY2hhcjogQ0hBUkFDVEVSXzhcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBBU0NJSSBjaGFyYWN0ZXIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSB0b19jaGFyYWN0ZXJfOCBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXJfY29kZTogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIE1pbl92YWx1ZTogSU5URUdFUl8zMiA9IC0yMTQ3NDgzNjQ4XG4gIE1heF92YWx1ZTogSU5URUdFUl8zMiA9IDIxNDc0ODM2NDdcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogSU5URUdFUl8zMilcbiAgICAgIC0tIE1ha2UgYGknIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBkaXZpZGVkIGJ5IGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtIC89IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsdWU6IFJlc3VsdCA9IChvdGhlci5pdGVtIC89IDApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF8zMl9SRUZ9IG90aGVyIGFzIHJlYWxfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhbF92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IG90aGVyIGFzIGRvdWJsZV92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkb3VibGVfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDApIG9yXG4gICAgICAgIChvdGhlci5jb25mb3Jtc190byAoMC4wKSBhbmQgaXRlbSA+IDApKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgaWYgaXQgaXMgbm90IGl0cyB0eXBlJ3MgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZSBhbmQgaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfMzJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtID49IDBcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0gMCBhbmRcbiAgICAgICAgaXRlbS50b19uYXR1cmFsXzMyID49IHtDSEFSQUNURVJfMzJ9Lk1pbl92YWx1ZSBhbmRcbiAgICAgICAgaXRlbS50b19uYXR1cmFsXzMyIDw9IHtDSEFSQUNURVJfMzJ9Lk1heF92YWx1ZSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgYWJzOiBJTlRFR0VSXzMyXG4gICAgICAtLSBBYnNvbHV0ZSB2YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWJzX3JlZi5pdGVtXG4gICAgZW5zdXJlXG4gICAgICBub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgICBzYW1lX2Fic29sdXRlX3ZhbHVlOiAoUmVzdWx0ID0gaXRlbSkgb3IgKFJlc3VsdCA9IC1pdGVtKVxuICAgIGVuZFxuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICsgb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC0gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBwcm9kdWN0IGFsaWFzIFwiKlwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtICogb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBxdW90aWVudCBhbGlhcyBcIi9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLyBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKCsgaXRlbSlcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBVbmFyeSBtaW51c1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKC0gaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIC8vIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIGdvb2RfZGl2aXNvcjogZGl2aXNpYmxlIChvdGhlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtIFxcXFwgb3RoZXIuaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gXiBvdGhlclxuICAgIGVuZFxuXG4gIGludGVydmFsIGFsaWFzIFwifC4ufFwiIChvdGhlcjogSU5URUdFUik6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIEludGVydmFsIGZyb20gY3VycmVudCBlbGVtZW50IHRvIGBvdGhlcidcbiAgICAgIC0tIChlbXB0eSBpZiBgb3RoZXInIGxlc3MgdGhhbiBjdXJyZW50IGludGVnZXIpXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaXRlbSwgb3RoZXIpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogSU5URUdFUl8zMl9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBJTlRFR0VSXzMyX1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIGl0ZW1fbm9uX25lZ2F0aXZlOiBpdGVtID49IDBcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtOQVRVUkFMXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF8xNn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBpdGVtX25vbl9uZWdhdGl2ZTogaXRlbSA+PSAwXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX3NtYWxsOiBpdGVtID49IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fc21hbGw6IGl0ZW0gPj0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMTZ9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyLCBmcm96ZW4gdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gUmV0dXJuIGBpdGVtJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIHRvX3JlYWw6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2RvdWJsZVxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGksIHZhbDogSU5URUdFUlxuICAgICAgYV9kaWdpdDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAweEYpXG4gICAgICAgIFJlc3VsdC5wdXQgKGFfZGlnaXQudG9faGV4X2NoYXJhY3RlciwgaSlcbiAgICAgICAgdmFsIDo9IHZhbCB8Pj4gNFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF92YWxpZF9jb3VudDogUmVzdWx0LmNvdW50ID0gKGNyZWF0ZSB7UExBVEZPUk19KS5JbnRlZ2VyXzMyX2JpdHMgLy8gNFxuICAgIGVuZFxuXG4gIHRvX2hleF9jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgaW5fYm91bmRzOiAwIDw9IGl0ZW0gYW5kIGl0ZW0gPD0gMTVcbiAgICBsb2NhbFxuICAgICAgdG1wOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHRtcCA6PSBpdGVtXG4gICAgICBpZiB0bXAgPD0gOSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAodG1wICsgKCcwJykuY29kZSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9ICgoJ0EnKS5jb2RlICsgKHRtcCAtIDEwKSkudG9fY2hhcmFjdGVyXzhcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLmhhcyAoUmVzdWx0KVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVJfMzIpOiBJTlRFR0VSXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0IGlmIGBuJyBwb3NpdGl2ZSxcbiAgICAgIC0tIHRvIGxlZnQgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzMyOiBuID49IC0zMlxuICAgIGRvXG4gICAgICBpZiBuID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfcmlnaHQgKG4pLml0ZW1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9sZWZ0ICgtIG4pLml0ZW1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X2xlZnQgKG4pKVxuICAgIGVuc3VyZVxuICAgICAgYml0X3NoaWZ0X2xlZnRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fMzI6IG4gPD0gMzJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzMyOiBuIDwgMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoMSB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMzI6IG4gPCAzMlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoMSB8PDwgbilcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiAoMSB8PDwgbikuYml0X25vdFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvemVuIHNldF9iaXRfd2l0aF9tYXNrIChiOiBCT09MRUFOOyBtOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYWxsIDEgYml0cyBvZiBtIHNldCB0byAxXG4gICAgICAtLSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCBtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgbS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGludGVnZXIgdmFsdWVcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlICgxMSlcbiAgICAgIFJlc3VsdC5hcHBlbmRfaW50ZWdlciAoaXRlbSlcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhYnNfcmVmOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEFic29sdXRlIHZhbHVlXG4gICAgZG9cbiAgICAgIGlmIGl0ZW0gPj0gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAtQ3VycmVudFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2FtZV9hYnNvbHV0ZV92YWx1ZTogKFJlc3VsdCB+IEN1cnJlbnQpIG9yIChSZXN1bHQgfiAtQ3VycmVudClcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgc2lnbl90aW1lc19hYnM6IHNpZ24gKiBhYnMgPSBpdGVtXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIlN0cnVjdHVyZSB0aGF0IGNhbiBiZSBpdGVyYXRlZCBvdmVyIHVzaW5nIGBhY3Jvc3MuLi5sb29wLi4uZW5kJy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBJVEVSQUJMRSBbR11cblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBuZXdfY3Vyc29yOiBJVEVSQVRJT05fQ1VSU09SIFtHXVxuICAgICAgLS0gRnJlc2ggY3Vyc29yIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHN0cnVjdHVyZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfYXR0YWNoZWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5jbGFzc1xuICBNSVNNQVRDSF9DT1JSRUNUT1JcblxuZmVhdHVyZSAtLSBDb3JyZWN0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCB1c2luZyBgbWlzbWF0Y2hfaW5mb3JtYXRpb24nLlxuICAgIGxvY2FsXG4gICAgICBsX21zZzogU1RSSU5HXG4gICAgICBsX2V4YzogRVhDRVBUSU9OU1xuICAgIGRvXG4gICAgICAgIC0tIElmIGl0IGlzIG5vdCByZWRlZmluZWQgdGhlbiB3ZSByYWlzZSBhbiBleGNlcHRpb24uXG4gICAgICBjcmVhdGUgbF9tc2cubWFrZV9mcm9tX3N0cmluZyAoXCJNaXNtYXRjaDogXCIpXG4gICAgICBjcmVhdGUgbF9leGNcbiAgICAgIGxfbXNnLmFwcGVuZCAoZ2VuZXJhdGluZ190eXBlKVxuICAgICAgbF9leGMucmFpc2VfcmV0cmlldmFsX2V4Y2VwdGlvbiAobF9tc2cpXG4gICAgZW5kXG5cbiAgbWlzbWF0Y2hfaW5mb3JtYXRpb246IE1JU01BVENIX0lORk9STUFUSU9OXG4gICAgICAtLSBPcmlnaW5hbCBhdHRyaWJ1dGUgdmFsdWVzIG9mIG1pc21hdGNoZWQgb2JqZWN0XG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxMiwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJVbnNpZ25lZCBpbnRlZ2VyIHZhbHVlcyBjb2RlZCBvbiAzMiBiaXRzLlwiXG4gIGV4dGVybmFsX25hbWU6IFwiU3lzdGVtLlVJbnQzMlwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTEwLTMwIDA4OjMyOjQ2IC0wNzAwIChUdWUsIDMwIE9jdCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjAyMiAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIE5BVFVSQUxfMzIgaW5oZXJpdFxuXG4gIE5BVFVSQUxfMzJfUkVGXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2xlc3MsXG4gICAgICBwbHVzLFxuICAgICAgbWludXMsXG4gICAgICBwcm9kdWN0LFxuICAgICAgcXVvdGllbnQsXG4gICAgICBwb3dlcixcbiAgICAgIGludGVnZXJfcXVvdGllbnQsXG4gICAgICBpbnRlZ2VyX3JlbWFpbmRlcixcbiAgICAgIGlkZW50aXR5LFxuICAgICAgYXNfbmF0dXJhbF84LFxuICAgICAgYXNfbmF0dXJhbF8xNixcbiAgICAgIGFzX25hdHVyYWxfMzIsXG4gICAgICBhc19uYXR1cmFsXzY0LFxuICAgICAgYXNfaW50ZWdlcl84LFxuICAgICAgYXNfaW50ZWdlcl8xNixcbiAgICAgIGFzX2ludGVnZXJfMzIsXG4gICAgICBhc19pbnRlZ2VyXzY0LFxuICAgICAgdG9fcmVhbF8zMixcbiAgICAgIHRvX3JlYWxfNjQsXG4gICAgICB0b19jaGFyYWN0ZXJfOCxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMixcbiAgICAgIGJpdF9hbmQsXG4gICAgICBiaXRfb3IsXG4gICAgICBiaXRfeG9yLFxuICAgICAgYml0X25vdCxcbiAgICAgIGJpdF9zaGlmdF9sZWZ0LFxuICAgICAgYml0X3NoaWZ0X3JpZ2h0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG5jb252ZXJ0XG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtOQVRVUkFMXzMyX1JFRn0pLFxuICB0b19yZWFsXzMyOiB7UkVBTF8zMn0sXG4gIHRvX3JlYWxfNjQ6IHtSRUFMXzY0fSxcbiAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9LFxuICB0b19uYXR1cmFsXzY0OiB7TkFUVVJBTF82NH1cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBOQVRVUkFMXzMyKTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogTkFUVVJBTF8zMlxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3F1b3RpZW50IGFsaWFzIFwiLy9cIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBSZW1haW5kZXIgb2YgdGhlIGludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHBvd2VyIGFsaWFzIFwiXlwiIChvdGhlcjogUkVBTF82NCk6IFJFQUxfNjRcbiAgICAgIC0tIEludGVnZXIgcG93ZXIgb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fcmVhbF8zMjogUkVBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfMzJcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBDSEFSQUNURVJfMzIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogTkFUVVJBTF8zMik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBOQVRVUkFMXzMyKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBOQVRVUkFMXzMyXG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIG9iamVjdHMgY29udGFpbmluZyBhbiBpbnRlZ2VyIHZhbHVlIGNvZGVkIG9uIDMyIGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBOQVRVUkFMXzMyX1JFRlxuXG5pbmhlcml0XG4gIE5VTUVSSUNcbiAgICByZW5hbWVcbiAgICAgIHF1b3RpZW50IGFzIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiLFxuICAgICAgb3Bwb3NpdGUgYXMgdW5hcHBsaWNhYmxlX29wcG9zaXRlXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBDT01QQVJBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIG91dCwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIHJlZGVmaW5lXG4gICAgICBpc19oYXNoYWJsZSwgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW06IE5BVFVSQUxfMzJcbiAgICAgIC0tIEludGVnZXIgdmFsdWVcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBIYXNoIGNvZGUgdmFsdWVcbiAgICBkb1xuICAgICAgICAtLSBDbGVhciBzaWduIGJpdC5cbiAgICAgIFJlc3VsdCA6PSAoaXRlbSAmIDB4N0ZGRkZGRkYpLnRvX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBzaWduOiBJTlRFR0VSXG4gICAgICAtLSBTaWduIHZhbHVlICgwLCAtMSBvciAxKVxuICAgIGRvXG4gICAgICBpZiBpdGVtID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAxXG4gICAgICBlbHNlaWYgaXRlbSA8IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdGhyZWVfd2F5OiBSZXN1bHQgPSB0aHJlZV93YXlfY29tcGFyaXNvbiAoemVybylcbiAgICBlbmRcblxuICBvbmU6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIipcIiBhbmQgXCIvXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgxKVxuICAgIGVuZFxuXG4gIHplcm86IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV1dHJhbCBlbGVtZW50IGZvciBcIitcIiBhbmQgXCItXCJcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgwKVxuICAgIGVuZFxuXG4gIGFzY2lpX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgdG9fY2hhcmFjdGVyXzggaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyX2NvZGU6IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzhcbiAgICBlbmRcblxuICBNaW5fdmFsdWU6IE5BVFVSQUxfMzIgPSAwXG4gIE1heF92YWx1ZTogTkFUVVJBTF8zMiA9IDQyOTQ5NjcyOTVcbiAgICAgIC0tIE1pbmltdW0gYW5kIE1heGltdW0gdmFsdWUgaG9sZCBpbiBgaXRlbScuXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIDwgb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QgYW5kIGlkZW50aWNhbCB0byBpdD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG90aGVyLml0ZW0gPSBpdGVtXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfaXRlbSAoaTogTkFUVVJBTF8zMilcbiAgICAgIC0tIE1ha2UgYGknIHRoZSBgaXRlbScgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSBpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGRpdmlzaWJsZSAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBjdXJyZW50IG9iamVjdCBiZSBkaXZpZGVkIGJ5IGBvdGhlcic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBvdGhlci5pdGVtIC89IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgdmFsdWU6IFJlc3VsdCA9IChvdGhlci5pdGVtIC89IDApXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtJTlRFR0VSXzMyX1JFRn0gb3RoZXIgYXMgaW50ZWdlcl92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpbnRlZ2VyX3ZhbHVlLml0ZW0gPj0gMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF8zMl9SRUZ9IG90aGVyIGFzIHJlYWxfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gcmVhbF92YWx1ZS5pdGVtID49IDAuMCBvciBpdGVtIC89IDBcbiAgICAgIGVsc2VpZiBhdHRhY2hlZCB7UkVBTF82NF9SRUZ9IG90aGVyIGFzIGRvdWJsZV92YWx1ZSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBkb3VibGVfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FmZV92YWx1ZXM6ICgob3RoZXIuY29uZm9ybXNfdG8gKDApIGFuZCBpdGVtIC89IDApIG9yXG4gICAgICAgIChvdGhlci5jb25mb3Jtc190byAoMC4wKSBhbmQgaXRlbSA+IDApKSBpbXBsaWVzIFJlc3VsdFxuICAgIGVuZFxuXG4gIGlzX2hhc2hhYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgaGFzaGVkP1xuICAgICAgLS0gKFRydWUgaWYgaXQgaXMgbm90IGl0cyB0eXBlJ3MgZGVmYXVsdC4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC89IDBcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGUnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2NoYXJhY3Rlcl84X2NvZGVcbiAgICBlbmRcblxuICBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGN1cnJlbnQgb2JqZWN0IHJlcHJlc2VudCBhIENIQVJBQ1RFUl84P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSA8PSB7Q0hBUkFDVEVSXzh9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZW5zdXJlXG4gICAgICBpbl9ib3VuZHM6IFJlc3VsdCA9IChcbiAgICAgICAgaXRlbSA+PSB7Q0hBUkFDVEVSXzh9Lk1pbl92YWx1ZS50b19uYXR1cmFsXzMyIGFuZFxuICAgICAgICBpdGVtIDw9IHtDSEFSQUNURVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfMzIpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl8zMn0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgdW5hcHBsaWNhYmxlX29wcG9zaXRlOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5vdF9hcHBsaWNhYmxlOiBGYWxzZVxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLy8gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gXFxcXCBvdGhlci5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBeIG90aGVyXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3JlZmVyZW5jZSAodjogTkFUVVJBTF8zMl9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IHYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBOQVRVUkFMXzMyX1JFRlxuICAgICAgLS0gQXNzb2NpYXRlZCByZWZlcmVuY2Ugb2YgQ3VycmVudFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0pXG4gICAgZW5zdXJlXG4gICAgICB0b19yZWZlcmVuY2Vfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIFRydWUgaWYgbm90IGB6ZXJvJy5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gLz0gMFxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMTZcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF90b29fYmlnOiBpdGVtIDw9IHtOQVRVUkFMXzh9Lk1heF92YWx1ZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7TkFUVVJBTF8xNn0uTWF4X3ZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW1cbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfOH0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X3Rvb19iaWc6IGl0ZW0gPD0ge0lOVEVHRVJfMTZ9Lk1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl8zMn0uTWF4X3ZhbHVlLnRvX25hdHVyYWxfMzJcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX3JlYWxfMzJcbiAgICBlbmRcblxuICB0b19yZWFsXzY0OiBSRUFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF82NFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXzY0XG4gICAgZW5kXG5cbiAgdG9faGV4X3N0cmluZzogU1RSSU5HXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIHN0cmluZy5cbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgICAgYV9kaWdpdCwgdmFsOiBOQVRVUkFMXzMyXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAoY3JlYXRlIHtQTEFURk9STX0pLkludGVnZXJfMzJfYml0cyAvLyA0XG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoaSlcbiAgICAgICAgUmVzdWx0LmZpbGxfYmxhbmtcbiAgICAgICAgdmFsIDo9IGl0ZW1cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAwXG4gICAgICBsb29wXG4gICAgICAgIGFfZGlnaXQgOj0gKHZhbCAmIDB4RilcbiAgICAgICAgUmVzdWx0LnB1dCAoYV9kaWdpdC50b19oZXhfY2hhcmFjdGVyLCBpKVxuICAgICAgICB2YWwgOj0gdmFsIHw+PiA0XG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgUmVzdWx0X3ZhbGlkX2NvdW50OiBSZXN1bHQuY291bnQgPSAoY3JlYXRlIHtQTEFURk9STX0pLkludGVnZXJfMzJfYml0cyAvLyA0XG4gICAgZW5kXG5cbiAgdG9faGV4X2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBpbl9ib3VuZHM6IDAgPD0gaXRlbSBhbmQgaXRlbSA8PSAxNVxuICAgIGxvY2FsXG4gICAgICB0bXA6IElOVEVHRVJcbiAgICBkb1xuICAgICAgdG1wIDo9IGl0ZW0udG9faW50ZWdlcl8zMlxuICAgICAgaWYgdG1wIDw9IDkgdGhlblxuICAgICAgICBSZXN1bHQgOj0gKHRtcCArICgnMCcpLmNvZGUpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSAoKCdBJykuY29kZSArICh0bXAgLSAxMCkpLnRvX2NoYXJhY3Rlcl84XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogKFwiMDEyMzQ1Njc4OUFCQ0RFRlwiKS5oYXMgKFJlc3VsdClcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXI6IENIQVJBQ1RFUlxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGB0b19jaGFyYWN0ZXJfOCcgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIFJldHVybnMgY29ycmVzcG9uZGluZyBDSEFSQUNURVJfMzIgdG8gYGl0ZW0nIHZhbHVlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGVcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fY2hhcmFjdGVyXzMyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQml0IG9wZXJhdGlvbnNcblxuICBiaXRfYW5kIGFsaWFzIFwiJlwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9hbmQgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX2FuZF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfb3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX29yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3hvciAoaS5pdGVtKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdHdpc2VfeG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT25lJ3MgY29tcGxlbWVudCBvZiBDdXJyZW50LlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X25vdClcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9ub3Rfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF9zaGlmdCAobjogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQgaWYgYG4nIHBvc2l0aXZlLFxuICAgICAgLS0gdG8gbGVmdCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzMyOiBuIDw9IDMyXG4gICAgICBuX2dyZWF0ZXJfb3JfZXF1YWxfdG9fbWludXNfMzI6IG4gPj0gLTMyXG4gICAgZG9cbiAgICAgIGlmIG4gPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGJpdF9zaGlmdF9yaWdodCAobikuaXRlbVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X2xlZnQgKC0gbikuaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzMyOiBuIDw9IDMyXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfbGVmdCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfbGVmdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b18zMjogbiA8PSAzMlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X3NoaWZ0X3JpZ2h0IChuKSlcbiAgICBlbnN1cmVcbiAgICAgIGJpdF9zaGlmdF9yaWdodF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gYml0X3Rlc3QgKG46IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBUZXN0IGBuJy10aCBwb3NpdGlvbiBvZiBDdXJyZW50LlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMzI6IG4gPCAzMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAmICgoMSkudG9fbmF0dXJhbF8zMiB8PDwgbikgLz0gMFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0IChiOiBCT09MRUFOOyBuOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fMzI6IG4gPCAzMlxuICAgIGRvXG4gICAgICBpZiBiIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gfCAoKDEpLnRvX25hdHVyYWxfMzIgfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19uYXR1cmFsXzMyIHw8PCBuKS5iaXRfbm90XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdF93aXRoX21hc2sgKGI6IEJPT0xFQU47IG06IE5BVFVSQUxfMzIpOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBhbGwgMSBiaXRzIG9mIG0gc2V0IHRvIDFcbiAgICAgIC0tIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8IG1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiBtLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgaW50ZWdlciB2YWx1ZVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDIwKVxuICAgICAgUmVzdWx0LmFwcGVuZF9uYXR1cmFsXzMyIChpdGVtKVxuICAgIGVuZFxuXG5ub3RlXG4gIGNvcHlyaWdodDogXCJDb3B5cmlnaHQgKGMpIDE5ODQtMjAxNCwgRWlmZmVsIFNvZnR3YXJlIGFuZCBvdGhlcnNcIlxuICBsaWNlbnNlOiAgIFwiRWlmZmVsIEZvcnVtIExpY2Vuc2UgdjIgKHNlZSBodHRwOi8vd3d3LmVpZmZlbC5jb20vbGljZW5zaW5nL2ZvcnVtLnR4dClcIlxuXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiSW50ZWdlciB2YWx1ZXMgY29kZWQgb24gOCBiaXRzXCJcbiAgZXh0ZXJuYWxfbmFtZTogXCJTeXN0ZW0uQnl0ZVwiXG4gIGFzc2VtYmx5OiBcIm1zY29ybGliXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTEwLTMwIDA4OjMyOjQ2IC0wNzAwIChUdWUsIDMwIE9jdCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MjAyMiAkXCJcblxuZnJvemVuIGV4cGFuZGVkIGNsYXNzIE5BVFVSQUxfOCBpbmhlcml0XG5cbiAgTkFUVVJBTF84X1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWxfMzIsXG4gICAgICB0b19yZWFsXzY0LFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuY29udmVydFxuICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7TkFUVVJBTF84X1JFRn0pLFxuICB0b19yZWFsXzMyOiB7UkVBTF8zMn0sXG4gIHRvX3JlYWxfNjQ6IHtSRUFMXzY0fSxcbiAgdG9faW50ZWdlcl8xNjoge0lOVEVHRVJfMTZ9LFxuICB0b19pbnRlZ2VyXzMyOiB7SU5URUdFUl8zMn0sXG4gIHRvX2ludGVnZXJfNjQ6IHtJTlRFR0VSXzY0fSxcbiAgdG9fbmF0dXJhbF8xNjoge05BVFVSQUxfMTZ9LFxuICB0b19uYXR1cmFsXzMyOiB7TkFUVVJBTF8zMn0sXG4gIHRvX25hdHVyYWxfNjQ6IHtOQVRVUkFMXzY0fVxuXG5mZWF0dXJlIC0tIENvbXBhcmlzb25cblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogTkFUVVJBTF84KTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gU3VtIHdpdGggYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBtaW51cyBhbGlhcyBcIi1cIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogTkFUVVJBTF84KTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogTkFUVVJBTF84XG4gICAgICAtLSBVbmFyeSBwbHVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogTkFUVVJBTF84KTogTkFUVVJBTF84XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfMzI6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWxfNjQ6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gQml0d2lzZSBhbmQgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfb3IgYWxpYXMgXCJ8XCIgKGk6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IE5BVFVSQUxfOCk6IE5BVFVSQUxfOFxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBOQVRVUkFMXzhcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byBsZWZ0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5lbmRcbiIsIm5vdGVcbiAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlcyB0byBvYmplY3RzIGNvbnRhaW5pbmcgYW4gaW50ZWdlciB2YWx1ZSBjb2RlZCBvbiA4IGJpdHNcIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDUtMTkgMTQ6MjY6MTQgLTA3MDAgKE1vbiwgMTkgTWF5IDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk1MTE3ICRcIlxuXG5jbGFzc1xuICBOQVRVUkFMXzhfUkVGXG5cbmluaGVyaXRcbiAgTlVNRVJJQ1xuICAgIHJlbmFtZVxuICAgICAgcXVvdGllbnQgYXMgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIsXG4gICAgICBvcHBvc2l0ZSBhcyB1bmFwcGxpY2FibGVfb3Bwb3NpdGVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIENPTVBBUkFCTEVcbiAgICByZWRlZmluZVxuICAgICAgb3V0LCBpc19lcXVhbFxuICAgIGVuZFxuXG4gIEhBU0hBQkxFXG4gICAgcmVkZWZpbmVcbiAgICAgIGlzX2hhc2hhYmxlLCBvdXQsIGlzX2VxdWFsXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbTogTkFUVVJBTF84XG4gICAgICAtLSBJbnRlZ2VyIHZhbHVlXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGhhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgc2lnbjogSU5URUdFUlxuICAgICAgLS0gU2lnbiB2YWx1ZSAoMCwgLTEgb3IgMSlcbiAgICBkb1xuICAgICAgaWYgaXRlbSA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gMVxuICAgICAgZWxzZWlmIGl0ZW0gPCAwIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IC0xXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHRocmVlX3dheTogUmVzdWx0ID0gdGhyZWVfd2F5X2NvbXBhcmlzb24gKHplcm8pXG4gICAgZW5kXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMSlcbiAgICBlbmRcblxuICB6ZXJvOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIrXCIgYW5kIFwiLVwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoMClcbiAgICBlbmRcblxuICBhc2NpaV9jaGFyOiBDSEFSQUNURVJfOFxuICAgICAgLS0gUmV0dXJucyBjb3JyZXNwb25kaW5nIEFTQ0lJIGNoYXJhY3RlciB0byBgaXRlbScgdmFsdWUuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIHRvX2NoYXJhY3Rlcl84IGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXJfY29kZTogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIE1pbl92YWx1ZTogTkFUVVJBTF84ID0gMFxuICBNYXhfdmFsdWU6IE5BVFVSQUxfOCA9IDI1NVxuICAgICAgLS0gTWluaW11bSBhbmQgTWF4aW11bSB2YWx1ZSBob2xkIGluIGBpdGVtJy5cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgaW50ZWdlciBsZXNzIHRoYW4gYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gPCBvdGhlci5pdGVtXG4gICAgZW5kXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAtLSBhcyBjdXJyZW50IG9iamVjdCBhbmQgaWRlbnRpY2FsIHRvIGl0P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSA9IGl0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldF9pdGVtIChpOiBOQVRVUkFMXzgpXG4gICAgICAtLSBNYWtlIGBpJyB0aGUgYGl0ZW0nIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGl0ZW1fc2V0OiBpdGVtID0gaVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIuaXRlbSAvPSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHZhbHVlOiBSZXN1bHQgPSAob3RoZXIuaXRlbSAvPSAwKVxuICAgIGVuZFxuXG4gIGV4cG9uZW50aWFibGUgKG90aGVyOiBOVU1FUklDKTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGVsZXZhdGVkIHRvIHRoZSBwb3dlciBgb3RoZXInP1xuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7SU5URUdFUl8zMl9SRUZ9IG90aGVyIGFzIGludGVnZXJfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaW50ZWdlcl92YWx1ZS5pdGVtID49IDAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfMzJfUkVGfSBvdGhlciBhcyByZWFsX3ZhbHVlIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHJlYWxfdmFsdWUuaXRlbSA+PSAwLjAgb3IgaXRlbSAvPSAwXG4gICAgICBlbHNlaWYgYXR0YWNoZWQge1JFQUxfNjRfUkVGfSBvdGhlciBhcyBkb3VibGVfdmFsdWUgdGhlblxuICAgICAgICBSZXN1bHQgOj0gZG91YmxlX3ZhbHVlLml0ZW0gPj0gMC4wIG9yIGl0ZW0gLz0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhZmVfdmFsdWVzOiAoKG90aGVyLmNvbmZvcm1zX3RvICgwKSBhbmQgaXRlbSAvPSAwKSBvclxuICAgICAgICAob3RoZXIuY29uZm9ybXNfdG8gKDAuMCkgYW5kIGl0ZW0gPiAwKSkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBpc19oYXNoYWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGN1cnJlbnQgb2JqZWN0IGJlIGhhc2hlZD9cbiAgICAgIC0tIChUcnVlIGlmIGl0IGlzIG5vdCBpdHMgdHlwZSdzIGRlZmF1bHQuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzg/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBjdXJyZW50IG9iamVjdCByZXByZXNlbnQgYSBDSEFSQUNURVJfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbnN1cmVcbiAgICAgIGluX2JvdW5kczogUmVzdWx0ID0gKGl0ZW0gPj0ge0NIQVJBQ1RFUl84fS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl84fS5NYXhfdmFsdWUpXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfY2hhcmFjdGVyXzMyX2NvZGU6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgY3VycmVudCBvYmplY3QgcmVwcmVzZW50IGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuc3VyZVxuICAgICAgaW5fYm91bmRzOiBSZXN1bHQgPSAoaXRlbSA+PSB7Q0hBUkFDVEVSXzMyfS5NaW5fdmFsdWUgYW5kIGl0ZW0gPD0ge0NIQVJBQ1RFUl8zMn0uTWF4X3ZhbHVlKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSArIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAtIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSAqIG90aGVyLml0ZW0pXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBSRUFMXzY0XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtIC8gb3RoZXIuaXRlbVxuICAgIGVuZFxuXG4gIGlkZW50aXR5IGFsaWFzIFwiK1wiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtICgrIGl0ZW0pXG4gICAgZW5kXG5cbiAgdW5hcHBsaWNhYmxlX29wcG9zaXRlOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBDdXJyZW50XG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG5vdF9hcHBsaWNhYmxlOiBGYWxzZVxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBJbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gLy8gb3RoZXIuaXRlbSlcbiAgICBlbmRcblxuICBpbnRlZ2VyX3JlbWFpbmRlciBhbGlhcyBcIlxcXFxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgICAgZ29vZF9kaXZpc29yOiBkaXZpc2libGUgKG90aGVyKVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0gXFxcXCBvdGhlci5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSBeIG90aGVyXG4gICAgZW5kXG5cbiAgaW50ZXJ2YWwgYWxpYXMgXCJ8Li58XCIgKG90aGVyOiBJTlRFR0VSKTogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gSW50ZXJ2YWwgZnJvbSBjdXJyZW50IGVsZW1lbnQgdG8gYG90aGVyJ1xuICAgICAgLS0gKGVtcHR5IGlmIGBvdGhlcicgbGVzcyB0aGFuIGN1cnJlbnQgaW50ZWdlcilcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChpdGVtLCBvdGhlcilcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gQ29udmVyc2lvblxuXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHY6IE5BVFVSQUxfOF9SRUYpXG4gICAgICAtLSBJbml0aWFsaXplIGBDdXJyZW50JyB3aXRoIGB2Lml0ZW0nLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm90X3ZvaWQ6IFYgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfaXRlbSAodi5pdGVtKVxuICAgIGVuc3VyZVxuICAgICAgaXRlbV9zZXQ6IGl0ZW0gPSB2Lml0ZW1cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgdG9fcmVmZXJlbmNlOiBOQVRVUkFMXzhfUkVGXG4gICAgICAtLSBBc3NvY2lhdGVkIHJlZmVyZW5jZSBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbSlcbiAgICBlbnN1cmVcbiAgICAgIHRvX3JlZmVyZW5jZV9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gVHJ1ZSBpZiBub3QgYHplcm8nLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbSAvPSAwXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS5hc19uYXR1cmFsXzhcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfMTZcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX25hdHVyYWxfNjRcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLmFzX2ludGVnZXJfOFxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0uYXNfaW50ZWdlcl82NFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzg6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzggdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX25hdHVyYWxfMTY6IE5BVFVSQUxfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8xNiB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX25hdHVyYWxfMTZcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzMyIHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19uYXR1cmFsXzY0OiBOQVRVUkFMXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfNjQgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfODogSU5URUdFUl84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfOCB2YWx1ZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfdG9vX2JpZzogaXRlbSA8PSB7SU5URUdFUl84fS5NYXhfdmFsdWUudG9fbmF0dXJhbF84XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzhcbiAgICBlbmRcblxuICBmcm96ZW4gdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzE2IHZhbHVlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfaW50ZWdlcl8xNlxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19pbnRlZ2VyXzMyOiBJTlRFR0VSXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMzIgdmFsdWUuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19pbnRlZ2VyXzMyXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2ludGVnZXJfNjQ6IElOVEVHRVJfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl82NCB2YWx1ZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX2ludGVnZXJfNjRcbiAgICBlbmRcblxuICB0b19yZWFsXzMyOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19yZWFsXzMyXG4gICAgZW5kXG5cbiAgdG9fcmVhbF82NDogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0udG9fcmVhbF82NFxuICAgIGVuZFxuXG4gIHRvX2hleF9zdHJpbmc6IFNUUklOR1xuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gICAgbG9jYWxcbiAgICAgIGksIHZhbDogSU5URUdFUlxuICAgICAgYV9kaWdpdDogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMlxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGkpXG4gICAgICAgIFJlc3VsdC5maWxsX2JsYW5rXG4gICAgICAgIHZhbCA6PSBpdGVtXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gMFxuICAgICAgbG9vcFxuICAgICAgICBhX2RpZ2l0IDo9ICh2YWwgJiAxNSlcbiAgICAgICAgUmVzdWx0LnB1dCAoYV9kaWdpdC50b19oZXhfY2hhcmFjdGVyLCBpKVxuICAgICAgICB2YWwgOj0gdmFsIHw+PiA0XG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgcmVzdWx0X3ZhbGlkX2NvdW50OiBSZXN1bHQuY291bnQgPSAyXG4gICAgZW5kXG5cbiAgdG9faGV4X2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIGhleGFkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICByZXF1aXJlXG4gICAgICBpbl9ib3VuZHM6IDAgPD0gaXRlbSBhbmQgaXRlbSA8PSAxNVxuICAgIGxvY2FsXG4gICAgICB0bXA6IElOVEVHRVJcbiAgICBkb1xuICAgICAgdG1wIDo9IGl0ZW1cbiAgICAgIFJlc3VsdCA6PSB0bXAudG9faGV4X2NoYXJhY3RlclxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiAoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLmhhcyAoUmVzdWx0KVxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3RlcjogQ0hBUkFDVEVSXG4gICAgICAtLSBSZXR1cm5zIGNvcnJlc3BvbmRpbmcgQVNDSUkgY2hhcmFjdGVyIHRvIGBpdGVtJyB2YWx1ZS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHRvX2NoYXJhY3Rlcl84JyBpbnN0ZWFkLlwiXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY2hhcmFjdGVyOiBpc192YWxpZF9jaGFyYWN0ZXJfOF9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl84XG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NoYXJhY3RlcjogaXNfdmFsaWRfY2hhcmFjdGVyXzhfY29kZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXRlbS50b19jaGFyYWN0ZXJfOFxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl8zMjogQ0hBUkFDVEVSXzMyXG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiAzMiBiaXQgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jaGFyYWN0ZXI6IGlzX3ZhbGlkX2NoYXJhY3Rlcl8zMl9jb2RlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtLnRvX2NoYXJhY3Rlcl8zMlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgaV9ub3Rfdm9pZDogaSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfYW5kIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9hbmRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIHJlcXVpcmVcbiAgICAgIGlfbm90X3ZvaWQ6IGkgLz0gVm9pZFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgICBSZXN1bHQuc2V0X2l0ZW0gKGl0ZW0uYml0X29yIChpLml0ZW0pKVxuICAgIGVuc3VyZVxuICAgICAgYml0d2lzZV9vcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIEJpdHdpc2UgeG9yIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICBpX25vdF92b2lkOiBpIC89IFZvaWRcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF94b3IgKGkuaXRlbSkpXG4gICAgZW5zdXJlXG4gICAgICBiaXR3aXNlX3hvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfbm90OiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9ub3QpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfbm90X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGZyb3plbiBiaXRfc2hpZnQgKG46IElOVEVHRVIpOiBOQVRVUkFMXzhcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gcmlnaHQgaWYgYG4nIHBvc2l0aXZlLFxuICAgICAgLS0gdG8gbGVmdCBvdGhlcndpc2UuXG4gICAgcmVxdWlyZVxuICAgICAgbl9sZXNzX29yX2VxdWFsX3RvXzg6IG4gPD0gOFxuICAgICAgbl9ncmVhdGVyX29yX2VxdWFsX3RvX21pbnVzXzg6IG4gPj0gLThcbiAgICBkb1xuICAgICAgaWYgbiA+IDAgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYml0X3NoaWZ0X3JpZ2h0IChuKS5pdGVtXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiaXRfc2hpZnRfbGVmdCAoLSBuKS5pdGVtXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfbGVmdCBhbGlhcyBcInw8PFwiIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2xlc3Nfb3JfZXF1YWxfdG9fODogbiA8PSA4XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICAgIFJlc3VsdC5zZXRfaXRlbSAoaXRlbS5iaXRfc2hpZnRfbGVmdCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfbGVmdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBiaXRfc2hpZnRfcmlnaHQgYWxpYXMgXCJ8Pj5cIiAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc19vcl9lcXVhbF90b184OiBuIDw9IDhcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdFxuICAgICAgUmVzdWx0LnNldF9pdGVtIChpdGVtLmJpdF9zaGlmdF9yaWdodCAobikpXG4gICAgZW5zdXJlXG4gICAgICBiaXRfc2hpZnRfcmlnaHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgZnJvemVuIGJpdF90ZXN0IChuOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gVGVzdCBgbictdGggcG9zaXRpb24gb2YgQ3VycmVudC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbm5lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fbGVzc190aGFuXzg6IG4gPCA4XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19uYXR1cmFsXzggfDw8IG4pIC89IDBcbiAgICBlbmRcblxuICBmcm96ZW4gc2V0X2JpdCAoYjogQk9PTEVBTjsgbjogSU5URUdFUik6IE5BVFVSQUxfOFxuICAgICAgLS0gQ29weSBvZiBjdXJyZW50IHdpdGggYG4nLXRoIHBvc2l0aW9uXG4gICAgICAtLSBzZXQgdG8gMSBpZiBgYicsIDAgb3RoZXJ3aXNlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9ubmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9sZXNzX3RoYW5fODogbiA8IDhcbiAgICBkb1xuICAgICAgaWYgYiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIHwgKCgxKS50b19uYXR1cmFsXzggfDw8IG4pXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtICYgKCgxKS50b19uYXR1cmFsXzggfDw8IG4pLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGZyb3plbiBzZXRfYml0X3dpdGhfbWFzayAoYjogQk9PTEVBTjsgbTogTkFUVVJBTF84KTogTkFUVVJBTF84XG4gICAgICAtLSBDb3B5IG9mIGN1cnJlbnQgd2l0aCBhbGwgMSBiaXRzIG9mIG0gc2V0IHRvIDFcbiAgICAgIC0tIGlmIGBiJywgMCBvdGhlcndpc2UuXG4gICAgZG9cbiAgICAgIGlmIGIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gaXRlbSB8IG1cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IGl0ZW0gJiBtLmJpdF9ub3RcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIG91dDogU1RSSU5HXG4gICAgICAtLSBQcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgaW50ZWdlciB2YWx1ZVxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDMpXG4gICAgICBSZXN1bHQuYXBwZW5kX25hdHVyYWxfOCAoaXRlbSlcbiAgICBlbmRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuXG5lbmRcbiIsIm5vdGVcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3NcblxuICBOVU1FUklDXG5cbmluaGVyaXRcbiAgREVCVUdfT1VUUFVUXG4gICAgcmVuYW1lXG4gICAgICBkZWJ1Z19vdXRwdXQgYXMgb3V0XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgb25lOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldXRyYWwgZWxlbWVudCBmb3IgXCIqXCIgYW5kIFwiL1wiXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgemVybzogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXV0cmFsIGVsZW1lbnQgZm9yIFwiK1wiIGFuZCBcIi1cIlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBkaXZpc2libGUgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZGl2aWRlZCBieSBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgZXhwb25lbnRpYWJsZSAob3RoZXI6IE5VTUVSSUMpOiBCT09MRUFOXG4gICAgICAtLSBNYXkgY3VycmVudCBvYmplY3QgYmUgZWxldmF0ZWQgdG8gdGhlIHBvd2VyIGBvdGhlcic/XG4gICAgb2Jzb2xldGVcbiAgICAgIFwiWzIwMDhfMDRfMDFdIFdpbGwgYmUgcmVtb3ZlZCBzaW5jZSBub3QgdXNlZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQmFzaWMgb3BlcmF0aW9uc1xuXG4gIHBsdXMgYWxpYXMgXCIrXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcicgKGNvbW11dGF0aXZlKS5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgcmVzdWx0X2V4aXN0czogUmVzdWx0IC89IFZvaWRcbiAgICAgIGNvbW11dGF0aXZlOiBSZXN1bHQgfiAob3RoZXIgKyBDdXJyZW50KVxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBSZXN1bHQgb2Ygc3VidHJhY3RpbmcgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByb2R1Y3QgYnkgYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogbGlrZSBDdXJyZW50KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBEaXZpc2lvbiBieSBgb3RoZXInXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfZXhpc3RzOiBvdGhlciAvPSBWb2lkXG4gICAgICBnb29kX2Rpdmlzb3I6IGRpdmlzaWJsZSAob3RoZXIpXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICByZXN1bHRfZXhpc3RzOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIG9wcG9zaXRlIGFsaWFzIFwiLVwiOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHJlc3VsdF9leGlzdHM6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4tLSAgbmV1dHJhbF9hZGRpdGlvbjogZXF1YWwgKEN1cnJlbnQgKyB6ZXJvLCBDdXJyZW50KTtcbi0tICBzZWxmX3N1YnRyYWN0aW9uOiBlcXVhbCAoQ3VycmVudCAtIEN1cnJlbnQsIHplcm8pO1xuLS0gIG5ldXRyYWxfbXVsdGlwbGljYXRpb246IGVxdWFsIChDdXJyZW50ICogb25lLCBDdXJyZW50KTtcbi0tICBzZWxmX2RpdmlzaW9uOiBkaXZpc2libGUgKEN1cnJlbnQpIGltcGxpZXMgZXF1YWwgKEN1cnJlbnQgLyBDdXJyZW50LCBvbmUpXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJPYmplY3RzIHRoYXQgbWF5IGJlIGNvbXBhcmVkIGFjY29yZGluZyB0byBhIHBhcnRpYWwgb3JkZXIgcmVsYXRpb25cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTItMDUtMjMgMjE6MTM6MTAgLTA3MDAgKFdlZCwgMjMgTWF5IDIwMTIpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkxOTgxICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBQQVJUX0NPTVBBUkFCTEVcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgb2JqZWN0IGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfbGVzc19lcXVhbCBhbGlhcyBcIjw9XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChDdXJyZW50IDwgb3RoZXIpIG9yIChDdXJyZW50IH4gb3RoZXIpXG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlciBhbGlhcyBcIj5cIiAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIGN1cnJlbnQgb2JqZWN0IGdyZWF0ZXIgdGhhbiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX2V4aXN0czogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gb3RoZXIgPCBDdXJyZW50XG4gICAgZW5kXG5cbiAgaXNfZ3JlYXRlcl9lcXVhbCBhbGlhcyBcIj49XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IG9iamVjdCBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChvdGhlciA8IEN1cnJlbnQpIG9yIChDdXJyZW50IH4gb3RoZXIpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJUYWJsZXMgd2hvc2Uga2V5cyBhcmUgaW50ZWdlcnMgaW4gYSBjb250aWd1b3VzIGludGVydmFsXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogaW5kZXhhYmxlLCBhY2Nlc3M7XG4gIGFjY2VzczogaW5kZXgsIG1lbWJlcnNoaXA7XG4gIGNvbnRlbnRzOiBnZW5lcmljO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgUkVBREFCTEVfSU5ERVhBQkxFIFtHXVxuXG5pbmhlcml0XG4gIElURVJBQkxFIFtHXVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiIChpOiBJTlRFR0VSKTogR1xuICAgICAgLS0gRW50cnkgYXQgcG9zaXRpb24gYGknXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgbmV3X2N1cnNvcjogSU5ERVhBQkxFX0lURVJBVElPTl9DVVJTT1IgW0ddXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuc3RhcnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyBhIHZhbGlkIGluZGV4P1xuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBvbmx5X2lmX2luX2luZGV4X3NldDpcbiAgICAgICAgUmVzdWx0IGltcGxpZXMgKChpID49IGluZGV4X3NldC5sb3dlcikgYW5kIChpIDw9IGluZGV4X3NldC51cHBlcikpXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG5cblxuXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xNCAyMjoyMToxOSAtMDcwMCAoV2VkLCAxNCBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUwNjAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR18zMlxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgcmVuYW1lXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGhhcywgaW5kZXhfb2YsIGxhc3RfaW5kZXhfb2YsIG9jY3VycmVuY2VzXG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtDSEFSQUNURVJfMzJdXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuY29udmVydFxuICB0b19jaWw6IHtTWVNURU1fU1RSSU5HfSxcbiAgYXNfcmVhZGFibGVfc3RyaW5nXzg6IHtSRUFEQUJMRV9TVFJJTkdfOH0sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbiArIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGM6IENIQVJBQ1RFUl8zMjsgbjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZSBzdHJpbmcgb2YgbGVuZ3RoIGBuJyBmaWxsZWQgd2l0aCBgYycuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgICAgZmlsbF9jaGFyYWN0ZXIgKGMpXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9zZXQ6IGNvdW50ID0gblxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICAgIGZpbGxlZDogb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGlmIEN1cnJlbnQgLz0gcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZW1wdHkgKGNvdW50ICsgMSlcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCAwLCBjb3VudCArIDEpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vdF9zaGFyZWRfaW1wbGVtZW50YXRpb246IEN1cnJlbnQgLz0gcyBpbXBsaWVzIG5vdCBzaGFyZWRfd2l0aCAocylcbiAgICAgIGluaXRpYWxpemVkOiBzYW1lX3N0cmluZyAocylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbm90X3NoYXJlZF9pbXBsZW1lbnRhdGlvbjogQ3VycmVudCAvPSBzXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYyAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5zZXRfc2hhcmVkX2Zyb21fcG9pbnRlciAoY19zdHJpbmcpXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBjcmVhdGUgYXJlYS5tYWtlX2ZpbGxlZCAoJyUvMDAwLycsIGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3Vic3RyaW5nX2ludG9fY2hhcmFjdGVyXzMyX2FyZWEgKGFyZWEsIDEsIGxfY291bnQpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NfcG9pbnRlciAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBDcmVhdGUgbmV3IGluc3RhbmNlIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX2Zyb21fYycuXCJcbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGRvXG4gICAgICBtYWtlX2Zyb21fYyAoY19zdHJpbmcpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIE51bWVyaWMgY29kZSBvZiBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRHVlIHRvIHBvdGVudGlhbCB0cnVuY2F0aW9uIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHNoYXJlZF93aXRoIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChvdGhlciAvPSBWb2lkKSBhbmQgdGhlbiAoYXJlYSA9IG90aGVyLmFyZWEpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IENIQVJBQ1RFUl8zMjsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGksIG5iLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfbG93ZXJfYXJlYSA6PSBhcmVhX2xvd2VyXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleCAtIDEgKyBsX2xvd2VyX2FyZWFcbiAgICAgICAgICBuYiA6PSBuYiArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIGEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIGEuaXRlbSAoaSkgPSBjXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMVxuICAgICAgICAgICAgLS0gYW5kIHN1YnN0cmFjdCBgYXJlYV9sb3dlcidcbiAgICAgICAgICBSZXN1bHQgOj0gaSArIDEgLSBsX2xvd2VyX2FyZWFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsYXN0X2luZGV4X29mIChjOiBDSEFSQUNURVJfMzI7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJyxcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kIC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCBsX2xvd2VyX2FyZWEgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMS5cbiAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleF9pbl9ib3VuZHMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9wb3MsIGVuZF9wb3MpXG4gICAgZW5kXG5cbiAgc3RyaW5nOiBTVFJJTkdfMzJcbiAgICAgIC0tIE5ldyBTVFJJTkdfMzIgaGF2aW5nIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3RyaW5nX3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN0cmluZ19yZXByZXNlbnRhdGlvbjogU1RSSU5HXzMyXG4gICAgICAtLSBTaW1pbGFyIHRvIGBzdHJpbmcnIGJ1dCBvbmx5IGNyZWF0ZSBhIG5ldyBvYmplY3QgaWYgYEN1cnJlbnQnIGlzIG5vdCBvZiBkeW5hbWljIHR5cGUge1NUUklOR18zMn1cbiAgICBkb1xuICAgICAgaWYgc2FtZV90eXBlIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIHRoZW4gYXR0YWNoZWQge1NUUklOR18zMn0gQ3VycmVudCBhcyBsX3MzMiB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3MzMlxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gc3RyaW5nXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGNvcnJlY3RfdHlwZTogUmVzdWx0LnNhbWVfdHlwZSAoY3JlYXRlIHtTVFJJTkdfMzJ9Lm1ha2VfZW1wdHkpXG4gICAgICBmaXJzdF9pdGVtOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKVxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuc3RyaW5nXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIG90aGVyLCBzdGFydF9pbmRleCwgY291bnQpXG4gICAgZW5kXG5cbiAgZnV6enlfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnQ6IElOVEVHRVI7IGZ1eno6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLmZ1enp5X2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnQsIGNvdW50LCBmdXp6KVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIEFsbG9jYXRlZCBzcGFjZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5jb3VudCAtIDFcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gQWN0dWFsIG51bWJlciBvZiBjaGFyYWN0ZXJzIG1ha2luZyB1cCB0aGUgc3RyaW5nXG5cbiAgb2NjdXJyZW5jZXMgKGM6IENIQVJBQ1RFUl8zMik6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50ICsgaVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiBhLml0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICB6ZXJvX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBSZXN1bHQgPSAwXG4gICAgICByZWN1cnNlX2lmX25vdF9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSAvPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgICByZWN1cnNlX2lmX2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpID0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IDEgKyBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIFJhbmdlIG9mIGFjY2VwdGFibGUgaW5kZXhlc1xuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKDEsIGNvdW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBpbmRleF9zZXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpbmRleF9zZXRfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIGxvY2FsXG4gICAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2hhc2gsIGxfb3RoZXJfaGFzaDogbGlrZSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgIGRvXG4gICAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBMZXQncyBjb21wYXJlIHRoZSBjb250ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBoYXNoX2NvZGUgYXJlIHRoZSBzYW1lIG9yIG5vdCB5ZXQgY29tcHV0ZWQuXG4gICAgICAgICAgbF9oYXNoIDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgICAgIGxfb3RoZXJfaGFzaCA6PSBvdGhlci5pbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBpZiBsX2hhc2ggPSAwIG9yIGVsc2UgbF9vdGhlcl9oYXNoID0gMCBvciBlbHNlIGxfaGFzaCA9IGxfb3RoZXJfaGFzaCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBuYilcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG5cbiAgICBlbmRcblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIG1hZGUgb2Ygc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2UgYXMgYG90aGVyJyByZWdhcmRsZXNzIG9mIGNhc2luZ1xuICAgICAgLS0gKHBvc3NpYmx5IHdpdGggYSBkaWZmZXJlbnQgY2FwYWNpdHkpP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGlmIG5iID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBuYiA9IDAgb3IgZWxzZSBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyLCAxLCBuYiwgMSlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAoQ3VycmVudClcbiAgICAgIGNvbnNpc3RlbnQ6IGF0dGFjaGVkIHtsaWtlIEN1cnJlbnR9IG90aGVyIGFzIGxfb3RoZXIgaW1wbGllcyAoc3RhbmRhcmRfaXNfZXF1YWwgKGxfb3RoZXIpIGltcGxpZXMgUmVzdWx0KVxuICAgICAgdmFsaWRfcmVzdWx0OiBhc19sb3dlciB+IG90aGVyLmFzX2xvd2VyIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBjYXNlbGVzcyBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICBsX2FyZWEsIGxfb3RoZXJfYXJlYTogbGlrZSBhcmVhXG4gICAgICBjMSxjMjogQ0hBUkFDVEVSXzMyXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgaW5kZXhfcG9zIC0gMVxuICAgICAgICAgIGogOj0gb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDFcbiAgICAgICAgICBuYiA6PSBuYiArIGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMxIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICAgIGMyIDo9IGxfb3RoZXJfYXJlYS5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGxfcHJvcC50b19sb3dlciAoYzEpIC89IGxfcHJvcC50b19sb3dlciAoYzIpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbmIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG8gYEN1cnJlbnQnIGFuZCBgb3RoZXInIGhhdmUgc2FtZSBjaGFyYWN0ZXIgc2VxdWVuY2U/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKHN0cmluZyB+IG90aGVyLnN0cmluZylcbiAgICBlbmRcblxuICBzYW1lX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyICsgc3RhcnRfcG9zIC0gMSwgYXJlYV9sb3dlciArIGluZGV4X3BvcyAtIDEsIG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NoYXJhY3RlcnM6IFJlc3VsdCA9IHN1YnN0cmluZyAoaW5kZXhfcG9zLCBpbmRleF9wb3MgKyBlbmRfcG9zIC0gc3RhcnRfcG9zKS5zYW1lX3N0cmluZyAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbGV4aWNvZ3JhcGhpY2FsbHkgbG93ZXIgdGhhbiBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBvdGhlcl9jb3VudDogSU5URUdFUlxuICAgICAgY3VycmVudF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb3RoZXJfY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgICBpZiBvdGhlcl9jb3VudCA9IGN1cnJlbnRfY291bnQgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgb3RoZXJfY291bnQpID4gMFxuICAgICAgICBlbHNlXG4gICAgICAgICAgaWYgY3VycmVudF9jb3VudCA8IG90aGVyX2NvdW50IHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgY3VycmVudF9jb3VudCkgPj0gMFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFJlc3VsdCA6PSBzdHJfc3RyaWN0X2NtcCAob3RoZXIuYXJlYSwgYXJlYSwgb3RoZXIuYXJlYV9sb3dlciwgYXJlYV9sb3dlciwgb3RoZXJfY291bnQpID4gMFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19zdHJpbmdfODogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG5cbiAgaXNfdmFsaWRfYXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBuYiA6PSBjb3VudCArIGlcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYiBvciBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkuY29kZSA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDFcbiAgICAgICAgbiA6PSBhcmVhX2xvd2VyICsgZW5kX2luZGV4IC0gMVxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuIG9yIG5vdCBsX3Byb3AuaXNfc3BhY2UgKGxfYXJlYS5pdGVtIChpKSlcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gaSA+IG5cbiAgICBlbmRcblxuICBoYXMgKGM6IENIQVJBQ1RFUl8zMik6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYiBvciBlbHNlIChsX2FyZWEuaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDwgbmIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzdGFydHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzMyKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICBsX3NfYXJlYSA6PSBzLmFyZWFcbiAgICAgICAgICAgIGogOj0gYXJlYV9sb3dlciArIGlcbiAgICAgICAgICAgIGkgOj0gcy5hcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgbmIgOj0gcy5hcmVhX2xvd2VyXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gbmJcbiAgICAgICAgICBsb29wXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgICBpZiBsX2FyZWEuaXRlbSAoaikgLz0gbF9zX2FyZWEuaXRlbSAoaSkgdGhlblxuICAgICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgICAgaSA6PSBuYiAtLSBKdW1wIG91dCBvZiBsb29wXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IFJlc3VsdCA9IHMuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoMSwgcy5jb3VudCkpXG4gICAgZW5kXG5cbiAgZW5kc193aXRoIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBmaW5pc2ggd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhLCBsX3NfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGogOj0gY291bnRcbiAgICAgICAgaWYgaSA8PSBqIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgICAgbF9zX2FyZWEgOj0gcy5hcmVhXG4gICAgICAgICAgICBqIDo9IGFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBpIDo9IHMuYXJlYV91cHBlciArIDFcbiAgICAgICAgICAgIG5iIDo9IHMuYXJlYV9sb3dlclxuICAgICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICB1bnRpbFxuICAgICAgICAgICAgaSA9IG5iXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgICAgaiA6PSBqIC0gMVxuICAgICAgICAgICAgaWYgbF9hcmVhLml0ZW0gKGopIC89IGxfc19hcmVhLml0ZW0gKGkpIHRoZW5cbiAgICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICAgIGkgOj0gbmIgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKGNvdW50IC0gcy5jb3VudCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICB2YWxpZF9jb2RlICh2OiBOQVRVUkFMXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHYnIGEgdmFsaWQgY29kZSBmb3IgYSBDSEFSQUNURVJfMzI/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID0gNCB0aGVuXG4gICAgICAgICAgLS0gQ2hlY2sgaWYgdGhpcyBpcyBgdHJ1ZV9jb25zdGFudCdcbiAgICAgICAgUmVzdWx0IDo9IGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbCAodHJ1ZV9jb25zdGFudClcbiAgICAgIGVsc2VpZiBuYiA9IDUgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYGZhbHNlX2NvbnN0YW50J1xuICAgICAgICBSZXN1bHQgOj0gaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsIChmYWxzZV9jb25zdGFudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYHR3aW4nLilcbiAgICBsb2NhbFxuICAgICAgb2xkX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb2xkX2FyZWEgOj0gYXJlYVxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgICAtLSBOb3RlOiA8PSBpcyBuZWVkZWQgYXMgYWxsIEVpZmZlbCBzdHJpbmcgc2hvdWxkIGhhdmUgYW5cbiAgICAgICAgICAtLSBleHRyYSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IG51bGwgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmIG9sZF9hcmVhID0gVm9pZCBvciBlbHNlIG9sZF9hcmVhID0gb3RoZXIuYXJlYSBvciBlbHNlIG9sZF9hcmVhLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgICAgIC0tIFByZXZlbnQgY29weWluZyBvZiBsYXJnZSBgYXJlYScgaWYgb25seSBhIGZldyBjaGFyYWN0ZXJzIGFyZSBhY3R1YWxseSB1c2VkLlxuICAgICAgICAgIGFyZWEgOj0gYXJlYS5yZXNpemVkX2FyZWEgKGNvdW50ICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9sZF9hcmVhLmNvcHlfZGF0YSAoYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgICAgYXJlYSA6PSBvbGRfYXJlYVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBuZXdfcmVzdWx0X2NvdW50OiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgICAtLSBzYW1lX2NoYXJhY3RlcnM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYG90aGVyJy5gaXRlbScgKGBpJylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmaWxsX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgY2hhcmFjdGVycyBhbGwgZXF1YWwgdG8gYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NhcDogbGlrZSBjYXBhY2l0eVxuICAgIGRvXG4gICAgICBsX2NhcCA6PSBjYXBhY2l0eVxuICAgICAgaWYgbF9jYXAgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NhcCAtIDEpXG4gICAgICAgIGNvdW50IDo9IGxfY2FwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogY291bnQgPSBjYXBhY2l0eVxuICAgICAgc2FtZV9zaXplOiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgLS0gYWxsX2NoYXI6IEZvciBldmVyeSBgaScgaW4gMS4uYGNhcGFjaXR5JywgYGl0ZW0nIChgaScpID0gYGMnXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICAtLSByZXZlcnNlZDogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY291bnQnLCBgUmVzdWx0Jy5gaXRlbScgKGBpJykgPSBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgb3V0OiBTVFJJTkdcbiAgICAgIC0tIFByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKGNvdW50KVxuICAgICAgUmVzdWx0LmFwcGVuZCAoYXNfc3RyaW5nXzgpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIHNhbWVfaXRlbXM6IHNhbWVfdHlwZSAoXCJcIikgaW1wbGllcyBzYW1lX3N0cmluZ19nZW5lcmFsIChSZXN1bHQpXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgc3RyaW5nX3NlYXJjaGVyOiBTVFJJTkdfMzJfU0VBUkNIRVJcbiAgICAgIC0tIFN0cmluZyBzZWFyY2hlciBzcGVjaWFsaXplZCBmb3IgUkVBREFCTEVfU1RSSU5HXzMyIGluc3RhbmNlc1xuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cl9zdHJpY3RfY21wICh0aGlzLCBvdGhlcjogbGlrZSBhcmVhOyB0aGlzX2luZGV4LCBvdGhlcl9pbmRleCwgbjogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENvbXBhcmUgYG4nIGNoYXJhY3RlcnMgZnJvbSBgdGhpcycgc3RhcnRpbmcgYXQgYHRoaXNfaW5kZXgnIHdpdGhcbiAgICAgIC0tIGBuJyBjaGFyYWN0ZXJzIGZyb20gYW5kIGBvdGhlcicgc3RhcnRpbmcgYXQgYG90aGVyX2luZGV4Jy5cbiAgICAgIC0tIDAgaWYgZXF1YWwsIDwgMCBpZiBgdGhpcycgPCBgb3RoZXInLFxuICAgICAgLS0gPiAwIGlmIGB0aGlzJyA+IGBvdGhlcidcbiAgICByZXF1aXJlXG4gICAgICB0aGlzX25vdF92b2lkOiB0aGlzIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX3ZhbGlkOiBuIDw9ICh0aGlzLnVwcGVyIC0gdGhpc19pbmRleCArIDEpIGFuZCBuIDw9IChvdGhlci51cHBlciAtIG90aGVyX2luZGV4ICsgMSlcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmIsIGxfY3VycmVudF9jb2RlLCBsX290aGVyX2NvZGU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHRoaXNfaW5kZXhcbiAgICAgICAgbmIgOj0gaSArIG5cbiAgICAgICAgaiA6PSBvdGhlcl9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY3VycmVudF9jb2RlIDo9IHRoaXMuaXRlbSAoaSkuY29kZVxuICAgICAgICBsX290aGVyX2NvZGUgOj0gb3RoZXIuaXRlbSAoaikuY29kZVxuICAgICAgICBpZiBsX2N1cnJlbnRfY29kZSAvPSBsX290aGVyX2NvZGUgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBsX2N1cnJlbnRfY29kZSAtIGxfb3RoZXJfY29kZVxuICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdG9fbG93ZXJfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgICAgLS0gd2l0aCB0aGVpciBsb3dlciB2ZXJzaW9uIHdoZW4gYXZhaWxhYmxlLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGk6IElOVEVHRVJcbiAgICAgIGMxLCBjMjogQ0hBUkFDVEVSXzMyXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgbG9vcFxuICAgICAgICBjMSA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGMyIDo9IGxfcHJvcC50b19sb3dlciAoYzEpXG4gICAgICAgICAgLS0gTGV0J3MgYXZvaWQgYSB3cml0ZSBhY2Nlc3MgaWYgbm90IG5lZWRlZC5cbiAgICAgICAgaWYgYzEgLz0gYzIgdGhlblxuICAgICAgICAgIGEucHV0IChjMiwgaSlcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX3VwcGVyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgdXBwZXIgdmVyc2lvbiB3aGVuIGF2YWlsYWJsZS5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgICBjMSwgYzI6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYzEgOj0gYS5pdGVtIChpKVxuICAgICAgICBjMiA6PSBsX3Byb3AudG9fdXBwZXIgKGMxKVxuICAgICAgICAgIC0tIExldCdzIGF2b2lkIGEgd3JpdGUgYWNjZXNzIGlmIG5vdCBuZWVkZWQuXG4gICAgICAgIGlmIGMxIC89IGMyIHRoZW5cbiAgICAgICAgICBhLnB1dCAoYzIsIGkpXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtaXJyb3JfYXJlYSAoYTogbGlrZSBhcmVhOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gTWlycm9yIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIGFfbm90X3ZvaWQ6IGEgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBhLmNvdW50XG4gICAgbG9jYWxcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpIDw9IGpcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZVxuICB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMixcbiAgU1RSSU5HXzhfU0VBUkNIRVIsIFNUUklOR18zMl9TRUFSQ0hFUixcbiAgSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSLFxuICBTVFJJTkdfVE9fSU5URUdFUl9DT05WRVJUT1IsXG4gIFNUUklOR19UT19SRUFMX0NPTlZFUlRPUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzXG5cbiAgYXJlYV9sb3dlcjogSU5URUdFUlxuICAgICAgLS0gTWluaW11bSBpbmRleFxuICAgIGRvXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX2xvd2VyX25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICAgIGFyZWFfbG93ZXJfdmFsaWQ6IFJlc3VsdCA8PSBhcmVhLnVwcGVyXG4gICAgZW5kXG5cbiAgYXJlYV91cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYV9sb3dlciArIGNvdW50IC0gMVxuICAgIGVuc3VyZVxuICAgICAgYXJlYV91cHBlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICAgIGFyZWFfdXBwZXJfaW5fYm91bmQ6IGFyZWFfbG93ZXIgPD0gUmVzdWx0ICsgMVxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgYXJlYV9ub3Rfdm9pZDogYXJlYSAvPSBWb2lkXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wNS0xNCAyMjoyMjowMiAtMDcwMCAoV2VkLCAxNCBNYXkgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTUwNjEgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR184XG5cbmluaGVyaXRcbiAgUkVBREFCTEVfU1RSSU5HX0dFTkVSQUxcbiAgICByZW5hbWVcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwsXG4gICAgICBpdGVtIGFzIGNoYXJhY3Rlcl8zMl9pdGVtLFxuICAgICAgaGFzIGFzIGNoYXJhY3Rlcl8zMl9oYXMsXG4gICAgICBpbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfaW5kZXhfb2YsXG4gICAgICBsYXN0X2luZGV4X29mIGFzIGNoYXJhY3Rlcl8zMl9sYXN0X2luZGV4X29mLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgY2hhcmFjdGVyXzMyX29jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICBlbmRcblxuICBSRUFEQUJMRV9JTkRFWEFCTEUgW0NIQVJBQ1RFUl84XVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgZW5kXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIGFzX3N0cmluZ184OiB7U1RSSU5HXzh9LFxuICBhc19yZWFkYWJsZV9zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzJ9LFxuICBhc19zdHJpbmdfMzI6IHtTVFJJTkdfMzJ9XG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZSAobjogSU5URUdFUilcbiAgICAgIC0tIEFsbG9jYXRlIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgnJS8wMDAvJywgbiArIDEpXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGM6IENIQVJBQ1RFUl84OyBuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlIHN0cmluZyBvZiBsZW5ndGggYG4nIGZpbGxlZCB3aXRoIGBjJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb3VudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgICBmaWxsX2NoYXJhY3RlciAoYylcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3NldDogY291bnQgPSBuXG4gICAgICBhcmVhX2FsbG9jYXRlZDogY2FwYWNpdHkgPj0gblxuICAgICAgZmlsbGVkOiBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIHRoZSBjaGFyYWN0ZXJzIG9mIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBpZiBDdXJyZW50IC89IHMgdGhlblxuICAgICAgICBjcmVhdGUgYXJlYS5tYWtlX2VtcHR5IChjb3VudCArIDEpXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgMCwgY291bnQgKyAxKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBub3Rfc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBDdXJyZW50IC89IHMgaW1wbGllcyBub3Qgc2hhcmVkX3dpdGggKHMpXG4gICAgICBpbml0aWFsaXplZDogc2FtZV9zdHJpbmcgKHMpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gSW5pdGlhbGl6ZSBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvblxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgbF9jb3VudCA6PSBjX3N0cmluZ19wcm92aWRlci5jb3VudFxuICAgICAgY3JlYXRlIGFyZWEubWFrZV9maWxsZWQgKCclLzAwMC8nLCBsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvX2NoYXJhY3Rlcl84X2FyZWEgKGFyZWEsIDEsIGxfY291bnQpXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NfcG9pbnRlciAoY19zdHJpbmc6IFBPSU5URVIpXG4gICAgICAtLSBDcmVhdGUgbmV3IGluc3RhbmNlIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlX2Zyb21fYycgaW5zdGVhZC5cIlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZG9cbiAgICAgIG1ha2VfZnJvbV9jIChjX3N0cmluZylcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IGRldGFjaGFibGUgU1lTVEVNX1NUUklORylcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCB3aXRoIGBhX3N5c3RlbV9zdHJpbmcnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IENIQVJBQ1RFUl84XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRm9yIGNvbnNpc3RlbmN5IHdpdGggVW5pY29kZSBzdHJpbmcgaGFuZGxpbmcsIHVzZSBgY29kZSAoaSknIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIHNoYXJlZF93aXRoIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBzaGFyZSB0aGUgdGV4dCBvZiBgb3RoZXInP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKG90aGVyIC89IFZvaWQpIGFuZCB0aGVuIChhcmVhID0gb3RoZXIuYXJlYSlcbiAgICBlbmRcblxuICBpbmRleF9vZiAoYzogQ0hBUkFDVEVSXzg7IHN0YXJ0X2luZGV4OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycgYXQgb3IgYWZ0ZXIgYHN0YXJ0X2luZGV4JztcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnRfaW5kZXggPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgaSwgbmIsIGxfbG93ZXJfYXJlYTogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgc3RhcnRfaW5kZXggPD0gbmIgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9sb3dlcl9hcmVhIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4IC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICAgIG5iIDo9IG5iICsgbF9sb3dlcl9hcmVhXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iIG9yIGVsc2UgYS5pdGVtIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBhZGQgKzEgZHVlIHRvIHRoZSBhcmVhIHN0YXJ0aW5nIGF0IDAgYW5kIG5vdCBhdCAxXG4gICAgICAgICAgICAtLSBhbmQgc3Vic3RyYWN0IGBhcmVhX2xvd2VyJ1xuICAgICAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIChzdGFydF9pbmRleCA8PSBSZXN1bHQgYW5kIFJlc3VsdCA8PSBjb3VudClcbiAgICAgIHplcm9faWZfYWJzZW50OiAoUmVzdWx0ID0gMCkgPSBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXMgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYmVmb3JlOiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBSZXN1bHQgLSAxKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZiAoYzogQ0hBUkFDVEVSXzg7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJyxcbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBpLCBsX2xvd2VyX2FyZWE6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBsX2xvd2VyX2FyZWEgOj0gYXJlYV9sb3dlclxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4X2Zyb21fZW5kIC0gMSArIGxfbG93ZXJfYXJlYVxuICAgICAgICBhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCBsX2xvd2VyX2FyZWEgb3IgZWxzZSBhLml0ZW0gKGkpID0gY1xuICAgICAgbG9vcFxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICAgICAgLS0gV2UgYWRkICsxIGR1ZSB0byB0aGUgYXJlYSBzdGFydGluZyBhdCAwIGFuZCBub3QgYXQgMS5cbiAgICAgIFJlc3VsdCA6PSBpICsgMSAtIGxfbG93ZXJfYXJlYVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9hZnRlcjogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgc3Vic3RyaW5nX2luZGV4X2luX2JvdW5kcyAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICBlbmRcblxuICBzdHJpbmc6IFNUUklOR184XG4gICAgICAtLSBOZXcgU1RSSU5HXzggaGF2aW5nIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBDdXJyZW50Jy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlX2Zyb21fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgc3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3RyaW5nX3R5cGU6IFJlc3VsdC5zYW1lX3R5cGUgKGNyZWF0ZSB7U1RSSU5HXzh9Lm1ha2VfZW1wdHkpXG4gICAgICBmaXJzdF9pdGVtOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKVxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuc3RyaW5nXG4gICAgZW5kXG5cbiAgc3RyaW5nX3JlcHJlc2VudGF0aW9uOiBTVFJJTkdfOFxuICAgICAgLS0gU2ltaWxhciB0byBgc3RyaW5nJyBidXQgb25seSBjcmVhdGUgYSBuZXcgb2JqZWN0IGlmIGBDdXJyZW50JyBpcyBub3Qgb2YgZHluYW1pYyB0eXBlIHtTVFJJTkdfOH1cbiAgICBkb1xuICAgICAgaWYgc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KSBhbmQgdGhlbiBhdHRhY2hlZCB7U1RSSU5HXzh9IEN1cnJlbnQgYXMgbF9zOCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3M4XG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdHJpbmdcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgY29ycmVjdF90eXBlOiBSZXN1bHQuc2FtZV90eXBlIChjcmVhdGUge1NUUklOR184fS5tYWtlX2VtcHR5KVxuICAgICAgZmlyc3RfaXRlbTogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSlcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLnN0cmluZ1xuICAgIGVuZFxuXG4gIHN1YnN0cmluZ19pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBzdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCBvdGhlciwgc3RhcnRfaW5kZXgsIGNvdW50KVxuICAgIGVuZFxuXG4gIGZ1enp5X2luZGV4IChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0OiBJTlRFR0VSOyBmdXp6OiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHN0cmluZ19zZWFyY2hlci5mdXp6eV9pbmRleCAoQ3VycmVudCwgb3RoZXIsIHN0YXJ0LCBjb3VudCwgZnV6eilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBBbGxvY2F0ZWQgc3BhY2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuY291bnQgLSAxXG4gICAgZW5kXG5cbiAgY291bnQ6IElOVEVHRVJcbiAgICAgIC0tIEFjdHVhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBtYWtpbmcgdXAgdGhlIHN0cmluZ1xuXG4gIG9jY3VycmVuY2VzIChjOiBDSEFSQUNURVJfOCk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiB0aW1lcyBgYycgYXBwZWFycyBpbiB0aGUgc3RyaW5nXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IGFyZWFfbG93ZXJcbiAgICAgICAgbmIgOj0gY291bnQgKyBpXG4gICAgICAgIGEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIGEuaXRlbSAoaSkgPSBjIHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHplcm9faWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIFJlc3VsdCA9IDBcbiAgICAgIHJlY3Vyc2VfaWZfbm90X2ZvdW5kX2F0X2ZpcnN0X3Bvc2l0aW9uOlxuICAgICAgICAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5vY2N1cnJlbmNlcyAoYylcbiAgICAgIHJlY3Vyc2VfaWZfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjKSBpbXBsaWVzXG4gICAgICAgICAgUmVzdWx0ID0gMSArIHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgIGVuZFxuXG4gIGluZGV4X3NldDogSU5URUdFUl9JTlRFUlZBTFxuICAgICAgLS0gUmFuZ2Ugb2YgYWNjZXB0YWJsZSBpbmRleGVzXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoMSwgY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGluZGV4X3NldF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGluZGV4X3NldF9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgICBsX2hhc2gsIGxfb3RoZXJfaGFzaDogbGlrZSBpbnRlcm5hbF9oYXNoX2NvZGVcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgICAtLSBMZXQncyBjb21wYXJlIHRoZSBjb250ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBoYXNoX2NvZGUgYXJlIHRoZSBzYW1lIG9yIG5vdCB5ZXQgY29tcHV0ZWQuXG4gICAgICAgICAgbF9oYXNoIDo9IGludGVybmFsX2hhc2hfY29kZVxuICAgICAgICAgIGxfb3RoZXJfaGFzaCA6PSBvdGhlci5pbnRlcm5hbF9oYXNoX2NvZGVcbiAgICAgICAgICBpZiBsX2hhc2ggPSAwIG9yIGVsc2UgbF9vdGhlcl9oYXNoID0gMCBvciBlbHNlIGxfaGFzaCA9IGxfb3RoZXJfaGFzaCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCBvdGhlci5hcmVhX2xvd2VyLCBhcmVhX2xvd2VyLCBuYilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJpbmcgbWFkZSBvZiBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZSBhcyBgb3RoZXInIHJlZ2FyZGxlc3Mgb2YgY2FzaW5nXG4gICAgICAtLSAocG9zc2libHkgd2l0aCBhIGRpZmZlcmVudCBjYXBhY2l0eSk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChDdXJyZW50KVxuICAgICAgY29uc2lzdGVudDogYXR0YWNoZWQge2xpa2UgQ3VycmVudH0gb3RoZXIgYXMgbF9vdGhlciBpbXBsaWVzIChzdGFuZGFyZF9pc19lcXVhbCAobF9vdGhlcikgaW1wbGllcyBSZXN1bHQpXG4gICAgICB2YWxpZF9yZXN1bHQ6IGFzX2xvd2VyIH4gb3RoZXIuYXNfbG93ZXIgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9vdGhlcl9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGMxLGMyOiBDSEFSQUNURVJcbiAgICBkb1xuICAgICAgbmIgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGlmIG5iIDw9IGNvdW50IC0gaW5kZXhfcG9zICsgMSB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfb3RoZXJfYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICBpIDo9IGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxXG4gICAgICAgICAgaiA6PSBvdGhlci5hcmVhX2xvd2VyICsgc3RhcnRfcG9zIC0gMVxuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgYzEgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgICAgYzIgOj0gbF9vdGhlcl9hcmVhLml0ZW0gKGopXG4gICAgICAgICAgaWYgYzEgLz0gYzIgYW5kIHRoZW4gYzEuYXNfbG93ZXIgLz0gYzIuYXNfbG93ZXIgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgICAgICAgICBpIDo9IG5iIC0gMSAtLSBKdW1wIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpbmNyZWFzaW5nX2luZGV4OiBsX2FyZWEudXBwZXIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIHNhbWVfc3RyaW5nIChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEbyBgQ3VycmVudCcgYW5kIGBvdGhlcicgaGF2ZSBzYW1lIGNoYXJhY3RlciBzZXF1ZW5jZT9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoc3RyaW5nIH4gb3RoZXIuc3RyaW5nKVxuICAgIGVuZFxuXG4gIHNhbWVfY2hhcmFjdGVycyAob3RoZXI6IFJFQURBQkxFX1NUUklOR184OyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicgd2l0aGluIGJvdW5kcyBgc3RhcnRfcG9zJyBhbmQgYGVuZF9wb3MnXG4gICAgICAtLSBpZGVudGljYWwgdG8gY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZyBzdGFydGluZyBhdCBpbmRleCBgaW5kZXhfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoc3RhcnRfcG9zKVxuICAgICAgdmFsaWRfZW5kX3Bvczogb3RoZXIudmFsaWRfaW5kZXggKGVuZF9wb3MpXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiB2YWxpZF9pbmRleCAoaW5kZXhfcG9zKVxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGFyZWEuc2FtZV9pdGVtcyAob3RoZXIuYXJlYSwgb3RoZXIuYXJlYV9sb3dlciArIHN0YXJ0X3BvcyAtIDEsIGFyZWFfbG93ZXIgKyBpbmRleF9wb3MgLSAxLCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3Bvcykuc2FtZV9zdHJpbmcgKG90aGVyLnN1YnN0cmluZyAoc3RhcnRfcG9zLCBlbmRfcG9zKSlcbiAgICBlbmRcblxuICBpc19sZXNzIGFsaWFzIFwiPFwiIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3RyaW5nIGxleGljb2dyYXBoaWNhbGx5IGxvd2VyIHRoYW4gYG90aGVyJz9cbiAgICBsb2NhbFxuICAgICAgb3RoZXJfY291bnQ6IElOVEVHRVJcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIG90aGVyX2NvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgICAgaWYgb3RoZXJfY291bnQgPSBjdXJyZW50X2NvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIGN1cnJlbnRfY291bnQgPCBvdGhlcl9jb3VudCB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIGN1cnJlbnRfY291bnQpID49IDBcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBSZXN1bHQgOj0gc3RyX3N0cmljdF9jbXAgKG90aGVyLmFyZWEsIGFyZWEsIG90aGVyLmFyZWFfbG93ZXIsIGFyZWFfbG93ZXIsIG90aGVyX2NvdW50KSA+IDBcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3N0cmluZ18zMjogQk9PTEVBTiA9IEZhbHNlXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuXG4gIGlzX3ZhbGlkX2FzX3N0cmluZ184OiBCT09MRUFOID0gVHJ1ZVxuICAgICAgLS0gPFByZWN1cnNvcj5cblxuICBpc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIGksIG46IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICAgIG4gOj0gYXJlYV9sb3dlciArIGVuZF9pbmRleCAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuIG9yIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gaSA+IG5cbiAgICBlbmRcblxuICBoYXMgKGM6IENIQVJBQ1RFUl84KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgaW5jbHVkZSBgYyc/XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iIG9yIGVsc2UgKGxfYXJlYS5pdGVtIChpKSA9IGMpXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gKGkgPCBuYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmFsc2VfaWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIG5vdCBSZXN1bHRcbiAgICAgIHRydWVfaWZfZmlyc3Q6IGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzIChjKSlcbiAgICBlbmRcblxuICBzdGFydHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HXzgpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBiZWdpbiB3aXRoIGBzJz9cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfc19hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgQ3VycmVudCA9IHMgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBpIDo9IHMuY291bnRcbiAgICAgICAgaWYgaSA8PSBjb3VudCB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX2xvd2VyICsgaVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBzLmNvdW50KSlcbiAgICBlbmRcblxuICBlbmRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR184KTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgZmluaXNoIHdpdGggYHMnP1xuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYSwgbF9zX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBDdXJyZW50ID0gcyB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlXG4gICAgICAgIGkgOj0gcy5jb3VudFxuICAgICAgICBqIDo9IGNvdW50XG4gICAgICAgIGlmIGkgPD0gaiB0aGVuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICAgIGxfc19hcmVhIDo9IHMuYXJlYVxuICAgICAgICAgICAgaiA6PSBhcmVhX3VwcGVyICsgMVxuICAgICAgICAgICAgaSA6PSBzLmFyZWFfdXBwZXIgKyAxXG4gICAgICAgICAgICBuYiA6PSBzLmFyZWFfbG93ZXJcbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSBuYlxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGogOj0gaiAtIDFcbiAgICAgICAgICAgIGlmIGxfYXJlYS5pdGVtIChqKSAvPSBsX3NfYXJlYS5pdGVtIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IG5iIC0tIEp1bXAgb3V0IG9mIGxvb3BcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gcy5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChjb3VudCAtIHMuY291bnQgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgdmFsaWRfY29kZSAodjogTkFUVVJBTF8zMik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGB2JyBhIHZhbGlkIGNvZGUgZm9yIGEgQ0hBUkFDVEVSXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdiA8PSB7Q0hBUkFDVEVSXzh9Lm1heF92YWx1ZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuYiA9IDQgdGhlblxuICAgICAgICAgIC0tIENoZWNrIGlmIHRoaXMgaXMgYHRydWVfY29uc3RhbnQnXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGkgOj0gYXJlYV9sb3dlclxuICAgICAgICBSZXN1bHQgOj0gbF9hcmVhLml0ZW0gKGkpLmxvd2VyID0gJ3QnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAxKS5sb3dlciA9ICdyJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMikubG93ZXIgPSAndScgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDMpLmxvd2VyID0gJ2UnXG4gICAgICBlbHNlaWYgbmIgPSA1IHRoZW5cbiAgICAgICAgICAtLSBDaGVjayBpZiB0aGlzIGlzIGBmYWxzZV9jb25zdGFudCdcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgaSA6PSBhcmVhX2xvd2VyXG4gICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkubG93ZXIgPSAnZicgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDEpLmxvd2VyID0gJ2EnIGFuZCB0aGVuXG4gICAgICAgICAgbF9hcmVhLml0ZW0gKGkgKyAyKS5sb3dlciA9ICdsJyBhbmQgdGhlblxuICAgICAgICAgIGxfYXJlYS5pdGVtIChpICsgMykubG93ZXIgPSAncycgYW5kIHRoZW5cbiAgICAgICAgICBsX2FyZWEuaXRlbSAoaSArIDQpLmxvd2VyID0gJ2UnXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HXzh9IC0tIER1cGxpY2F0aW9uXG5cbiAgY29weSAob3RoZXI6IGxpa2UgQ3VycmVudClcbiAgICAgIC0tIFJlaW5pdGlhbGl6ZSBieSBjb3B5aW5nIHRoZSBjaGFyYWN0ZXJzIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYHR3aW4nLilcbiAgICBsb2NhbFxuICAgICAgb2xkX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBvdGhlciAvPSBDdXJyZW50IHRoZW5cbiAgICAgICAgb2xkX2FyZWEgOj0gYXJlYVxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgICAtLSBOb3RlOiA8PSBpcyBuZWVkZWQgYXMgYWxsIEVpZmZlbCBzdHJpbmcgc2hvdWxkIGhhdmUgYW5cbiAgICAgICAgICAtLSBleHRyYSBjaGFyYWN0ZXIgdG8gaW5zZXJ0IG51bGwgY2hhcmFjdGVyIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmIG9sZF9hcmVhID0gVm9pZCBvciBlbHNlIG9sZF9hcmVhID0gb3RoZXIuYXJlYSBvciBlbHNlIG9sZF9hcmVhLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgICAgIC0tIFByZXZlbnQgY29weWluZyBvZiBsYXJnZSBgYXJlYScgaWYgb25seSBhIGZldyBjaGFyYWN0ZXJzIGFyZSBhY3R1YWxseSB1c2VkLlxuICAgICAgICAgIGFyZWEgOj0gYXJlYS5yZXNpemVkX2FyZWEgKGNvdW50ICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG9sZF9hcmVhLmNvcHlfZGF0YSAoYXJlYSwgMCwgMCwgY291bnQpXG4gICAgICAgICAgYXJlYSA6PSBvbGRfYXJlYVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBuZXdfcmVzdWx0X2NvdW50OiBjb3VudCA9IG90aGVyLmNvdW50XG4gICAgICAtLSBzYW1lX2NoYXJhY3RlcnM6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gYG90aGVyJy5gaXRlbScgKGBpJylcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBmaWxsX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBGaWxsIHdpdGggYGNhcGFjaXR5JyBjaGFyYWN0ZXJzIGFsbCBlcXVhbCB0byBgYycuXG4gICAgbG9jYWxcbiAgICAgIGxfY2FwOiBsaWtlIGNhcGFjaXR5XG4gICAgZG9cbiAgICAgIGxfY2FwIDo9IGNhcGFjaXR5XG4gICAgICBpZiBsX2NhcCAvPSAwIHRoZW5cbiAgICAgICAgYXJlYS5maWxsX3dpdGggKGMsIDAsIGxfY2FwIC0gMSlcbiAgICAgICAgY291bnQgOj0gbF9jYXBcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZmlsbGVkOiBjb3VudCA9IGNhcGFjaXR5XG4gICAgICBzYW1lX3NpemU6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICAtLSBhbGxfY2hhcjogRm9yIGV2ZXJ5IGBpJyBpbiAxLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgYydcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBSZXN1bHQnLmBpdGVtJyAoYGknKSA9IGBpdGVtJyAoYGNvdW50JysxLWBpJylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBPdXRwdXRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gUHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAoY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBvdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzYW1lX2l0ZW1zOiBzYW1lX3R5cGUgKFwiXCIpIGltcGxpZXMgUmVzdWx0LnNhbWVfc3RyaW5nIChDdXJyZW50KVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIHN0cmluZ19zZWFyY2hlcjogU1RSSU5HXzhfU0VBUkNIRVJcbiAgICAgIC0tIFN0cmluZyBzZWFyY2hlciBzcGVjaWFsaXplZCBmb3IgUkVBREFCTEVfU1RSSU5HXzggaW5zdGFuY2VzXG4gICAgb25jZVxuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlXG4gICAgZW5kXG5cbiAgc3RyX3N0cmljdF9jbXAgKHRoaXMsIG90aGVyOiBsaWtlIGFyZWE7IHRoaXNfaW5kZXgsIG90aGVyX2luZGV4LCBuOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQ29tcGFyZSBgbicgY2hhcmFjdGVycyBmcm9tIGB0aGlzJyBzdGFydGluZyBhdCBgdGhpc19pbmRleCcgd2l0aFxuICAgICAgLS0gYG4nIGNoYXJhY3RlcnMgZnJvbSBhbmQgYG90aGVyJyBzdGFydGluZyBhdCBgb3RoZXJfaW5kZXgnLlxuICAgICAgLS0gMCBpZiBlcXVhbCwgPCAwIGlmIGB0aGlzJyA8IGBvdGhlcicsXG4gICAgICAtLSA+IDAgaWYgYHRoaXMnID4gYG90aGVyJ1xuICAgIHJlcXVpcmVcbiAgICAgIHRoaXNfbm90X3ZvaWQ6IHRoaXMgLz0gVm9pZFxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5fdmFsaWQ6IG4gPD0gKHRoaXMudXBwZXIgLSB0aGlzX2luZGV4ICsgMSkgYW5kIG4gPD0gKG90aGVyLnVwcGVyIC0gb3RoZXJfaW5kZXggKyAxKVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYiwgbF9jdXJyZW50X2NvZGUsIGxfb3RoZXJfY29kZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gdGhpc19pbmRleFxuICAgICAgICBuYiA6PSBpICsgblxuICAgICAgICBqIDo9IG90aGVyX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgbF9jdXJyZW50X2NvZGUgOj0gdGhpcy5pdGVtIChpKS5jb2RlXG4gICAgICAgIGxfb3RoZXJfY29kZSA6PSBvdGhlci5pdGVtIChqKS5jb2RlXG4gICAgICAgIGlmIGxfY3VycmVudF9jb2RlIC89IGxfb3RoZXJfY29kZSB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IGxfY3VycmVudF9jb2RlIC0gbF9vdGhlcl9jb2RlXG4gICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlcl9hcmVhIChhOiBsaWtlIGFyZWE7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjaGFyYWN0ZXJzIGluIGBhJyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgICAtLSB3aXRoIHRoZWlyIGxvd2VyIHZlcnNpb24uXG4gICAgcmVxdWlyZVxuICAgICAgYV9ub3Rfdm9pZDogYSAvPSBWb2lkXG4gICAgICBzdGFydF9pbmRleF9ub25fbmVnYXRpdmU6IHN0YXJ0X2luZGV4ID49IDBcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGEuY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgIGxvb3BcbiAgICAgICAgYS5wdXQgKGEuaXRlbSAoaSkubG93ZXIsIGkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX3VwcGVyX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGNoYXJhY3RlcnMgaW4gYGEnIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICAgIC0tIHdpdGggdGhlaXIgdXBwZXIgdmVyc2lvbi5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgbG9vcFxuICAgICAgICBhLnB1dCAoYS5pdGVtIChpKS51cHBlciwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yX2FyZWEgKGE6IGxpa2UgYXJlYTsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIE1pcnJvciBhbGwgY2hhcmFjdGVycyBpbiBgYScgYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4Jy5cbiAgICByZXF1aXJlXG4gICAgICBhX25vdF92b2lkOiBhIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgYS5jb3VudFxuICAgIGxvY2FsXG4gICAgICBjOiBDSEFSQUNURVJfOFxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpIDw9IGpcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBhLml0ZW0gKGkpXG4gICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZVxuICB7UkVBREFCTEVfU1RSSU5HXzgsIFJFQURBQkxFX1NUUklOR18zMixcbiAgU1RSSU5HXzhfU0VBUkNIRVIsIFNUUklOR18zMl9TRUFSQ0hFUixcbiAgSEVYQURFQ0lNQUxfU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVEVSLFxuICBTVFJJTkdfVE9fSU5URUdFUl9DT05WRVJUT1IsXG4gIFNUUklOR19UT19SRUFMX0NPTlZFUlRPUn0gLS0gSW1wbGVtZW50YXRpb25cblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnNcblxuICBhcmVhX2xvd2VyOiBJTlRFR0VSXG4gICAgICAtLSBNaW5pbXVtIGluZGV4XG4gICAgZG9cbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfbG93ZXJfbm9uX25lZ2F0aXZlOiBSZXN1bHQgPj0gMFxuICAgICAgYXJlYV9sb3dlcl92YWxpZDogUmVzdWx0IDw9IGFyZWEudXBwZXJcbiAgICBlbmRcblxuICBhcmVhX3VwcGVyOiBJTlRFR0VSXG4gICAgICAtLSBNYXhpbXVtIGluZGV4XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhX2xvd2VyICsgY291bnQgLSAxXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX3VwcGVyX3ZhbGlkOiBSZXN1bHQgPD0gYXJlYS51cHBlclxuICAgICAgYXJlYV91cHBlcl9pbl9ib3VuZDogYXJlYV9sb3dlciA8PSBSZXN1bHQgKyAxXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBhcmVhX25vdF92b2lkOiBhcmVhIC89IFZvaWRcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGRlc2NyaXB0aW9uOiBcIkNvbW1vbiBhbmNlc3RvcnMgdG8gYWxsIFNUUklORyBjbGFzc2VzLiBSZWFkLW9ubHkgaW50ZXJmYWNlLlwiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxNC0wMy0xOSAwNjoyNzowMSAtMDcwMCAoV2VkLCAxOSBNYXIgMjAxNCkgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTQ2MzAgJFwiXG5cbmRlZmVycmVkIGNsYXNzXG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG5cbmluaGVyaXRcbiAgQ09NUEFSQUJMRVxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICBlbmRcblxuICBIQVNIQUJMRVxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuICBTVFJJTkdfSEFORExFUlxuICAgIGV4cG9ydFxuICAgICAge1JFQURBQkxFX1NUUklOR19HRU5FUkFMfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICB1bmRlZmluZVxuICAgICAgaXNfZXF1YWxcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlIChuOiBJTlRFR0VSKVxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9zaXplOiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nOiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbiAgbWFrZV9lbXB0eVxuICAgICAgLS0gQ3JlYXRlIGVtcHR5IHN0cmluZy5cbiAgICBkb1xuICAgICAgbWFrZSAoMClcbiAgICBlbnN1cmVcbiAgICAgIGVtcHR5OiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSAwXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvZGUgYXQgcG9zaXRpb24gYGknXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKGM6IGxpa2UgaXRlbTsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBQb3NpdGlvbiBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJyBhdCBvciBhZnRlciBgc3RhcnRfaW5kZXgnO1xuICAgICAgLS0gMCBpZiBub25lLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X2xhcmdlX2Vub3VnaDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgc3RhcnRfc21hbGxfZW5vdWdoOiBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIHN0YXJ0X2luZGV4IDw9IG5iIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSBpdGVtIChpKSA9IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGkgPD0gbmIgdGhlblxuICAgICAgICAgIFJlc3VsdCA6PSBpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9yZXN1bHQ6IFJlc3VsdCA9IDAgb3IgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50KVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9IG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzIChjKVxuICAgICAgZm91bmRfaWZfcHJlc2VudDogc3Vic3RyaW5nIChzdGFydF9pbmRleCwgY291bnQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9iZWZvcmU6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXMgKGMpIGltcGxpZXNcbiAgICAgICAgbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIFJlc3VsdCAtIDEpLmhhcyAoYylcbiAgICBlbmRcblxuICBsYXN0X2luZGV4X29mIChjOiBsaWtlIGl0ZW07IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfaW5kZXhfZnJvbV9lbmRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2UgaXRlbSAoUmVzdWx0KSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhcyAoYykgaW1wbGllcyBpdGVtIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9hZnRlcjogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXMgKGMpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2ZfY29kZSAoYzogbGlrZSBjb2RlOyBzdGFydF9pbmRleDogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnIGF0IG9yIGFmdGVyIGBzdGFydF9pbmRleCc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfbGFyZ2VfZW5vdWdoOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBzdGFydF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4IDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgc3RhcnRfaW5kZXggPD0gbmIgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBlbHNlIGNvZGUgKGkpID0gY1xuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgaSA8PSBuYiB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IGlcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX3Jlc3VsdDogUmVzdWx0ID0gMCBvciAoc3RhcnRfaW5kZXggPD0gUmVzdWx0IGFuZCBSZXN1bHQgPD0gY291bnQpXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYylcbiAgICAgIGZvdW5kX2lmX3ByZXNlbnQ6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYykgaW1wbGllcyBjb2RlIChSZXN1bHQpID0gY1xuICAgICAgbm9uZV9iZWZvcmU6IHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGNvdW50KS5oYXNfY29kZSAoYykgaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0IC0gMSkuaGFzX2NvZGUgKGMpXG4gICAgZW5kXG5cbiAgbGFzdF9pbmRleF9vZl9jb2RlIChjOiBsaWtlIGNvZGU7IHN0YXJ0X2luZGV4X2Zyb21fZW5kOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gUG9zaXRpb24gb2YgbGFzdCBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIC0tIDAgaWYgbm9uZS5cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9zbWFsbF9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kIDw9IGNvdW50XG4gICAgICBzdGFydF9pbmRleF9sYXJnZV9lbm91Z2g6IHN0YXJ0X2luZGV4X2Zyb21fZW5kID49IDFcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBSZXN1bHQgOj0gc3RhcnRfaW5kZXhfZnJvbV9lbmRcbiAgICAgIHVudGlsXG4gICAgICAgIFJlc3VsdCA8PSAwIG9yIGVsc2UgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCAtIDFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiAwIDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IHN0YXJ0X2luZGV4X2Zyb21fZW5kXG4gICAgICB6ZXJvX2lmX2Fic2VudDogKFJlc3VsdCA9IDApID0gbm90IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKVxuICAgICAgZm91bmRfaWZfcHJlc2VudDogc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleF9mcm9tX2VuZCkuaGFzX2NvZGUgKGMpIGltcGxpZXMgY29kZSAoUmVzdWx0KSA9IGNcbiAgICAgIG5vbmVfYWZ0ZXI6IHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXhfZnJvbV9lbmQpLmhhc19jb2RlIChjKSBpbXBsaWVzXG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKFJlc3VsdCArIDEsIHN0YXJ0X2luZGV4X2Zyb21fZW5kKS5oYXNfY29kZSAoYylcbiAgICBlbmRcblxuICBmYWxzZV9jb25zdGFudDogU1RSSU5HXzggPSBcImZhbHNlXCJcbiAgICAgIC0tIENvbnN0YW50IHN0cmluZyBcImZhbHNlXCJcblxuICB0cnVlX2NvbnN0YW50OiBTVFJJTkdfOCA9IFwidHJ1ZVwiXG4gICAgICAtLSBDb25zdGFudCBzdHJpbmcgXCJ0cnVlXCJcblxuICBoYXNoX2NvZGU6IElOVEVHRVJcbiAgICAgIC0tIEhhc2ggY29kZSB2YWx1ZVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfaGFzaF9jb2RlXG4gICAgICBpZiBSZXN1bHQgPSAwIHRoZW5cbiAgICAgICAgICAtLSBUaGUgbWFnaWMgbnVtYmVyIGA4Mzg4NTkzJyBiZWxvdyBpcyB0aGUgZ3JlYXRlc3QgcHJpbWUgbG93ZXIgdGhhblxuICAgICAgICAgIC0tIDJeMjMgc28gdGhhdCB0aGlzIG1hZ2ljIG51bWJlciBzaGlmdGVkIHRvIHRoZSBsZWZ0IGRvZXMgbm90IGV4Y2VlZCAyXjMxLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSAoKFJlc3VsdCBcXFxcIDgzODg1OTMpIHw8PCA4KSArIGl0ZW0gKGkpLmNvZGVcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gUmVzdWx0XG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjYXNlX2luc2Vuc2l0aXZlX2hhc2hfY29kZTogSU5URUdFUlxuICAgICAgLS0gSGFzaCBjb2RlIHZhbHVlIG9mIHRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYEN1cnJlbnQnLlxuICAgIGxvY2FsXG4gICAgICBsX3Byb3BzOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGVcbiAgICAgIGlmIFJlc3VsdCA9IDAgdGhlblxuICAgICAgICAgIC0tIFRoZSBtYWdpYyBudW1iZXIgYDgzODg1OTMnIGJlbG93IGlzIHRoZSBncmVhdGVzdCBwcmltZSBsb3dlciB0aGFuXG4gICAgICAgICAgLS0gMl4yMyBzbyB0aGF0IHRoaXMgbWFnaWMgbnVtYmVyIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgZG9lcyBub3QgZXhjZWVkIDJeMzEuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICAgIGxfcHJvcHMgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSAoKFJlc3VsdCBcXFxcIDgzODg1OTMpIHw8PCA4KSArIGxfcHJvcHMudG9fbG93ZXIgKGl0ZW0gKGkpKS5jb2RlXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGUgOj0gUmVzdWx0XG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvbnNpc3RlbnQ6IFJlc3VsdCA9IGFzX2xvd2VyLmhhc2hfY29kZVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBpc19pbW11dGFibGU6IEJPT0xFQU5cbiAgICAgIC0tIENhbiB0aGUgY2hhcmFjdGVyIHNlcXVlbmNlIG9mIGBDdXJyZW50JyBiZSBub3QgY2hhbmdlZD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXggKGk6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaScgd2l0aGluIHRoZSBib3VuZHMgb2YgdGhlIHN0cmluZz9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IChpID4gMCkgYW5kIChpIDw9IGNvdW50KVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKDEgPD0gaSBhbmQgaSA8PSBjb3VudClcbiAgICBlbmRcblxuICB2YWxpZF9jb2RlICh2OiBsaWtlIGNvZGUpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdicgYSB2YWxpZCBjb2RlIGZvciBDdXJyZW50P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfc3RyaW5nXzg6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhIHNlcXVlbmNlIG9mIENIQVJBQ1RFUl84P1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfc3RyaW5nXzMyOiBCT09MRUFOXG4gICAgICAtLSBJcyBgQ3VycmVudCcgYSBzZXF1ZW5jZSBvZiBDSEFSQUNURVJfMzI/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuICBpc192YWxpZF9hc19zdHJpbmdfODogQk9PTEVBTlxuICAgICAgLS0gSXMgYEN1cnJlbnQnIGNvbnZlcnRpYmxlIHRvIGEgc2VxdWVuY2Ugb2YgQ0hBUkFDVEVSXzggd2l0aG91dCBpbmZvcm1hdGlvbiBsb3NzP1xuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaXNfZW1wdHk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBlbXB0eT9cbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG4gIGlzX3doaXRlc3BhY2U6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cnVjdHVyZSBjb250YWluaW5nIG9ubHkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIGNvdW50KVxuICAgIGVuZFxuXG4gIGlzX3N1YnN0cmluZ193aGl0ZXNwYWNlIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgc3Vic3RyaW5nIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcgY29udGFpbmluZyBvbmx5IHdoaXRlc3BhY2UgY2hhcmFjdGVycz9cbiAgICByZXF1aXJlXG4gICAgICBzdGFydF9pbmRleF9iaWdfZW5vdWdoOiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICBlbmRfaW5kZXhfc21hbGxfZW5vdWdoOiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIGNvbnNpc3RlbnRfaW5kZXhlczogc3RhcnRfaW5kZXggLSAxIDw9IGVuZF9pbmRleFxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgaGFzIChjOiBsaWtlIGl0ZW0pOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBpbmNsdWRlIGBjJz9cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmIgb3IgZWxzZSAoaXRlbSAoaSkgPSBjKVxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgUmVzdWx0IDo9IChpIDw9IG5iKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGZhbHNlX2lmX2VtcHR5OiBjb3VudCA9IDAgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2ZpcnN0OiBjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgPSBjIGltcGxpZXMgUmVzdWx0XG4gICAgICByZWN1cnNlOiAoY291bnQgPiAwIGFuZCB0aGVuIGl0ZW0gKDEpIC89IGMpIGltcGxpZXNcbiAgICAgICAgKFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLmhhcyAoYykpXG4gICAgZW5kXG5cbiAgaGFzX2NvZGUgKGM6IGxpa2UgY29kZSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgc3RyaW5nIGluY2x1ZGUgYGMnP1xuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbmIgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBlbHNlIChjb2RlIChpKSA9IGMpXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBSZXN1bHQgOj0gKGkgPD0gbmIpXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgZmFsc2VfaWZfZW1wdHk6IGNvdW50ID0gMCBpbXBsaWVzIG5vdCBSZXN1bHRcbiAgICAgIHRydWVfaWZfZmlyc3Q6IGNvdW50ID4gMCBhbmQgdGhlbiBjb2RlICgxKSA9IGMgaW1wbGllcyBSZXN1bHRcbiAgICAgIHJlY3Vyc2U6IChjb3VudCA+IDAgYW5kIHRoZW4gY29kZSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAoUmVzdWx0ID0gc3Vic3RyaW5nICgyLCBjb3VudCkuaGFzX2NvZGUgKGMpKVxuICAgIGVuZFxuXG4gIGlzX251bWJlcl9zZXF1ZW5jZTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgbnVtYmVyIHNlcXVlbmNlP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgIGVuc3VyZVxuICAgICAgc3ludGF4X2FuZF9yYW5nZTpcbiAgICAgICAgLS0gUmVzdWx0IGlzIHRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gIEN1cnJlbnQgY2FuIGJlIHByb2R1Y2VkIGJ5IFwiSW50ZWdlcl9saXRlcmFsXCI6XG4gICAgICAgIC0tXG4gICAgICAgIC0tIEludGVnZXJfbGl0ZXJhbCA9IFtTcGFjZV0gW1NpZ25dIEludGVnZXIgW1NwYWNlXVxuICAgICAgICAtLSBTcGFjZSAgPSBcIiBcIiB8IFwiIFwiIFNwYWNlXG4gICAgICAgIC0tIFNpZ24gICA9IFwiK1wiIHwgXCItXCJcbiAgICAgICAgLS0gSW50ZWdlciAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgID0gXCIwXCJ8XCIxXCJ8XCIyXCJ8XCIzXCJ8XCI0XCJ8XCI1XCJ8XCI2XCJ8XCI3XCJ8XCI4XCJ8XCI5XCJcbiAgICBlbmRcblxuICBpc19yZWFsX3NlcXVlbmNlOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSByZWFsIHNlcXVlbmNlP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9yX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9yX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9kb3VibGVcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaXMgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgIGVuZFxuXG4gIGlzX3JlYWwsIGlzX3JlYWxfMzI6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIFJFQUxfMzI/XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b3JfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b3JfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9yZWFsKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLmlzX2ludGVncmFsX3JlYWxcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSAxLiBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgICAgICAtLSAyLiBUaGUgbnVtZXJpY2FsIHZhbHVlIHJlcHJlc2VudGVkIGJ5ICdDdXJyZW50J1xuICAgICAgICAtLSAgaXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZFxuICAgICAgICAtLSAgYnkgYW4gaW5zdGFuY2Ugb2YgdHlwZSBSRUFMLlxuICAgIGVuZFxuXG4gIGlzX2RvdWJsZSwgaXNfcmVhbF82NDogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgUkVBTF82ND9cbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2RvdWJsZSlcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5pc19pbnRlZ3JhbF9kb3VibGVcbiAgICBlbnN1cmVcbiAgICAgIHN5bnRheF9hbmRfcmFuZ2U6XG4gICAgICAgIC0tICdSZXN1bHQnIGlzIFRydWUgaWYgYW5kIG9ubHkgaWYgdGhlIGZvbGxvd2luZyB0d29cbiAgICAgICAgLS0gY29uZGl0aW9ucyBhcmUgc2F0aXNmaWVkOlxuICAgICAgICAtLVxuICAgICAgICAtLSAxLiBJbiB0aGUgZm9sbG93aW5nIEJORiBncmFtbWFyLCB0aGUgdmFsdWUgb2ZcbiAgICAgICAgLS0gICdDdXJyZW50JyBjYW4gYmUgcHJvZHVjZWQgYnkgXCJSZWFsX2xpdGVyYWxcIjpcbiAgICAgICAgLS1cbiAgICAgICAgLS0gUmVhbF9saXRlcmFsID0gTWFudGlzc2EgW0V4cG9uZW50X3BhcnRdXG4gICAgICAgIC0tIEV4cG9uZW50X3BhcnQgPSBcIkVcIiBFeHBvbmVudFxuICAgICAgICAtLSAgICAgICAgIHwgXCJlXCIgRXhwb25lbnRcbiAgICAgICAgLS0gRXhwb25lbnQgICA9IEludGVnZXJfbGl0ZXJhbFxuICAgICAgICAtLSBNYW50aXNzYSAgID0gRGVjaW1hbF9saXRlcmFsXG4gICAgICAgIC0tIERlY2ltYWxfbGl0ZXJhbCA9IEludGVnZXJfbGl0ZXJhbCBbXCIuXCIgW0ludGVnZXJdXSB8IFwiLlwiIEludGVnZXJcbiAgICAgICAgLS0gSW50ZWdlcl9saXRlcmFsID0gW1NpZ25dIEludGVnZXJcbiAgICAgICAgLS0gU2lnbiAgICAgPSBcIitcIiB8IFwiLVwiXG4gICAgICAgIC0tIEludGVnZXIgICAgPSBEaWdpdCB8IERpZ2l0IEludGVnZXJcbiAgICAgICAgLS0gRGlnaXQgICAgPSBcIjBcInxcIjFcInxcIjJcInxcIjNcInxcIjRcInxcIjVcInxcIjZcInxcIjdcInxcIjhcInxcIjlcIlxuICAgICAgICAtLVxuICAgICAgICAtLSAyLiBUaGUgbnVtZXJpY2FsIHZhbHVlIHJlcHJlc2VudGVkIGJ5ICdDdXJyZW50J1xuICAgICAgICAtLSAgaXMgd2l0aGluIHRoZSByYW5nZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZFxuICAgICAgICAtLSAgYnkgYW4gaW5zdGFuY2Ugb2YgdHlwZSBET1VCTEUuXG4gICAgZW5kXG5cbiAgaXNfYm9vbGVhbjogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgQ3VycmVudCcgcmVwcmVzZW50IGEgQk9PTEVBTj9cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaXNfYm9vbGVhbjogUmVzdWx0ID0gKHRydWVfY29uc3RhbnQuc2FtZV9zdHJpbmdfZ2VuZXJhbCAoYXNfbG93ZXIpIG9yXG4gICAgICAgIGZhbHNlX2NvbnN0YW50LnNhbWVfc3RyaW5nX2dlbmVyYWwgKGFzX2xvd2VyKSlcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzg6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhbiBJTlRFR0VSXzg/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX2ludGVnZXJfOClcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzE2OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl8xNj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl8xNilcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyLCBpc19pbnRlZ2VyXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl8zMj9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl8zMilcbiAgICBlbmRcblxuICBpc19pbnRlZ2VyXzY0OiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYW4gSU5URUdFUl82ND9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfaW50ZWdlcl82NClcbiAgICBlbmRcblxuICBpc19uYXR1cmFsXzg6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfOD9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF84KVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfMTY6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfMTY/XG5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGlzX3ZhbGlkX2ludGVnZXJfb3JfbmF0dXJhbCAoe05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbmF0dXJhbF8xNilcbiAgICBlbmRcblxuICBpc19uYXR1cmFsLCBpc19uYXR1cmFsXzMyOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIGBDdXJyZW50JyByZXByZXNlbnQgYSBOQVRVUkFMXzMyP1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9uYXR1cmFsXzMyKVxuICAgIGVuZFxuXG4gIGlzX25hdHVyYWxfNjQ6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIHJlcHJlc2VudCBhIE5BVFVSQUxfNjQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpc192YWxpZF9pbnRlZ2VyX29yX25hdHVyYWwgKHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25hdHVyYWxfNjQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gTWVhc3VyZW1lbnRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGNoYXJhY3RlcnMgaW4gQ3VycmVudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgY2FwYWNpdHk6IElOVEVHRVJcbiAgICAgIC0tIE51bWJlciBvZiBjaGFyYWN0ZXJzIGFsbG9jYXRlZCBpbiBDdXJyZW50XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGNhcGFjaXR5X25vbl9uZWdhdGl2ZTogUmVzdWx0ID49IDBcbiAgICBlbmRcblxuICBvY2N1cnJlbmNlcyAoYzogQ0hBUkFDVEVSXzMyKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGBjJyBhcHBlYXJzIGluIHRoZSBzdHJpbmdcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG5iID4gMCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpID0gYyB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgemVyb19pZl9lbXB0eTogY291bnQgPSAwIGltcGxpZXMgUmVzdWx0ID0gMFxuICAgICAgcmVjdXJzZV9pZl9ub3RfZm91bmRfYXRfZmlyc3RfcG9zaXRpb246XG4gICAgICAgIChjb3VudCA+IDAgYW5kIHRoZW4gaXRlbSAoMSkgLz0gYykgaW1wbGllc1xuICAgICAgICAgIFJlc3VsdCA9IHN1YnN0cmluZyAoMiwgY291bnQpLm9jY3VycmVuY2VzIChjKVxuICAgICAgcmVjdXJzZV9pZl9mb3VuZF9hdF9maXJzdF9wb3NpdGlvbjpcbiAgICAgICAgKGNvdW50ID4gMCBhbmQgdGhlbiBpdGVtICgxKSA9IGMpIGltcGxpZXNcbiAgICAgICAgICBSZXN1bHQgPSAxICsgc3Vic3RyaW5nICgyLCBjb3VudCkub2NjdXJyZW5jZXMgKGMpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIElzIHN0cmluZyBtYWRlIG9mIHNhbWUgY2hhcmFjdGVyIHNlcXVlbmNlIGFzIGBvdGhlcicgcmVnYXJkbGVzcyBvZiBjYXNpbmdcbiAgICAgIC0tIChwb3NzaWJseSB3aXRoIGEgZGlmZmVyZW50IGNhcGFjaXR5KT9cbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgb3RoZXIgPSBDdXJyZW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgaWYgbmIgPSBvdGhlci5jb3VudCB0aGVuXG4gICAgICAgICAgUmVzdWx0IDo9IG5iID0gMCBvciBlbHNlIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyAob3RoZXIsIDEsIG5iLCAxKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc3ltbWV0cmljOiBSZXN1bHQgaW1wbGllcyBvdGhlci5pc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIChDdXJyZW50KVxuICAgICAgY29uc2lzdGVudDogYXR0YWNoZWQge2xpa2UgQ3VycmVudH0gb3RoZXIgYXMgbF9vdGhlciBpbXBsaWVzIChzdGFuZGFyZF9pc19lcXVhbCAobF9vdGhlcikgaW1wbGllcyBSZXN1bHQpXG4gICAgICB2YWxpZF9yZXN1bHQ6IGFzX2xvd2VyIH4gb3RoZXIuYXNfbG93ZXIgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJ1xuICAgICAgLS0gY2FzZWxlc3MgaWRlbnRpY2FsIHRvIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgYzEsYzI6IGxpa2UgaXRlbVxuICAgIGRvXG4gICAgICBuYiA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgaWYgbmIgPD0gY291bnQgLSBpbmRleF9wb3MgKyAxIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgaSA6PSBpbmRleF9wb3NcbiAgICAgICAgICBqIDo9IHN0YXJ0X3Bvc1xuICAgICAgICAgIG5iIDo9IG5iICsgaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgYzEgOj0gaXRlbSAoaSlcbiAgICAgICAgICBjMiA6PSBvdGhlci5pdGVtIChqKVxuICAgICAgICAgIGlmIGMxIC89IGMyIGFuZCB0aGVuIGxfcHJvcC50b19sb3dlciAoYzEpIC89IGxfcHJvcC50b19sb3dlciAoYzIpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgaSA6PSBuYiAtIDEgLS0gSnVtcCBvdXQgb2YgdGhlIGxvb3BcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaW5jcmVhc2luZ19pbmRleDogbmIgLSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jaGFyYWN0ZXJzOiBSZXN1bHQgPSBzdWJzdHJpbmcgKGluZGV4X3BvcywgaW5kZXhfcG9zICsgZW5kX3BvcyAtIHN0YXJ0X3BvcykuaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCAob3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpKVxuICAgIGVuZFxuXG4gIGhhc19zdWJzdHJpbmcgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYEN1cnJlbnQnIGNvbnRhaW4gYG90aGVyJz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZWlmIG90aGVyLmNvdW50IDw9IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHN1YnN0cmluZ19pbmRleCAob3RoZXIsIDEpID4gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBmYWxzZV9pZl90b29fc21hbGw6IGNvdW50IDwgb3RoZXIuY291bnQgaW1wbGllcyBub3QgUmVzdWx0XG4gICAgICB0cnVlX2lmX2luaXRpYWw6IChjb3VudCA+PSBvdGhlci5jb3VudCBhbmQgdGhlblxuICAgICAgICBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBvdGhlci5jb3VudCkpKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgcmVjdXJzZTogKGNvdW50ID49IG90aGVyLmNvdW50IGFuZCB0aGVuXG4gICAgICAgIG5vdCBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nICgxLCBvdGhlci5jb3VudCkpKSBpbXBsaWVzXG4gICAgICAgIChSZXN1bHQgPSBzdWJzdHJpbmcgKDIsIGNvdW50KS5oYXNfc3Vic3RyaW5nIChvdGhlcikpXG4gICAgZW5kXG5cbiAgc2FtZV9zdHJpbmcgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgYG90aGVyJyByZXByZXNlbnQgdGhlIHNhbWUgc3RyaW5nIGFzIGBDdXJyZW50Jz9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBvdGhlciA9IEN1cnJlbnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBpZiBuYiA9IG90aGVyLmNvdW50IHRoZW5cbiAgICAgICAgICBSZXN1bHQgOj0gbmIgPSAwIG9yIGVsc2Ugc2FtZV9jaGFyYWN0ZXJzIChvdGhlciwgMSwgbmIsIDEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2FtZV9jaGFyYWN0ZXJzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvcywgaW5kZXhfcG9zOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIGlkZW50aWNhbCB0byBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iIDo9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICBpZiBuYiA8PSBjb3VudCAtIGluZGV4X3BvcyArIDEgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgICAgICBpIDo9IGluZGV4X3Bvc1xuICAgICAgICAgIGogOj0gc3RhcnRfcG9zXG4gICAgICAgICAgbmIgOj0gbmIgKyBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSAvPSBvdGhlci5pdGVtIChqKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgIGkgOj0gbmIgLSAxIC0tIEp1bXAgb3V0IG9mIHRoZSBsb29wXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGluY3JlYXNpbmdfaW5kZXg6IG5iIC0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2hhcmFjdGVyczogUmVzdWx0ID0gc3Vic3RyaW5nIChpbmRleF9wb3MsIGluZGV4X3BvcyArIGVuZF9wb3MgLSBzdGFydF9wb3MpLnNhbWVfc3RyaW5nIChvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykpXG4gICAgZW5kXG5cbiAgc3RhcnRzX3dpdGggKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBzdHJpbmcgYmVnaW4gd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGlmIGkgPD0gY291bnQgdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIGkgPSAwXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgaWYgY29kZSAoaSkgLz0gcy5jb2RlIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKDEsIHMuY291bnQpKVxuICAgIGVuZFxuXG4gIGVuZHNfd2l0aCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBCT09MRUFOXG4gICAgICAtLSBEb2VzIHN0cmluZyBmaW5pc2ggd2l0aCBgcyc/XG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBqOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIEN1cnJlbnQgPSBzIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgaSA6PSBzLmNvdW50XG4gICAgICAgIGogOj0gY291bnRcbiAgICAgICAgaWYgaSA8PSBqIHRoZW5cbiAgICAgICAgICBmcm9tXG4gICAgICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGlmIGNvZGUoaikgLz0gcy5jb2RlIChpKSB0aGVuXG4gICAgICAgICAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgICAgICAgICAgICBpIDo9IDEgLS0gSnVtcCBvdXQgb2YgbG9vcFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgICBqIDo9IGogLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSBzLnNhbWVfc3RyaW5nIChzdWJzdHJpbmcgKGNvdW50IC0gcy5jb3VudCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXhfaW5fYm91bmRzIChvdGhlcjogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUw7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYG90aGVyJyBhdCBvciBhZnRlciBgc3RhcnRfcG9zJ1xuICAgICAgLS0gYW5kIHRvIG9yIGJlZm9yZSBgZW5kX3Bvcyc7XG4gICAgICAtLSAwIGlmIG5vbmUuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm9udm9pZDogb3RoZXIgLz0gVm9pZFxuICAgICAgb3RoZXJfbm90ZW1wdHk6IG5vdCBvdGhlci5pc19lbXB0eVxuICAgICAgc3RhcnRfcG9zX2xhcmdlX2Vub3VnaDogc3RhcnRfcG9zID49IDFcbiAgICAgIHN0YXJ0X3Bvc19zbWFsbF9lbm91Z2g6IHN0YXJ0X3BvcyA8PSBjb3VudFxuICAgICAgZW5kX3Bvc19sYXJnZV9lbm91Z2g6IGVuZF9wb3MgPj0gc3RhcnRfcG9zXG4gICAgICBlbmRfcG9zX3NtYWxsX2Vub3VnaDogZW5kX3BvcyA8PSBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBjb3JyZWN0X3BsYWNlOiBSZXN1bHQgPiAwIGltcGxpZXMgb3RoZXIuc2FtZV9zdHJpbmcgKHN1YnN0cmluZyAoUmVzdWx0LCBSZXN1bHQgKyBvdGhlci5jb3VudCAtIDEpKVxuICAgICAgLS0gZm9yYWxsIHggOiBzdGFydF9wb3MuLlJlc3VsdFxuICAgICAgLS0gIG5vdCBzdWJzdHJpbmcgKHgsIHgrb3RoZXIuY291bnQgLTEpLmlzX2VxdWFsIChvdGhlcilcbiAgICBlbmRcblxuICBzdWJzdHJpbmdfaW5kZXggKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXg6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBJbmRleCBvZiBmaXJzdCBvY2N1cnJlbmNlIG9mIG90aGVyIGF0IG9yIGFmdGVyIHN0YXJ0X2luZGV4O1xuICAgICAgLS0gMCBpZiBub25lXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiBzdGFydF9pbmRleCA+PSAxIGFuZCBzdGFydF9pbmRleCA8PSBjb3VudCArIDFcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfcmVzdWx0OiBSZXN1bHQgPSAwIG9yIGVsc2VcbiAgICAgICAgKHN0YXJ0X2luZGV4IDw9IFJlc3VsdCBhbmQgUmVzdWx0IDw9IGNvdW50IC0gb3RoZXIuY291bnQgKyAxKVxuICAgICAgemVyb19pZl9hYnNlbnQ6IChSZXN1bHQgPSAwKSA9XG4gICAgICAgIG5vdCBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBjb3VudCkuaGFzX3N1YnN0cmluZyAob3RoZXIpXG4gICAgICBhdF90aGlzX2luZGV4OiBSZXN1bHQgPj0gc3RhcnRfaW5kZXggaW1wbGllc1xuICAgICAgICBvdGhlci5zYW1lX3N0cmluZyAoc3Vic3RyaW5nIChSZXN1bHQsIFJlc3VsdCArIG90aGVyLmNvdW50IC0gMSkpXG4gICAgICBub25lX2JlZm9yZTogUmVzdWx0ID4gc3RhcnRfaW5kZXggaW1wbGllc1xuICAgICAgICBub3Qgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgUmVzdWx0ICsgb3RoZXIuY291bnQgLSAyKS5oYXNfc3Vic3RyaW5nIChvdGhlcilcbiAgICBlbmRcblxuICBmdXp6eV9pbmRleCAob3RoZXI6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydDogSU5URUdFUjsgZnV6ejogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIFBvc2l0aW9uIG9mIGZpcnN0IG9jY3VycmVuY2Ugb2YgYG90aGVyJyBhdCBvciBhZnRlciBgc3RhcnQnXG4gICAgICAtLSB3aXRoIDAuLmBmdXp6JyBtaXNtYXRjaGVzIGJldHdlZW4gdGhlIHN0cmluZyBhbmQgYG90aGVyJy5cbiAgICAgIC0tIDAgaWYgdGhlcmUgYXJlIG5vIGZ1enp5IG1hdGNoZXNcbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9leGlzdHM6IG90aGVyIC89IFZvaWRcbiAgICAgIG90aGVyX25vdF9lbXB0eTogbm90IG90aGVyLmlzX2VtcHR5XG4gICAgICBzdGFydF9sYXJnZV9lbm91Z2g6IHN0YXJ0ID49IDFcbiAgICAgIHN0YXJ0X3NtYWxsX2Vub3VnaDogc3RhcnQgPD0gY291bnRcbiAgICAgIGFjY2VwdGFibGVfZnV6enk6IGZ1enogPD0gb3RoZXIuY291bnRcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBmcm96ZW4gdG9fY2lsOiBTWVNURU1fU1RSSU5HXG4gICAgICAtLSBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgU1lTVEVNX1NUUklORyB1c2luZyBjaGFyYWN0ZXJzXG4gICAgICAtLSBvZiBDdXJyZW50IGJldHdlZW4gaW5kaWNlcyBgMScgYW5kIGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gZG90bmV0X2NvbnZlcnRvci5mcm9tX3N0cmluZ190b19zeXN0ZW1fc3RyaW5nIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3N0cmluZ184OiBTVFJJTkdfOFxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfOC5cbiAgICByZXF1aXJlXG4gICAgICBpc192YWxpZF9hc19zdHJpbmdfODogaXNfdmFsaWRfYXNfc3RyaW5nXzhcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFzX3N0cmluZ184XG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfOF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGlkZW50aXR5OiAoY29uZm9ybXNfdG8gKFwiXCIpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzhfY29udmVyc2lvbjogU1RSSU5HXzhcbiAgICAgIC0tIEVxdWl2YWxlbnQgdG8gYGFzX3N0cmluZ184JyB3aXRoIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAtLSBUbyBiZSB1c2VkIGZvciBtaWdyYXRpbmcgZXhpc3RpbmcgY29kZSB0byBVbmljb2RlXG4gICAgICAtLSB3aGVuIHlvdSBnZXQgYSBjb21waWxlciBlcnJvciBidXQgY2Fubm90IG9yIGRvIG5vdCBoYXZlXG4gICAgICAtLSB0aGUgdGltZSB5ZXQgdG8gYWRkcmVzcyB0aGUgdGFyZ2V0IHJlY2lwaWVudCBvZiB0aGUgc3RyaW5nIHRvIGJlXG4gICAgICAtLSBhIFJFQURBQkxFX1NUUklOR18zMiBvciBkZXNjZW5kYW50cy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVcGRhdGUgcmVjaXBpZW50IG9mIGNhbGwgdG8gdXNlIFJFQURBQkxFX1NUUklOR18zMiBhbmQgZGVzY2VuZGFudHMgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXNfc3RyaW5nXzhcbiAgICBlbmRcblxuICBhc19yZWFkYWJsZV9zdHJpbmdfODogUkVBREFCTEVfU1RSSU5HXzhcbiAgICAgIC0tXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGV4cGxpY2l0IGNvbnZlcnNpb24gYHRvX3N0cmluZ184JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfOFxuICAgIGVuZFxuXG4gIGFzX3N0cmluZ184OiBTVFJJTkdfOFxuICAgICAgLS0gQ29udmVydCBgQ3VycmVudCcgYXMgYSBTVFJJTkdfOC4gSWYgYSBjb2RlIG9mIGBDdXJyZW50JyBpc1xuICAgICAgLS0gbm90IGEgdmFsaWQgY29kZSBmb3IgYSBTVFJJTkdfOCBpdCBpcyByZXBsYWNlZCB3aXRoIHRoZSBudWxsXG4gICAgICAtLSBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvZGU6IGxpa2UgY29kZVxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7U1RSSU5HXzh9IEN1cnJlbnQgYXMgbF9yZXN1bHQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gbF9yZXN1bHRcbiAgICAgIGVsc2VcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuYilcbiAgICAgICAgUmVzdWx0LnNldF9jb3VudCAobmIpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IDFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfY29kZSA6PSBjb2RlIChpKVxuICAgICAgICAgIGlmIFJlc3VsdC52YWxpZF9jb2RlIChsX2NvZGUpIHRoZW5cbiAgICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAobF9jb2RlLCBpKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIFJlc3VsdC5wdXRfY29kZSAoMCwgaSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfOF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGlkZW50aXR5OiAoY29uZm9ybXNfdG8gKFwiXCIpIGFuZCBSZXN1bHQgPSBDdXJyZW50KSBvciAobm90IGNvbmZvcm1zX3RvIChcIlwiKSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfc3RyaW5nXzMyX2NvbnZlcnNpb246IFNUUklOR18zMlxuICAgICAgLS0gRXF1aXZhbGVudCB0byBgYXNfc3RyaW5nXzMyJyB3aXRoIGEgZGlmZmVyZW50IG5hbWUuXG4gICAgICAtLSBUbyBiZSB1c2VkIGZvciBtaWdyYXRpbmcgZXhpc3RpbmcgY29kZSB0byBVbmljb2RlXG4gICAgICAtLSB3aGVuIHlvdSBnZXQgYSBjb21waWxlciBlcnJvciBidXQgY2Fubm90IG9yIGRvIG5vdCBoYXZlXG4gICAgICAtLSB0aGUgdGltZSB5ZXQgdG8gYWRkcmVzcyB0aGUgc291cmNlIG9mIHRoZSBzdHJpbmcgdG8gYmVcbiAgICAgIC0tIGEgUkVBREFCTEVfU1RSSU5HXzMyIG9yIGRlc2NlbmRhbnRzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVwZGF0ZSB0YXJnZXQgb2YgY2FsbCB0byB1c2UgUkVBREFCTEVfU1RSSU5HXzMyIGFuZCBkZXNjZW5kYW50cyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfMzJcbiAgICBlbmRcblxuICBhc19yZWFkYWJsZV9zdHJpbmdfMzI6IFJFQURBQkxFX1NUUklOR18zMlxuICAgICAgLS1cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgZXhwbGljaXQgY29udmVyc2lvbiBgdG9fc3RyaW5nXzMyJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhc19zdHJpbmdfMzJcbiAgICBlbmRcblxuICBhc19zdHJpbmdfMzIsIHRvX3N0cmluZ18zMjogU1RSSU5HXzMyXG4gICAgICAtLSBDb252ZXJ0IGBDdXJyZW50JyBhcyBhIFNUUklOR18zMi5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1NUUklOR18zMn0gQ3VycmVudCBhcyBsX3Jlc3VsdCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBsX3Jlc3VsdFxuICAgICAgZWxzZVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG5iKVxuICAgICAgICBSZXN1bHQuc2V0X2NvdW50IChuYilcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgUmVzdWx0LnB1dF9jb2RlIChjb2RlIChpKSwgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhc19zdHJpbmdfMzJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBpZGVudGl0eTogKGNvbmZvcm1zX3RvIChjcmVhdGUge1NUUklOR18zMn0ubWFrZV9lbXB0eSkgYW5kIFJlc3VsdCA9IEN1cnJlbnQpIG9yIChub3QgY29uZm9ybXNfdG8gKGNyZWF0ZSB7U1RSSU5HXzMyfS5tYWtlX2VtcHR5KSBhbmQgUmVzdWx0IC89IEN1cnJlbnQpXG4gICAgZW5kXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIGFzX2xvd2VyX2F0dGFjaGVkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbGVuZ3RoOiBSZXN1bHQuY291bnQgPSBjb3VudFxuICAgICAgYW5jaG9yOiBjb3VudCA+IDAgaW1wbGllcyBSZXN1bHQuaXRlbSAoMSkgPSBpdGVtICgxKS5hc19sb3dlclxuICAgICAgcmVjdXJzZTogY291bnQgPiAxIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoMiwgY291bnQpIH4gc3Vic3RyaW5nICgyLCBjb3VudCkuYXNfbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBhc191cHBlcl9hdHRhY2hlZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIGxlbmd0aDogUmVzdWx0LmNvdW50ID0gY291bnRcbiAgICAgIGFuY2hvcjogY291bnQgPiAwIGltcGxpZXMgUmVzdWx0Lml0ZW0gKDEpID0gaXRlbSAoMSkuYXNfdXBwZXJcbiAgICAgIHJlY3Vyc2U6IGNvdW50ID4gMSBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDIsIGNvdW50KSB+IHN1YnN0cmluZyAoMiwgY291bnQpLmFzX3VwcGVyXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIDgtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzg6IGlzX2ludGVnZXJfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfaW50ZWdlcl84XG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl8xNjogSU5URUdFUl8xNlxuICAgICAgLS0gMTYtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzE2OiBpc19pbnRlZ2VyXzE2XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXzE2XG4gICAgZW5kXG5cbiAgdG9faW50ZWdlciwgdG9faW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gMzItYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyOiBpc19pbnRlZ2VyXzMyXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXG4gICAgZW5kXG5cbiAgdG9faW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gNjQtYml0IGludGVnZXIgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19pbnRlZ2VyXzY0OiBpc19pbnRlZ2VyXzY0XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9pbnRlZ2VyXzY0XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIDgtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzg6IGlzX25hdHVyYWxfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucGFyc2Vfc3RyaW5nX3dpdGhfdHlwZSAoQ3VycmVudCwge05VTUVSSUNfSU5GT1JNQVRJT059LnR5cGVfbm9fbGltaXRhdGlvbilcbiAgICAgIFJlc3VsdCA6PSBsX2NvbnZlcnRvci5wYXJzZWRfbmF0dXJhbF84XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gMTYtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzE2OiBpc19uYXR1cmFsXzE2XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzE2XG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbCwgdG9fbmF0dXJhbF8zMjogTkFUVVJBTF8zMlxuICAgICAgLS0gMzItYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsOiBpc19uYXR1cmFsXzMyXG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgdG9fbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gNjQtYml0IG5hdHVyYWwgdmFsdWVcbiAgICByZXF1aXJlXG4gICAgICBpc19uYXR1cmFsXzY0OiBpc19uYXR1cmFsXzY0XG4gICAgbG9jYWxcbiAgICAgIGxfY29udmVydG9yOiBsaWtlIGN0b2lfY29udmVydG9yXG4gICAgZG9cbiAgICAgIGxfY29udmVydG9yIDo9IGN0b2lfY29udmVydG9yXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB7TlVNRVJJQ19JTkZPUk1BVElPTn0udHlwZV9ub19saW1pdGF0aW9uKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLnBhcnNlZF9uYXR1cmFsXzY0XG4gICAgZW5kXG5cbiAgdG9fcmVhbCwgdG9fcmVhbF8zMjogUkVBTFxuICAgICAgLS0gUmVhbCB2YWx1ZTtcbiAgICAgIC0tIGZvciBleGFtcGxlLCB3aGVuIGFwcGxpZWQgdG8gXCIxMjMuMFwiLCB3aWxsIHlpZWxkIDEyMy4wXG4gICAgcmVxdWlyZVxuICAgICAgcmVwcmVzZW50c19hX3JlYWw6IGlzX3JlYWxcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRvX2RvdWJsZS50cnVuY2F0ZWRfdG9fcmVhbFxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZSwgdG9fcmVhbF82NDogRE9VQkxFXG4gICAgICAtLSBcIkRvdWJsZVwiIHZhbHVlO1xuICAgICAgLS0gZm9yIGV4YW1wbGUsIHdoZW4gYXBwbGllZCB0byBcIjEyMy4wXCIsIHdpbGwgeWllbGQgMTIzLjAgKGRvdWJsZSlcbiAgICByZXF1aXJlXG4gICAgICByZXByZXNlbnRzX2FfZG91YmxlOiBpc19kb3VibGVcbiAgICBsb2NhbFxuICAgICAgbF9jb252ZXJ0b3I6IGxpa2UgY3Rvcl9jb252ZXJ0b3JcbiAgICBkb1xuICAgICAgbF9jb252ZXJ0b3IgOj0gY3Rvcl9jb252ZXJ0b3JcbiAgICAgIGxfY29udmVydG9yLnBhcnNlX3N0cmluZ193aXRoX3R5cGUgKEN1cnJlbnQsIHtOVU1FUklDX0lORk9STUFUSU9OfS50eXBlX25vX2xpbWl0YXRpb24pXG4gICAgICBSZXN1bHQgOj0gbF9jb252ZXJ0b3IucGFyc2VkX2RvdWJsZVxuICAgIGVuZFxuXG4gIHRvX2Jvb2xlYW46IEJPT0xFQU5cbiAgICAgIC0tIEJvb2xlYW4gdmFsdWU7XG4gICAgICAtLSBcIlRydWVcIiB5aWVsZHMgYFRydWUnLCBcIkZhbHNlXCIgeWllbGRzIGBGYWxzZSdcbiAgICAgIC0tIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2Jvb2xlYW46IGlzX2Jvb2xlYW5cbiAgICBkb1xuICAgICAgY2hlY2sgdHJ1ZV9jb25zdGFudC5jb3VudCA9IDQgZW5kXG4gICAgICBpZiBjb3VudCA9IDQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICB0b19ib29sZWFuOiAoUmVzdWx0ID0gYXNfbG93ZXIuc2FtZV9zdHJpbmcgKHRydWVfY29uc3RhbnQpKSBvclxuICAgICAgICAobm90IFJlc3VsdCA9IGFzX2xvd2VyLnNhbWVfc3RyaW5nIChmYWxzZV9jb25zdGFudCkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIHNwbGl0IChhX3NlcGFyYXRvcjogQ0hBUkFDVEVSXzMyKTogTElTVCBbbGlrZSBDdXJyZW50XVxuICAgICAgLS0gU3BsaXQgb24gYGFfc2VwYXJhdG9yJy5cbiAgICBsb2NhbFxuICAgICAgbF9saXN0OiBBUlJBWUVEX0xJU1QgW2xpa2UgQ3VycmVudF1cbiAgICAgIHBhcnQ6IGxpa2UgQ3VycmVudFxuICAgICAgaSwgaiwgYzogSU5URUdFUlxuICAgIGRvXG4gICAgICBjIDo9IGNvdW50XG4gICAgICAgIC0tIFdvcnNlIGNhc2UgYWxsb2NhdGlvbjogZXZlcnkgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yXG4gICAgICBjcmVhdGUgbF9saXN0Lm1ha2UgKGMgKyAxKVxuICAgICAgaWYgYyA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGNcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGogOj0gaW5kZXhfb2YgKGFfc2VwYXJhdG9yLCBpKVxuICAgICAgICAgIGlmIGogPSAwIHRoZW5cbiAgICAgICAgICAgICAgLS0gTm8gc2VwYXJhdG9yIHdhcyBmb3VuZCwgd2Ugd2lsbFxuICAgICAgICAgICAgICAtLSBzaW1wbHkgY3JlYXRlIGEgbGlzdCB3aXRoIGEgY29weSBvZlxuICAgICAgICAgICAgICAtLSBDdXJyZW50IGluIGl0LlxuICAgICAgICAgICAgaiA6PSBjICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIHBhcnQgOj0gc3Vic3RyaW5nIChpLCBqIC0gMSlcbiAgICAgICAgICBsX2xpc3QuZXh0ZW5kIChwYXJ0KVxuICAgICAgICAgIGkgOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGlmIGogPSBjIHRoZW5cbiAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgbGFzdF9jaGFyYWN0ZXJfaXNfYV9zZXBhcmF0b3I6IGl0ZW0gKGopID0gYV9zZXBhcmF0b3JcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEEgc2VwYXJhdG9yIHdhcyBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmdcbiAgICAgICAgICBsX2xpc3QuZXh0ZW5kIChuZXdfc3RyaW5nICgwKSlcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0ZW5kIGVtcHR5IHN0cmluZywgc2luY2UgQ3VycmVudCBpcyBlbXB0eS5cbiAgICAgICAgbF9saXN0LmV4dGVuZCAobmV3X3N0cmluZyAoMCkpXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSBsX2xpc3RcbiAgICAgIGNoZWNrXG4gICAgICAgIGxfbGlzdC5jb3VudCA9IG9jY3VycmVuY2VzIChhX3NlcGFyYXRvcikgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIHBsdXNfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50ICsgcy5jb3VudFxuICAgICAgaW5pdGlhbDogZWxrc19jaGVja2luZyBpbXBsaWVzIFJlc3VsdC5zdWJzdHJpbmcgKDEsIGNvdW50KSB+IEN1cnJlbnRcbiAgICAgIGZpbmFsOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgUmVzdWx0LnN1YnN0cmluZyAoY291bnQgKyAxLCBjb3VudCArIHMuY291bnQpLnNhbWVfc3RyaW5nIChzKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIER1cGxpY2F0aW9uXG5cbiAgc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDb3B5IG9mIHN1YnN0cmluZyBjb250YWluaW5nIGFsbCBjaGFyYWN0ZXJzIGF0IGluZGljZXNcbiAgICAgIC0tIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCdcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc3Vic3RyaW5nX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc3Vic3RyaW5nX2NvdW50OiBSZXN1bHQuY291bnQgPSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEgb3IgUmVzdWx0LmNvdW50ID0gMFxuICAgICAgZmlyc3RfY29kZTogUmVzdWx0LmNvdW50ID4gMCBpbXBsaWVzIFJlc3VsdC5pdGVtICgxKSA9IGl0ZW0gKHN0YXJ0X2luZGV4KVxuICAgICAgcmVjdXJzZTogUmVzdWx0LmNvdW50ID4gMCBpbXBsaWVzXG4gICAgICAgIFJlc3VsdC5zdWJzdHJpbmcgKDIsIFJlc3VsdC5jb3VudCkgfiBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4ICsgMSwgZW5kX2luZGV4KVxuICAgIGVuZFxuXG4gIGhlYWQgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFByZWZpeCwgcmV0YWluaW5nIGZpcnN0IGBuJyBjaGFyYWN0ZXJzIChvciBhcyBtYW55IGFzIGF2YWlsYWJsZSkuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IHN1YnN0cmluZyAoMSwgbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgKGNvdW50KVxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAoY291bnQpXG4gICAgZW5kXG5cbiAgdGFpbCAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gU3VmZml4LCByZXRhaW5pbmcgbGFzdCBgbicgY2hhcmFjdGVycyAob3IgYXMgbWFueSBhcyBhdmFpbGFibGUpLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBzdWJzdHJpbmcgKGNvdW50IC0gbiArIDEsIGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQpXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG4ubWluIChjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gQXNzZXJ0aW9uIGhlbHBlclxuXG4gIGVsa3NfY2hlY2tpbmc6IEJPT0xFQU4gPSBGYWxzZVxuICAgICAgLS0gQXJlIEVMS1MgY2hlY2tpbmdzIHZlcmlmaWVkPyBNdXN0IGJlIFRydWUgd2hlbiBjaGFuZ2luZyBpbXBsZW1lbnRhdGlvbiBvZiBTVFJJTkdfR0VORVJBTCBvciBkZXNjZW5kYW50LlxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIG5ld19zdHJpbmcgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBjdXJyZW50IHdpdGggc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X3N0cmluZ19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIG5ld19zdHJpbmdfZW1wdHk6IFJlc3VsdC5pc19lbXB0eVxuICAgICAgbmV3X3N0cmluZ19hcmVhX2JpZ19lbm91Z2g6IFJlc3VsdC5jYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbiAgaXNfdmFsaWRfaW50ZWdlcl9vcl9uYXR1cmFsICh0eXBlOiBJTlRFR0VSKSA6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBDdXJyZW50JyBhIHZhbGlkIG51bWJlciBhY2NvcmRpbmcgdG8gZ2l2ZW4gYHR5cGUnP1xuICAgIGxvY2FsXG4gICAgICBsX2NvbnZlcnRvcjogbGlrZSBjdG9pX2NvbnZlcnRvclxuICAgIGRvXG4gICAgICBsX2NvbnZlcnRvciA6PSBjdG9pX2NvbnZlcnRvclxuICAgICAgbF9jb252ZXJ0b3IucmVzZXQgKHR5cGUpXG4gICAgICBsX2NvbnZlcnRvci5wYXJzZV9zdHJpbmdfd2l0aF90eXBlIChDdXJyZW50LCB0eXBlKVxuICAgICAgUmVzdWx0IDo9IGxfY29udmVydG9yLmlzX2ludGVncmFsX2ludGVnZXJcbiAgICBlbmRcblxuICBzdHJpbmdfc2VhcmNoZXI6IFNUUklOR19TRUFSQ0hFUlxuICAgICAgLS0gRmFjaWxpdGllcyB0byBzZWFyY2ggc3RyaW5nIGluIGFub3RoZXIgc3RyaW5nLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzdHJpbmdfc2VhcmNoZXJfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY19zdHJpbmdfcHJvdmlkZXI6IENfU1RSSU5HXG4gICAgICAtLSBUbyBjcmVhdGUgRWlmZmVsIHN0cmluZ3MgZnJvbSBDIHN0cmluZy5cbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKDApXG4gICAgZW5zdXJlXG4gICAgICBjX3N0cmluZ19wcm92aWRlcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBjdG9pX2NvbnZlcnRvcjogU1RSSU5HX1RPX0lOVEVHRVJfQ09OVkVSVE9SXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byBpbnRlZ2VyIG9yIG5hdHVyYWxcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfdHJhaWxpbmdfc2VwYXJhdG9ycyAoXCIgXCIpXG4gICAgICBSZXN1bHQuc2V0X2xlYWRpbmdfc2VwYXJhdG9yc19hY2NlcHRhYmxlIChUcnVlKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgZW5zdXJlXG4gICAgICBjdG9pX2NvbnZlcnRvcl9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBjdG9yX2NvbnZlcnRvcjogU1RSSU5HX1RPX1JFQUxfQ09OVkVSVE9SXG4gICAgICAtLSBDb252ZXJ0b3IgdXNlZCB0byBjb252ZXJ0IHN0cmluZyB0byByZWFsIG9yIGRvdWJsZVxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZVxuICAgICAgUmVzdWx0LnNldF9sZWFkaW5nX3NlcGFyYXRvcnMgKFwiIFwiKVxuICAgICAgUmVzdWx0LnNldF90cmFpbGluZ19zZXBhcmF0b3JzIChcIiBcIilcbiAgICAgIFJlc3VsdC5zZXRfbGVhZGluZ19zZXBhcmF0b3JzX2FjY2VwdGFibGUgKFRydWUpXG4gICAgICBSZXN1bHQuc2V0X3RyYWlsaW5nX3NlcGFyYXRvcnNfYWNjZXB0YWJsZSAoVHJ1ZSlcbiAgICBlbnN1cmVcbiAgICAgIGN0b3JfY29udmVydG9yX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGRvdG5ldF9jb252ZXJ0b3I6IFNZU1RFTV9TVFJJTkdfRkFDVE9SWVxuICAgICAgLS0gQ29udmVydG9yIHVzZWQgdG8gY29udmVydCBmcm9tIGFuZCB0byBTWVNURU1fU1RSSU5HLlxuICAgIG9uY2VcbiAgICAgIGNyZWF0ZSBSZXN1bHRcbiAgICBlbnN1cmVcbiAgICAgIGRvdG5ldF9jb252ZXJ0b3Jfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX3Byb3BlcnRpZXM6IENIQVJBQ1RFUl9QUk9QRVJUWVxuICAgICAgLS0gQWNjZXNzIHRvIFVuaWNvZGUgY2hhcmFjdGVyIHByb3BlcnRpZXNcbiAgICBvbmNlXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VcbiAgICBlbmRcblxuZmVhdHVyZSB7UkVBREFCTEVfU1RSSU5HX0dFTkVSQUx9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgaW50ZXJuYWxfaGFzaF9jb2RlOiBJTlRFR0VSXG4gICAgICAtLSBDYWNoZSBmb3IgYGhhc2hfY29kZScuXG5cbiAgaW50ZXJuYWxfY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGU6IElOVEVHRVI7XG4gICAgICAtLSBDYXNoIGZvciBgY2FzZV9pbnNlbnNpdGl2ZV9oYXNoX2NvZGUnLlxuXG5cbmZlYXR1cmUgLS0gQWNjZXNzOiBDdXJzb3JcblxuICBuZXdfY2hhcmFjdGVyXzMyX2N1cnNvcjogU1RSSU5HX0lURVJBVElPTl9DVVJTT1JcbiAgICAgIC0tIEZyZXNoIGN1cnNvciBmb3IgdGhpcyBzdHJpbmcgdGhhdCBpdGVyYXRlcyBvdmVyIGNvZGUgcG9pbnRzIChzZWUgYGNvZGUnKVxuICAgICAgLS0gZXhwb3NlZCBhcyB7Q0hBUkFDVEVSXzMyfS5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChDdXJyZW50KVxuICAgICAgUmVzdWx0LnN0YXJ0XG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJGaW5pdGUgc3RydWN0dXJlcyB3aG9zZSBpdGVtIGNvdW50IGlzIHN1YmplY3QgdG8gY2hhbmdlXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBuYW1lczogc3RvcmFnZTtcbiAgc2l6ZTogcmVzaXphYmxlO1xuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA3LTIzIDE0OjAyOjE5IC0wNzAwIChNb24sIDIzIEp1bCAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4OSAkXCJcblxuZGVmZXJyZWQgY2xhc3MgUkVTSVpBQkxFIFtHXSBpbmhlcml0XG5cbiAgQk9VTkRFRCBbR11cblxuZmVhdHVyZSAtLSBNZWFzdXJlbWVudFxuXG4gIEdyb3d0aF9wZXJjZW50YWdlOiBJTlRFR0VSID0gNTBcbiAgICAgIC0tIFBlcmNlbnRhZ2UgYnkgd2hpY2ggc3RydWN0dXJlIHdpbGwgZ3JvdyBhdXRvbWF0aWNhbGx5XG5cbiAgTWluaW1hbF9pbmNyZWFzZTogSU5URUdFUiA9IDVcbiAgICAgIC0tIE1pbmltYWwgbnVtYmVyIG9mIGFkZGl0aW9uYWwgaXRlbXNcblxuICBhZGRpdGlvbmFsX3NwYWNlOiBJTlRFR0VSXG4gICAgICAtLSBQcm9wb3NlZCBudW1iZXIgb2YgYWRkaXRpb25hbCBpdGVtc1xuICAgICAgLS18IFJlc3VsdCBpcyBhIHJlYXNvbmFibGUgdmFsdWUsIHJlc3VsdGluZyBmcm9tIGEgc3BhY2UtdGltZSB0cmFkZW9mZi5cbiAgICBkb1xuICAgICAgICAtLSBUbyBwcmV2ZW50IG92ZXJmbG93IHdlIGRvIG5vdCB1c2UgYGdyb3d0aF9wZXJjZW50YWdlJyBidXQgaXRzIGtub3duIHZhbHVlLlxuICAgICAgUmVzdWx0IDo9IChjYXBhY2l0eSAvLyAyKS5tYXggKE1pbmltYWxfaW5jcmVhc2UpXG4gICAgZW5zdXJlXG4gICAgICBBdF9sZWFzdF9vbmU6IFJlc3VsdCA+PSAxXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHJlc2l6YWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGBjYXBhY2l0eScgYmUgY2hhbmdlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGF1dG9tYXRpY19ncm93XG4gICAgICAtLSBDaGFuZ2UgdGhlIGNhcGFjaXR5IHRvIGFjY29tbW9kYXRlIGF0IGxlYXN0XG4gICAgICAtLSBgR3Jvd3RoX3BlcmNlbnRhZ2UnIG1vcmUgaXRlbXMuXG4gICAgICAtLXwgVHJhZGVzIHNwYWNlIGZvciB0aW1lOlxuICAgICAgLS18IGFsbG9jYXRlcyBmYWlybHkgbGFyZ2UgY2h1bmtzIG9mIG1lbW9yeSBidXQgbm90IHZlcnkgb2Z0ZW4uXG4gICAgcmVxdWlyZVxuICAgICAgcmVzaXphYmxlOiByZXNpemFibGVcbiAgICBkb1xuICAgICAgZ3JvdyAoY2FwYWNpdHkgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgIGVuc3VyZVxuICAgICAgaW5jcmVhc2VkX2NhcGFjaXR5OiBjYXBhY2l0eSA+PSBvbGQgY2FwYWNpdHkgKyBvbGQgYWRkaXRpb25hbF9zcGFjZVxuICAgIGVuZFxuXG4gIGdyb3cgKGk6IElOVEVHRVIpXG4gICAgICAtLSBFbnN1cmUgdGhhdCBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgaScuXG4gICAgcmVxdWlyZVxuICAgICAgcmVzaXphYmxlOiByZXNpemFibGVcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NhcGFjaXR5OiBjYXBhY2l0eSA+PSBpXG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gRGVjcmVhc2UgYGNhcGFjaXR5JyB0byB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgIC0tIEFwcGx5IHRvIHJlZHVjZSBhbGxvY2F0ZWQgc3RvcmFnZS5cbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIG1pbmltYWxfY2FwYWNpdHk6IGNhcGFjaXR5ID0gY291bnRcbiAgICBlbmRcblxuaW52YXJpYW50XG5cbiAgaW5jcmVhc2VfYnlfYXRfbGVhc3Rfb25lOiBNaW5pbWFsX2luY3JlYXNlID49IDFcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTIsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJub3RlXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMy0wMy0wNCAxNTowMToyNSAtMDgwMCAoTW9uLCAwNCBNYXIgMjAxMykgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTIxNzggJFwiXG5cbmZyb3plbiBjbGFzc1xuICBTUEVDSUFMIFtUXVxuXG5pbmhlcml0XG4gIEFCU1RSQUNUX1NQRUNJQUxcbiAgICByZWRlZmluZVxuICAgICAgZGVidWdfb3V0cHV0XG4gICAgZW5kXG5cbiAgUkVBREFCTEVfSU5ERVhBQkxFIFtUXVxuXG5jcmVhdGVcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9uYXRpdmVfYXJyYXlcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW5pdGlhbGl6YXRpb25cblxuICBtYWtlX2VtcHR5IChuOiBJTlRFR0VSKVxuICAgICAgLS0gQ3JlYXRlIGEgc3BlY2lhbCBvYmplY3QgZm9yIGBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgY2FwYWNpdHlfc2V0OiBjYXBhY2l0eSA9IG5cbiAgICAgIGNvdW50X3NldDogY291bnQgPSAwXG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKHY6IFQ7IG46IElOVEVHRVIpXG4gICAgICAtLSBDcmVhdGUgYSBzcGVjaWFsIG9iamVjdCBmb3IgYG4nIGVudHJpZXMgaW5pdGlhbGl6ZWQgd2l0aCBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgbWFrZV9lbXB0eSAobilcbiAgICAgIGZpbGxfd2l0aCAodiwgMCwgbiAtIDEpXG4gICAgZW5zdXJlXG4gICAgICBjYXBhY2l0eV9zZXQ6IGNhcGFjaXR5ID0gblxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYsIDAsIG4gLSAxKVxuICAgIGVuZFxuXG4gIG1ha2VfZnJvbV9uYXRpdmVfYXJyYXkgKGFuX2FycmF5OiBsaWtlIG5hdGl2ZV9hcnJheSlcbiAgICAgIC0tIENyZWF0ZSBhIHNwZWNpYWwgb2JqZWN0IGZyb20gYGFuX2FycmF5Jy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgICBhbl9hcnJheV9ub3Rfdm9pZDogYW5fYXJyYXkgLz0gVm9pZFxuICAgIGRvXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIgKGk6IElOVEVHRVIpOiBUIGFzc2lnbiBwdXRcbiAgICAgIC0tIEl0ZW0gYXQgYGknLXRoIHBvc2l0aW9uXG4gICAgICAtLSAoaW5kaWNlcyBiZWdpbiBhdCAwKVxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IFRcbiAgICAgIC0tIEl0ZW0gYXQgYGknLXRoIHBvc2l0aW9uXG4gICAgICAtLSAoaW5kaWNlcyBiZWdpbiBhdCAwKVxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luZGV4OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpXG4gICAgZW5kXG5cbiAgaW5kZXhfb2YgKHY6IFQ7IHN0YXJ0X3Bvc2l0aW9uOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gSW5kZXggb2YgZmlyc3Qgb2NjdXJyZW5jZSBvZiBpdGVtIGlkZW50aWNhbCB0byBgdicuXG4gICAgICAtLSAtMSBpZiBub25lLlxuICAgICAgLS0gKFVzZSBvYmplY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb24uKVxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvc2l0aW9uOiBzdGFydF9wb3NpdGlvbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgUmVzdWx0IDo9IHN0YXJ0X3Bvc2l0aW9uXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICB1bnRpbFxuICAgICAgICBSZXN1bHQgPj0gbmIgb3IgZWxzZSBpdGVtIChSZXN1bHQpIH4gdlxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgZW5kXG4gICAgICBpZiBSZXN1bHQgPj0gbmIgdGhlblxuICAgICAgICBSZXN1bHQgOj0gLTFcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZm91bmRfb3Jfbm90X2ZvdW5kOiBSZXN1bHQgPSAtMSBvciBlbHNlIChSZXN1bHQgPj0gMCBhbmQgdGhlbiBSZXN1bHQgPCBjb3VudClcbiAgICBlbmRcblxuICBpdGVtX2FkZHJlc3MgKGk6IElOVEVHRVIpOiBQT0lOVEVSXG4gICAgICAtLSBBZGRyZXNzIG9mIGVsZW1lbnQgYXQgcG9zaXRpb24gYGknLlxuICAgICAgLS0gVXNlIG9ubHkgd2hlbiBpbnRlcmZhY2luZyB3aXRoIEMgZXh0ZXJuYWxzIHdoZW4gQ3VycmVudCBpcyBndWFyYW50ZWVkIHRvIG5vdCBtb3ZlIGluIG1lbW9yeS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAwXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPCBjb3VudFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYmFzZV9hZGRyZXNzICsgaSAqIGVsZW1lbnRfc2l6ZVxuICAgIGVuc3VyZVxuICAgICAgZWxlbWVudF9hZGRyZXNzX25vdF9udWxsOiBSZXN1bHQgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgZW5kXG5cbiAgYmFzZV9hZGRyZXNzOiBQT0lOVEVSXG4gICAgICAtLSBBZGRyZXNzIG9mIGVsZW1lbnQgYXQgcG9zaXRpb24gYDAnLlxuICAgICAgLS0gVXNlIG9ubHkgd2hlbiBpbnRlcmZhY2luZyB3aXRoIEMgZXh0ZXJuYWxzIHdoZW4gQ3VycmVudCBpcyBndWFyYW50ZWVkIHRvIG5vdCBtb3ZlIGluIG1lbW9yeS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBiYXNlX2FkZHJlc3Nfbm90X251bGw6IFJlc3VsdCAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICBlbmRcblxuICBuYXRpdmVfYXJyYXk6IE5BVElWRV9BUlJBWSBbVF1cbiAgICAgIC0tIE9ubHkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCAuTkVUXG4gICAgcmVxdWlyZVxuICAgICAgaXNfZG90bmV0OiB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0XG4gICAgZW5kXG5cbiAgdG9fYXJyYXk6IEFSUkFZIFtUXVxuICAgICAgLS0gQnVpbGQgYW4gYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgQ3VycmVudCBmcm9tIGAxJyB0byBgY291bnQnLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZnJvbV9zcGVjaWFsIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgdG9fYXJyYXlfYXR0YWNoZWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICB0b19hcnJheV9sb3dlcl9zZXQ6IFJlc3VsdC5sb3dlciA9IDFcbiAgICAgIHRvX2FycmF5X3VwcGVyX3NldDogUmVzdWx0LnVwcGVyID0gY291bnRcbiAgICBlbmRcblxuICBpbmRleF9zZXQ6IElOVEVHRVJfSU5URVJWQUxcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZSAobG93ZXIsIHVwcGVyKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgbG93ZXI6IElOVEVHRVIgPSAwXG4gICAgICAtLSBNaW5pbXVtIGluZGV4IG9mIEN1cnJlbnRcblxuICB1cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleCBvZiBDdXJyZW50XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBjb3VudCAtIDFcbiAgICBlbnN1cmVcbiAgICAgIGRlZmluaXRpb246IGxvd2VyIDw9IFJlc3VsdCArIDFcbiAgICBlbmRcblxuICBjb3VudDogSU5URUdFUlxuICAgICAgLS0gQ291bnQgb2Ygc3BlY2lhbCBhcmVhXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGNhcGFjaXR5OiBJTlRFR0VSXG4gICAgICAtLSBDYXBhY2l0eSBvZiBzcGVjaWFsIGFyZWFcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGZpbGxlZF93aXRoICh2OiBUOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBiZXR3ZWVuIGluZGV4IGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgICAtLSBzZXQgdG8gYHYnP1xuICAgICAgLS0gKFVzZSByZWZlcmVuY2UgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb24uKVxuICAgIHJlcXVpcmVcbiAgICAgIHN0YXJ0X2luZGV4X25vbl9uZWdhdGl2ZTogc3RhcnRfaW5kZXggPj0gMFxuICAgICAgc3RhcnRfaW5kZXhfbm90X3Rvb19iaWc6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDwgY291bnRcbiAgICBsb2NhbFxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBlbmRfaW5kZXggb3IgZWxzZSBub3QgUmVzdWx0XG4gICAgICBsb29wXG4gICAgICAgIFJlc3VsdCA6PSBpdGVtIChpKSA9IHZcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgc2FtZV9pdGVtcyAob3RoZXI6IGxpa2UgQ3VycmVudDsgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSB0aGUgYG4nIGVsZW1lbnRzIG9mIGBvdGhlcicgZnJvbSBgc291cmNlX2luZGV4JyBwb3NpdGlvbiB0aGUgc2FtZSBhc1xuICAgICAgLS0gdGhlIGBuJyBlbGVtZW50cyBvZiBgQ3VycmVudCcgZnJvbSBgZGVzdGluYXRpb25faW5kZXgnP1xuICAgICAgLS0gKFVzZSByZWZlcmVuY2UgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb24uKVxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBzb3VyY2VfaW5kZXhfbm9uX25lZ2F0aXZlOiBzb3VyY2VfaW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfbm9uX25lZ2F0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAwXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IG90aGVyLmNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjb3VudFxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgaWYgb3RoZXIgLz0gQ3VycmVudCB0aGVuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHNvdXJjZV9pbmRleFxuICAgICAgICAgIGogOj0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggKyBuXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBvdGhlci5pdGVtIChpKSAvPSBpdGVtIChqKSB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gRmFsc2VcbiAgICAgICAgICAgIGkgOj0gbmIgLSAxXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX29uX2VtcHR5X2FyZWE6IChuID0gMCkgaW1wbGllcyBSZXN1bHRcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiBDdXJyZW50P1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gKDAgPD0gaSkgYW5kIChpIDwgY291bnQpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRWxlbWVudCBjaGFuZ2VcblxuICBwdXQgKHY6IFQ7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBpdGVtIGJ5IGB2Jy5cbiAgICAgIC0tIChJbmRpY2VzIGJlZ2luIGF0IDAuKVxuICAgIHJlcXVpcmVcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAwXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPCBjb3VudFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IHZcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG4gIGZvcmNlICh2OiBUOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gSWYgYGknIGlzIGVxdWFsIHRvIGBjb3VudCcgaW5jcmVhc2UgYGNvdW50JyBieSBvbmUgYW5kIGluc2VydCBgdicgYXQgaW5kZXggYGNvdW50JyxcbiAgICAgIC0tIG90aGVyd2lzZSByZXBsYWNlIGBpJy10aCBpdGVtIGJ5IGB2Jy5cbiAgICAgIC0tIChJbmRpY2VzIGJlZ2luIGF0IDAuKVxuICAgIHJlcXVpcmVcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+PSAwXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnRcbiAgICAgIG5vdF9mdWxsOiBpID0gY291bnQgaW1wbGllcyBjb3VudCA8IGNhcGFjaXR5XG4gICAgZG9cbiAgICAgIGlmIGkgPCBjb3VudCB0aGVuXG4gICAgICAgIHB1dCAodiwgaSlcbiAgICAgIGVsc2VcbiAgICAgICAgZXh0ZW5kICh2KVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IChpICsgMSkubWF4IChvbGQgY291bnQpXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gdlxuICAgIGVuZFxuXG4gIGV4dGVuZCAodjogVClcbiAgICAgIC0tIEFkZCBgdicgYXQgaW5kZXggYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBjb3VudF9zbWFsbF9lbm91Z2g6IGNvdW50IDwgY2FwYWNpdHlcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBjb3VudF9pbmNyZWFzZWQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGluc2VydGVkOiBpdGVtIChjb3VudCAtIDEpID0gdlxuICAgIGVuZFxuXG4gIGV4dGVuZF9maWxsZWQgKHY6IFQpXG4gICAgICAtLSBTZXQgaXRlbXMgYmV0d2VlbiBgY291bnQnIGFuZCBgY2FwYWNpdHkgLSAxJyB3aXRoIGB2Jy5cbiAgICBkb1xuICAgICAgZmlsbF93aXRoICh2LCBjb3VudCwgY2FwYWNpdHkgLSAxKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X2luY3JlYXNlZDogY291bnQgPSBjYXBhY2l0eVxuICAgICAgZmlsbGVkOiBmaWxsZWRfd2l0aCAodiwgb2xkIGNvdW50LCBjYXBhY2l0eSAtIDEpXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoICh2OiBUOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGl0ZW1zIGJldHdlZW4gYHN0YXJ0X2luZGV4JyBhbmQgYGVuZF9pbmRleCcgd2l0aCBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9pbl9ib3VuZDogc3RhcnRfaW5kZXggPD0gY291bnRcbiAgICAgIHN0YXJ0X2luZGV4X25vdF90b29fYmlnOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8IGNhcGFjaXR5XG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2NvdW50OiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBsX2NvdW50IDo9IGNvdW50Lm1pbiAoZW5kX2luZGV4ICsgMSlcbiAgICAgICAgbmIgOj0gbF9jb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIHB1dCAodiwgaSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbF9jb3VudFxuICAgICAgICBuYiA6PSBlbmRfaW5kZXggKyAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgZXh0ZW5kICh2KVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBjb3VudF9kZWZpbml0aW9uOiBjb3VudCA9IChvbGQgY291bnQpLm1heCAoZW5kX2luZGV4ICsgMSlcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYsIHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoX2RlZmF1bHQgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBDbGVhciBpdGVtcyBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX3NlbGZfaW5pdGlhbGl6aW5nOiAoe1R9KS5oYXNfZGVmYXVsdFxuICAgICAgc3RhcnRfaW5kZXhfbm9uX25lZ2F0aXZlOiBzdGFydF9pbmRleCA+PSAwXG4gICAgICBzdGFydF9pbmRleF9ub3RfdG9vX2JpZzogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPCBjb3VudFxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKCh7VH0pLmRlZmF1bHQsIHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBmaWxsZWQ6IGZpbGxlZF93aXRoICgoe1R9KS5kZWZhdWx0LCBzdGFydF9pbmRleCwgZW5kX2luZGV4KVxuICAgIGVuZFxuXG4gIGluc2VydF9kYXRhIChvdGhlcjogU1BFQ0lBTCBbVF07IHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG46IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYG4nIGVsZW1lbnRzIG9mIGBvdGhlcicgZnJvbSBgc291cmNlX2luZGV4JyBwb3NpdGlvbiB0byBDdXJyZW50IGF0XG4gICAgICAtLSBgZGVzdGluYXRpb25faW5kZXgnIGFuZCBzaGlmdCBlbGVtZW50cyBiZXR3ZWVuIGBkZXN0aW5hdGlvbl9pbmRleCcgYW5kIGBjb3VudCdcbiAgICAgIC0tIHRvIHRoZSByaWdodC4gT3RoZXIgZWxlbWVudHMgb2YgQ3VycmVudCByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICBzb3VyY2VfaW5kZXhfbm9uX25lZ2F0aXZlOiBzb3VyY2VfaW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfbm9uX25lZ2F0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9pbl9ib3VuZDogZGVzdGluYXRpb25faW5kZXggPD0gY291bnRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9zb3VyY2U6IHNvdXJjZV9pbmRleCArIG4gPD0gb3RoZXIuY291bnRcbiAgICAgIG5faXNfc21hbGxfZW5vdWdoX2Zvcl9kZXN0aW5hdGlvbjogY291bnQgKyBuIDw9IGNhcGFjaXR5XG4gICAgICBzYW1lX3R5cGU6IG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KVxuICAgIGxvY2FsXG4gICAgICBsX3JlbWFpbmluZ19pdGVtcywgbF9vZmZzZXQsIGxfbmJfaXRlbXNfbGVmdDogSU5URUdFUlxuICAgICAgbF9zb3VyY2VfaW5kZXgsIGxfZW5kX2luZGV4LCBsX2Rlc3RpbmF0aW9uX2luZGV4OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfcmVtYWluaW5nX2l0ZW1zIDo9IGNvdW50IC0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgIGlmIGxfcmVtYWluaW5nX2l0ZW1zID0gMCB0aGVuXG4gICAgICAgICAgLS0gSXQgaXMgYmVpbmcgYWRkZWQgYXQgdGhlIGVuZCBvZiBDdXJyZW50LCB0aGVyZWZvcmUgd2UgY2FuIHNpbXBseSBleHRlbmQuXG4gICAgICAgIGNvcHlfZGF0YSAob3RoZXIsIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBlbHNlaWYgbiA8PSBsX3JlbWFpbmluZ19pdGVtcyB0aGVuXG4gICAgICAgICAgLS0gU2ltcGxlIGNhc2Ugd2hlcmUgd2UgY2FuIHBlcmZvcm0gYSBtb3ZlIG9mIHRoZSBleGlzdGluZyBpdGVtcyB0byB0aGUgZW5kXG4gICAgICAgICAgLS0gYW5kIHRoZW4gY29weSB0aGUgZWxlbWVudHMgb2YgYG90aGVyJy5cbiAgICAgICAgbW92ZV9kYXRhIChkZXN0aW5hdGlvbl9pbmRleCwgZGVzdGluYXRpb25faW5kZXggKyBuLCBsX3JlbWFpbmluZ19pdGVtcylcbiAgICAgICAgY29weV9kYXRhIChvdGhlciwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBCZWNhdXNlIHdlIGNhbm5vdCBoYXZlIHVuaW5pdGlhbGl6ZWQgaXRlbXMsIHdlIGNhbm5vdCBtb3ZlIGFsbCB0aGUgcmVtYWluaW5nIGl0ZW1zIGJleW9uZCBjb3VudFxuICAgICAgICAgIC0tIGluc3RlYWQgd2UgY29weSBieSBjaHVua3Mgb2YgYGxfcmVtYWluaW5nX2l0ZW1zJy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc291cmNlX2luZGV4IDo9IHNvdXJjZV9pbmRleFxuICAgICAgICAgIGxfZGVzdGluYXRpb25faW5kZXggOj0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgICAgICBsX2VuZF9pbmRleCA6PSBzb3VyY2VfaW5kZXggKyBuXG4gICAgICAgICAgbF9uYl9pdGVtc19sZWZ0IDo9IG5cbiAgICAgICAgICBsX29mZnNldCA6PSBsX3JlbWFpbmluZ19pdGVtc1xuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc291cmNlX2luZGV4ID49IGxfZW5kX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBtb3ZlX2RhdGEgKGxfZGVzdGluYXRpb25faW5kZXgsIGxfZGVzdGluYXRpb25faW5kZXggKyBsX29mZnNldCwgbF9yZW1haW5pbmdfaXRlbXMpXG4gICAgICAgICAgY29weV9kYXRhIChvdGhlciwgbF9zb3VyY2VfaW5kZXgsIGxfZGVzdGluYXRpb25faW5kZXgsIGxfb2Zmc2V0KVxuICAgICAgICAgIGxfZGVzdGluYXRpb25faW5kZXggOj0gbF9kZXN0aW5hdGlvbl9pbmRleCArIGxfb2Zmc2V0XG4gICAgICAgICAgbF9zb3VyY2VfaW5kZXggOj0gbF9zb3VyY2VfaW5kZXggKyBsX29mZnNldFxuICAgICAgICAgICAgLS0gQ29tcHV0ZSBob3cgbWFueSBtb3JlIGl0ZW1zIHdlIGhhdmUgdG8gY29weS5cbiAgICAgICAgICBsX25iX2l0ZW1zX2xlZnQgOj0gbF9uYl9pdGVtc19sZWZ0IC0gbF9yZW1haW5pbmdfaXRlbXNcbiAgICAgICAgICBsX29mZnNldCA6PSBsX29mZnNldC5taW4gKGxfbmJfaXRlbXNfbGVmdClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGNvcGllZDogc2FtZV9pdGVtcyAob3RoZXIsIHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICBjb3VudF91cGRhdGVkOiBjb3VudCA9IG9sZCBjb3VudCArIG5cbiAgICBlbmRcblxuICBjb3B5X2RhdGEgKG90aGVyOiBTUEVDSUFMIFtUXTsgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIENvcHkgYG4nIGVsZW1lbnRzIG9mIGBvdGhlcicgZnJvbSBgc291cmNlX2luZGV4JyBwb3NpdGlvbiB0byBDdXJyZW50IGF0XG4gICAgICAtLSBgZGVzdGluYXRpb25faW5kZXgnLiBPdGhlciBlbGVtZW50cyBvZiBDdXJyZW50IHJlbWFpbiB1bmNoYW5nZWQuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBvdGhlci5jb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPD0gY2FwYWNpdHlcbiAgICAgIHNhbWVfdHlwZTogb3RoZXIuY29uZm9ybXNfdG8gKEN1cnJlbnQpXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIG1vdmVfZGF0YSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gc291cmNlX2luZGV4XG4gICAgICAgICAgaiA6PSBkZXN0aW5hdGlvbl9pbmRleFxuICAgICAgICAgIG5iIDo9IHNvdXJjZV9pbmRleCArIG5cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGZvcmNlIChvdGhlci5pdGVtIChpKSwgailcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgY29waWVkOiBzYW1lX2l0ZW1zIChvdGhlciwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gKG9sZCBjb3VudCkubWF4IChkZXN0aW5hdGlvbl9pbmRleCArIG4pXG4gICAgZW5kXG5cbiAgbW92ZV9kYXRhIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuOiBJTlRFR0VSKVxuICAgICAgLS0gTW92ZSBgbicgZWxlbWVudHMgb2YgQ3VycmVudCBmcm9tIGBzb3VyY2Vfc3RhcnQnIHBvc2l0aW9uIHRvIGBkZXN0aW5hdGlvbl9pbmRleCcuXG4gICAgICAtLSBPdGhlciBlbGVtZW50cyByZW1haW4gdW5jaGFuZ2VkLlxuICAgIHJlcXVpcmVcbiAgICAgIHNvdXJjZV9pbmRleF9ub25fbmVnYXRpdmU6IHNvdXJjZV9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9ub25fbmVnYXRpdmU6IGRlc3RpbmF0aW9uX2luZGV4ID49IDBcbiAgICAgIGRlc3RpbmF0aW9uX2luZGV4X2luX2JvdW5kOiBkZXN0aW5hdGlvbl9pbmRleCA8PSBjb3VudFxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBjb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPD0gY2FwYWNpdHlcbiAgICBkb1xuICAgICAgaWYgc291cmNlX2luZGV4ID0gZGVzdGluYXRpb25faW5kZXggdGhlblxuICAgICAgZWxzZWlmIHNvdXJjZV9pbmRleCA+IGRlc3RpbmF0aW9uX2luZGV4IHRoZW5cbiAgICAgICAgaWYgZGVzdGluYXRpb25faW5kZXggKyBuIDwgc291cmNlX2luZGV4IHRoZW5cbiAgICAgICAgICBub25fb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgICAgZWxzZVxuICAgICAgICAgIG92ZXJsYXBwaW5nX21vdmUgKHNvdXJjZV9pbmRleCwgZGVzdGluYXRpb25faW5kZXgsIG4pXG4gICAgICAgIGVuZFxuICAgICAgZWxzZVxuICAgICAgICBpZiBzb3VyY2VfaW5kZXggKyBuIDwgZGVzdGluYXRpb25faW5kZXggdGhlblxuICAgICAgICAgIG5vbl9vdmVybGFwcGluZ19tb3ZlIChzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG1vdmVkOiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbilcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gKG9sZCBjb3VudCkubWF4IChkZXN0aW5hdGlvbl9pbmRleCArIG4pXG4gICAgZW5kXG5cbiAgb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIE1vdmUgYG4nIGVsZW1lbnRzIG9mIEN1cnJlbnQgZnJvbSBgc291cmNlX3N0YXJ0JyBwb3NpdGlvbiB0byBgZGVzdGluYXRpb25faW5kZXgnLlxuICAgICAgLS0gT3RoZXIgZWxlbWVudHMgcmVtYWluIHVuY2hhbmdlZC5cbiAgICByZXF1aXJlXG4gICAgICBzb3VyY2VfaW5kZXhfbm9uX25lZ2F0aXZlOiBzb3VyY2VfaW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfbm9uX25lZ2F0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9pbl9ib3VuZDogZGVzdGluYXRpb25faW5kZXggPD0gY291bnRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIGRpZmZlcmVudF9zb3VyY2VfYW5kX3RhcmdldDogc291cmNlX2luZGV4IC89IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3Jfc291cmNlOiBzb3VyY2VfaW5kZXggKyBuIDw9IGNvdW50XG4gICAgICBuX2lzX3NtYWxsX2Vub3VnaF9mb3JfZGVzdGluYXRpb246IGRlc3RpbmF0aW9uX2luZGV4ICsgbiA8PSBjYXBhY2l0eVxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgc291cmNlX2luZGV4IDwgZGVzdGluYXRpb25faW5kZXggdGhlblxuICAgICAgICAgIC0tIFdlIHNoaWZ0IGZyb20gbGVmdCB0byByaWdodCBzdGFydGluZyBmcm9tIHRoZSBlbmRcbiAgICAgICAgICAtLSBkdWUgdG8gcG9zc2libGUgb3ZlcmxhcHBpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHNvdXJjZV9pbmRleCArIG4gLSAxXG4gICAgICAgICAgbmIgOj0gc291cmNlX2luZGV4IC0gMVxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGRlc3RpbmF0aW9uX2luZGV4IC0gc291cmNlX2luZGV4XG4gICAgICAgICAgaWYgKGRlc3RpbmF0aW9uX2luZGV4ICsgbiA+PSBjb3VudCkgdGhlblxuICAgICAgICAgICAgICAtLSBJbml0aWFsaXplIGVsZW1lbnRzIGFib3ZlIGBjb3VudCcgdG8gYSBkdW1teSBpdGVtLlxuICAgICAgICAgICAgZmlsbF93aXRoIChpdGVtIChzb3VyY2VfaW5kZXgpLCBjb3VudCwgZGVzdGluYXRpb25faW5kZXggKyBuIC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgbF9vZmZzZXRfcG9zaXRpdmU6IGxfb2Zmc2V0ID4gMFxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0IChpdGVtIChpKSwgaSArIGxfb2Zmc2V0KVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gV2Ugc2hpZnQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzb3VyY2VfaW5kZXhcbiAgICAgICAgICBuYiA6PSBzb3VyY2VfaW5kZXggKyBuXG4gICAgICAgICAgbF9vZmZzZXQgOj0gc291cmNlX2luZGV4IC0gZGVzdGluYXRpb25faW5kZXhcbiAgICAgICAgICBjaGVja1xuICAgICAgICAgICAgbF9vZmZzZXRfcG9zaXRpdmU6IGxfb2Zmc2V0ID4gMFxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgZm9yY2UgKGl0ZW0gKGkpLCBpIC0gbF9vZmZzZXQpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbW92ZWQ6IHNhbWVfaXRlbXMgKG9sZCB0d2luLCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGRlc3RpbmF0aW9uX2luZGV4ICsgbilcbiAgICBlbmRcblxuICBub25fb3ZlcmxhcHBpbmdfbW92ZSAoc291cmNlX2luZGV4LCBkZXN0aW5hdGlvbl9pbmRleCwgbjogSU5URUdFUilcbiAgICAgIC0tIE1vdmUgYG4nIGVsZW1lbnRzIG9mIEN1cnJlbnQgZnJvbSBgc291cmNlX3N0YXJ0JyBwb3NpdGlvbiB0byBgZGVzdGluYXRpb25faW5kZXgnLlxuICAgICAgLS0gT3RoZXIgZWxlbWVudHMgcmVtYWluIHVuY2hhbmdlZC5cbiAgICByZXF1aXJlXG4gICAgICBzb3VyY2VfaW5kZXhfbm9uX25lZ2F0aXZlOiBzb3VyY2VfaW5kZXggPj0gMFxuICAgICAgZGVzdGluYXRpb25faW5kZXhfbm9uX25lZ2F0aXZlOiBkZXN0aW5hdGlvbl9pbmRleCA+PSAwXG4gICAgICBkZXN0aW5hdGlvbl9pbmRleF9pbl9ib3VuZDogZGVzdGluYXRpb25faW5kZXggPD0gY291bnRcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICAgIGRpZmZlcmVudF9zb3VyY2VfYW5kX3RhcmdldDogc291cmNlX2luZGV4IC89IGRlc3RpbmF0aW9uX2luZGV4XG4gICAgICBub25fb3ZlcmxhcHBpbmc6XG4gICAgICAgIChzb3VyY2VfaW5kZXggPCBkZXN0aW5hdGlvbl9pbmRleCBpbXBsaWVzIHNvdXJjZV9pbmRleCArIG4gPCBkZXN0aW5hdGlvbl9pbmRleCkgb3JcbiAgICAgICAgKHNvdXJjZV9pbmRleCA+IGRlc3RpbmF0aW9uX2luZGV4IGltcGxpZXMgZGVzdGluYXRpb25faW5kZXggKyBuIDwgc291cmNlX2luZGV4KVxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX3NvdXJjZTogc291cmNlX2luZGV4ICsgbiA8PSBjb3VudFxuICAgICAgbl9pc19zbWFsbF9lbm91Z2hfZm9yX2Rlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbl9pbmRleCArIG4gPD0gY2FwYWNpdHlcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzb3VyY2VfaW5kZXhcbiAgICAgICAgbmIgOj0gc291cmNlX2luZGV4ICsgblxuICAgICAgICBsX29mZnNldCA6PSBkZXN0aW5hdGlvbl9pbmRleCAtIHNvdXJjZV9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGZvcmNlIChpdGVtIChpKSwgaSArIGxfb2Zmc2V0KVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG1vdmVkOiBzYW1lX2l0ZW1zIChDdXJyZW50LCBzb3VyY2VfaW5kZXgsIGRlc3RpbmF0aW9uX2luZGV4LCBuKVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSAob2xkIGNvdW50KS5tYXggKGRlc3RpbmF0aW9uX2luZGV4ICsgbilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZXNpemluZ1xuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIEtlZXAgdGhlIGZpcnN0IGBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgICBsZXNzX3RoYW5fY291bnQ6IG4gPD0gY291bnRcbiAgICBkb1xuICAgICAgc2V0X2NvdW50IChuKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBuXG4gICAgICBrZXB0OiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgMCwgMCwgbilcbiAgICBlbmRcblxuICBrZWVwX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBLZWVwIHRoZSBsYXN0IGBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgICBsZXNzX3RoYW5fY291bnQ6IG4gPD0gY291bnRcbiAgICBkb1xuICAgICAgb3ZlcmxhcHBpbmdfbW92ZSAoY291bnQgLSBuLCAwLCBuKVxuICAgICAgc2V0X2NvdW50IChuKVxuICAgIGVuc3VyZVxuICAgICAgY291bnRfdXBkYXRlZDogY291bnQgPSBuXG4gICAgICBrZXB0OiBzYW1lX2l0ZW1zIChvbGQgdHdpbiwgbiwgMCwgbilcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSB0aGUgZmlyc3QgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICAgIGxlc3NfdGhhbl9jb3VudDogbiA8PSBjb3VudFxuICAgIGRvXG4gICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gb2xkIGNvdW50IC0gblxuICAgICAga2VwdDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIG4sIDAsIGNvdW50KVxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gS2VlcCB0aGUgZmlyc3QgIGBjb3VudCAtIG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICAgIGxlc3NfdGhhbl9jb3VudDogbiA8PSBjb3VudFxuICAgIGRvXG4gICAgICBrZWVwX2hlYWQgKGNvdW50IC0gbilcbiAgICBlbnN1cmVcbiAgICAgIGNvdW50X3VwZGF0ZWQ6IGNvdW50ID0gb2xkIGNvdW50IC0gblxuICAgICAga2VwdDogc2FtZV9pdGVtcyAob2xkIHR3aW4sIDAsIDAsIGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZWRfYXJlYSAobjogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ3JlYXRlIGEgY29weSBvZiBDdXJyZW50IHdpdGggYSBjb3VudCBvZiBgbidcbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAobilcbiAgICAgIFJlc3VsdC5jb3B5X2RhdGEgKEN1cnJlbnQsIDAsIDAsIG4ubWluIChjb3VudCkpXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBSZXN1bHRfZGlmZmVyZW50X2Zyb21fY3VycmVudDogUmVzdWx0IC89IEN1cnJlbnRcbiAgICAgIG5ld19jb3VudDogUmVzdWx0LmNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIG5ld19jYXBhY2l0eTogUmVzdWx0LmNhcGFjaXR5ID0gblxuICAgICAgcHJlc2VydmVkOiBSZXN1bHQuc2FtZV9pdGVtcyAoQ3VycmVudCwgMCwgMCwgbi5taW4gKG9sZCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoYV9kZWZhdWx0X3ZhbHVlOiBUOyBuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBDcmVhdGUgYSBjb3B5IG9mIEN1cnJlbnQgd2l0aCBhIGNvdW50IG9mIGBuJyB3aGVyZSBub3QgeWV0IGluaXRpYWxpemVkXG4gICAgICAtLSBlbnRyaWVzIGFyZSBzZXQgdG8gYGFfZGVmYXVsdF92YWx1ZScuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHkgKG4pXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBSZXN1bHQuY29weV9kYXRhIChDdXJyZW50LCAwLCAwLCBjb3VudClcbiAgICAgICAgUmVzdWx0LmZpbGxfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlLCBjb3VudCwgbiAtIDEpXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdC5jb3B5X2RhdGEgKEN1cnJlbnQsIDAsIDAsIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIFJlc3VsdF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICAgIFJlc3VsdF9kaWZmZXJlbnRfZnJvbV9jdXJyZW50OiBSZXN1bHQgLz0gQ3VycmVudFxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuXG4gICAgICBuZXdfY2FwYWNpdHk6IFJlc3VsdC5jYXBhY2l0eSA9IG5cbiAgICAgIHByZXNlcnZlZDogUmVzdWx0LnNhbWVfaXRlbXMgKEN1cnJlbnQsIDAsIDAsIG4ubWluIChvbGQgY291bnQpKVxuICAgIGVuZFxuXG4gIGFsaWFzZWRfcmVzaXplZF9hcmVhIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBUcnkgdG8gcmVzaXplIGBDdXJyZW50JyB3aXRoIGEgY291bnQgb2YgYG4nLCBpZiBub3RcbiAgICAgIC0tIHBvc3NpYmxlIGEgbmV3IGNvcHlcbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgUmVzdWx0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgbmV3X2NvdW50OiBSZXN1bHQuY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAgbmV3X2NhcGFjaXR5OiBSZXN1bHQuY2FwYWNpdHkgPSBuXG4gICAgICBwcmVzZXJ2ZWQ6IFJlc3VsdC5zYW1lX2l0ZW1zIChvbGQgdHdpbiwgMCwgMCwgbi5taW4gKG9sZCBjb3VudCkpXG4gICAgZW5kXG5cbiAgYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0IChhX2RlZmF1bHRfdmFsdWU6IFQ7IG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIFRyeSB0byByZXNpemUgYEN1cnJlbnQnIHdpdGggYSBjb3VudCBvZiBgbicsIGlmIG5vdFxuICAgICAgLS0gcG9zc2libGUgYSBuZXcgY29weS4gTm9uIHlldCBpbml0aWFsaXplZCBlbnRyaWVzIGFyZSBzZXQgdG8gYGFfZGVmYXVsdF92YWx1ZScuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBSZXN1bHQuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIFJlc3VsdC5jb3VudCwgbiAtIDEpXG4gICAgZW5zdXJlXG4gICAgICBSZXN1bHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBuZXdfY291bnQ6IFJlc3VsdC5jb3VudCA9IG5cbiAgICAgIG5ld19jYXBhY2l0eTogUmVzdWx0LmNhcGFjaXR5ID0gblxuICAgICAgcHJlc2VydmVkOiBSZXN1bHQuc2FtZV9pdGVtcyAob2xkIHR3aW4sIDAsIDAsIG4ubWluIChvbGQgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZXBsYWNlX2FsbCAodjogVClcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGl0ZW1zIHdpdGggYHYnLlxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBjb3VudCAtIDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwXG4gICAgICBsb29wXG4gICAgICAgIHB1dCAodiwgaSlcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBjbGVhcmVkOiBmaWxsZWRfd2l0aCAodiwgMCwgdXBwZXIpXG4gICAgZW5kXG5cbiAgd2lwZV9vdXRcbiAgICAgIC0tIFJlc2V0IGNvdW50IHRvIHplcm8uXG4gICAgZG9cbiAgICAgIHNldF9jb3VudCAoMClcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgICBjb3VudF9yZXNldDogY291bnQgPSAwXG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiQmVjYXVzZSBvZiB0aGUgbmV3IHByZWNvbmRpdGlvbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGBmaWxsX3dpdGgnIGluc3RlYWQuXCJcbiAgICByZXF1aXJlXG4gICAgICBoYXNfZGVmYXVsdDogKHtUfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgZmlsbF93aXRoX2RlZmF1bHQgKDAsIHVwcGVyKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICAgIGNvdW50X3Jlc2V0OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEl0ZXJhdGlvblxuXG4gIGRvX2FsbF9pbl9ib3VuZHMgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtUXV07IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIG5iIDo9IGVuZF9pbmRleFxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbaXRlbSAoaSldKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl9pbl9ib3VuZHMgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtUXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtUXSwgQk9PTEVBTl07IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYlxuICAgICAgbG9vcFxuICAgICAgICBpZiB0ZXN0Lml0ZW0gKFtpdGVtIChpKV0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2l0ZW0gKGkpXSlcbiAgICAgICAgZW5kXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRoZXJlX2V4aXN0c19pbl9ib3VuZHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtUXSwgQk9PTEVBTl07IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICBuYiA6PSBlbmRfaW5kZXhcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgIGxvb3BcbiAgICAgICAgUmVzdWx0IDo9IHRlc3QuaXRlbSAoW2l0ZW0gKGkpXSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZm9yX2FsbF9pbl9ib3VuZHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtUXSwgQk9PTEVBTl07IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYWxsIGl0ZW1zP1xuICAgIHJlcXVpcmVcbiAgICAgIHRlc3Rfbm90X3ZvaWQ6IHRlc3QgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gc3RhcnRfaW5kZXhcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmIgb3Igbm90IFJlc3VsdFxuICAgICAgbG9vcFxuICAgICAgICBSZXN1bHQgOj0gdGVzdC5pdGVtIChbaXRlbSAoaSldKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19hbGxfd2l0aF9pbmRleF9pbl9ib3VuZHMgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtULCBJTlRFR0VSXV07IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtLCBmcm9tIGZpcnN0IHRvIGxhc3QuXG4gICAgICAtLSBgYWN0aW9uJyByZWNlaXZlcyBpdGVtIGFuZCBpdHMgaW5kZXguXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgY2hhbmdlcyB0aGUgc3RydWN0dXJlO1xuICAgICAgLS0gaW4gc3VjaCBhIGNhc2UsIGFwcGx5IGl0ZXJhdG9yIHRvIGNsb25lIG9mIHN0cnVjdHVyZSBpbnN0ZWFkLlxuICAgIHJlcXVpcmVcbiAgICAgIGFjdGlvbl9ub3Rfdm9pZDogYWN0aW9uIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGogOj0gbG93ZXJcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtIChpKSwgal0pXG4gICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZG9faWZfd2l0aF9pbmRleF9pbl9ib3VuZHMgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtULCBJTlRFR0VSXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtULCBJTlRFR0VSXSwgQk9PTEVBTl07IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gYGFjdGlvbicgYW5kIGB0ZXN0JyByZWNlaXZlIHRoZSBpdGVtIGFuZCBpdHMgaW5kZXguXG4gICAgICAtLSBTZW1hbnRpY3Mgbm90IGd1YXJhbnRlZWQgaWYgYGFjdGlvbicgb3IgYHRlc3QnIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgIGogOj0gbG93ZXJcbiAgICAgICAgbmIgOj0gZW5kX2luZGV4XG4gICAgICB1bnRpbFxuICAgICAgICBpID4gbmJcbiAgICAgIGxvb3BcbiAgICAgICAgaWYgdGVzdC5pdGVtIChbaXRlbSAoaSksIGpdKSB0aGVuXG4gICAgICAgICAgYWN0aW9uLmNhbGwgKFtpdGVtIChpKSwgal0pXG4gICAgICAgIGVuZFxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE91dHB1dFxuXG4gIGRlYnVnX291dHB1dDogU1RSSU5HXG4gICAgICAtLSBTdHJpbmcgdGhhdCBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRlYnVnZ2VyIHRvIHJlcHJlc2VudCBgQ3VycmVudCcuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBQcmVjdXJzb3JcbiAgICAgIFJlc3VsdC5hcHBlbmRfc3RyaW5nIChcIiwgY2FwYWNpdHk9XCIpXG4gICAgICBSZXN1bHQuYXBwZW5kX2ludGVnZXIgKGNhcGFjaXR5KVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVsZW1lbnRfc2l6ZTogSU5URUdFUlxuICAgICAgLS0gU2l6ZSBvZiBlbGVtZW50c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIGVsZW1lbnRfc2l6ZV9ub25fbmVnYXRpdmU6IFJlc3VsdCA+PSAwXG4gICAgZW5kXG5cbiAgc2V0X2NvdW50IChuOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBjb3VudCcgd2l0aCBgbicuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgICAgdmFsaWRfbmV3X2NvdW50OiBuIDw9IGNvdW50XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgY291bnRfc2V0OiBjb3VudCA9IG5cbiAgICAgIGNhcGFjaXR5X3ByZXNlcnZlZDogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuaW52YXJpYW50XG4gIGNvdW50X2xlc3NfdGhhbl9jYXBhY2l0eTogY291bnQgPD0gY2FwYWNpdHlcblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTMsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iLCJjbGFzc1xuICBTVFJJTkdcblxuaW5oZXJpdFxuICBSRUFEQUJMRV9TVFJJTkdfMzJcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGV4cG9ydFxuICAgICAge0FOWX0gbWFrZSwgbWFrZV9lbXB0eSwgbWFrZV9maWxsZWQsIG1ha2VfZnJvbV9jLCBtYWtlX2Zyb21fc3RyaW5nLCBmaWxsX2NoYXJhY3RlclxuICAgIGVuZFxuXG4gIFNUUklOR19HRU5FUkFMXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGhhcywgaW5kZXhfb2YsIGxhc3RfaW5kZXhfb2YsIG9jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWxcbiAgICByZW5hbWVcbiAgICAgIGFwcGVuZCBhcyBhcHBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBhcHBlbmRfc3Vic3RyaW5nIGFzIGFwcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmQgYXMgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3Vic3RyaW5nIGFzIHByZXBlbmRfc3Vic3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsXG4gICAgZW5kXG5cbiAgSU5ERVhBQkxFIFtDSEFSQUNURVJfMzIsIElOVEVHRVJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsLFxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFJFU0laQUJMRSBbQ0hBUkFDVEVSXzMyXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGl0ZW0sIGF0LCBwdXQsIHZhbGlkX2luZGV4XG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBlbmRcblxuICBNSVNNQVRDSF9DT1JSRUNUT1JcbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBjb3JyZWN0X21pc21hdGNoXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBtYWtlLFxuICBtYWtlX2VtcHR5LFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX3N0cmluZyxcbiAgbWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsLFxuICBtYWtlX2Zyb21fYyxcbiAgbWFrZV9mcm9tX2NfcG9pbnRlcixcbiAgbWFrZV9mcm9tX2NpbFxuXG5jb252ZXJ0XG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9LFxuICBtYWtlX2Zyb21fY2lsICh7U1lTVEVNX1NUUklOR30pLFxuICBhc19zdHJpbmdfODoge1JFQURBQkxFX1NUUklOR184LCBTVFJJTkdfOH1cblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIHMzMiB0aGVuXG4gICAgICAgIG1ha2VfZnJvbV9zdHJpbmcgKHMzMilcbiAgICAgIGVsc2VcbiAgICAgICAgbWFrZSAocy5jb3VudClcbiAgICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gYV9zeXN0ZW1fc3RyaW5nLmxlbmd0aCArIGRvdG5ldF9jb252ZXJ0b3IuZXNjYXBlX2NvdW50IChhX3N5c3RlbV9zdHJpbmcpXG4gICAgICBlbmRcbiAgICAgIG1ha2UgKGxfY291bnQpXG4gICAgICBpZiBsX2NvdW50ID4gMCBhbmQgdGhlbiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZG90bmV0X2NvbnZlcnRvci5yZWFkX3N5c3RlbV9zdHJpbmdfaW50byAoYV9zeXN0ZW1fc3RyaW5nLCBDdXJyZW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvbV9jIChjX3N0cmluZzogUE9JTlRFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyIChjX3N0cmluZylcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N0cmluZ19pbnRvIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgbm9femVyb19ieXRlOiBub3QgaGFzICgnJS8wLycpXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgICAtLSBjb3JyZWN0X2NvdW50OiB0aGUgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyBjb3VudFxuICAgICAgLS0gICAgICAgaXMgTlVMTFxuICAgIGVuZFxuXG4gIGZyb21fY19zdWJzdHJpbmcgKGNfc3RyaW5nOiBQT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBzdWJzdHJpbmcgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoY19zdHJpbmcgKyAoc3RhcnRfcG9zIC0gMSksIGxfY291bnQpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdWJzdHJpbmdfaW50byAoQ3VycmVudCwgMSwgbF9jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NvdW50OiBjb3VudCA9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgZW5kXG5cbiAgYWRhcHQgKHM6IFNUUklOR18zMik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT2JqZWN0IG9mIGEgdHlwZSBjb25mb3JtaW5nIHRvIHRoZSB0eXBlIG9mIGBzJyxcbiAgICAgIC0tIGluaXRpYWxpemVkIHdpdGggYXR0cmlidXRlcyBmcm9tIGBzJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoMClcbiAgICAgIFJlc3VsdC5zaGFyZSAocylcbiAgICBlbnN1cmVcbiAgICAgIGFkYXB0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBSZXN1bHQuc2hhcmVkX3dpdGggKHMpXG4gICAgZW5kXG5cbiAgcmVtYWtlIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZScgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX3NpemU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nOiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyIGFzc2lnbiBwdXRcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpXG4gICAgZW5kXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLmNvZGUudG9fbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJEdWUgdG8gcG90ZW50aWFsIHRydW5jYXRpb24gaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGBjb2RlIChpKScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSkubmF0dXJhbF8zMl9jb2RlLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkPyAoQW5zd2VyOiB5ZXMuKVxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBCT09MRUFOID0gRmFsc2VcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldCAodDogUkVBREFCTEVfU1RSSU5HXzMyOyBuMSwgbjI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgY3VycmVudCBzdHJpbmcgdG8gc3Vic3RyaW5nIG9mIGB0JyBmcm9tIGluZGljZXMgYG4xJ1xuICAgICAgLS0gdG8gYG4yJywgb3IgdG8gZW1wdHkgc3RyaW5nIGlmIG5vIHN1Y2ggc3Vic3RyaW5nLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiB0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgczogUkVBREFCTEVfU1RSSU5HXzMyXG4gICAgZG9cbiAgICAgIHMgOj0gdC5zdWJzdHJpbmcgKG4xLCBuMilcbiAgICAgIGFyZWEgOj0gcy5hcmVhXG4gICAgICBjb3VudCA6PSBzLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgaXNfc3Vic3RyaW5nOiBzYW1lX3N0cmluZyAodC5zdWJzdHJpbmcgKG4xLCBuMikpXG4gICAgZW5kXG5cbiAgc3ViY29weSAob3RoZXI6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIHRvIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgICBlbm91Z2hfc3BhY2U6IChjb3VudCAtIGluZGV4X3BvcykgPj0gKGVuZF9wb3MgLSBzdGFydF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGxfb3RoZXJfYXJlYSwgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgZW5kX3BvcyA+PSBzdGFydF9wb3MgdGhlblxuICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpZiBsX2FyZWEgLz0gbF9vdGhlcl9hcmVhIHRoZW5cbiAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX290aGVyX2FyZWEsIHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY29waWVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaW5kZXhfcG9zIC0gMSkgK1xuICAgICAgICBvbGQgb3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpICtcbiAgICAgICAgb2xkIHN1YnN0cmluZyAoaW5kZXhfcG9zICsgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKSwgY291bnQpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4JyB0byBgZW5kX2luZGV4JyB3aXRoIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsbF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgZGlmZjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIHNfY291bnQ6IElOVEVHRVJcbiAgICAgIG9sZF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBzX2NvdW50IDo9IHMuY291bnRcbiAgICAgIG9sZF9jb3VudCA6PSBjb3VudFxuICAgICAgZGlmZiA6PSBzX2NvdW50IC0gKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIG5ld19zaXplIDo9IGRpZmYgKyBvbGRfY291bnRcbiAgICAgIGlmIGRpZmYgPiAwIHRoZW5cbiAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSB0aGUgc3RyaW5nLlxuICAgICAgICBncm93IChuZXdfc2l6ZSlcbiAgICAgIGVuZFxuXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAtLXwgV2UgbW92ZSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgZm9yd2FyZCAoaWYgZGlmZiBpcyA+IDApLCBiYWNrd2FyZCAoaWYgZGlmZiA8IDApLFxuICAgICAgICAtLXwgYW5kIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICAgICAgaWYgZGlmZiAvPSAwIHRoZW5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKGVuZF9pbmRleCwgZW5kX2luZGV4ICsgZGlmZiwgb2xkX2NvdW50IC0gZW5kX2luZGV4KVxuICAgICAgZW5kXG4gICAgICAgIC0tfCBTZXQgbmV3IGNvdW50XG4gICAgICBzZXRfY291bnQgKG5ld19zaXplKVxuICAgICAgICAtLXwgV2UgY29weSB0aGUgc3Vic3RyaW5nLlxuICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHN0YXJ0X2luZGV4IC0gMSwgc19jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudCAtIGVuZF9pbmRleCArIHN0YXJ0X2luZGV4IC0gMVxuICAgICAgcmVwbGFjZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgKHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArXG4gICAgICAgICAgcyArIHN1YnN0cmluZyAoZW5kX2luZGV4ICsgMSwgY291bnQpKSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmdfYWxsIChvcmlnaW5hbCwgbmV3OiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IG9jY3VycmVuY2Ugb2YgYG9yaWdpbmFsJyB3aXRoIGBuZXcnLlxuICAgIHJlcXVpcmVcbiAgICAgIG9yaWdpbmFsX2V4aXN0czogb3JpZ2luYWwgLz0gVm9pZFxuICAgICAgbmV3X2V4aXN0czogbmV3IC89IFZvaWRcbiAgICAgIG9yaWdpbmFsX25vdF9lbXB0eTogbm90IG9yaWdpbmFsLmlzX2VtcHR5XG4gICAgZXh0ZXJuXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBsX2NvdW50IC89IDAgdGhlblxuICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYywgMCwgbF9jb3VudCAtIDEpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgcmVwbGFjZV9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBmaWxsX3dpdGgnIGluc3RlYWQnXCJcbiAgICBkb1xuICAgICAgZmlsbF93aXRoIChjKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgZmlyc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBkb1xuICAgICAgaWYgbiA8IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBsb2NhbFxuICAgICAgbmI6IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsZWZ0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgbmIsIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBuYl9zcGFjZSA+IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKG5iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50IHZhbHVlLlxuICAgICAgICBuYiA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYl9zcGFjZSwgMCwgbmIpXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgaSA6PSBuYlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA8IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbm90IGxfcHJvcC5pc19zcGFjZSAoYykgdGhlblxuICAgICAgICAgICAgLS0gV2UgYXJlIGRvbmUuXG4gICAgICAgICAgaSA6PSAtMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzaGFyZSAob3RoZXI6IFNUUklOR18zMilcbiAgICAgIC0tIE1ha2UgY3VycmVudCBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJy5cbiAgICAgIC0tIFN1YnNlcXVlbnQgY2hhbmdlcyB0byB0aGUgY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZ1xuICAgICAgLS0gd2lsbCBhbHNvIGFmZmVjdCBgb3RoZXInLCBhbmQgY29udmVyc2VseS5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgIGNvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkX2NvdW50OiBvdGhlci5jb3VudCA9IGNvdW50XG4gICAgICBzaGFyZWRfYXJlYTogb3RoZXIuYXJlYSA9IGFyZWFcbiAgICBlbmRcblxuICBwdXQgKGM6IENIQVJBQ1RFUl8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfMzIsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBwcmVwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcmVjZWRlLCBwcmVwZW5kX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gQWRkIGBjJyBhdCBmcm9udC5cbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIDEsIGNvdW50KVxuICAgICAgbF9hcmVhLnB1dCAoYywgMClcbiAgICAgIGNvdW50IDo9IGNvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgZW5kXG5cbiAgcHJlcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBvZiBjdXJyZW50LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgbF9zX2NvdW50LCBjb3VudClcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBiZWdpbm5pbmcuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCAwLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoaS5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBwcmVwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBhcHBlbmQgKGxfczMyKVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSkpXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChjb3VudCArIHMuY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGFwcGVuZGVkOiBzIC89IFZvaWQgaW1wbGllc1xuICAgICAgICAoZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHR3aW4gKyBvbGQgcy50d2luKSlcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfOCAoaTogSU5URUdFUl84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfOH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzY0IChpOiBJTlRFR0VSXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8zMiAoaTogTkFUVVJBTF8zMilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMzJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF82NCAoaTogTkFUVVJBTF82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWEucHV0IChjLCBjdXJyZW50X2NvdW50KVxuICAgICAgY291bnQgOj0gY3VycmVudF9jb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBpbnNlcnQgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEFkZCBgcycgdG8gbGVmdCBvZiBwb3NpdGlvbiBgaScgaW4gY3VycmVudCBzdHJpbmcuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGluc2VydF9zdHJpbmcnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50ICsgMVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID4gMFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCBpKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkgKyBvbGQgKHMudHdpbikgKyBvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIGluc2VydF9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICBuZXdfc2l6ZSA6PSAxICsgY291bnRcbiAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgIHBvcyA6PSBpIC0gMVxuICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIDEsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgIC0tIEluc2VydCBuZXcgY2hhcmFjdGVyXG4gICAgICBsX2FyZWEucHV0IChjLCBwb3MpXG5cbiAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgb25lX21vcmVfY2hhcmFjdGVyOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IGNcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChpLCBpIC0gMSwgbF9jb3VudCAtIGkpXG4gICAgICAgIC0tIFVwZGF0ZSBjb250ZW50LlxuICAgICAgY291bnQgOj0gbF9jb3VudCAtIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAobi5taW4gKGNvdW50KSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4J1xuICAgICAgLS0gdG8gYGVuZF9pbmRleCcgaW5jbHVzaXZlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBuYl9yZW1vdmVkOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iX3JlbW92ZWQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBuYl9yZW1vdmVkID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9pbmRleCArIG5iX3JlbW92ZWQgLSAxLCBzdGFydF9pbmRleCAtIDEsIGxfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICAgIGNvdW50IDo9IGxfY291bnQgLSBuYl9yZW1vdmVkXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgKyBvbGQgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgbGFzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIG4gPiBsX2NvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX2hlYWQgKGxfY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBjb3VudCAtIG4ubWluIChjb3VudCkpKVxuICAgIGVuZFxuXG4gIHBydW5lIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycsIGlmIGFueS5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgY291bnRlcjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGNvdW50ZXIgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgY291bnRlciA+IGNvdW50IG9yIGVsc2UgKGl0ZW0gKGNvdW50ZXIpID0gYylcbiAgICAgIGxvb3BcbiAgICAgICAgY291bnRlciA6PSBjb3VudGVyICsgMVxuICAgICAgZW5kXG4gICAgICBpZiBjb3VudGVyIDw9IGNvdW50IHRoZW5cbiAgICAgICAgcmVtb3ZlIChjb3VudGVyKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICAgIC0tIFRyYXZlcnNlIHN0cmluZyBhbmQgc2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdFxuICAgICAgICAtLSBlYWNoIHRpbWUgd2UgZmluZCBhbiBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBsX2NoYXIgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIGxfY2hhciAvPSBjIHRoZW5cbiAgICAgICAgICBsX2FyZWEucHV0IChsX2NoYXIsIGopXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBqXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjaGFuZ2VkX2NvdW50OiBjb3VudCA9IChvbGQgY291bnQpIC0gKG9sZCBvY2N1cnJlbmNlcyAoYykpXG4gICAgICAtLSByZW1vdmVkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSAvPSBgYydcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfbGVhZGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBsZWFkaW5nIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHkgb3IgZWxzZSBpdGVtICgxKSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbF90cmFpbGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBjaGFyYWN0ZXIuXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKCclLzAwMC8nLCBuZXdzaXplICsgMSlcbiAgICBlbmRcblxuICBncm93IChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgdGhlIGNhcGFjaXR5IGlzIGF0IGxlYXN0IGBuZXdzaXplJy5cbiAgICBkb1xuICAgICAgaWYgbmV3c2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdzaXplKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuIDo9IGNvdW50XG4gICAgICBpZiBuIDwgY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9zdHJpbmc6IHNhbWVfc3RyaW5nIChvbGQgdHdpbilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX3VwcGVyXG4gICAgZW5kXG5cbiAgbGVmdF9qdXN0aWZ5XG4gICAgICAtLSBMZWZ0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpdGR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGUgc3BhY2VzLlxuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGxlZnRfYWRqdXN0XG5cbiAgICAgICAgLS0gR2V0IG5ldyBjb3VudFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgaWYgaSA8IG5iIHRoZW5cbiAgICAgICAgICAtLSBgbGVmdF9hZGp1c3QnIGRpZCByZW1vdmUgc29tZSBjaGFyYWN0ZXJzLCBzbyB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAgIC0tIHNvbWUgd2hpdGUgc3BhY2VzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNlbnRlcl9qdXN0aWZ5XG4gICAgICAtLSBDZW50ZXIganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iLCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbGVmdF9uYl9zcGFjZSwgcmlnaHRfbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA9IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGxlZnRfbmJfc3BhY2UpKVxuICAgICAgbG9vcFxuICAgICAgICBsZWZ0X25iX3NwYWNlIDo9IGxlZnRfbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IC0xIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGkpKVxuICAgICAgbG9vcFxuICAgICAgICByaWdodF9uYl9zcGFjZSA6PSByaWdodF9uYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gV2UgZW5jb3VyYWdlIHRoYXQgbW9yZSBzcGFjZXMgd2lsbCBiZSBwdXQgdG8gdGhlIGxlZnQsIHdoZW5cbiAgICAgICAgLS0gbnVtYmVyIG9mIHNwYWNlcyBpcyBub3QgZXZlbi5cbiAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgKyByaWdodF9uYl9zcGFjZVxuICAgICAgaWYgbF9vZmZzZXQgXFxcXCAyID0gMCB0aGVuXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyXG4gICAgICBlbHNlXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyIC0gMVxuICAgICAgZW5kXG4gICAgICBpZiBsX29mZnNldCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodCBvciBsZWZ0IChkZXBlbmRpbmcgb24gc2lnbiBvZlxuICAgICAgICAgIC0tIGBsX29mZnNldCcgYnkgYGxfb2Zmc2V0JyBwb3NpdGlvbi5cbiAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0LFxuICAgICAgICAgIG5iIC0gbGVmdF9uYl9zcGFjZSAtIHJpZ2h0X25iX3NwYWNlKVxuXG4gICAgICAgIGlmIGxfb2Zmc2V0IDwgMCB0aGVuXG4gICAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEZpbGwgcmlnaHQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIG5iIC0gcmlnaHRfbmJfc3BhY2UgLSBsX29mZnNldCwgbmIgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2p1c3RpZnlcbiAgICAgIC0tIFJpZ2h0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICByaWdodF9hZGp1c3RcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIG5iX3NwYWNlIDo9IG5iIC0gaVxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAoaSksIGkgKyBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGkgKyAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBuYl9zcGFjZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBuYl9zcGFjZSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX2p1c3RpZnkgKHBpdm90OiBDSEFSQUNURVJfMzI7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgdGVtcDogQVJSQVlFRF9MSVNUIFtDSEFSQUNURVJfMzJdXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSB0ZW1wLm1ha2UgKGNhcGFjaXR5KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjb3VudFxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYzogQU5ZXG4gICAgICAtLSBBIHJlZmVyZW5jZSB0byBhIEMgZm9ybSBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIC0tIFVzZWZ1bCBvbmx5IGZvciBpbnRlcmZhY2luZyB3aXRoIEMgc29mdHdhcmUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2lzX2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEucHV0ICgnJVUnLCBjb3VudClcbiAgICAgIFJlc3VsdCA6PSBsX2FyZWFcbiAgICBlbmRcblxuICBtaXJyb3JlZDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBNaXJyb3IgaW1hZ2Ugb2Ygc3RyaW5nO1xuICAgICAgLS0gUmVzdWx0IGZvciBcIkhlbGxvIHdvcmxkXCIgaXMgXCJkbHJvdyBvbGxlSFwiLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0Lm1pcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yXG4gICAgICAtLSBSZXZlcnNlIHRoZSBvcmRlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgLS0gXCJIZWxsbyB3b3JsZFwiIC0+IFwiZGxyb3cgb2xsZUhcIi5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgICAtLSBOb3RoaW5nIHRvIGJlIGRvbmUgYmVjYXVzZSB3ZSBvbmx5IGFkZGVkIGBpbnRlcm5hbF9oYXNoX2NvZGUnIHRoYXQgd2lsbFxuICAgICAgICAtLSBiZSByZWNvbXB1dGVkIG5leHQgdGltZSB3ZSBxdWVyeSBgaGFzaF9jb2RlJy5cblxuICAgICAgICAtLSBJbiAuTkVULCB3ZSBoYXZlIGEgbWlzbWF0Y2ggdGhhdCBpcyB0cmlnZ2VyZWQgZHVlIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAgICAtLSBTUEVDSUFMIFtDSEFSQUNURVJfMzJdIGFzIGEgLk5FVCBhcnJheSBvZiBVSW50MTYuXG4gICAgICBpZiBhcmVhID0gVm9pZCBhbmQgdGhlbiBhdHRhY2hlZCB7bGlrZSBhcmVhfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcImFyZWFcIikgYXMgbF9hcmVhIHRoZW5cbiAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMjYgMTQ6NDk6NDAgLTA3MDAgKFdlZCwgMjYgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NzIxICRcIlxuXG5jbGFzc1xuICBTVFJJTkdfOFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR184XG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBtYWtlLCBtYWtlX2VtcHR5LCBtYWtlX2ZpbGxlZCwgbWFrZV9mcm9tX2MsIG1ha2VfZnJvbV9zdHJpbmcsIGZpbGxfY2hhcmFjdGVyXG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBlbmRcblxuICBTVFJJTkdfR0VORVJBTFxuICAgIHJlbmFtZVxuICAgICAgYXBwZW5kIGFzIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIGFwcGVuZF9zdWJzdHJpbmcgYXMgYXBwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZCBhcyBwcmVwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdWJzdHJpbmcgYXMgcHJlcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfc3RyaW5nIGFzIHNhbWVfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX2NoYXJhY3RlcnMgYXMgc2FtZV9jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnMgYXMgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzX2dlbmVyYWwsXG4gICAgICBzdGFydHNfd2l0aCBhcyBzdGFydHNfd2l0aF9nZW5lcmFsLFxuICAgICAgZW5kc193aXRoIGFzIGVuZHNfd2l0aF9nZW5lcmFsLFxuICAgICAgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbCBhcyBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsX2dlbmVyYWwsXG4gICAgICBpdGVtIGFzIGNoYXJhY3Rlcl8zMl9pdGVtLFxuICAgICAgaGFzIGFzIGNoYXJhY3Rlcl8zMl9oYXMsXG4gICAgICBpbmRleF9vZiBhcyBjaGFyYWN0ZXJfMzJfaW5kZXhfb2YsXG4gICAgICBsYXN0X2luZGV4X29mIGFzIGNoYXJhY3Rlcl8zMl9sYXN0X2luZGV4X29mLFxuICAgICAgb2NjdXJyZW5jZXMgYXMgY2hhcmFjdGVyXzMyX29jY3VycmVuY2VzXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbQ0hBUkFDVEVSXzgsIElOVEVHRVJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsLFxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFJFU0laQUJMRSBbQ0hBUkFDVEVSXzhdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFRPX1NQRUNJQUwgW0NIQVJBQ1RFUl84XVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBpdGVtLCBhdCwgcHV0LCB2YWxpZF9pbmRleFxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9zdHJpbmcsXG4gIG1ha2VfZnJvbV9jLFxuICBtYWtlX2Zyb21fY19wb2ludGVyLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIGFzX3N0cmluZ18zMjoge1JFQURBQkxFX1NUUklOR18zMiwgU1RSSU5HXzMyfVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gYV9zeXN0ZW1fc3RyaW5nLmxlbmd0aCArIGRvdG5ldF9jb252ZXJ0b3IuZXNjYXBlX2NvdW50IChhX3N5c3RlbV9zdHJpbmcpXG4gICAgICBlbmRcbiAgICAgIG1ha2UgKGxfY291bnQpXG4gICAgICBpZiBsX2NvdW50ID4gMCBhbmQgdGhlbiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZG90bmV0X2NvbnZlcnRvci5yZWFkX3N5c3RlbV9zdHJpbmdfaW50byAoYV9zeXN0ZW1fc3RyaW5nLCBDdXJyZW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvbV9jIChjX3N0cmluZzogUE9JTlRFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyIChjX3N0cmluZylcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N0cmluZ19pbnRvIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgbm9femVyb19ieXRlOiBub3QgaGFzICgnJS8wLycpXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgICAtLSBjb3JyZWN0X2NvdW50OiB0aGUgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyBjb3VudFxuICAgICAgLS0gICAgICAgaXMgTlVMTFxuICAgIGVuZFxuXG4gIGZyb21fY19zdWJzdHJpbmcgKGNfc3RyaW5nOiBQT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBzdWJzdHJpbmcgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoY19zdHJpbmcgKyAoc3RhcnRfcG9zIC0gMSksIGxfY291bnQpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdWJzdHJpbmdfaW50byAoQ3VycmVudCwgMSwgbF9jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NvdW50OiBjb3VudCA9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgZW5kXG5cbiAgYWRhcHQgKHM6IFNUUklOR184KTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPYmplY3Qgb2YgYSB0eXBlIGNvbmZvcm1pbmcgdG8gdGhlIHR5cGUgb2YgYHMnLFxuICAgICAgLS0gaW5pdGlhbGl6ZWQgd2l0aCBhdHRyaWJ1dGVzIGZyb20gYHMnXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgUmVzdWx0LnNoYXJlIChzKVxuICAgIGVuc3VyZVxuICAgICAgYWRhcHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzaGFyZWRfaW1wbGVtZW50YXRpb246IFJlc3VsdC5zaGFyZWRfd2l0aCAocylcbiAgICBlbmRcblxuICByZW1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9zdHJpbmc6IGNvdW50ID0gMFxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfOCBhc3NpZ24gcHV0XG4gICAgICAtLSBDaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfMzJfaXRlbSAoaTogSU5URUdFUik6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICBkb1xuICAgICAgICAtLSBXZSBzaG91bGQgYmUgdXNpbmcgYGFyZWEuaXRlbSAoaSAtIDEpLnRvX2NoYXJhY3Rlcl8zMidcbiAgICAgICAgLS0gYnV0IHNvbWUgZGVzY2VuZGFudHMgb2YgU1RSSU5HIHRoYXQgaGF2ZSB0aGVpciBjb250ZW50IGVuY29kZWRcbiAgICAgICAgLS0gaW4gVVRGLTggZm9yIGV4YW1wbGUgcmVsaWVzIG9uIGBjb2RlJyB0byBnZXQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgLS0gQ0hBUkFDVEVSXzMyIGJ5IHJlYWRpbmcgbW9yZSB0aGFuIG9uZSBieXRlLiBPbmNlIHRoZXkgaGF2ZVxuICAgICAgICAtLSBiZWVuIHVwZGF0ZWQgdG8gdXNlIGBjaGFyYWN0ZXJfMzJfaXRlbScgd2UgY2FuIHJldmVydCB0aGUgY29kZVxuICAgICAgICAtLSBiYWNrIHRvIHVzaW5nIGBhcmVhJyBkaXJlY3RseS5cbiAgICAgIFJlc3VsdCA6PSBjb2RlIChpKS50b19jaGFyYWN0ZXJfMzJcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gTnVtZXJpYyBjb2RlIG9mIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5jb2RlLnRvX25hdHVyYWxfMzJcbiAgICBlbmRcblxuICBpdGVtX2NvZGUgKGk6IElOVEVHRVIpOiBJTlRFR0VSXG4gICAgICAtLSBOdW1lcmljIGNvZGUgb2YgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJy5cbiAgICAgIC0tIFVzZSBgY29kZScgaW5zdGVhZCBmb3IgY29uc2lzdGVuY3kgd2l0aCBVbmljb2RlIGhhbmRsaW5nLlxuICAgICAgLS18IE5vdCBvYnNvbGV0ZSBiZWNhdXNlIG9sZCBjb2RlIHVzaW5nIGp1c3QgQVNDSUkgaXMgc2FmZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLmNvZGVcbiAgICBlbmRcblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnMuXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkPyAoQW5zd2VyOiB5ZXMuKVxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBCT09MRUFOID0gRmFsc2VcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldCAodDogUkVBREFCTEVfU1RSSU5HXzg7IG4xLCBuMjogSU5URUdFUilcbiAgICAgIC0tIFNldCBjdXJyZW50IHN0cmluZyB0byBzdWJzdHJpbmcgb2YgYHQnIGZyb20gaW5kaWNlcyBgbjEnXG4gICAgICAtLSB0byBgbjInLCBvciB0byBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBzdWJzdHJpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHQgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfOFxuICAgIGRvXG4gICAgICBzIDo9IHQuc3Vic3RyaW5nIChuMSwgbjIpXG4gICAgICBhcmVhIDo9IHMuYXJlYVxuICAgICAgY291bnQgOj0gcy5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX3N1YnN0cmluZzogc2FtZV9zdHJpbmcgKHQuc3Vic3RyaW5nIChuMSwgbjIpKVxuICAgIGVuZFxuXG4gIHN1YmNvcHkgKG90aGVyOiBSRUFEQUJMRV9TVFJJTkdfODsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIHRvIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgICBlbm91Z2hfc3BhY2U6IChjb3VudCAtIGluZGV4X3BvcykgPj0gKGVuZF9wb3MgLSBzdGFydF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGxfb3RoZXJfYXJlYSwgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgZW5kX3BvcyA+PSBzdGFydF9wb3MgdGhlblxuICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpZiBsX2FyZWEgLz0gbF9vdGhlcl9hcmVhIHRoZW5cbiAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX290aGVyX2FyZWEsIHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY29waWVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaW5kZXhfcG9zIC0gMSkgK1xuICAgICAgICBvbGQgb3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpICtcbiAgICAgICAgb2xkIHN1YnN0cmluZyAoaW5kZXhfcG9zICsgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKSwgY291bnQpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnIHRvIGBlbmRfaW5kZXgnIHdpdGggYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBkaWZmOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgc19jb3VudDogSU5URUdFUlxuICAgICAgb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHNfY291bnQgOj0gcy5jb3VudFxuICAgICAgb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICBkaWZmIDo9IHNfY291bnQgLSAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgbmV3X3NpemUgOj0gZGlmZiArIG9sZF9jb3VudFxuICAgICAgaWYgZGlmZiA+IDAgdGhlblxuICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIHRoZSBzdHJpbmcuXG4gICAgICAgIGdyb3cgKG5ld19zaXplKVxuICAgICAgZW5kXG5cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIC0tfCBXZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBmb3J3YXJkIChpZiBkaWZmIGlzID4gMCksIGJhY2t3YXJkIChpZiBkaWZmIDwgMCksXG4gICAgICAgIC0tfCBhbmQgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICBpZiBkaWZmIC89IDAgdGhlblxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoZW5kX2luZGV4LCBlbmRfaW5kZXggKyBkaWZmLCBvbGRfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICBlbmRcbiAgICAgICAgLS18IFNldCBuZXcgY291bnRcbiAgICAgIHNldF9jb3VudCAobmV3X3NpemUpXG4gICAgICAgIC0tfCBXZSBjb3B5IHRoZSBzdWJzdHJpbmcuXG4gICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgc3RhcnRfaW5kZXggLSAxLCBzX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50IC0gZW5kX2luZGV4ICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICByZXBsYWNlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCAoc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICtcbiAgICAgICAgICBzICsgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZ19hbGwgKG9yaWdpbmFsLCBuZXc6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBvY2N1cnJlbmNlIG9mIGBvcmlnaW5hbCcgd2l0aCBgbmV3Jy5cbiAgICByZXF1aXJlXG4gICAgICBvcmlnaW5hbF9leGlzdHM6IG9yaWdpbmFsIC89IFZvaWRcbiAgICAgIG5ld19leGlzdHM6IG5ldyAvPSBWb2lkXG4gICAgICBvcmlnaW5hbF9ub3RfZW1wdHk6IG5vdCBvcmlnaW5hbC5pc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2ZpcnN0X3BvcywgbF9uZXh0X3BvczogSU5URUdFUlxuICAgICAgbF9vcmlnX2NvdW50LCBsX25ld19jb3VudCwgbF9uZXdfbG93ZXIsIGxfY291bnQsIGksIGxfaW5kZXhfY291bnQ6IElOVEVHRVJcbiAgICAgIGxfc3JjX2luZGV4LCBsX2Rlc3RfaW5kZXgsIGxfcHJldl9pbmRleCwgbF9jb3B5X2RlbHRhOiBJTlRFR0VSXG4gICAgICBsX2FyZWEsIGxfbmV3X2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxfc3RyaW5nX3NlYXJjaGVyOiBsaWtlIHN0cmluZ19zZWFyY2hlclxuICAgICAgbF9pbmRleF9saXN0OiBTUEVDSUFMIFtJTlRFR0VSXVxuICAgIGRvXG4gICAgICBpZiBub3QgaXNfZW1wdHkgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfc3RyaW5nX3NlYXJjaGVyIDo9IHN0cmluZ19zZWFyY2hlclxuICAgICAgICBsX3N0cmluZ19zZWFyY2hlci5pbml0aWFsaXplX2RlbHRhcyAob3JpZ2luYWwpXG4gICAgICAgIGxfb3JpZ19jb3VudCA6PSBvcmlnaW5hbC5jb3VudFxuICAgICAgICBsX25ld19jb3VudCA6PSBuZXcuY291bnRcbiAgICAgICAgaWYgbF9vcmlnX2NvdW50ID49IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfd2l0aF9kZWx0YXMgKEN1cnJlbnQsIG9yaWdpbmFsLCAxLCBsX2NvdW50KVxuICAgICAgICAgIGlmIGxfZmlyc3RfcG9zID4gMCB0aGVuXG4gICAgICAgICAgICBpZiBsX29yaWdfY291bnQgPSBsX25ld19jb3VudCB0aGVuXG4gICAgICAgICAgICAgICAgLS0gU3RyaW5nIHdpbGwgbm90IGJlIHJlc2l6ZWQsIHNpbXBseSBwZXJmb3JtIGNoYXJhY3RlciBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgZnJvbVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgPSAwXG4gICAgICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX25ld19hcmVhLCBsX25ld19sb3dlciwgbF9maXJzdF9wb3MgLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICBpZiBsX2ZpcnN0X3BvcyArIGxfbmV3X2NvdW50IDw9IGxfY291bnQgdGhlblxuICAgICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCwgbF9jb3VudClcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSAwXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgZWxzZWlmIGxfb3JpZ19jb3VudCA+IGxfbmV3X2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAtLSBOZXcgc3RyaW5nIGlzIHNtYWxsZXIgdGhhbiBwcmV2aW91cyBzdHJpbmcsIHdlIGNhbiBvcHRpbWl6ZVxuICAgICAgICAgICAgICAgIC0tIHN1YnN0aXR1dGlvbiBieSBvbmx5IG1vdmluZyBibG9jayBiZXR3ZWVuIHR3byBvY2N1cnJlbmNlcyBvZiBgb3JnaW5hbCcuXG4gICAgICAgICAgICAgIGZyb21cbiAgICAgICAgICAgICAgICBsX25leHRfcG9zIDo9IGxfc3RyaW5nX3NlYXJjaGVyLnN1YnN0cmluZ19pbmRleF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50LCBsX2NvdW50KVxuICAgICAgICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgICAgICAgIGxfbmV3X2xvd2VyIDo9IG5ldy5hcmVhX2xvd2VyXG4gICAgICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA9IDBcbiAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgLS0gQ29weSBuZXcgc3RyaW5nIGludG8gQ3VycmVudFxuICAgICAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2ZpcnN0X3BvcyAtIDEgLSBsX29mZnNldCwgbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgYGxfbmV4dF9wb3MnXG4gICAgICAgICAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKGxfZmlyc3RfcG9zICsgbF9vcmlnX2NvdW50IC0gMSxcbiAgICAgICAgICAgICAgICAgIGxfZmlyc3RfcG9zICsgbF9uZXdfY291bnQgLSAxIC0gbF9vZmZzZXQsIGxfbmV4dF9wb3MgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgICBsX2ZpcnN0X3BvcyA6PSBsX25leHRfcG9zXG4gICAgICAgICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQgKyAobF9vcmlnX2NvdW50IC0gbF9uZXdfY291bnQpXG4gICAgICAgICAgICAgICAgaWYgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCA8PSBsX2NvdW50IHRoZW5cbiAgICAgICAgICAgICAgICAgIGxfbmV4dF9wb3MgOj0gbF9zdHJpbmdfc2VhcmNoZXIuc3Vic3RyaW5nX2luZGV4X3dpdGhfZGVsdGFzIChDdXJyZW50LCBvcmlnaW5hbCwgbF9maXJzdF9wb3MgKyBsX29yaWdfY291bnQsIGxfY291bnQpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgbF9uZXh0X3BvcyA6PSAwXG4gICAgICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gZmluYWwgc3Vic3RpdHV0aW9uOlxuICAgICAgICAgICAgICAgIC0tIENvcHkgbmV3IHN0cmluZyBpbnRvIEN1cnJlbnRcbiAgICAgICAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAobF9uZXdfYXJlYSwgbF9uZXdfbG93ZXIsIGxfZmlyc3RfcG9zIC0gMSAtIGxfb2Zmc2V0LCBsX25ld19jb3VudClcbiAgICAgICAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIGJldHdlZW4gYGxfZmlyc3RfcG9zJyBhbmQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX2ZpcnN0X3BvcyArIGxfb3JpZ19jb3VudCAtIDEsXG4gICAgICAgICAgICAgICAgbF9maXJzdF9wb3MgKyBsX25ld19jb3VudCAtIDEgLSBsX29mZnNldCwgbF9jb3VudCArIDEgLSBsX2ZpcnN0X3BvcyAtIGxfb3JpZ19jb3VudClcbiAgICAgICAgICAgICAgICAgIC0tIFBlcmZvcm0gbGFzdCBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgbF9vZmZzZXQgOj0gbF9vZmZzZXQgKyAobF9vcmlnX2NvdW50IC0gbF9uZXdfY291bnQpXG5cbiAgICAgICAgICAgICAgICAtLSBVcGRhdGUgYGNvdW50J1xuICAgICAgICAgICAgICBzZXRfY291bnQgKGxfY291bnQgLSBsX29mZnNldClcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgICAgICAtLSBTdHJpbmcgd2FzIG1vZGlmaWVkIHdlIG5lZWQgdG8gcmVjb21wdXRlIHRoZSBgaGFzaF9jb2RlJy5cbiAgICAgICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICAgICAgZW5kXG4gICAgICAgIGVsc2VpZiBhdHRhY2hlZCBsX3N0cmluZ19zZWFyY2hlci5zdWJzdHJpbmdfaW5kZXhfbGlzdF93aXRoX2RlbHRhcyAoQ3VycmVudCwgb3JpZ2luYWwsIDEsIGxfY291bnQpIGFzIGxfbGlzdCB0aGVuXG4gICAgICAgICAgICAtLSBHZXQgdGhlIG51bWJlciBvZiBzdWJzdGl0dXRpb24gdG8gYmUgcGVyZm9ybWVkIGJ5IGdldHRpbmcgYSBsaXN0XG4gICAgICAgICAgICAtLSBvZiBsb2NhdGlvbiB3aGVyZSBgb3JpZ2luYWwnIGFwcGVhcnMuXG4gICAgICAgICAgbF9pbmRleF9saXN0IDo9IGxfbGlzdC5hcmVhXG4gICAgICAgICAgbF9pbmRleF9jb3VudCA6PSBsX2luZGV4X2xpc3QuY291bnRcbiAgICAgICAgICAgIC0tIFN0b3JlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgdXAgdG8gd2hpY2ggd2UgbmVlZCB0byBtb3ZlXG4gICAgICAgICAgICAtLSBjaGFyYWN0ZXJzIGluIHRoZSByZWFsbG9jYXRlZCBzdHJpbmcuXG4gICAgICAgICAgbF9wcmV2X2luZGV4IDo9IGxfY291bnRcbiAgICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAgbF9jb3B5X2RlbHRhIDo9IGxfbmV3X2NvdW50IC0gbF9vcmlnX2NvdW50XG4gICAgICAgICAgbF9jb3VudCA6PSBsX2NvdW50ICsgKGxfaW5kZXhfY291bnQgKiBsX2NvcHlfZGVsdGEpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWEucmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyVVJywgbF9jb3VudCArIDEpXG4gICAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgICAgICAgIC0tIFBlcmZvcm0gdGhlIHN1YnN0aXR1dGlvbiBzdGFydGluZyBmcm9tIHRoZSBlbmQuXG4gICAgICAgICAgZnJvbVxuICAgICAgICAgICAgaSA6PSBsX2luZGV4X2NvdW50XG4gICAgICAgICAgICBsX25ld19sb3dlciA6PSBuZXcuYXJlYV9sb3dlclxuICAgICAgICAgICAgbF9uZXdfYXJlYSA6PSBuZXcuYXJlYVxuICAgICAgICAgIHVudGlsXG4gICAgICAgICAgICBpID0gMFxuICAgICAgICAgIGxvb3BcbiAgICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICAgIGxfc3JjX2luZGV4IDo9IGxfaW5kZXhfbGlzdC5pdGVtIChpKVxuICAgICAgICAgICAgbF9kZXN0X2luZGV4IDo9IGxfc3JjX2luZGV4ICsgaSAqIGxfY29weV9kZWx0YVxuICAgICAgICAgICAgICAtLSBTaGlmdCBub24tbWF0Y2hpbmcgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb2YgdGhlIG5ld2x5IHJlcGxhY2VkIHN0cmluZy5cbiAgICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChsX3NyY19pbmRleCArIGxfb3JpZ19jb3VudCAtIDEsIGxfZGVzdF9pbmRleCArIGxfbmV3X2NvdW50IC0gMSwgbF9wcmV2X2luZGV4IC0gbF9zcmNfaW5kZXggLSBsX29yaWdfY291bnQgKyAxKVxuICAgICAgICAgICAgICAtLSBTdG9yZSBuZXcgZW5kIG9mIHN0cmluZyB3aGVyZSBjaGFyYWN0ZXJzIHdpbGwgYmUgbW92ZWQuXG4gICAgICAgICAgICBsX3ByZXZfaW5kZXggOj0gbF9zcmNfaW5kZXggLSAxXG5cbiAgICAgICAgICAgICAgLS0gQ29weSBgbmV3JyB0byBpdHMgYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfbmV3X2FyZWEsIGxfbmV3X2xvd2VyLCBsX2Rlc3RfaW5kZXggLSAxLCBsX25ld19jb3VudClcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIFVwZGF0ZSB0aGUgbmV3IGBjb3VudCcgd2hpY2ggYWxzbyByZXNldHMgdGhlIGBoYXNoX2NvZGUnLlxuICAgICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGxfY291bnQgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NvdW50IC0gMSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICByZXBsYWNlX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgZmlsbF93aXRoJyBpbnN0ZWFkJ1wiXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoYylcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGtlZXBfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgbG9jYWxcbiAgICAgIG5iOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBpZiBuIDwgbmIgdGhlblxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iIC0gbiwgMCwgbilcbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbGVmdF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIG5iLCBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbmJfc3BhY2UgPiBuYiBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAobmJfc3BhY2UpLmlzX3NwYWNlXG4gICAgICBsb29wXG4gICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudCB2YWx1ZS5cbiAgICAgICAgbmIgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmJfc3BhY2UsIDAsIG5iKVxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGkgOj0gbmJcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPCAwIG9yIGVsc2Ugbm90IGxfYXJlYS5pdGVtIChpKS5pc19zcGFjZVxuICAgICAgbG9vcFxuICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNoYXJlIChvdGhlcjogU1RSSU5HXzgpXG4gICAgICAtLSBNYWtlIGN1cnJlbnQgc3RyaW5nIHNoYXJlIHRoZSB0ZXh0IG9mIGBvdGhlcicuXG4gICAgICAtLSBTdWJzZXF1ZW50IGNoYW5nZXMgdG8gdGhlIGNoYXJhY3RlcnMgb2YgY3VycmVudCBzdHJpbmdcbiAgICAgIC0tIHdpbGwgYWxzbyBhZmZlY3QgYG90aGVyJywgYW5kIGNvbnZlcnNlbHkuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBkb1xuICAgICAgYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICBjb3VudCA6PSBvdGhlci5jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIHNoYXJlZF9jb3VudDogb3RoZXIuY291bnQgPSBjb3VudFxuICAgICAgc2hhcmVkX2FyZWE6IG90aGVyLmFyZWEgPSBhcmVhXG4gICAgZW5kXG5cbiAgcHV0IChjOiBDSEFSQUNURVJfODsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfOCwgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHByZWNlZGUsIHByZXBlbmRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIEFkZCBgYycgYXQgZnJvbnQuXG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKGNvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCAxLCBjb3VudClcbiAgICAgIGxfYXJlYS5wdXQgKGMsIDApXG4gICAgICBjb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR184fSBzIGFzIGxfczggdGhlblxuICAgICAgICBwcmVwZW5kIChsX3M4KVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCBsX3NfY291bnQsIGNvdW50KVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGJlZ2lubmluZy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIDAsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmQgKGIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChkLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChpLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kIChyLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfOClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgcHJlcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzh9IHMgYXMgbF9zOCB0aGVuXG4gICAgICAgIGFwcGVuZCAobF9zOClcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmQgKHM6IFJFQURBQkxFX1NUUklOR184KVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzg7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpKSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIFJlc3VsdC5hcHBlbmQgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzgpXG4gICAgICAtLSBBcHBlbmQgYSBjb3B5IG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgcyAvPSBWb2lkIHRoZW5cbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBhcHBlbmRlZDogcyAvPSBWb2lkIGltcGxpZXNcbiAgICAgICAgKGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCB0d2luICsgb2xkIHMudHdpbikpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzh9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl8xNn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl82NCAoaTogSU5URUdFUl82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzggKGk6IE5BVFVSQUxfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl84XG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfOClcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX25hdHVyYWxfMzIgKGk6IE5BVFVSQUxfMzIpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzMyXG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfOFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzgpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzY0IChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzhcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl84KVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gQXBwZW5kIGBjJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgY3VycmVudF9jb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjdXJyZW50X2NvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgYXJlYS5wdXQgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgICBjb3VudCA6PSBjdXJyZW50X2NvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXRlbV9pbnNlcnRlZDogaXRlbSAoY291bnQpID0gY1xuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHN0YWJsZV9iZWZvcmU6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGNvdW50IC0gMSkgfiAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgYXBwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmQgKGIub3V0KVxuICAgIGVuZFxuXG4gIGluc2VydCAoczogUkVBREFCTEVfU1RSSU5HXzg7IGk6IElOVEVHRVIpXG4gICAgICAtLSBBZGQgYHMnIHRvIGxlZnQgb2YgcG9zaXRpb24gYGknIGluIGN1cnJlbnQgc3RyaW5nLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBpbnNlcnRfc3RyaW5nJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfZXhpc3RzOiBzIC89IFZvaWRcbiAgICAgIGluZGV4X3NtYWxsX2Vub3VnaDogaSA8PSBjb3VudCArIDFcbiAgICAgIGluZGV4X2xhcmdlX2Vub3VnaDogaSA+IDBcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfc3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfODsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfODsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgYycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgIG5ld19zaXplIDo9IDEgKyBjb3VudFxuICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgcG9zIDo9IGkgLSAxXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgMSwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgLS0gSW5zZXJ0IG5ldyBjaGFyYWN0ZXJcbiAgICAgIGxfYXJlYS5wdXQgKGMsIHBvcylcblxuICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBvbmVfbW9yZV9jaGFyYWN0ZXI6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gY1xuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmUgKGk6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYGknLXRoIGNoYXJhY3Rlci5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKGksIGkgLSAxLCBsX2NvdW50IC0gaSlcbiAgICAgICAgLS0gVXBkYXRlIGNvbnRlbnQuXG4gICAgICBjb3VudCA6PSBsX2NvdW50IC0gMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nIChuLm1pbiAoY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnXG4gICAgICAtLSB0byBgZW5kX2luZGV4JyBpbmNsdXNpdmUuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIG5iX3JlbW92ZWQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmJfcmVtb3ZlZCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIG5iX3JlbW92ZWQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X2luZGV4ICsgbmJfcmVtb3ZlZCAtIDEsIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgICAgY291bnQgOj0gbF9jb3VudCAtIG5iX3JlbW92ZWRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArIG9sZCBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBsYXN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbiA+IGxfY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAobF9jb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGNvdW50IC0gbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcHJ1bmUgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYGMnLCBpZiBhbnkuXG4gICAgcmVxdWlyZSBlbHNlXG4gICAgICBUcnVlXG4gICAgbG9jYWxcbiAgICAgIGNvdW50ZXI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgICBjb3VudGVyIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGNvdW50ZXIgPiBjb3VudCBvciBlbHNlIChpdGVtIChjb3VudGVyKSA9IGMpXG4gICAgICBsb29wXG4gICAgICAgIGNvdW50ZXIgOj0gY291bnRlciArIDFcbiAgICAgIGVuZFxuICAgICAgaWYgY291bnRlciA8PSBjb3VudCB0aGVuXG4gICAgICAgIHJlbW92ZSAoY291bnRlcilcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbCAoYzogQ0hBUkFDVEVSXzgpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl84XG4gICAgZG9cbiAgICAgICAgLS0gVHJhdmVyc2Ugc3RyaW5nIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0XG4gICAgICAgIC0tIGVhY2ggdGltZSB3ZSBmaW5kIGFuIG9jY3VycmVuY2Ugb2YgYGMnLlxuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY2hhciA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbF9jaGFyIC89IGMgdGhlblxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfY2hhciwgailcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGNvdW50IDo9IGpcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNoYW5nZWRfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCkgLSAob2xkIG9jY3VycmVuY2VzIChjKSlcbiAgICAgIC0tIHJlbW92ZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpIC89IGBjJ1xuICAgIGVuZFxuXG4gIHBydW5lX2FsbF9sZWFkaW5nIChjOiBDSEFSQUNURVJfOClcbiAgICAgIC0tIFJlbW92ZSBhbGwgbGVhZGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoMSkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKDEpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfdHJhaWxpbmcgKGM6IENIQVJBQ1RFUl84KVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWFfd2l0aF9kZWZhdWx0ICgnJS8wMDAvJywgbmV3c2l6ZSArIDEpXG4gICAgZW5kXG5cbiAgZ3JvdyAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIEVuc3VyZSB0aGF0IHRoZSBjYXBhY2l0eSBpcyBhdCBsZWFzdCBgbmV3c2l6ZScuXG4gICAgZG9cbiAgICAgIGlmIG5ld3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3c2l6ZSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfc3RyaW5nOiBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX2xvd2VyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX2xvd2VyXG4gICAgZW5kXG5cbiAgYXNfdXBwZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIHVwcGVyIGNhc2VcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b191cHBlclxuICAgIGVuZFxuXG4gIGxlZnRfanVzdGlmeVxuICAgICAgLS0gTGVmdCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aXRkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIHdoaXRlIHNwYWNlcy5cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICBsZWZ0X2FkanVzdFxuXG4gICAgICAgIC0tIEdldCBuZXcgY291bnRcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIGlmIGkgPCBuYiB0aGVuXG4gICAgICAgICAgLS0gYGxlZnRfYWRqdXN0JyBkaWQgcmVtb3ZlIHNvbWUgY2hhcmFjdGVycywgc28gd2UgbmVlZCB0byBhZGRcbiAgICAgICAgICAtLSBzb21lIHdoaXRlIHNwYWNlcyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSBuYlxuICAgICAgICBsb29wXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjZW50ZXJfanVzdGlmeVxuICAgICAgLS0gQ2VudGVyIGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYiwgbF9vZmZzZXQ6IElOVEVHRVJcbiAgICAgIGxlZnRfbmJfc3BhY2UsIHJpZ2h0X25iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgPSBuYiBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAobGVmdF9uYl9zcGFjZSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA6PSBsZWZ0X25iX3NwYWNlICsgMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSByaWdodCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSBuYiAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAtMSBvciBlbHNlIG5vdCBsX2FyZWEuaXRlbSAoaSkuaXNfc3BhY2VcbiAgICAgIGxvb3BcbiAgICAgICAgcmlnaHRfbmJfc3BhY2UgOj0gcmlnaHRfbmJfc3BhY2UgKyAxXG4gICAgICAgIGkgOj0gaSAtIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFdlIGVuY291cmFnZSB0aGF0IG1vcmUgc3BhY2VzIHdpbGwgYmUgcHV0IHRvIHRoZSBsZWZ0LCB3aGVuXG4gICAgICAgIC0tIG51bWJlciBvZiBzcGFjZXMgaXMgbm90IGV2ZW4uXG4gICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlICsgcmlnaHRfbmJfc3BhY2VcbiAgICAgIGlmIGxfb2Zmc2V0IFxcXFwgMiA9IDAgdGhlblxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMlxuICAgICAgZWxzZVxuICAgICAgICBsX29mZnNldCA6PSBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLy8gMiAtIDFcbiAgICAgIGVuZFxuICAgICAgaWYgbF9vZmZzZXQgLz0gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQgb3IgbGVmdCAoZGVwZW5kaW5nIG9uIHNpZ24gb2ZcbiAgICAgICAgICAtLSBgbF9vZmZzZXQnIGJ5IGBsX29mZnNldCcgcG9zaXRpb24uXG4gICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCxcbiAgICAgICAgICBuYiAtIGxlZnRfbmJfc3BhY2UgLSByaWdodF9uYl9zcGFjZSlcblxuICAgICAgICBpZiBsX29mZnNldCA8IDAgdGhlblxuICAgICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQgLSAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBGaWxsIHJpZ2h0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBuYiAtIHJpZ2h0X25iX3NwYWNlIC0gbF9vZmZzZXQsIG5iIC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICByaWdodF9qdXN0aWZ5XG4gICAgICAtLSBSaWdodCBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBuYl9zcGFjZSA6PSBuYiAtIGlcbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGkpLCBpICsgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBpICsgMVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICBmcm9tXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbmJfc3BhY2UgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgbmJfc3BhY2UgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgIGVuZFxuXG4gIGNoYXJhY3Rlcl9qdXN0aWZ5IChwaXZvdDogQ0hBUkFDVEVSXzg7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfOF1cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0NIQVJBQ1RFUl84XVxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBjcmVhdGUgdGVtcC5tYWtlIChjYXBhY2l0eSlcbiAgICAgIGZyb21cbiAgICAgICAgaSA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBpID4gY291bnRcbiAgICAgIGxvb3BcbiAgICAgICAgdGVtcC5leHRlbmQgKGl0ZW0gKGkpKVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIFJlc3VsdCA6PSB0ZW1wXG4gICAgZW5kXG5cbiAgZnJvemVuIHRvX2M6IEFOWVxuICAgICAgLS0gQSByZWZlcmVuY2UgdG8gYSBDIGZvcm0gb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICAtLSBVc2VmdWwgb25seSBmb3IgaW50ZXJmYWNpbmcgd2l0aCBDIHNvZnR3YXJlLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vdF9pc19kb3RuZXQ6IG5vdCB7UExBVEZPUk19LmlzX2RvdG5ldFxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLnB1dCAoJyVVJywgY291bnQpXG4gICAgICBSZXN1bHQgOj0gbF9hcmVhXG4gICAgZW5kXG5cbiAgbWlycm9yZWQ6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTWlycm9yIGltYWdlIG9mIHN0cmluZztcbiAgICAgIC0tIFJlc3VsdCBmb3IgXCJIZWxsbyB3b3JsZFwiIGlzIFwiZGxyb3cgb2xsZUhcIi5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdC5taXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG1pcnJvclxuICAgICAgLS0gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgY2hhcmFjdGVycy5cbiAgICAgIC0tIFwiSGVsbG8gd29ybGRcIiAtPiBcImRscm93IG9sbGVIXCIuXG4gICAgbG9jYWxcbiAgICAgIGE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzhcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgLS0gTm90aGluZyB0byBiZSBkb25lIGJlY2F1c2Ugd2Ugb25seSBhZGRlZCBgaW50ZXJuYWxfaGFzaF9jb2RlJyB0aGF0IHdpbGxcbiAgICAgIC0tIGJlIHJlY29tcHV0ZWQgbmV4dCB0aW1lIHdlIHF1ZXJ5IGBoYXNoX2NvZGUnLlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGVtcHR5X2FyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl84XVxuICAgICAgLS0gRW1wdHkgYGFyZWEnIHRvIGF2b2lkIHVzZWxlc3MgY3JlYXRpb24gb2YgZW1wdHkgYXJlYXMgd2hlbiB3aXBpbmcgb3V0IGEgU1RSSU5HLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlNpbXBseSBjcmVhdGUgYGFyZWEnIGRpcmVjdGx5LlwiXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9lbXB0eSAoMSlcbiAgICAgIFJlc3VsdC5leHRlbmQgKCclVScpXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9hcmVhX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb21tb24gYW5jZXN0b3JzIHRvIGFsbCBTVFJJTkcgY2xhc3Nlcy5cIlxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTQtMDMtMTkgMDc6MzY6MTAgLTA3MDAgKFdlZCwgMTkgTWFyIDIwMTQpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDk0NjMzICRcIlxuXG5kZWZlcnJlZCBjbGFzc1xuICBTVFJJTkdfR0VORVJBTFxuXG5pbmhlcml0XG4gIFJFQURBQkxFX1NUUklOR19HRU5FUkFMXG4gICAgZXhwb3J0XG4gICAgICB7QU5ZfSBjb3B5LCBzdGFuZGFyZF9jb3B5LCBkZWVwX2NvcHlcbiAgICBlbmRcblxuY29udmVydFxuICBhc19zdHJpbmdfMzI6IHtSRUFEQUJMRV9TVFJJTkdfMzIsIFNUUklOR18zMn0sXG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9XG5cbmZlYXR1cmUgLS0gU2V0dGluZ3NcblxuICBwdXRfY29kZSAodjogbGlrZSBjb2RlOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUHV0IGNvZGUgYHYnIGF0IHBvc2l0aW9uIGBpJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9jb2RlOiB2YWxpZF9jb2RlICh2KVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogY29kZSAoaSkgPSB2XG4gICAgICBzdGFibGVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBzdGFibGVfYmVmb3JlX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGkgLSAxKSB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkpXG4gICAgICBzdGFibGVfYWZ0ZXJfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSB+IChvbGQgc3Vic3RyaW5nIChpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtTVFJJTkdfSEFORExFUn0gLS0gU2V0dGluZ3NcblxuICBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfY291bnQ6IDAgPD0gbnVtYmVyIGFuZCBudW1iZXIgPD0gY2FwYWNpdHlcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG51bWJlclxuICAgIGVuZFxuXG4gIHNldF9pbnRlcm5hbF9oYXNoX2NvZGUgKHY6IGxpa2UgaW50ZXJuYWxfaGFzaF9jb2RlKVxuICAgICAgLS0gU2V0IGBpbnRlcm5hbF9oYXNoX2NvZGUnIHdpdGggYHYnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZfbm9ubmVnYXRpdmU6IHYgPj0gMFxuICAgIGRvXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gdlxuICAgIGVuc3VyZVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlX3NldDogaW50ZXJuYWxfaGFzaF9jb2RlID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgYXBwZW5kX2NvZGUgKGM6IGxpa2UgY29kZSlcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2NvZGU6IHZhbGlkX2NvZGUgKGMpXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudCArIDFcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudClcbiAgICAgIGVuZFxuICAgICAgc2V0X2NvdW50IChjdXJyZW50X2NvdW50KVxuICAgICAgcHV0X2NvZGUgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGNvZGUgKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gMVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBsX3NfY291bnRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jb2RlIChzLmNvZGUgKGkpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50XG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHRvX3N0cmluZ18zMiArIHMpKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdWJzdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIGNvbXBhdGlibGVfc3RyaW5nczogaXNfc3RyaW5nXzggaW1wbGllcyBzLmlzX3ZhbGlkX2FzX3N0cmluZ184XG4gICAgICBzdGFydF9pbmRleF92YWxpZDogc3RhcnRfaW5kZXggPj0gMVxuICAgICAgZW5kX2luZGV4X3ZhbGlkOiBlbmRfaW5kZXggPD0gcy5jb3VudFxuICAgICAgdmFsaWRfYm91bmRzOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgICAgaTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUpXG4gICAgICAgIGVuZFxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBzdGFydF9pbmRleFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBlbmRfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jb2RlIChzLmNvZGUgKGkpKVxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkICh0b19zdHJpbmdfMzIgKyBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkpKVxuICAgIGVuZFxuXG4gIHByZXBlbmQgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSlcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgQ3VycmVudCcgYXQgdGhlIGVuZCBzdGFydGluZyBmcm9tIHRoZSBlbmQgc2luY2UgaXQgd2lsbCBwcm9iYWJseSBvdmVybGFwLlxuICAgICAgICBzZXRfY291bnQgKGxfbmV3X3NpemUpXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxfY291bnRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKGNvZGUgKGkpLCBpICsgbF9zX2NvdW50KVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gQ29weSBgcycgYXQgdGhlIGJlZ2lubmluZyBvZiBDdXJyZW50LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGxfc19jb3VudFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKHMuY29kZSAoaSksIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCAoY291bnQgKyBzLmNvdW50KVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnRvX3N0cmluZ18zMiArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTDsgc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICBjb21wYXRpYmxlX3N0cmluZ3M6IGlzX3N0cmluZ184IGltcGxpZXMgcy5pc192YWxpZF9hc19zdHJpbmdfOFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplKVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBDb3B5IGBDdXJyZW50JyBhdCB0aGUgZW5kIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCBzaW5jZSBpdCB3aWxsIHByb2JhYmx5IG92ZXJsYXAuXG4gICAgICAgIHNldF9jb3VudCAobF9uZXdfc2l6ZSlcbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbF9jb3VudFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBwdXRfY29kZSAoY29kZSAoaSksIGkgKyBsX3NfY291bnQpXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBDb3B5IGBzJyBhdCB0aGUgYmVnaW5uaW5nIG9mIEN1cnJlbnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IHN0YXJ0X2luZGV4XG4gICAgICAgICAgaiA6PSAxXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IGVuZF9pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgcHV0X2NvZGUgKHMuY29kZSAoaSksIGopXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICAgIGogOj0gaiArIDFcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpLnRvX3N0cmluZ18zMiArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZGVmZXJyZWRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBuLm1pbiAob2xkIGNvdW50KVxuICAgICAga2VwdDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfYXJndW1lbnQ6IG4gPj0gMFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKGNvdW50IC0gbi5taW4oY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIGxlZnRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtICgxKS5pc19zcGFjZVxuICAgICAga2VwdDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAoKG9sZCB0d2luKS5zdWJzdHJpbmcgKG9sZCBjb3VudCAtIGNvdW50ICsgMSwgb2xkIGNvdW50KSlcbiAgICAgIG9ubHlfc3BhY2VzX3JlbW92ZWRfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoMSwgKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpIC0gMSlcbiAgICBlbmRcblxuICByaWdodF9hZGp1c3RcbiAgICAgIC0tIFJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtIChjb3VudCkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKChvbGQgdHdpbikuc3Vic3RyaW5nICgxLCBjb3VudCkpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2FmdGVyOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpICsgY291bnQsIG9sZCBjb3VudClcbiAgICBlbmRcblxuICBhZGp1c3RcbiAgICAgIC0tIFJlbW92ZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyB3aGl0ZXNwYWNlLlxuICAgIGRvXG4gICAgICBsZWZ0X2FkanVzdFxuICAgICAgcmlnaHRfYWRqdXN0XG4gICAgZW5zdXJlXG4gICAgICB2YWxpZF9jb3VudDogY291bnQgPD0gb2xkIGNvdW50XG4gICAgICBuZXdfY291bnRfbGVmdDogbm90IGlzX2VtcHR5IGltcGxpZXMgbm90IGl0ZW0gKDEpLmlzX3NwYWNlXG4gICAgICBuZXdfY291bnRfcmlnaHQ6IG5vdCBpc19lbXB0eSBpbXBsaWVzIG5vdCBpdGVtIChjb3VudCkuaXNfc3BhY2VcbiAgICAgIGtlcHQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyAob2xkIHR3aW4pLmhhc19zdWJzdHJpbmcgKEN1cnJlbnQpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2JlZm9yZTogZWxrc19jaGVja2luZyBpbXBsaWVzIChvbGQgdHdpbikuaXNfc3Vic3RyaW5nX3doaXRlc3BhY2UgKDEsIChvbGQgdHdpbikuc3Vic3RyaW5nX2luZGV4IChDdXJyZW50LCAxKSAtIDEpXG4gICAgICBvbmx5X3NwYWNlc19yZW1vdmVkX2FmdGVyOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKG9sZCB0d2luKS5pc19zdWJzdHJpbmdfd2hpdGVzcGFjZSAoKG9sZCB0d2luKS5zdWJzdHJpbmdfaW5kZXggKEN1cnJlbnQsIDEpICsgY291bnQsIG9sZCBjb3VudClcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50IC0gMVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIHRvX3N0cmluZ18zMiB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkudG9fc3RyaW5nXzMyICsgb2xkIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KS50b19zdHJpbmdfMzIpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICByZXNpemUgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2Ugc3RyaW5nIHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBhdCBsZWFzdCBgbmV3c2l6ZScgY2hhcmFjdGVycy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgY2hhcmFjdGVyLlxuICAgIHJlcXVpcmVcbiAgICAgIG5ld19zaXplX2xhcmdlX2Vub3VnaDogbmV3c2l6ZSA+PSBjb3VudFxuICAgIGRlZmVycmVkXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY2FwYWNpdHlfbGFyZ2VfZW5vdWdoOiBjYXBhY2l0eSA+PSBuZXdzaXplXG4gICAgICBzYW1lX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBtdXRhYmxlOiBub3QgaXNfaW1tdXRhYmxlXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJPYmplY3RzIHRoYXQgY2FuIGFjY2VzcyBgc2V0X2NvdW50JyBmcm9tIFNUUklOR1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbGVnYWw6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmNsYXNzXG4gIFNUUklOR19IQU5ETEVSXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJDb250YWluZXJzIHdob3NlIGl0ZW1zIGFyZSBhY2Nlc3NpYmxlIHRocm91Z2gga2V5c1wiXG4gIGxpYnJhcnk6IFwiRnJlZSBpbXBsZW1lbnRhdGlvbiBvZiBFTEtTIGxpYnJhcnlcIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBzdGF0dXM6IFwiU2VlIG5vdGljZSBhdCBlbmQgb2YgY2xhc3MuXCJcbiAgbmFtZXM6IHRhYmxlLCBhY2Nlc3M7XG4gIGFjY2Vzczoga2V5LCBtZW1iZXJzaGlwO1xuICBjb250ZW50czogZ2VuZXJpYztcbiAgZGF0ZTogXCIkRGF0ZTogMjAxMi0wNS0yMyAyMToxMzoxMCAtMDcwMCAoV2VkLCAyMyBNYXkgMjAxMikgJFwiXG4gIHJldmlzaW9uOiBcIiRSZXZpc2lvbjogOTE5ODEgJFwiXG5cbmRlZmVycmVkIGNsYXNzIFRBQkxFIFtHLCBIXSBpbmhlcml0XG5cbiAgQkFHIFtHXVxuICAgIHJlbmFtZVxuICAgICAgcHV0IGFzIGJhZ19wdXRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGs6IEgpOiBHIGFzc2lnbiBmb3JjZVxuICAgICAgLS0gRW50cnkgb2Yga2V5IGBrJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2tleSAoaylcbiAgICBkZWZlcnJlZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICB2YWxpZF9rZXkgKGs6IEgpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgaycgYSB2YWxpZCBrZXk/XG4gICAgZGVmZXJyZWRcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHB1dCAodjogRzsgazogSClcbiAgICAgIC0tIEFzc29jaWF0ZSB2YWx1ZSBgdicgd2l0aCBrZXkgYGsnLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2tleTogdmFsaWRfa2V5IChrKVxuICAgIGRlZmVycmVkXG4gICAgZW5kXG5cbiAgZm9yY2UgKHY6IEc7IGs6IEgpXG4gICAgICAtLSBBc3NvY2lhdGUgdmFsdWUgYHYnIHdpdGgga2V5IGBrJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9rZXk6IHZhbGlkX2tleSAoaylcbiAgICBkZWZlcnJlZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGspID0gdlxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBiYWdfcHV0ICh2OiBHKVxuICAgIGRvXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIiwibm90ZVxuICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VzIHRvIHNwZWNpYWwgb2JqZWN0cywgZm9yIGRpcmVjdCBhY2Nlc3MgdG8gYXJyYXlzIGFuZCBzdHJpbmdzXCJcbiAgbGlicmFyeTogXCJGcmVlIGltcGxlbWVudGF0aW9uIG9mIEVMS1MgbGlicmFyeVwiXG4gIHN0YXR1czogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBsZWdhbDogXCJTZWUgbm90aWNlIGF0IGVuZCBvZiBjbGFzcy5cIlxuICBkYXRlOiBcIiREYXRlOiAyMDEyLTA1LTIzIDIxOjEzOjEwIC0wNzAwIChXZWQsIDIzIE1heSAyMDEyKSAkXCJcbiAgcmV2aXNpb246IFwiJFJldmlzaW9uOiA5MTk4MSAkXCJcblxuY2xhc3MgVE9fU1BFQ0lBTCBbVF1cblxuY3JlYXRlXG4gIG1ha2VfZW1wdHlfYXJlYSxcbiAgbWFrZV9maWxsZWRfYXJlYVxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGFyZWE6IFNQRUNJQUwgW1RdXG4gICAgICAtLSBTcGVjaWFsIGRhdGEgem9uZVxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHlfYXJlYSAobjogSU5URUdFUilcbiAgICAgIC0tIENyZWF0ZXMgYSBzcGVjaWFsIG9iamVjdCBmb3IgYG4nIGVudHJpZXMuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBkb1xuICAgICAgY3JlYXRlIGFyZWEubWFrZV9lbXB0eSAobilcbiAgICBlbnN1cmVcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBhcmVhIC89IFZvaWRcbiAgICAgIGNhcGFjaXR5X3NldDogYXJlYS5jYXBhY2l0eSA9IG5cbiAgICAgIGNvdW50X3NldDogYXJlYS5jb3VudCA9IDBcbiAgICBlbmRcblxuICBtYWtlX2ZpbGxlZF9hcmVhIChhX2RlZmF1bHRfdmFsdWU6IFQ7IG46IElOVEVHRVIpXG4gICAgICAtLSBDcmVhdGVzIGEgc3BlY2lhbCBvYmplY3QgZm9yIGBuJyBlbnRyaWVzLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkIChhX2RlZmF1bHRfdmFsdWUsIG4pXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX2FsbG9jYXRlZDogYXJlYSAvPSBWb2lkXG4gICAgICBjYXBhY2l0eV9zZXQ6IGFyZWEuY2FwYWNpdHkgPSBuXG4gICAgICBjb3VudF9zZXQ6IGFyZWEuY291bnQgPSBuXG4gICAgICBhcmVhX2ZpbGxlZDogYXJlYS5maWxsZWRfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlLCAwLCBuIC0gMSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBUIGFzc2lnbiBwdXRcbiAgICAgIC0tIEVudHJ5IGF0IGluZGV4IGBpJywgaWYgaW4gaW5kZXggaW50ZXJ2YWxcbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbmRleDogdmFsaWRfaW5kZXggKGkpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIHZhbGlkX2luZGV4IChpOiBJTlRFR0VSKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYGknIHdpdGhpbiB0aGUgYm91bmRzIG9mIEN1cnJlbnQ/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLnZhbGlkX2luZGV4IChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBUOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfaW5kZXg6IHZhbGlkX2luZGV4IChpKVxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodiwgaSlcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IHZcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gRWxlbWVudCBjaGFuZ2VcblxuICBzZXRfYXJlYSAob3RoZXI6IGxpa2UgYXJlYSlcbiAgICAgIC0tIE1ha2UgYG90aGVyJyB0aGUgbmV3IGBhcmVhJ1xuICAgIGRvXG4gICAgICBhcmVhIDo9IG90aGVyXG4gICAgZW5zdXJlXG4gICAgICBhcmVhX3NldDogYXJlYSA9IG90aGVyXG4gICAgZW5kXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDEyLCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG5cbmVuZFxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9