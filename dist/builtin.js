var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"any.e","content":"class\n  ANY\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    external\n      \"built_in\"\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n  frozen dlo_nothing\n      -- Execute a null action.\n    do\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\n\nend\n"});
__eiffel_builtin.push({"filename":"array.e","content":"note\n  library: \"Free implementation of ELKS library\"\n  status: \"See notice at end of class.\"\n  legal: \"See notice at end of class.\"\n  date: \"$Date: 2013-01-25 14:18:20 -0800 (Fri, 25 Jan 2013) $\"\n  revision: \"$Revision: 92138 $\"\n\nclass ARRAY [G] inherit\n\n  RESIZABLE [G]\n    redefine\n      full, copy, is_equal, resizable\n    end\n\n  INDEXABLE [G, INTEGER]\n    rename\n      item as item alias \"[]\"\n    redefine\n      copy, is_equal\n    end\n\n  TO_SPECIAL [G]\n    export\n      {ARRAY} set_area\n    redefine\n      copy, is_equal, item, put, at, valid_index\n    end\n\ncreate\n  make_empty,\n  make,\n  make_filled,\n  make_from_array,\n  make_from_special,\n  make_from_cil\n\nconvert\n  to_cil: {NATIVE_ARRAY [G]},\n  to_special: {SPECIAL [G]},\n  make_from_cil ({NATIVE_ARRAY [G]})\n\nfeature -- Initialization\n\n  make_empty\n      -- Allocate empty array starting at `1'.\n    do\n      lower := 1\n      upper := 0\n      make_empty_area (0)\n    ensure\n      lower_set: lower = 1\n      upper_set: upper = 0\n      items_set: all_default\n    end\n\n  make_filled (a_default_value: G; min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    require\n      valid_bounds: min_index <= max_index + 1\n    local\n      n: INTEGER\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        n := max_index - min_index + 1\n      end\n      make_filled_area (a_default_value, n)\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: filled_with (a_default_value)\n    end\n\n  make (min_index, max_index: INTEGER)\n      -- Allocate array; set index interval to\n      -- `min_index' .. `max_index'; set all values to default.\n      -- (Make array empty if `min_index' = `max_index' + 1).\n    obsolete\n      \" `make' is not void-safe statically. Use `make_empty' or `make_filled' instead. [07-2010]\"\n    require\n      valid_bounds: min_index <= max_index + 1\n      has_default: min_index <= max_index implies ({G}).has_default\n    do\n      lower := min_index\n      upper := max_index\n      if min_index <= max_index then\n        make_filled_area (({G}).default, max_index - min_index + 1)\n      else\n        make_empty_area (0)\n      end\n    ensure\n      lower_set: lower = min_index\n      upper_set: upper = max_index\n      items_set: all_default\n    end\n\n  make_from_array (a: ARRAY [G])\n      -- Initialize from the items of `a'.\n      -- (Useful in proper descendants of class `ARRAY',\n      -- to initialize an array-like object from a manifest array.)\n    require\n      array_exists: a /= Void\n    do\n      set_area (a.area)\n      lower := a.lower\n      upper := a.upper\n    ensure\n      shared: area = a.area\n      lower_set: lower = a.lower\n      upper_set: upper = a.upper\n    end\n\n  make_from_special (a: SPECIAL [G])\n      -- Initialize Current from items of `a'.\n    require\n      special_attached: a /= Void\n    do\n      set_area (a)\n      lower := 1\n      upper := a.count\n    ensure\n      shared: area = a\n      lower_set: lower = 1\n      upper_set: upper = a.count\n    end\n\n  make_from_cil (na: NATIVE_ARRAY [like item])\n      -- Initialize array from `na'.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n      na_not_void: na /= Void\n    do\n      create area.make_from_native_array (na)\n      lower := 1\n      upper := area.count\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): G assign put\n      -- Entry at index `i', if in index interval\n    do\n      Result := area.item (i - lower)\n    end\n\n  entry (i: INTEGER): G\n      -- Entry at index `i', if in index interval\n    require\n      valid_key: valid_index (i)\n    do\n      Result := item (i)\n    end\n\n  has (v: G): BOOLEAN\n      -- Does `v' appear in array?\n      -- (Reference or object equality,\n      -- based on `object_comparison'.)\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n      l_area := area\n      nb := upper - lower\n      if object_comparison and v /= Void then\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) ~ v\n          i := i + 1\n        end\n      else\n        from\n        until\n          i > nb or Result\n        loop\n          Result := l_area.item (i) = v\n          i := i + 1\n        end\n      end\n    end\n\nfeature -- Measurement\n\n  lower: INTEGER\n      -- Minimum index\n\n  upper: INTEGER\n      -- Maximum index\n\n  count, capacity: INTEGER\n      -- Number of available indices\n    do\n      Result := upper - lower + 1\n    ensure then\n      consistent_with_bounds: Result = upper - lower + 1\n    end\n\n  occurrences (v: G): INTEGER\n      -- Number of times `v' appears in structure\n    local\n      i: INTEGER\n    do\n      if object_comparison then\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) ~ v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      else\n        from\n          i := lower\n        until\n          i > upper\n        loop\n          if item (i) = v then\n            Result := Result + 1\n          end\n          i := i + 1\n        end\n      end\n    end\n\n  index_set: INTEGER_INTERVAL\n      -- Range of acceptable indexes\n    do\n      create Result.make (lower, upper)\n    ensure then\n      same_count: Result.count = count\n      same_bounds:\n        ((Result.lower = lower) and (Result.upper = upper))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is array made of the same items as `other'?\n    local\n      i: INTEGER\n    do\n      if other = Current then\n        Result := True\n      elseif lower = other.lower and then upper = other.upper and then\n        object_comparison = other.object_comparison\n      then\n        if object_comparison then\n          from\n            Result := True\n            i := lower\n          until\n            not Result or i > upper\n          loop\n            Result := item (i) ~ other.item (i)\n            i := i + 1\n          end\n        else\n          Result := area.same_items (other.area, 0, 0, count)\n        end\n      end\n    end\n\nfeature -- Status report\n\n  all_default: BOOLEAN\n      -- Are all items set to default values?\n    do\n      if count > 0 then\n        Result := ({G}).has_default and then area.filled_with (({G}).default, 0, upper - lower)\n      else\n        Result := True\n      end\n    ensure\n      definition: Result = (count = 0 or else\n        ((not attached item (upper) as i or else i = ({G}).default) and\n        subarray (lower, upper - 1).all_default))\n    end\n\n  filled_with (v: G): BOOLEAN\n      -- Are all items set to `v'?\n    do\n      Result := area.filled_with (v, 0, upper - lower)\n    ensure\n      definition: Result = (count = 0 or else\n        (item (upper) = v and subarray (lower, upper - 1).filled_with (v)))\n    end\n\n  full: BOOLEAN\n      -- Is structure filled to capacity? (Answer: yes)\n    do\n      Result := True\n    end\n\n  same_items (other: like Current): BOOLEAN\n      -- Do `other' and Current have same items?\n    require\n      other_not_void: other /= Void\n    do\n      if count = other.count then\n        Result := area.same_items (other.area, 0, 0, count)\n      end\n    ensure\n      definition: Result = ((count = other.count) and then\n        (count = 0 or else (item (upper) = other.item (other.upper)\n        and subarray (lower, upper - 1).same_items\n        (other.subarray (other.lower, other.upper - 1)))))\n    end\n\n  valid_index (i: INTEGER): BOOLEAN\n      -- Is `i' within the bounds of the array?\n    do\n      Result := (lower <= i) and then (i <= upper)\n    end\n\n  extendible: BOOLEAN\n      -- May items be added?\n      -- (Answer: no, although array may be resized.)\n    do\n      Result := False\n    end\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: no.)\n    do\n      Result := False\n    end\n\n  resizable: BOOLEAN\n      -- Can array be resized automatically?\n    do\n      Result := ({G}).has_default\n    end\n\n  valid_index_set: BOOLEAN\n    do\n      Result := index_set.count = count\n    end\n\nfeature -- Element change\n\n  put (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    do\n      area.put (v, i - lower)\n    end\n\n  enter (v: like item; i: INTEGER)\n      -- Replace `i'-th entry, if in index interval, by `v'.\n    require\n      valid_key: valid_index (i)\n    do\n      area.put (v, i - lower)\n    end\n\n  force (v: like item; i: INTEGER)\n      -- Assign item `v' to `i'-th entry.\n      -- Resize the array if `i' falls out of currently defined bounds; preserve existing items.\n      -- In void-safe mode, if ({G}).has_default does not hold, then you can only insert between\n      -- `lower - 1' or `upper + 1' position in the ARRAY.\n    require\n      has_default_if_too_low:\n        (i < lower - 1 and lower /= {like lower}.min_value) implies ({G}).has_default\n      has_default_if_too_high:\n        (i > upper + 1 and upper /= {like upper}.max_value) implies ({G}).has_default\n    local\n      old_size, new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      l_count, l_offset: INTEGER\n      l_increased_by_one: BOOLEAN\n    do\n      new_lower := lower.min (i)\n      new_upper := upper.max (i)\n      new_size := new_upper - new_lower + 1\n      l_increased_by_one := (i = upper + 1) or (i = lower - 1)\n      if empty_area then\n          -- List is empty. First we create an empty SPECIAL of the right capacity.\n        make_empty_area (new_size.max (additional_space))\n        if not l_increased_by_one then\n            -- We need to fill the SPECIAL for `0' to `new_size - 2' with the default value.\n          area.fill_with (({G}).default, 0, new_size - 2)\n        end\n        area.extend (v)\n      else\n        old_size := area.capacity\n        if new_size > old_size then\n          set_area (area.aliased_resized_area (new_size.max (old_size + additional_space)))\n        end\n        if new_lower < lower then\n            -- We have inserted below the previous `lower'. We need to shift entries to the right\n            -- before we can insert `v'.\n          l_offset := lower - new_lower\n          l_count := capacity\n          if not l_increased_by_one and l_offset > l_count then\n              -- With the `new_lower' given, the data has to move\n              -- beyond the `area''s count which requires us to fill\n              -- the gap between the old data's location and the new one\n              -- with the default value.\n            area.fill_with (({G}).default, l_count, l_offset - 1)\n          end\n          area.move_data (0, l_offset, l_count)\n          if not l_increased_by_one then\n              -- We start at `1' and not `0' because next instruction\n              -- will update the item at position `0'.\n            area.fill_with (({G}).default, 1, l_offset - 1)\n          end\n            -- Insert `v' at the new lower position.\n          area.put (v, 0)\n        else\n          if new_size > area.count then\n              -- We are adding to the new `upper' position. First we fill the non-initialized\n              -- elements if any up to `new_size - 2' (i.e. up the the item prior to `upper').\n            if not l_increased_by_one then\n              area.fill_with (({G}).default, area.count, new_size - 2)\n            end\n              -- Add `v' at upper position.\n            area.extend (v)\n          else\n              -- Here `lower' hasn't changed\n            area.put (v, i - lower)\n          end\n        end\n      end\n      lower := new_lower\n      upper := new_upper\n    ensure\n      inserted: item (i) = v\n      higher_count: count >= old count\n      lower_set: lower = (old lower).min (i)\n      upper_set: upper = (old upper).max (i)\n    end\n\n  fill_with (v: G)\n      -- Set items between `lower' and `upper' with `v'.\n    do\n      area.fill_with (v, 0, upper - lower)\n    ensure\n      same_capacity: capacity = old capacity\n      count_definition: count = old count\n      filled: filled_with (v)\n    end\n\n  subcopy (other: ARRAY [like item]; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy items of `other' within bounds `start_pos' and `end_pos'\n      -- to current array starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: start_pos >= other.lower\n      valid_end_pos: end_pos <= other.upper\n      valid_bounds: start_pos <= end_pos + 1\n      valid_index_pos: index_pos >= lower\n      enough_space: (upper - index_pos) >= (end_pos - start_pos)\n    do\n      area.copy_data (other.area, start_pos - other.lower, index_pos - lower, end_pos - start_pos + 1)\n    ensure\n      -- copied: forall `i' in 0 .. (`end_pos'-`start_pos'),\n      --     item (index_pos + i) = other.item (start_pos + i)\n    end\n\nfeature -- Iteration\n\n  do_all (action: PROCEDURE [ANY, TUPLE [G]])\n      -- Apply `action' to every item, from first to last.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n    do\n      area.do_all_in_bounds (action, 0, count - 1)\n    end\n\n  do_if (action: PROCEDURE [ANY, TUPLE [G]]; test: FUNCTION [ANY, TUPLE [G], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    require\n      action_not_void: action /= Void\n      test_not_void: test /= Void\n    do\n      area.do_if_in_bounds (action, test, 0, count - 1)\n    end\n\n  there_exists (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for at least one item?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.there_exists_in_bounds (test, 0, count - 1)\n    end\n\n  for_all (test: FUNCTION [ANY, TUPLE [G], BOOLEAN]): BOOLEAN\n      -- Is `test' true for all items?\n    require\n      test_not_void: test /= Void\n    do\n      Result := area.for_all_in_bounds (test, 0, count - 1)\n    end\n\n  do_all_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]])\n      -- Apply `action' to every item, from first to last.\n      -- `action' receives item and its index.\n      -- Semantics not guaranteed if `action' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        action.call ([l_area.item (i), j])\n        j := j + 1\n        i := i + 1\n      end\n    end\n\n  do_if_with_index (action: PROCEDURE [ANY, TUPLE [G, INTEGER]]; test: FUNCTION [ANY, TUPLE [G, INTEGER], BOOLEAN])\n      -- Apply `action' to every item that satisfies `test', from first to last.\n      -- `action' and `test' receive the item and its index.\n      -- Semantics not guaranteed if `action' or `test' changes the structure;\n      -- in such a case, apply iterator to clone of structure instead.\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n    do\n      from\n        i := 0\n        j := lower\n        nb := count - 1\n        l_area := area\n      until\n        i > nb\n      loop\n        if test.item ([l_area.item (i), j]) then\n          action.call ([l_area.item (i), j])\n        end\n        j := j + 1\n        i := i + 1\n      end\n    end\n\nfeature -- Removal\n\n  wipe_out\n      -- Make array empty.\n    obsolete\n      \"Not applicable since not `prunable'. Use `discard_items' instead.\"\n    do\n      discard_items\n    end\n\n  discard_items\n      -- Reset all items to default values with reallocation.\n    require\n      has_default: ({G}).has_default\n    do\n      create area.make_filled (({G}).default, capacity)\n    ensure\n      default_items: all_default\n    end\n\n  clear_all\n      -- Reset all items to default values.\n    require\n      has_default: ({G}).has_default\n    do\n      area.fill_with (({G}).default, 0, area.count - 1)\n    ensure\n      stable_lower: lower = old lower\n      stable_upper: upper = old upper\n      default_items: all_default\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all items except for the first `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    do\n      if n < count then\n        upper := lower + n - 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_lower: lower = old lower\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all items except for the last `n';\n      -- do nothing if `n' >= `count'.\n    require\n      non_negative_argument: n >= 0\n    local\n      nb: INTEGER\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        lower := upper - n + 1\n        area := area.aliased_resized_area (n)\n      end\n    ensure\n      new_count: count = n.min (old count)\n      same_upper: upper = old upper\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_upper: upper = old upper\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' items;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        upper := lower - 1\n        area := area.aliased_resized_area (0)\n      else\n        keep_head (count - n)\n      end\n    ensure\n      new_count: count = (old count - n).max (0)\n      same_lower: lower = old lower\n    end\n\nfeature -- Resizing\n\n  grow (i: INTEGER)\n      -- Change the capacity to at least `i'.\n    do\n      if i > capacity then\n        conservative_resize_with_default (({G}).default, lower, upper + i - capacity)\n      end\n    end\n\n  conservative_resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \" `conservative_resize' is not void-safe statically. Use `conservative_resize_with_default' instead. [07-2010]\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  conservative_resize_with_default (a_default_value: G; min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    require\n      good_indices: min_index <= max_index\n    local\n      new_size: INTEGER\n      new_lower, new_upper: INTEGER\n      offset: INTEGER\n    do\n      if empty_area then\n        set_area (area.aliased_resized_area_with_default (a_default_value, max_index - min_index + 1))\n        lower := min_index\n        upper := max_index\n      else\n        new_lower := min_index.min (lower)\n        new_upper := max_index.max (upper)\n        new_size := new_upper - new_lower + 1\n        if new_size > area.count then\n          set_area (area.aliased_resized_area_with_default (a_default_value, new_size))\n        end\n        if new_lower < lower then\n          offset := lower - new_lower\n          area.move_data (0, offset, upper - lower + 1)\n          area.fill_with (a_default_value, 0, offset - 1)\n        end\n        lower := new_lower\n        upper := new_upper\n      end\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  resize (min_index, max_index: INTEGER)\n      -- Rearrange array so that it can accommodate\n      -- indices down to `min_index' and up to `max_index'.\n      -- Do not lose any previously entered item.\n    obsolete\n      \"Use `conservative_resize_with_default' instead as future versions will implement `resize' as specified in ELKS.\"\n    require\n      good_indices: min_index <= max_index\n      has_default: ({G}).has_default\n    do\n      conservative_resize_with_default (({G}).default, min_index, max_index)\n    ensure\n      no_low_lost: lower = min_index or else lower = old lower\n      no_high_lost: upper = max_index or else upper = old upper\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < area.capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_items: same_items (old twin)\n    end\n\n  rebase (a_lower: like lower)\n      -- Without changing the actual content of `Current' we set `lower' to `a_lower'\n      -- and `upper' accordingly to `a_lower + count - 1'.\n    local\n      l_old_lower: like lower\n    do\n      l_old_lower := lower\n      lower := a_lower\n      upper := a_lower + (upper - l_old_lower)\n    ensure\n      lower_set: lower = a_lower\n      upper_set: upper = a_lower + old count - 1\n    end\n\nfeature -- Conversion\n\n  to_c: ANY\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    do\n      Result := area\n    end\n\n  to_cil: NATIVE_ARRAY [G]\n      -- Address of actual sequence of values,\n      -- for passing to external (non-Eiffel) routines.\n    require\n      is_dotnet: {PLATFORM}.is_dotnet\n    do\n      Result := area.native_array\n    ensure\n      to_cil_not_void: Result /= Void\n    end\n\n  to_special: SPECIAL [G]\n      -- 'area'.\n    do\n      Result := area\n    ensure\n      to_special_not_void: Result /= Void\n    end\n\n  linear_representation: LINEAR [G]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [G]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := lower\n      until\n        i > upper\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\nfeature -- Duplication\n\n  copy (other: like Current)\n      -- Reinitialize by copying all the items of `other'.\n      -- (This is also used by `clone'.)\n    do\n      if other /= Current then\n        standard_copy (other)\n        set_area (other.area.twin)\n      end\n    ensure then\n      equal_areas: area ~ other.area\n    end\n\n  subarray (start_pos, end_pos: INTEGER): ARRAY [G]\n      -- Array made of items of current array within\n      -- bounds `start_pos' and `end_pos'.\n    require\n      valid_start_pos: valid_index (start_pos)\n      valid_end_pos: end_pos <= upper\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n    do\n      if start_pos <= end_pos then\n        create Result.make_filled (item (start_pos), start_pos, end_pos)\n          -- Only copy elements if needed.\n        Result.subcopy (Current, start_pos, end_pos, start_pos)\n      else\n          -- make empty\n        create Result.make_empty\n        Result.rebase (start_pos)\n      end\n    ensure\n      lower: Result.lower = start_pos\n      upper: Result.upper = end_pos\n      -- copied: forall `i' in `start_pos' .. `end_pos',\n      --     Result.item (i) = item (i)\n    end\n\nfeature {NONE} -- Inapplicable\n\n  prune (v: G)\n      -- Remove first occurrence of `v' if any.\n      -- (Precondition is False.)\n    do\n    end\n\n  extend (v: G)\n      -- Add `v' to structure.\n      -- (Precondition is False.)\n    do\n    end\n\nfeature {NONE} -- Implementation\n\n  empty_area: BOOLEAN\n      -- Is `area' empty?\n    do\n      Result := area = Void or else area.capacity = 0\n    end\n\ninvariant\n\n  area_exists: area /= Void\n  consistent_size: capacity = upper - lower + 1\n  non_negative_count: count >= 0\n  index_set_has_same_count: valid_index_set\n-- Internal discussion haven't reached an agreement on this invariant\n--  index_set_has_same_bounds: ((index_set.lower = lower) and\n--        (index_set.upper = lower + count - 1))\n\nend\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      asa_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\n-- convert\n--   make_from_reference ({INTEGER_32_REF}),\n--   to_real: {REAL_32},\n--   to_double: {REAL_64},\n--   to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil,\n  make_from_separate\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    extern\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFueS5lIiwiYXJyYXkuZSIsImludGVnZXIuZSIsInN0cmluZy5lIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUNEQTtBQ0FBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzXG4gIEFOWVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBjb25mb3Jtc190byAob3RoZXI6IEFOWSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBjb25mb3JtIHRvIHR5cGVcbiAgICAgIC0tIG9mIGBvdGhlcicgKGFzIHBlciBFaWZmZWw6IFRoZSBMYW5ndWFnZSwgY2hhcHRlciAxMyk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgc2FtZV90eXBlIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBpZGVudGljYWwgdG8gdHlwZSBvZiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvbmZvcm1zX3RvIChvdGhlcikgYW5kXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkXG4gICAgICAtLSBlcXVhbCB0byBjdXJyZW50IG9iamVjdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIgfiBDdXJyZW50XG4gICAgICBjb25zaXN0ZW50OiBzdGFuZGFyZF9pc19lcXVhbCAob3RoZXIpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QsIGFuZCBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3R5cGU6IFJlc3VsdCBpbXBsaWVzIHNhbWVfdHlwZSAob3RoZXIpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG90aGVyLnN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBlcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkXG4gICAgICAtLSB0byBvYmplY3RzIGNvbnNpZGVyZWQgZXF1YWw/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkIHRvXG4gICAgICAtLSBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlP1xuICAgICAgLS0gQWx3YXlzIHVzZXMgZGVmYXVsdCBvYmplY3QgY29tcGFyaXNvbiBjcml0ZXJpb24uXG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuc3RhbmRhcmRfaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19kZWVwX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBDdXJyZW50JyBhbmQgYG90aGVyJyBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfZGVlcF9lcXVhbCAoQ3VycmVudClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkXG4gICAgICAtLSBvciBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIGRvXG4gICAgICBpZiBhID0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiID0gVm9pZFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYiAvPSBWb2lkIGFuZCB0aGVuIGEuaXNfZGVlcF9lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2VxdWFsIChhLCBiKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgYm90aF9vcl9ub25lX3ZvaWQ6IChhID0gVm9pZCkgaW1wbGllcyAoUmVzdWx0ID0gKGIgPSBWb2lkKSlcbiAgICAgIHNhbWVfdHlwZTogKFJlc3VsdCBhbmQgKGEgLz0gVm9pZCkpIGltcGxpZXMgKGIgLz0gVm9pZCBhbmQgdGhlbiBhLnNhbWVfdHlwZSAoYikpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIGRlZXBfZXF1YWwgKGIsIGEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgaW86IFNURF9GSUxFU1xuICAgICAgLS0gSGFuZGxlIHRvIHN0YW5kYXJkIGZpbGUgc2V0dXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpb19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gTmV3IHN0cmluZyBjb250YWluaW5nIHRlcnNlIHByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRhZ2dlZF9vdXRcbiAgICBlbnN1cmVcbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdGFnZ2VkX291dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHRhZ2dlZF9vdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcHJpbnQgKG86IGRldGFjaGFibGUgQU5ZKVxuICAgICAgLS0gV3JpdGUgdGVyc2UgZXh0ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYG8nXG4gICAgICAtLSBvbiBzdGFuZGFyZCBvdXRwdXQuXG4gICAgZG9cbiAgICAgIGlmIG8gLz0gVm9pZCB0aGVuXG4gICAgICAgIGlvLnB1dF9zdHJpbmcgKG8ub3V0KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgZGVmYXVsdF9jcmVhdGVcbiAgICAgIC0tIFByb2Nlc3MgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBubyBjcmVhdGlvbiBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG4gIGZyb3plbiBkbG9fbm90aGluZ1xuICAgICAgLS0gRXhlY3V0ZSBhIG51bGwgYWN0aW9uLlxuICAgIGRvXG4gICAgZW5kXG5cbmludmFyaWFudFxuICByZWZsZXhpdmVfZXF1YWxpdHk6IHN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICByZWZsZXhpdmVfY29uZm9ybWFuY2U6IGNvbmZvcm1zX3RvIChDdXJyZW50KVxuXG5cbmVuZFxuIiwibm90ZVxuICBsaWJyYXJ5OiBcIkZyZWUgaW1wbGVtZW50YXRpb24gb2YgRUxLUyBsaWJyYXJ5XCJcbiAgc3RhdHVzOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGxlZ2FsOiBcIlNlZSBub3RpY2UgYXQgZW5kIG9mIGNsYXNzLlwiXG4gIGRhdGU6IFwiJERhdGU6IDIwMTMtMDEtMjUgMTQ6MTg6MjAgLTA4MDAgKEZyaSwgMjUgSmFuIDIwMTMpICRcIlxuICByZXZpc2lvbjogXCIkUmV2aXNpb246IDkyMTM4ICRcIlxuXG5jbGFzcyBBUlJBWSBbR10gaW5oZXJpdFxuXG4gIFJFU0laQUJMRSBbR11cbiAgICByZWRlZmluZVxuICAgICAgZnVsbCwgY29weSwgaXNfZXF1YWwsIHJlc2l6YWJsZVxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbRywgSU5URUdFUl1cbiAgICByZW5hbWVcbiAgICAgIGl0ZW0gYXMgaXRlbSBhbGlhcyBcIltdXCJcbiAgICByZWRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWxcbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtHXVxuICAgIGV4cG9ydFxuICAgICAge0FSUkFZfSBzZXRfYXJlYVxuICAgIHJlZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgaXRlbSwgcHV0LCBhdCwgdmFsaWRfaW5kZXhcbiAgICBlbmRcblxuY3JlYXRlXG4gIG1ha2VfZW1wdHksXG4gIG1ha2UsXG4gIG1ha2VfZmlsbGVkLFxuICBtYWtlX2Zyb21fYXJyYXksXG4gIG1ha2VfZnJvbV9zcGVjaWFsLFxuICBtYWtlX2Zyb21fY2lsXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7TkFUSVZFX0FSUkFZIFtHXX0sXG4gIHRvX3NwZWNpYWw6IHtTUEVDSUFMIFtHXX0sXG4gIG1ha2VfZnJvbV9jaWwgKHtOQVRJVkVfQVJSQVkgW0ddfSlcblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZW1wdHlcbiAgICAgIC0tIEFsbG9jYXRlIGVtcHR5IGFycmF5IHN0YXJ0aW5nIGF0IGAxJy5cbiAgICBkb1xuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gMFxuICAgICAgbWFrZV9lbXB0eV9hcmVhICgwKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAwXG4gICAgICBpdGVtc19zZXQ6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgbWFrZV9maWxsZWQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBhcnJheTsgc2V0IGluZGV4IGludGVydmFsIHRvXG4gICAgICAtLSBgbWluX2luZGV4JyAuLiBgbWF4X2luZGV4Jzsgc2V0IGFsbCB2YWx1ZXMgdG8gZGVmYXVsdC5cbiAgICAgIC0tIChNYWtlIGFycmF5IGVtcHR5IGlmIGBtaW5faW5kZXgnID0gYG1heF9pbmRleCcgKyAxKS5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9ib3VuZHM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG46IElOVEVHRVJcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBuIDo9IG1heF9pbmRleCAtIG1pbl9pbmRleCArIDFcbiAgICAgIGVuZFxuICAgICAgbWFrZV9maWxsZWRfYXJlYSAoYV9kZWZhdWx0X3ZhbHVlLCBuKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IG1pbl9pbmRleFxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IG1heF9pbmRleFxuICAgICAgaXRlbXNfc2V0OiBmaWxsZWRfd2l0aCAoYV9kZWZhdWx0X3ZhbHVlKVxuICAgIGVuZFxuXG4gIG1ha2UgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgYXJyYXk7IHNldCBpbmRleCBpbnRlcnZhbCB0b1xuICAgICAgLS0gYG1pbl9pbmRleCcgLi4gYG1heF9pbmRleCc7IHNldCBhbGwgdmFsdWVzIHRvIGRlZmF1bHQuXG4gICAgICAtLSAoTWFrZSBhcnJheSBlbXB0eSBpZiBgbWluX2luZGV4JyA9IGBtYXhfaW5kZXgnICsgMSkuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiIGBtYWtlJyBpcyBub3Qgdm9pZC1zYWZlIHN0YXRpY2FsbHkuIFVzZSBgbWFrZV9lbXB0eScgb3IgYG1ha2VfZmlsbGVkJyBpbnN0ZWFkLiBbMDctMjAxMF1cIlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2JvdW5kczogbWluX2luZGV4IDw9IG1heF9pbmRleCArIDFcbiAgICAgIGhhc19kZWZhdWx0OiBtaW5faW5kZXggPD0gbWF4X2luZGV4IGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgbG93ZXIgOj0gbWluX2luZGV4XG4gICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGlmIG1pbl9pbmRleCA8PSBtYXhfaW5kZXggdGhlblxuICAgICAgICBtYWtlX2ZpbGxlZF9hcmVhICgoe0d9KS5kZWZhdWx0LCBtYXhfaW5kZXggLSBtaW5faW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlX2VtcHR5X2FyZWEgKDApXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGxvd2VyX3NldDogbG93ZXIgPSBtaW5faW5kZXhcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBtYXhfaW5kZXhcbiAgICAgIGl0ZW1zX3NldDogYWxsX2RlZmF1bHRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fYXJyYXkgKGE6IEFSUkFZIFtHXSlcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgaXRlbXMgb2YgYGEnLlxuICAgICAgLS0gKFVzZWZ1bCBpbiBwcm9wZXIgZGVzY2VuZGFudHMgb2YgY2xhc3MgYEFSUkFZJyxcbiAgICAgIC0tIHRvIGluaXRpYWxpemUgYW4gYXJyYXktbGlrZSBvYmplY3QgZnJvbSBhIG1hbmlmZXN0IGFycmF5LilcbiAgICByZXF1aXJlXG4gICAgICBhcnJheV9leGlzdHM6IGEgLz0gVm9pZFxuICAgIGRvXG4gICAgICBzZXRfYXJlYSAoYS5hcmVhKVxuICAgICAgbG93ZXIgOj0gYS5sb3dlclxuICAgICAgdXBwZXIgOj0gYS51cHBlclxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYS5hcmVhXG4gICAgICBsb3dlcl9zZXQ6IGxvd2VyID0gYS5sb3dlclxuICAgICAgdXBwZXJfc2V0OiB1cHBlciA9IGEudXBwZXJcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fc3BlY2lhbCAoYTogU1BFQ0lBTCBbR10pXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgZnJvbSBpdGVtcyBvZiBgYScuXG4gICAgcmVxdWlyZVxuICAgICAgc3BlY2lhbF9hdHRhY2hlZDogYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIHNldF9hcmVhIChhKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYS5jb3VudFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkOiBhcmVhID0gYVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IDFcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhLmNvdW50XG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAobmE6IE5BVElWRV9BUlJBWSBbbGlrZSBpdGVtXSlcbiAgICAgIC0tIEluaXRpYWxpemUgYXJyYXkgZnJvbSBgbmEnLlxuICAgIHJlcXVpcmVcbiAgICAgIGlzX2RvdG5ldDoge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICAgIG5hX25vdF92b2lkOiBuYSAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZnJvbV9uYXRpdmVfYXJyYXkgKG5hKVxuICAgICAgbG93ZXIgOj0gMVxuICAgICAgdXBwZXIgOj0gYXJlYS5jb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEFjY2Vzc1xuXG4gIGl0ZW0gYWxpYXMgXCJbXVwiLCBhdCBhbGlhcyBcIkBcIiAoaTogSU5URUdFUik6IEcgYXNzaWduIHB1dFxuICAgICAgLS0gRW50cnkgYXQgaW5kZXggYGknLCBpZiBpbiBpbmRleCBpbnRlcnZhbFxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gbG93ZXIpXG4gICAgZW5kXG5cbiAgZW50cnkgKGk6IElOVEVHRVIpOiBHXG4gICAgICAtLSBFbnRyeSBhdCBpbmRleCBgaScsIGlmIGluIGluZGV4IGludGVydmFsXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpXG4gICAgZW5kXG5cbiAgaGFzICh2OiBHKTogQk9PTEVBTlxuICAgICAgLS0gRG9lcyBgdicgYXBwZWFyIGluIGFycmF5P1xuICAgICAgLS0gKFJlZmVyZW5jZSBvciBvYmplY3QgZXF1YWxpdHksXG4gICAgICAtLSBiYXNlZCBvbiBgb2JqZWN0X2NvbXBhcmlzb24nLilcbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBuYiA6PSB1cHBlciAtIGxvd2VyXG4gICAgICBpZiBvYmplY3RfY29tcGFyaXNvbiBhbmQgdiAvPSBWb2lkIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgfiB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGkgPiBuYiBvciBSZXN1bHRcbiAgICAgICAgbG9vcFxuICAgICAgICAgIFJlc3VsdCA6PSBsX2FyZWEuaXRlbSAoaSkgPSB2XG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIE1lYXN1cmVtZW50XG5cbiAgbG93ZXI6IElOVEVHRVJcbiAgICAgIC0tIE1pbmltdW0gaW5kZXhcblxuICB1cHBlcjogSU5URUdFUlxuICAgICAgLS0gTWF4aW11bSBpbmRleFxuXG4gIGNvdW50LCBjYXBhY2l0eTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIGF2YWlsYWJsZSBpbmRpY2VzXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjb25zaXN0ZW50X3dpdGhfYm91bmRzOiBSZXN1bHQgPSB1cHBlciAtIGxvd2VyICsgMVxuICAgIGVuZFxuXG4gIG9jY3VycmVuY2VzICh2OiBHKTogSU5URUdFUlxuICAgICAgLS0gTnVtYmVyIG9mIHRpbWVzIGB2JyBhcHBlYXJzIGluIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG9iamVjdF9jb21wYXJpc29uIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gbG93ZXJcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID4gdXBwZXJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGlmIGl0ZW0gKGkpIH4gdiB0aGVuXG4gICAgICAgICAgICBSZXN1bHQgOj0gUmVzdWx0ICsgMVxuICAgICAgICAgIGVuZFxuICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbHNlXG4gICAgICAgIGZyb21cbiAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA+IHVwcGVyXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBpZiBpdGVtIChpKSA9IHYgdGhlblxuICAgICAgICAgICAgUmVzdWx0IDo9IFJlc3VsdCArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgaW5kZXhfc2V0OiBJTlRFR0VSX0lOVEVSVkFMXG4gICAgICAtLSBSYW5nZSBvZiBhY2NlcHRhYmxlIGluZGV4ZXNcbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChsb3dlciwgdXBwZXIpXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHNhbWVfY291bnQ6IFJlc3VsdC5jb3VudCA9IGNvdW50XG4gICAgICBzYW1lX2JvdW5kczpcbiAgICAgICAgKChSZXN1bHQubG93ZXIgPSBsb3dlcikgYW5kIChSZXN1bHQudXBwZXIgPSB1cHBlcikpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYXJyYXkgbWFkZSBvZiB0aGUgc2FtZSBpdGVtcyBhcyBgb3RoZXInP1xuICAgIGxvY2FsXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIG90aGVyID0gQ3VycmVudCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICBlbHNlaWYgbG93ZXIgPSBvdGhlci5sb3dlciBhbmQgdGhlbiB1cHBlciA9IG90aGVyLnVwcGVyIGFuZCB0aGVuXG4gICAgICAgIG9iamVjdF9jb21wYXJpc29uID0gb3RoZXIub2JqZWN0X2NvbXBhcmlzb25cbiAgICAgIHRoZW5cbiAgICAgICAgaWYgb2JqZWN0X2NvbXBhcmlzb24gdGhlblxuICAgICAgICAgIGZyb21cbiAgICAgICAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgICAgICAgICBpIDo9IGxvd2VyXG4gICAgICAgICAgdW50aWxcbiAgICAgICAgICAgIG5vdCBSZXN1bHQgb3IgaSA+IHVwcGVyXG4gICAgICAgICAgbG9vcFxuICAgICAgICAgICAgUmVzdWx0IDo9IGl0ZW0gKGkpIH4gb3RoZXIuaXRlbSAoaSlcbiAgICAgICAgICAgIGkgOj0gaSArIDFcbiAgICAgICAgICBlbmRcbiAgICAgICAgZWxzZVxuICAgICAgICAgIFJlc3VsdCA6PSBhcmVhLnNhbWVfaXRlbXMgKG90aGVyLmFyZWEsIDAsIDAsIGNvdW50KVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBhbGxfZGVmYXVsdDogQk9PTEVBTlxuICAgICAgLS0gQXJlIGFsbCBpdGVtcyBzZXQgdG8gZGVmYXVsdCB2YWx1ZXM/XG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID4gMCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSAoe0d9KS5oYXNfZGVmYXVsdCBhbmQgdGhlbiBhcmVhLmZpbGxlZF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBkZWZpbml0aW9uOiBSZXN1bHQgPSAoY291bnQgPSAwIG9yIGVsc2VcbiAgICAgICAgKChub3QgYXR0YWNoZWQgaXRlbSAodXBwZXIpIGFzIGkgb3IgZWxzZSBpID0gKHtHfSkuZGVmYXVsdCkgYW5kXG4gICAgICAgIHN1YmFycmF5IChsb3dlciwgdXBwZXIgLSAxKS5hbGxfZGVmYXVsdCkpXG4gICAgZW5kXG5cbiAgZmlsbGVkX3dpdGggKHY6IEcpOiBCT09MRUFOXG4gICAgICAtLSBBcmUgYWxsIGl0ZW1zIHNldCB0byBgdic/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLmZpbGxlZF93aXRoICh2LCAwLCB1cHBlciAtIGxvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvdW50ID0gMCBvciBlbHNlXG4gICAgICAgIChpdGVtICh1cHBlcikgPSB2IGFuZCBzdWJhcnJheSAobG93ZXIsIHVwcGVyIC0gMSkuZmlsbGVkX3dpdGggKHYpKSlcbiAgICBlbmRcblxuICBmdWxsOiBCT09MRUFOXG4gICAgICAtLSBJcyBzdHJ1Y3R1cmUgZmlsbGVkIHRvIGNhcGFjaXR5PyAoQW5zd2VyOiB5ZXMpXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBUcnVlXG4gICAgZW5kXG5cbiAgc2FtZV9pdGVtcyAob3RoZXI6IGxpa2UgQ3VycmVudCk6IEJPT0xFQU5cbiAgICAgIC0tIERvIGBvdGhlcicgYW5kIEN1cnJlbnQgaGF2ZSBzYW1lIGl0ZW1zP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGlmIGNvdW50ID0gb3RoZXIuY291bnQgdGhlblxuICAgICAgICBSZXN1bHQgOj0gYXJlYS5zYW1lX2l0ZW1zIChvdGhlci5hcmVhLCAwLCAwLCBjb3VudClcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKChjb3VudCA9IG90aGVyLmNvdW50KSBhbmQgdGhlblxuICAgICAgICAoY291bnQgPSAwIG9yIGVsc2UgKGl0ZW0gKHVwcGVyKSA9IG90aGVyLml0ZW0gKG90aGVyLnVwcGVyKVxuICAgICAgICBhbmQgc3ViYXJyYXkgKGxvd2VyLCB1cHBlciAtIDEpLnNhbWVfaXRlbXNcbiAgICAgICAgKG90aGVyLnN1YmFycmF5IChvdGhlci5sb3dlciwgb3RoZXIudXBwZXIgLSAxKSkpKSlcbiAgICBlbmRcblxuICB2YWxpZF9pbmRleCAoaTogSU5URUdFUik6IEJPT0xFQU5cbiAgICAgIC0tIElzIGBpJyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgYXJyYXk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSAobG93ZXIgPD0gaSkgYW5kIHRoZW4gKGkgPD0gdXBwZXIpXG4gICAgZW5kXG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTlxuICAgICAgLS0gTWF5IGl0ZW1zIGJlIGFkZGVkP1xuICAgICAgLS0gKEFuc3dlcjogbm8sIGFsdGhvdWdoIGFycmF5IG1heSBiZSByZXNpemVkLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IEZhbHNlXG4gICAgZW5kXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiBuby4pXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBGYWxzZVxuICAgIGVuZFxuXG4gIHJlc2l6YWJsZTogQk9PTEVBTlxuICAgICAgLS0gQ2FuIGFycmF5IGJlIHJlc2l6ZWQgYXV0b21hdGljYWxseT9cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZW5kXG5cbiAgdmFsaWRfaW5kZXhfc2V0OiBCT09MRUFOXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBpbmRleF9zZXQuY291bnQgPSBjb3VudFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgcHV0ICh2OiBsaWtlIGl0ZW07IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGBpJy10aCBlbnRyeSwgaWYgaW4gaW5kZXggaW50ZXJ2YWwsIGJ5IGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBlbnRlciAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBgaSctdGggZW50cnksIGlmIGluIGluZGV4IGludGVydmFsLCBieSBgdicuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfa2V5OiB2YWxpZF9pbmRleCAoaSlcbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICBlbmRcblxuICBmb3JjZSAodjogbGlrZSBpdGVtOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQXNzaWduIGl0ZW0gYHYnIHRvIGBpJy10aCBlbnRyeS5cbiAgICAgIC0tIFJlc2l6ZSB0aGUgYXJyYXkgaWYgYGknIGZhbGxzIG91dCBvZiBjdXJyZW50bHkgZGVmaW5lZCBib3VuZHM7IHByZXNlcnZlIGV4aXN0aW5nIGl0ZW1zLlxuICAgICAgLS0gSW4gdm9pZC1zYWZlIG1vZGUsIGlmICh7R30pLmhhc19kZWZhdWx0IGRvZXMgbm90IGhvbGQsIHRoZW4geW91IGNhbiBvbmx5IGluc2VydCBiZXR3ZWVuXG4gICAgICAtLSBgbG93ZXIgLSAxJyBvciBgdXBwZXIgKyAxJyBwb3NpdGlvbiBpbiB0aGUgQVJSQVkuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHRfaWZfdG9vX2xvdzpcbiAgICAgICAgKGkgPCBsb3dlciAtIDEgYW5kIGxvd2VyIC89IHtsaWtlIGxvd2VyfS5taW5fdmFsdWUpIGltcGxpZXMgKHtHfSkuaGFzX2RlZmF1bHRcbiAgICAgIGhhc19kZWZhdWx0X2lmX3Rvb19oaWdoOlxuICAgICAgICAoaSA+IHVwcGVyICsgMSBhbmQgdXBwZXIgLz0ge2xpa2UgdXBwZXJ9Lm1heF92YWx1ZSkgaW1wbGllcyAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGxvY2FsXG4gICAgICBvbGRfc2l6ZSwgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIG5ld19sb3dlciwgbmV3X3VwcGVyOiBJTlRFR0VSXG4gICAgICBsX2NvdW50LCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lOiBCT09MRUFOXG4gICAgZG9cbiAgICAgIG5ld19sb3dlciA6PSBsb3dlci5taW4gKGkpXG4gICAgICBuZXdfdXBwZXIgOj0gdXBwZXIubWF4IChpKVxuICAgICAgbmV3X3NpemUgOj0gbmV3X3VwcGVyIC0gbmV3X2xvd2VyICsgMVxuICAgICAgbF9pbmNyZWFzZWRfYnlfb25lIDo9IChpID0gdXBwZXIgKyAxKSBvciAoaSA9IGxvd2VyIC0gMSlcbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICAgIC0tIExpc3QgaXMgZW1wdHkuIEZpcnN0IHdlIGNyZWF0ZSBhbiBlbXB0eSBTUEVDSUFMIG9mIHRoZSByaWdodCBjYXBhY2l0eS5cbiAgICAgICAgbWFrZV9lbXB0eV9hcmVhIChuZXdfc2l6ZS5tYXggKGFkZGl0aW9uYWxfc3BhY2UpKVxuICAgICAgICBpZiBub3QgbF9pbmNyZWFzZWRfYnlfb25lIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG5lZWQgdG8gZmlsbCB0aGUgU1BFQ0lBTCBmb3IgYDAnIHRvIGBuZXdfc2l6ZSAtIDInIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDAsIG5ld19zaXplIC0gMilcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuZXh0ZW5kICh2KVxuICAgICAgZWxzZVxuICAgICAgICBvbGRfc2l6ZSA6PSBhcmVhLmNhcGFjaXR5XG4gICAgICAgIGlmIG5ld19zaXplID4gb2xkX3NpemUgdGhlblxuICAgICAgICAgIHNldF9hcmVhIChhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuZXdfc2l6ZS5tYXggKG9sZF9zaXplICsgYWRkaXRpb25hbF9zcGFjZSkpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgICAgLS0gV2UgaGF2ZSBpbnNlcnRlZCBiZWxvdyB0aGUgcHJldmlvdXMgYGxvd2VyJy4gV2UgbmVlZCB0byBzaGlmdCBlbnRyaWVzIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgLS0gYmVmb3JlIHdlIGNhbiBpbnNlcnQgYHYnLlxuICAgICAgICAgIGxfb2Zmc2V0IDo9IGxvd2VyIC0gbmV3X2xvd2VyXG4gICAgICAgICAgbF9jb3VudCA6PSBjYXBhY2l0eVxuICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgYW5kIGxfb2Zmc2V0ID4gbF9jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdpdGggdGhlIGBuZXdfbG93ZXInIGdpdmVuLCB0aGUgZGF0YSBoYXMgdG8gbW92ZVxuICAgICAgICAgICAgICAtLSBiZXlvbmQgdGhlIGBhcmVhJydzIGNvdW50IHdoaWNoIHJlcXVpcmVzIHVzIHRvIGZpbGxcbiAgICAgICAgICAgICAgLS0gdGhlIGdhcCBiZXR3ZWVuIHRoZSBvbGQgZGF0YSdzIGxvY2F0aW9uIGFuZCB0aGUgbmV3IG9uZVxuICAgICAgICAgICAgICAtLSB3aXRoIHRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIGxfY291bnQsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICBhcmVhLm1vdmVfZGF0YSAoMCwgbF9vZmZzZXQsIGxfY291bnQpXG4gICAgICAgICAgaWYgbm90IGxfaW5jcmVhc2VkX2J5X29uZSB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIHN0YXJ0IGF0IGAxJyBhbmQgbm90IGAwJyBiZWNhdXNlIG5leHQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgLS0gd2lsbCB1cGRhdGUgdGhlIGl0ZW0gYXQgcG9zaXRpb24gYDAnLlxuICAgICAgICAgICAgYXJlYS5maWxsX3dpdGggKCh7R30pLmRlZmF1bHQsIDEsIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgICBlbmRcbiAgICAgICAgICAgIC0tIEluc2VydCBgdicgYXQgdGhlIG5ldyBsb3dlciBwb3NpdGlvbi5cbiAgICAgICAgICBhcmVhLnB1dCAodiwgMClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmIG5ld19zaXplID4gYXJlYS5jb3VudCB0aGVuXG4gICAgICAgICAgICAgIC0tIFdlIGFyZSBhZGRpbmcgdG8gdGhlIG5ldyBgdXBwZXInIHBvc2l0aW9uLiBGaXJzdCB3ZSBmaWxsIHRoZSBub24taW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgLS0gZWxlbWVudHMgaWYgYW55IHVwIHRvIGBuZXdfc2l6ZSAtIDInIChpLmUuIHVwIHRoZSB0aGUgaXRlbSBwcmlvciB0byBgdXBwZXInKS5cbiAgICAgICAgICAgIGlmIG5vdCBsX2luY3JlYXNlZF9ieV9vbmUgdGhlblxuICAgICAgICAgICAgICBhcmVhLmZpbGxfd2l0aCAoKHtHfSkuZGVmYXVsdCwgYXJlYS5jb3VudCwgbmV3X3NpemUgLSAyKVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgICAgIC0tIEFkZCBgdicgYXQgdXBwZXIgcG9zaXRpb24uXG4gICAgICAgICAgICBhcmVhLmV4dGVuZCAodilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIC0tIEhlcmUgYGxvd2VyJyBoYXNuJ3QgY2hhbmdlZFxuICAgICAgICAgICAgYXJlYS5wdXQgKHYsIGkgLSBsb3dlcilcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIGxvd2VyIDo9IG5ld19sb3dlclxuICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogaXRlbSAoaSkgPSB2XG4gICAgICBoaWdoZXJfY291bnQ6IGNvdW50ID49IG9sZCBjb3VudFxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IChvbGQgbG93ZXIpLm1pbiAoaSlcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSAob2xkIHVwcGVyKS5tYXggKGkpXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoICh2OiBHKVxuICAgICAgLS0gU2V0IGl0ZW1zIGJldHdlZW4gYGxvd2VyJyBhbmQgYHVwcGVyJyB3aXRoIGB2Jy5cbiAgICBkb1xuICAgICAgYXJlYS5maWxsX3dpdGggKHYsIDAsIHVwcGVyIC0gbG93ZXIpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgICAgY291bnRfZGVmaW5pdGlvbjogY291bnQgPSBvbGQgY291bnRcbiAgICAgIGZpbGxlZDogZmlsbGVkX3dpdGggKHYpXG4gICAgZW5kXG5cbiAgc3ViY29weSAob3RoZXI6IEFSUkFZIFtsaWtlIGl0ZW1dOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgaXRlbXMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZCBgZW5kX3BvcydcbiAgICAgIC0tIHRvIGN1cnJlbnQgYXJyYXkgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogc3RhcnRfcG9zID49IG90aGVyLmxvd2VyXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IG90aGVyLnVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgICAgdmFsaWRfaW5kZXhfcG9zOiBpbmRleF9wb3MgPj0gbG93ZXJcbiAgICAgIGVub3VnaF9zcGFjZTogKHVwcGVyIC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBkb1xuICAgICAgYXJlYS5jb3B5X2RhdGEgKG90aGVyLmFyZWEsIHN0YXJ0X3BvcyAtIG90aGVyLmxvd2VyLCBpbmRleF9wb3MgLSBsb3dlciwgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgZW5zdXJlXG4gICAgICAtLSBjb3BpZWQ6IGZvcmFsbCBgaScgaW4gMCAuLiAoYGVuZF9wb3MnLWBzdGFydF9wb3MnKSxcbiAgICAgIC0tICAgICBpdGVtIChpbmRleF9wb3MgKyBpKSA9IG90aGVyLml0ZW0gKHN0YXJ0X3BvcyArIGkpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gSXRlcmF0aW9uXG5cbiAgZG9fYWxsIChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbR11dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSwgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIGNoYW5nZXMgdGhlIHN0cnVjdHVyZTtcbiAgICAgIC0tIGluIHN1Y2ggYSBjYXNlLCBhcHBseSBpdGVyYXRvciB0byBjbG9uZSBvZiBzdHJ1Y3R1cmUgaW5zdGVhZC5cbiAgICByZXF1aXJlXG4gICAgICBhY3Rpb25fbm90X3ZvaWQ6IGFjdGlvbiAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9fYWxsX2luX2JvdW5kcyAoYWN0aW9uLCAwLCBjb3VudCAtIDEpXG4gICAgZW5kXG5cbiAgZG9faWYgKGFjdGlvbjogUFJPQ0VEVVJFIFtBTlksIFRVUExFIFtHXV07IHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pXG4gICAgICAtLSBBcHBseSBgYWN0aW9uJyB0byBldmVyeSBpdGVtIHRoYXQgc2F0aXNmaWVzIGB0ZXN0JywgZnJvbSBmaXJzdCB0byBsYXN0LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgcmVxdWlyZVxuICAgICAgYWN0aW9uX25vdF92b2lkOiBhY3Rpb24gLz0gVm9pZFxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEuZG9faWZfaW5fYm91bmRzIChhY3Rpb24sIHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICB0aGVyZV9leGlzdHMgKHRlc3Q6IEZVTkNUSU9OIFtBTlksIFRVUExFIFtHXSwgQk9PTEVBTl0pOiBCT09MRUFOXG4gICAgICAtLSBJcyBgdGVzdCcgdHJ1ZSBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0/XG4gICAgcmVxdWlyZVxuICAgICAgdGVzdF9ub3Rfdm9pZDogdGVzdCAvPSBWb2lkXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLnRoZXJlX2V4aXN0c19pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBmb3JfYWxsICh0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbR10sIEJPT0xFQU5dKTogQk9PTEVBTlxuICAgICAgLS0gSXMgYHRlc3QnIHRydWUgZm9yIGFsbCBpdGVtcz9cbiAgICByZXF1aXJlXG4gICAgICB0ZXN0X25vdF92b2lkOiB0ZXN0IC89IFZvaWRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuZm9yX2FsbF9pbl9ib3VuZHMgKHRlc3QsIDAsIGNvdW50IC0gMSlcbiAgICBlbmRcblxuICBkb19hbGxfd2l0aF9pbmRleCAoYWN0aW9uOiBQUk9DRURVUkUgW0FOWSwgVFVQTEUgW0csIElOVEVHRVJdXSlcbiAgICAgIC0tIEFwcGx5IGBhY3Rpb24nIHRvIGV2ZXJ5IGl0ZW0sIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIHJlY2VpdmVzIGl0ZW0gYW5kIGl0cyBpbmRleC5cbiAgICAgIC0tIFNlbWFudGljcyBub3QgZ3VhcmFudGVlZCBpZiBgYWN0aW9uJyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGFjdGlvbi5jYWxsIChbbF9hcmVhLml0ZW0gKGkpLCBqXSlcbiAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBkb19pZl93aXRoX2luZGV4IChhY3Rpb246IFBST0NFRFVSRSBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl1dOyB0ZXN0OiBGVU5DVElPTiBbQU5ZLCBUVVBMRSBbRywgSU5URUdFUl0sIEJPT0xFQU5dKVxuICAgICAgLS0gQXBwbHkgYGFjdGlvbicgdG8gZXZlcnkgaXRlbSB0aGF0IHNhdGlzZmllcyBgdGVzdCcsIGZyb20gZmlyc3QgdG8gbGFzdC5cbiAgICAgIC0tIGBhY3Rpb24nIGFuZCBgdGVzdCcgcmVjZWl2ZSB0aGUgaXRlbSBhbmQgaXRzIGluZGV4LlxuICAgICAgLS0gU2VtYW50aWNzIG5vdCBndWFyYW50ZWVkIGlmIGBhY3Rpb24nIG9yIGB0ZXN0JyBjaGFuZ2VzIHRoZSBzdHJ1Y3R1cmU7XG4gICAgICAtLSBpbiBzdWNoIGEgY2FzZSwgYXBwbHkgaXRlcmF0b3IgdG8gY2xvbmUgb2Ygc3RydWN0dXJlIGluc3RlYWQuXG4gICAgbG9jYWxcbiAgICAgIGksIGosIG5iOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMFxuICAgICAgICBqIDo9IGxvd2VyXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IG5iXG4gICAgICBsb29wXG4gICAgICAgIGlmIHRlc3QuaXRlbSAoW2xfYXJlYS5pdGVtIChpKSwgal0pIHRoZW5cbiAgICAgICAgICBhY3Rpb24uY2FsbCAoW2xfYXJlYS5pdGVtIChpKSwgal0pXG4gICAgICAgIGVuZFxuICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICB3aXBlX291dFxuICAgICAgLS0gTWFrZSBhcnJheSBlbXB0eS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJOb3QgYXBwbGljYWJsZSBzaW5jZSBub3QgYHBydW5hYmxlJy4gVXNlIGBkaXNjYXJkX2l0ZW1zJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGRpc2NhcmRfaXRlbXNcbiAgICBlbmRcblxuICBkaXNjYXJkX2l0ZW1zXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMgd2l0aCByZWFsbG9jYXRpb24uXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGNyZWF0ZSBhcmVhLm1ha2VfZmlsbGVkICgoe0d9KS5kZWZhdWx0LCBjYXBhY2l0eSlcbiAgICBlbnN1cmVcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgaXRlbXMgdG8gZGVmYXVsdCB2YWx1ZXMuXG4gICAgcmVxdWlyZVxuICAgICAgaGFzX2RlZmF1bHQ6ICh7R30pLmhhc19kZWZhdWx0XG4gICAgZG9cbiAgICAgIGFyZWEuZmlsbF93aXRoICgoe0d9KS5kZWZhdWx0LCAwLCBhcmVhLmNvdW50IC0gMSlcbiAgICBlbnN1cmVcbiAgICAgIHN0YWJsZV9sb3dlcjogbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIHN0YWJsZV91cHBlcjogdXBwZXIgPSBvbGQgdXBwZXJcbiAgICAgIGRlZmF1bHRfaXRlbXM6IGFsbF9kZWZhdWx0XG4gICAgZW5kXG5cbiAga2VlcF9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIHJlcXVpcmVcbiAgICAgIG5vbl9uZWdhdGl2ZV9hcmd1bWVudDogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPCBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyICsgbiAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhIChuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gbi5taW4gKG9sZCBjb3VudClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBsYXN0IGBuJztcbiAgICAgIC0tIGRvIG5vdGhpbmcgaWYgYG4nID49IGBjb3VudCcuXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX2FyZ3VtZW50OiBuID49IDBcbiAgICBsb2NhbFxuICAgICAgbmI6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBsb3dlciA6PSB1cHBlciAtIG4gKyAxXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG4ubWluIChvbGQgY291bnQpXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV9oZWFkIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGZpcnN0IGBuJyBpdGVtcztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICB1cHBlciA6PSBsb3dlciAtIDFcbiAgICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhICgwKVxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IChvbGQgY291bnQgLSBuKS5tYXggKDApXG4gICAgICBzYW1lX3VwcGVyOiB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHJlbW92ZV90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGxhc3QgYG4nIGl0ZW1zO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIGlmIG4gPiBjb3VudCB0aGVuXG4gICAgICAgIHVwcGVyIDo9IGxvd2VyIC0gMVxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKDApXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCAtIG4pLm1heCAoMClcbiAgICAgIHNhbWVfbG93ZXI6IGxvd2VyID0gb2xkIGxvd2VyXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBncm93IChpOiBJTlRFR0VSKVxuICAgICAgLS0gQ2hhbmdlIHRoZSBjYXBhY2l0eSB0byBhdCBsZWFzdCBgaScuXG4gICAgZG9cbiAgICAgIGlmIGkgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGNvbnNlcnZhdGl2ZV9yZXNpemVfd2l0aF9kZWZhdWx0ICgoe0d9KS5kZWZhdWx0LCBsb3dlciwgdXBwZXIgKyBpIC0gY2FwYWNpdHkpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBjb25zZXJ2YXRpdmVfcmVzaXplIChtaW5faW5kZXgsIG1heF9pbmRleDogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBhcnJheSBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gaW5kaWNlcyBkb3duIHRvIGBtaW5faW5kZXgnIGFuZCB1cCB0byBgbWF4X2luZGV4Jy5cbiAgICAgIC0tIERvIG5vdCBsb3NlIGFueSBwcmV2aW91c2x5IGVudGVyZWQgaXRlbS5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCIgYGNvbnNlcnZhdGl2ZV9yZXNpemUnIGlzIG5vdCB2b2lkLXNhZmUgc3RhdGljYWxseS4gVXNlIGBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCcgaW5zdGVhZC4gWzA3LTIwMTBdXCJcbiAgICByZXF1aXJlXG4gICAgICBnb29kX2luZGljZXM6IG1pbl9pbmRleCA8PSBtYXhfaW5kZXhcbiAgICAgIGhhc19kZWZhdWx0OiAoe0d9KS5oYXNfZGVmYXVsdFxuICAgIGRvXG4gICAgICBjb25zZXJ2YXRpdmVfcmVzaXplX3dpdGhfZGVmYXVsdCAoKHtHfSkuZGVmYXVsdCwgbWluX2luZGV4LCBtYXhfaW5kZXgpXG4gICAgZW5zdXJlXG4gICAgICBub19sb3dfbG9zdDogbG93ZXIgPSBtaW5faW5kZXggb3IgZWxzZSBsb3dlciA9IG9sZCBsb3dlclxuICAgICAgbm9faGlnaF9sb3N0OiB1cHBlciA9IG1heF9pbmRleCBvciBlbHNlIHVwcGVyID0gb2xkIHVwcGVyXG4gICAgZW5kXG5cbiAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZTogRzsgbWluX2luZGV4LCBtYXhfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZWFycmFuZ2UgYXJyYXkgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGluZGljZXMgZG93biB0byBgbWluX2luZGV4JyBhbmQgdXAgdG8gYG1heF9pbmRleCcuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGl0ZW0uXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBuZXdfbG93ZXIsIG5ld191cHBlcjogSU5URUdFUlxuICAgICAgb2Zmc2V0OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGVtcHR5X2FyZWEgdGhlblxuICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbWF4X2luZGV4IC0gbWluX2luZGV4ICsgMSkpXG4gICAgICAgIGxvd2VyIDo9IG1pbl9pbmRleFxuICAgICAgICB1cHBlciA6PSBtYXhfaW5kZXhcbiAgICAgIGVsc2VcbiAgICAgICAgbmV3X2xvd2VyIDo9IG1pbl9pbmRleC5taW4gKGxvd2VyKVxuICAgICAgICBuZXdfdXBwZXIgOj0gbWF4X2luZGV4Lm1heCAodXBwZXIpXG4gICAgICAgIG5ld19zaXplIDo9IG5ld191cHBlciAtIG5ld19sb3dlciArIDFcbiAgICAgICAgaWYgbmV3X3NpemUgPiBhcmVhLmNvdW50IHRoZW5cbiAgICAgICAgICBzZXRfYXJlYSAoYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKGFfZGVmYXVsdF92YWx1ZSwgbmV3X3NpemUpKVxuICAgICAgICBlbmRcbiAgICAgICAgaWYgbmV3X2xvd2VyIDwgbG93ZXIgdGhlblxuICAgICAgICAgIG9mZnNldCA6PSBsb3dlciAtIG5ld19sb3dlclxuICAgICAgICAgIGFyZWEubW92ZV9kYXRhICgwLCBvZmZzZXQsIHVwcGVyIC0gbG93ZXIgKyAxKVxuICAgICAgICAgIGFyZWEuZmlsbF93aXRoIChhX2RlZmF1bHRfdmFsdWUsIDAsIG9mZnNldCAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBsb3dlciA6PSBuZXdfbG93ZXJcbiAgICAgICAgdXBwZXIgOj0gbmV3X3VwcGVyXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5vX2xvd19sb3N0OiBsb3dlciA9IG1pbl9pbmRleCBvciBlbHNlIGxvd2VyID0gb2xkIGxvd2VyXG4gICAgICBub19oaWdoX2xvc3Q6IHVwcGVyID0gbWF4X2luZGV4IG9yIGVsc2UgdXBwZXIgPSBvbGQgdXBwZXJcbiAgICBlbmRcblxuICByZXNpemUgKG1pbl9pbmRleCwgbWF4X2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIGFycmF5IHNvIHRoYXQgaXQgY2FuIGFjY29tbW9kYXRlXG4gICAgICAtLSBpbmRpY2VzIGRvd24gdG8gYG1pbl9pbmRleCcgYW5kIHVwIHRvIGBtYXhfaW5kZXgnLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBpdGVtLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQnIGluc3RlYWQgYXMgZnV0dXJlIHZlcnNpb25zIHdpbGwgaW1wbGVtZW50IGByZXNpemUnIGFzIHNwZWNpZmllZCBpbiBFTEtTLlwiXG4gICAgcmVxdWlyZVxuICAgICAgZ29vZF9pbmRpY2VzOiBtaW5faW5kZXggPD0gbWF4X2luZGV4XG4gICAgICBoYXNfZGVmYXVsdDogKHtHfSkuaGFzX2RlZmF1bHRcbiAgICBkb1xuICAgICAgY29uc2VydmF0aXZlX3Jlc2l6ZV93aXRoX2RlZmF1bHQgKCh7R30pLmRlZmF1bHQsIG1pbl9pbmRleCwgbWF4X2luZGV4KVxuICAgIGVuc3VyZVxuICAgICAgbm9fbG93X2xvc3Q6IGxvd2VyID0gbWluX2luZGV4IG9yIGVsc2UgbG93ZXIgPSBvbGQgbG93ZXJcbiAgICAgIG5vX2hpZ2hfbG9zdDogdXBwZXIgPSBtYXhfaW5kZXggb3IgZWxzZSB1cHBlciA9IG9sZCB1cHBlclxuICAgIGVuZFxuXG4gIHRyaW1cbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgbG9jYWxcbiAgICAgIG46IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbiA6PSBjb3VudFxuICAgICAgaWYgbiA8IGFyZWEuY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9pdGVtczogc2FtZV9pdGVtcyAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgcmViYXNlIChhX2xvd2VyOiBsaWtlIGxvd2VyKVxuICAgICAgLS0gV2l0aG91dCBjaGFuZ2luZyB0aGUgYWN0dWFsIGNvbnRlbnQgb2YgYEN1cnJlbnQnIHdlIHNldCBgbG93ZXInIHRvIGBhX2xvd2VyJ1xuICAgICAgLS0gYW5kIGB1cHBlcicgYWNjb3JkaW5nbHkgdG8gYGFfbG93ZXIgKyBjb3VudCAtIDEnLlxuICAgIGxvY2FsXG4gICAgICBsX29sZF9sb3dlcjogbGlrZSBsb3dlclxuICAgIGRvXG4gICAgICBsX29sZF9sb3dlciA6PSBsb3dlclxuICAgICAgbG93ZXIgOj0gYV9sb3dlclxuICAgICAgdXBwZXIgOj0gYV9sb3dlciArICh1cHBlciAtIGxfb2xkX2xvd2VyKVxuICAgIGVuc3VyZVxuICAgICAgbG93ZXJfc2V0OiBsb3dlciA9IGFfbG93ZXJcbiAgICAgIHVwcGVyX3NldDogdXBwZXIgPSBhX2xvd2VyICsgb2xkIGNvdW50IC0gMVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICB0b19jOiBBTllcbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWFcbiAgICBlbmRcblxuICB0b19jaWw6IE5BVElWRV9BUlJBWSBbR11cbiAgICAgIC0tIEFkZHJlc3Mgb2YgYWN0dWFsIHNlcXVlbmNlIG9mIHZhbHVlcyxcbiAgICAgIC0tIGZvciBwYXNzaW5nIHRvIGV4dGVybmFsIChub24tRWlmZmVsKSByb3V0aW5lcy5cbiAgICByZXF1aXJlXG4gICAgICBpc19kb3RuZXQ6IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLm5hdGl2ZV9hcnJheVxuICAgIGVuc3VyZVxuICAgICAgdG9fY2lsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIHRvX3NwZWNpYWw6IFNQRUNJQUwgW0ddXG4gICAgICAtLSAnYXJlYScuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhXG4gICAgZW5zdXJlXG4gICAgICB0b19zcGVjaWFsX25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtHXVxuICAgICAgLS0gUmVwcmVzZW50YXRpb24gYXMgYSBsaW5lYXIgc3RydWN0dXJlXG4gICAgbG9jYWxcbiAgICAgIHRlbXA6IEFSUkFZRURfTElTVCBbR11cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbG93ZXJcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiB1cHBlclxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIGNvcHkgKG90aGVyOiBsaWtlIEN1cnJlbnQpXG4gICAgICAtLSBSZWluaXRpYWxpemUgYnkgY29weWluZyBhbGwgdGhlIGl0ZW1zIG9mIGBvdGhlcicuXG4gICAgICAtLSAoVGhpcyBpcyBhbHNvIHVzZWQgYnkgYGNsb25lJy4pXG4gICAgZG9cbiAgICAgIGlmIG90aGVyIC89IEN1cnJlbnQgdGhlblxuICAgICAgICBzdGFuZGFyZF9jb3B5IChvdGhlcilcbiAgICAgICAgc2V0X2FyZWEgKG90aGVyLmFyZWEudHdpbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBlcXVhbF9hcmVhczogYXJlYSB+IG90aGVyLmFyZWFcbiAgICBlbmRcblxuICBzdWJhcnJheSAoc3RhcnRfcG9zLCBlbmRfcG9zOiBJTlRFR0VSKTogQVJSQVkgW0ddXG4gICAgICAtLSBBcnJheSBtYWRlIG9mIGl0ZW1zIG9mIGN1cnJlbnQgYXJyYXkgd2l0aGluXG4gICAgICAtLSBib3VuZHMgYHN0YXJ0X3BvcycgYW5kIGBlbmRfcG9zJy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IHZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBlbmRfcG9zIDw9IHVwcGVyXG4gICAgICB2YWxpZF9ib3VuZHM6IChzdGFydF9wb3MgPD0gZW5kX3Bvcykgb3IgKHN0YXJ0X3BvcyA9IGVuZF9wb3MgKyAxKVxuICAgIGRvXG4gICAgICBpZiBzdGFydF9wb3MgPD0gZW5kX3BvcyB0aGVuXG4gICAgICAgIGNyZWF0ZSBSZXN1bHQubWFrZV9maWxsZWQgKGl0ZW0gKHN0YXJ0X3BvcyksIHN0YXJ0X3BvcywgZW5kX3BvcylcbiAgICAgICAgICAtLSBPbmx5IGNvcHkgZWxlbWVudHMgaWYgbmVlZGVkLlxuICAgICAgICBSZXN1bHQuc3ViY29weSAoQ3VycmVudCwgc3RhcnRfcG9zLCBlbmRfcG9zLCBzdGFydF9wb3MpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gbWFrZSBlbXB0eVxuICAgICAgICBjcmVhdGUgUmVzdWx0Lm1ha2VfZW1wdHlcbiAgICAgICAgUmVzdWx0LnJlYmFzZSAoc3RhcnRfcG9zKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBsb3dlcjogUmVzdWx0Lmxvd2VyID0gc3RhcnRfcG9zXG4gICAgICB1cHBlcjogUmVzdWx0LnVwcGVyID0gZW5kX3Bvc1xuICAgICAgLS0gY29waWVkOiBmb3JhbGwgYGknIGluIGBzdGFydF9wb3MnIC4uIGBlbmRfcG9zJyxcbiAgICAgIC0tICAgICBSZXN1bHQuaXRlbSAoaSkgPSBpdGVtIChpKVxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbmFwcGxpY2FibGVcblxuICBwcnVuZSAodjogRylcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGB2JyBpZiBhbnkuXG4gICAgICAtLSAoUHJlY29uZGl0aW9uIGlzIEZhbHNlLilcbiAgICBkb1xuICAgIGVuZFxuXG4gIGV4dGVuZCAodjogRylcbiAgICAgIC0tIEFkZCBgdicgdG8gc3RydWN0dXJlLlxuICAgICAgLS0gKFByZWNvbmRpdGlvbiBpcyBGYWxzZS4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBlbXB0eV9hcmVhOiBCT09MRUFOXG4gICAgICAtLSBJcyBgYXJlYScgZW1wdHk/XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhID0gVm9pZCBvciBlbHNlIGFyZWEuY2FwYWNpdHkgPSAwXG4gICAgZW5kXG5cbmludmFyaWFudFxuXG4gIGFyZWFfZXhpc3RzOiBhcmVhIC89IFZvaWRcbiAgY29uc2lzdGVudF9zaXplOiBjYXBhY2l0eSA9IHVwcGVyIC0gbG93ZXIgKyAxXG4gIG5vbl9uZWdhdGl2ZV9jb3VudDogY291bnQgPj0gMFxuICBpbmRleF9zZXRfaGFzX3NhbWVfY291bnQ6IHZhbGlkX2luZGV4X3NldFxuLS0gSW50ZXJuYWwgZGlzY3Vzc2lvbiBoYXZlbid0IHJlYWNoZWQgYW4gYWdyZWVtZW50IG9uIHRoaXMgaW52YXJpYW50XG4tLSAgaW5kZXhfc2V0X2hhc19zYW1lX2JvdW5kczogKChpbmRleF9zZXQubG93ZXIgPSBsb3dlcikgYW5kXG4tLSAgICAgICAgKGluZGV4X3NldC51cHBlciA9IGxvd2VyICsgY291bnQgLSAxKSlcblxuZW5kXG4iLCJleHBhbmRlZCBjbGFzcyBJTlRFR0VSXzMyIGluaGVyaXRcblxuICBJTlRFR0VSXzMyX1JFRlxuICAgIHJlZGVmaW5lXG4gICAgICBpc19sZXNzLFxuICAgICAgcGx1cyxcbiAgICAgIG1pbnVzLFxuICAgICAgcHJvZHVjdCxcbiAgICAgIHF1b3RpZW50LFxuICAgICAgcG93ZXIsXG4gICAgICBpbnRlZ2VyX3F1b3RpZW50LFxuICAgICAgaW50ZWdlcl9yZW1haW5kZXIsXG4gICAgICBvcHBvc2l0ZSxcbiAgICAgIGlkZW50aXR5LFxuICAgICAgYXNhX25hdHVyYWxfOCxcbiAgICAgIGFzX25hdHVyYWxfMTYsXG4gICAgICBhc19uYXR1cmFsXzMyLFxuICAgICAgYXNfbmF0dXJhbF82NCxcbiAgICAgIGFzX2ludGVnZXJfOCxcbiAgICAgIGFzX2ludGVnZXJfMTYsXG4gICAgICBhc19pbnRlZ2VyXzMyLFxuICAgICAgYXNfaW50ZWdlcl82NCxcbiAgICAgIHRvX3JlYWwsXG4gICAgICB0b19kb3VibGUsXG4gICAgICB0b19jaGFyYWN0ZXJfOCxcbiAgICAgIHRvX2NoYXJhY3Rlcl8zMixcbiAgICAgIGJpdF9hbmQsXG4gICAgICBiaXRfb3IsXG4gICAgICBiaXRfeG9yLFxuICAgICAgYml0X25vdCxcbiAgICAgIGJpdF9zaGlmdF9sZWZ0LFxuICAgICAgYml0X3NoaWZ0X3JpZ2h0XG4gICAgZW5kXG5cbmNyZWF0ZVxuICBkZWZhdWx0X2NyZWF0ZSxcbiAgbWFrZV9mcm9tX3JlZmVyZW5jZVxuXG4tLSBjb252ZXJ0XG4tLSAgIG1ha2VfZnJvbV9yZWZlcmVuY2UgKHtJTlRFR0VSXzMyX1JFRn0pLFxuLS0gICB0b19yZWFsOiB7UkVBTF8zMn0sXG4tLSAgIHRvX2RvdWJsZToge1JFQUxfNjR9LFxuLS0gICB0b19pbnRlZ2VyXzY0OiB7SU5URUdFUl82NH1cblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfbGVzcyBhbGlhcyBcIjxcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBCT09MRUFOXG4gICAgICAtLSBJcyBjdXJyZW50IGludGVnZXIgbGVzcyB0aGFuIGBvdGhlcic/XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJhc2ljIG9wZXJhdGlvbnNcblxuICBwbHVzIGFsaWFzIFwiK1wiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFN1bSB3aXRoIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgbWludXMgYWxpYXMgXCItXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gUmVzdWx0IG9mIHN1YnRyYWN0aW5nIGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcHJvZHVjdCBhbGlhcyBcIipcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBQcm9kdWN0IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcXVvdGllbnQgYWxpYXMgXCIvXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogUkVBTF82NFxuICAgICAgLS0gRGl2aXNpb24gYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBpZGVudGl0eSBhbGlhcyBcIitcIjogSU5URUdFUl8zMlxuICAgICAgLS0gVW5hcnkgcGx1c1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBvcHBvc2l0ZSBhbGlhcyBcIi1cIjogSU5URUdFUl8zMlxuICAgICAgLS0gVW5hcnkgbWludXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9xdW90aWVudCBhbGlhcyBcIi8vXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gSW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaW50ZWdlcl9yZW1haW5kZXIgYWxpYXMgXCJcXFxcXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gUmVtYWluZGVyIG9mIHRoZSBpbnRlZ2VyIGRpdmlzaW9uIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBwb3dlciBhbGlhcyBcIl5cIiAob3RoZXI6IFJFQUxfNjQpOiBSRUFMXzY0XG4gICAgICAtLSBJbnRlZ2VyIHBvd2VyIG9mIEN1cnJlbnQgYnkgYG90aGVyJ1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbmF0dXJhbF84OiBOQVRVUkFMXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzE2OiBOQVRVUkFMXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfMzI6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF82NDogTkFUVVJBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzg6IElOVEVHRVJfOFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzggdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMTY6IElOVEVHRVJfMTZcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8xNiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl8zMjogSU5URUdFUl8zMlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzMyIHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzY0OiBJTlRFR0VSXzY0XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfNjQgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX3JlYWw6IFJFQUxfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzMyXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2RvdWJsZTogUkVBTF82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhIFJFQUxfNjRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzg6IENIQVJBQ1RFUl84XG4gICAgICAtLSBBc3NvY2lhdGVkIGNoYXJhY3RlciBpbiA4IGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19jaGFyYWN0ZXJfMzI6IENIQVJBQ1RFUl8zMlxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gMzIgYml0IHZlcnNpb24uXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIEJpdCBvcGVyYXRpb25zXG5cbiAgYml0X2FuZCBhbGlhcyBcIiZcIiAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2UgYW5kIGJldHdlZW4gQ3VycmVudCcgYW5kIGBpJy5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X29yIGFsaWFzIFwifFwiIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSBvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF94b3IgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIHhvciBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9ub3Q6IElOVEVHRVJfMzJcbiAgICAgIC0tIE9uZSdzIGNvbXBsZW1lbnQgb2YgQ3VycmVudC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X2xlZnQgYWxpYXMgXCJ8PDxcIiAobjogSU5URUdFUik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFNoaWZ0IEN1cnJlbnQgZnJvbSBgbicgcG9zaXRpb24gdG8gbGVmdC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYml0X3NoaWZ0X3JpZ2h0IGFsaWFzIFwifD4+XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIHJpZ2h0LlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZW5kXG4iLCJjbGFzc1xuICBTVFJJTkdcblxuaW5oZXJpdFxuICBSRUFEQUJMRV9TVFJJTkdfMzJcbiAgICByZWRlZmluZVxuICAgICAgYXJlYVxuICAgIGV4cG9ydFxuICAgICAge0FOWX0gbWFrZSwgbWFrZV9lbXB0eSwgbWFrZV9maWxsZWQsIG1ha2VfZnJvbV9jLCBtYWtlX2Zyb21fc3RyaW5nLCBmaWxsX2NoYXJhY3RlclxuICAgIGVuZFxuXG4gIFNUUklOR19HRU5FUkFMXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGhhcywgaW5kZXhfb2YsIGxhc3RfaW5kZXhfb2YsIG9jY3VycmVuY2VzXG4gICAgcmVkZWZpbmVcbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWxcbiAgICByZW5hbWVcbiAgICAgIGFwcGVuZCBhcyBhcHBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBhcHBlbmRfc3Vic3RyaW5nIGFzIGFwcGVuZF9zdWJzdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmQgYXMgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHByZXBlbmRfc3Vic3RyaW5nIGFzIHByZXBlbmRfc3Vic3RyaW5nX2dlbmVyYWwsXG4gICAgICBzYW1lX3N0cmluZyBhcyBzYW1lX3N0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9jaGFyYWN0ZXJzIGFzIHNhbWVfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc2FtZV9jYXNlbGVzc19jaGFyYWN0ZXJzIGFzIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVyc19nZW5lcmFsLFxuICAgICAgc3RhcnRzX3dpdGggYXMgc3RhcnRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGVuZHNfd2l0aCBhcyBlbmRzX3dpdGhfZ2VuZXJhbCxcbiAgICAgIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWwgYXMgaXNfY2FzZV9pbnNlbnNpdGl2ZV9lcXVhbF9nZW5lcmFsXG4gICAgZW5kXG5cbiAgSU5ERVhBQkxFIFtDSEFSQUNURVJfMzIsIElOVEVHRVJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgcHJ1bmVfYWxsLFxuICAgICAgY2hhbmdlYWJsZV9jb21wYXJpc29uX2NyaXRlcmlvblxuICAgIGVuZFxuXG4gIFJFU0laQUJMRSBbQ0hBUkFDVEVSXzMyXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBUT19TUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXQsIGl0ZW0sIGF0LCBwdXQsIHZhbGlkX2luZGV4XG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBlbmRcblxuICBNSVNNQVRDSF9DT1JSRUNUT1JcbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBjb3JyZWN0X21pc21hdGNoXG4gICAgZW5kXG5cbmNyZWF0ZVxuICBtYWtlLFxuICBtYWtlX2VtcHR5LFxuICBtYWtlX2ZpbGxlZCxcbiAgbWFrZV9mcm9tX3N0cmluZyxcbiAgbWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsLFxuICBtYWtlX2Zyb21fYyxcbiAgbWFrZV9mcm9tX2NfcG9pbnRlcixcbiAgbWFrZV9mcm9tX2NpbCxcbiAgbWFrZV9mcm9tX3NlcGFyYXRlXG5cbmNvbnZlcnRcbiAgdG9fY2lsOiB7U1lTVEVNX1NUUklOR30sXG4gIG1ha2VfZnJvbV9jaWwgKHtTWVNURU1fU1RSSU5HfSksXG4gIGFzX3N0cmluZ184OiB7UkVBREFCTEVfU1RSSU5HXzgsIFNUUklOR184fVxuXG5mZWF0dXJlIC0tIEluaXRpYWxpemF0aW9uXG5cbiAgbWFrZV9mcm9tX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEluaXRpYWxpemUgZnJvbSB0aGUgY2hhcmFjdGVycyBvZiBgcycuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgczMyIHRoZW5cbiAgICAgICAgbWFrZV9mcm9tX3N0cmluZyAoczMyKVxuICAgICAgZWxzZVxuICAgICAgICBtYWtlIChzLmNvdW50KVxuICAgICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtYWtlX2Zyb21fY2lsIChhX3N5c3RlbV9zdHJpbmc6IGRldGFjaGFibGUgU1lTVEVNX1NUUklORylcbiAgICAgIC0tIEluaXRpYWxpemUgQ3VycmVudCB3aXRoIGBhX3N5c3RlbV9zdHJpbmcnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGlmIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBhX3N5c3RlbV9zdHJpbmcubGVuZ3RoICsgZG90bmV0X2NvbnZlcnRvci5lc2NhcGVfY291bnQgKGFfc3lzdGVtX3N0cmluZylcbiAgICAgIGVuZFxuICAgICAgbWFrZSAobF9jb3VudClcbiAgICAgIGlmIGxfY291bnQgPiAwIGFuZCB0aGVuIGFfc3lzdGVtX3N0cmluZyAvPSBWb2lkIHRoZW5cbiAgICAgICAgc2V0X2NvdW50IChsX2NvdW50KVxuICAgICAgICBkb3RuZXRfY29udmVydG9yLnJlYWRfc3lzdGVtX3N0cmluZ19pbnRvIChhX3N5c3RlbV9zdHJpbmcsIEN1cnJlbnQpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBmcm9tX2MgKGNfc3RyaW5nOiBQT0lOVEVSKVxuICAgICAgLS0gUmVzZXQgY29udGVudHMgb2Ygc3RyaW5nIGZyb20gY29udGVudHMgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXIgKGNfc3RyaW5nKVxuICAgICAgICAtLSBSZXNpemUgc3RyaW5nIGluIGNhc2UgaXQgaXMgbm90IGJpZyBlbm91Z2hcbiAgICAgIGxfY291bnQgOj0gY19zdHJpbmdfcHJvdmlkZXIuY291bnRcbiAgICAgIGdyb3cgKGxfY291bnQgKyAxKVxuICAgICAgY291bnQgOj0gbF9jb3VudFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnJlYWRfc3RyaW5nX2ludG8gKEN1cnJlbnQpXG4gICAgZW5zdXJlXG4gICAgICBub196ZXJvX2J5dGU6IG5vdCBoYXMgKCclLzAvJylcbiAgICAgIC0tIGNoYXJhY3RlcnM6IGZvciBhbGwgaSBpbiAxLi5jb3VudCwgaXRlbSAoaSkgZXF1YWxzXG4gICAgICAtLSAgICAgICBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIChpIC0gMSlcbiAgICAgIC0tIGNvcnJlY3RfY291bnQ6IHRoZSBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIGNvdW50XG4gICAgICAtLSAgICAgICBpcyBOVUxMXG4gICAgZW5kXG5cbiAgZnJvbV9jX3N1YnN0cmluZyAoY19zdHJpbmc6IFBPSU5URVI7IHN0YXJ0X3BvcywgZW5kX3BvczogSU5URUdFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIHN1YnN0cmluZyBvZiBgY19zdHJpbmcnLFxuICAgICAgLS0gYSBzdHJpbmcgY3JlYXRlZCBieSBzb21lIEMgZnVuY3Rpb24uXG4gICAgcmVxdWlyZVxuICAgICAgY19zdHJpbmdfZXhpc3RzOiBjX3N0cmluZyAvPSBkZWZhdWx0X3BvaW50ZXJcbiAgICAgIHN0YXJ0X3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA+PSAxXG4gICAgICBlbmRfcG9zaXRpb25fYmlnX2Vub3VnaDogc3RhcnRfcG9zIDw9IGVuZF9wb3MgKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMVxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIuc2V0X3NoYXJlZF9mcm9tX3BvaW50ZXJfYW5kX2NvdW50IChjX3N0cmluZyArIChzdGFydF9wb3MgLSAxKSwgbF9jb3VudClcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N1YnN0cmluZ19pbnRvIChDdXJyZW50LCAxLCBsX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgdmFsaWRfY291bnQ6IGNvdW50ID0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIC0tIGNoYXJhY3RlcnM6IGZvciBhbGwgaSBpbiAxLi5jb3VudCwgaXRlbSAoaSkgZXF1YWxzXG4gICAgICAtLSAgICAgICBBU0NJSSBjaGFyYWN0ZXIgYXQgYWRkcmVzcyBjX3N0cmluZyArIChpIC0gMSlcbiAgICBlbmRcblxuICBhZGFwdCAoczogU1RSSU5HXzMyKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBPYmplY3Qgb2YgYSB0eXBlIGNvbmZvcm1pbmcgdG8gdGhlIHR5cGUgb2YgYHMnLFxuICAgICAgLS0gaW5pdGlhbGl6ZWQgd2l0aCBhdHRyaWJ1dGVzIGZyb20gYHMnXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nICgwKVxuICAgICAgUmVzdWx0LnNoYXJlIChzKVxuICAgIGVuc3VyZVxuICAgICAgYWRhcHRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgICBzaGFyZWRfaW1wbGVtZW50YXRpb246IFJlc3VsdC5zaGFyZWRfd2l0aCAocylcbiAgICBlbmRcblxuICByZW1ha2UgKG46IElOVEVHRVIpXG4gICAgICAtLSBBbGxvY2F0ZSBzcGFjZSBmb3IgYXQgbGVhc3QgYG4nIGNoYXJhY3RlcnMuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiVXNlIGBtYWtlJyBpbnN0ZWFkXCJcbiAgICByZXF1aXJlXG4gICAgICBub25fbmVnYXRpdmVfc2l6ZTogbiA+PSAwXG4gICAgZG9cbiAgICAgIG1ha2UgKG4pXG4gICAgZW5zdXJlXG4gICAgICBlbXB0eV9zdHJpbmc6IGNvdW50ID0gMFxuICAgICAgYXJlYV9hbGxvY2F0ZWQ6IGNhcGFjaXR5ID49IG5cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBBY2Nlc3NcblxuICBpdGVtIGFsaWFzIFwiW11cIiwgYXQgYWxpYXMgXCJAXCIgKGk6IElOVEVHRVIpOiBDSEFSQUNURVJfMzIgYXNzaWduIHB1dFxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSlcbiAgICBlbmRcblxuICBjb2RlIChpOiBJTlRFR0VSKTogTkFUVVJBTF8zMlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSkuY29kZS50b19uYXR1cmFsXzMyXG4gICAgZW5kXG5cbiAgaXRlbV9jb2RlIChpOiBJTlRFR0VSKTogSU5URUdFUlxuICAgICAgLS0gQ2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJ1xuICAgIG9ic29sZXRlXG4gICAgICBcIkR1ZSB0byBwb3RlbnRpYWwgdHJ1bmNhdGlvbiBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgYGNvZGUgKGkpJyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBhcmVhLml0ZW0gKGkgLSAxKS5uYXR1cmFsXzMyX2NvZGUuYXNfaW50ZWdlcl8zMlxuICAgIGVuZFxuXG4gIGFyZWE6IFNQRUNJQUwgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIC0tIFN0b3JhZ2UgZm9yIGNoYXJhY3RlcnNcblxuZmVhdHVyZSAtLSBTdGF0dXMgcmVwb3J0XG5cbiAgZXh0ZW5kaWJsZTogQk9PTEVBTiA9IFRydWVcbiAgICAgIC0tIE1heSBuZXcgaXRlbXMgYmUgYWRkZWQ/IChBbnN3ZXI6IHllcy4pXG5cbiAgcHJ1bmFibGU6IEJPT0xFQU5cbiAgICAgIC0tIE1heSBpdGVtcyBiZSByZW1vdmVkPyAoQW5zd2VyOiB5ZXMuKVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gVHJ1ZVxuICAgIGVuZFxuXG4gIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb246IEJPT0xFQU4gPSBGYWxzZVxuXG5mZWF0dXJlIC0tIEVsZW1lbnQgY2hhbmdlXG5cbiAgc2V0ICh0OiBSRUFEQUJMRV9TVFJJTkdfMzI7IG4xLCBuMjogSU5URUdFUilcbiAgICAgIC0tIFNldCBjdXJyZW50IHN0cmluZyB0byBzdWJzdHJpbmcgb2YgYHQnIGZyb20gaW5kaWNlcyBgbjEnXG4gICAgICAtLSB0byBgbjInLCBvciB0byBlbXB0eSBzdHJpbmcgaWYgbm8gc3VjaCBzdWJzdHJpbmcuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHQgLz0gVm9pZFxuICAgIGxvY2FsXG4gICAgICBzOiBSRUFEQUJMRV9TVFJJTkdfMzJcbiAgICBkb1xuICAgICAgcyA6PSB0LnN1YnN0cmluZyAobjEsIG4yKVxuICAgICAgYXJlYSA6PSBzLmFyZWFcbiAgICAgIGNvdW50IDo9IHMuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19zdWJzdHJpbmc6IHNhbWVfc3RyaW5nICh0LnN1YnN0cmluZyAobjEsIG4yKSlcbiAgICBlbmRcblxuICBzdWJjb3B5IChvdGhlcjogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9wb3MsIGVuZF9wb3MsIGluZGV4X3BvczogSU5URUdFUilcbiAgICAgIC0tIENvcHkgY2hhcmFjdGVycyBvZiBgb3RoZXInIHdpdGhpbiBib3VuZHMgYHN0YXJ0X3BvcycgYW5kXG4gICAgICAtLSBgZW5kX3BvcycgdG8gY3VycmVudCBzdHJpbmcgc3RhcnRpbmcgYXQgaW5kZXggYGluZGV4X3BvcycuXG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICAgIHZhbGlkX3N0YXJ0X3Bvczogb3RoZXIudmFsaWRfaW5kZXggKHN0YXJ0X3BvcylcbiAgICAgIHZhbGlkX2VuZF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChlbmRfcG9zKVxuICAgICAgdmFsaWRfYm91bmRzOiAoc3RhcnRfcG9zIDw9IGVuZF9wb3MpIG9yIChzdGFydF9wb3MgPSBlbmRfcG9zICsgMSlcbiAgICAgIHZhbGlkX2luZGV4X3BvczogdmFsaWRfaW5kZXggKGluZGV4X3BvcylcbiAgICAgIGVub3VnaF9zcGFjZTogKGNvdW50IC0gaW5kZXhfcG9zKSA+PSAoZW5kX3BvcyAtIHN0YXJ0X3BvcylcbiAgICBsb2NhbFxuICAgICAgbF9vdGhlcl9hcmVhLCBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBlbmRfcG9zID49IHN0YXJ0X3BvcyB0aGVuXG4gICAgICAgIGxfb3RoZXJfYXJlYSA6PSBvdGhlci5hcmVhXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIGlmIGxfYXJlYSAvPSBsX290aGVyX2FyZWEgdGhlblxuICAgICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKGxfb3RoZXJfYXJlYSwgc3RhcnRfcG9zIC0gMSwgaW5kZXhfcG9zIC0gMSxcbiAgICAgICAgICAgIGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgICBjb3BpZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpbmRleF9wb3MgLSAxKSArXG4gICAgICAgIG9sZCBvdGhlci5zdWJzdHJpbmcgKHN0YXJ0X3BvcywgZW5kX3BvcykgK1xuICAgICAgICBvbGQgc3Vic3RyaW5nIChpbmRleF9wb3MgKyAoZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIHJlcGxhY2Vfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnIHRvIGBlbmRfaW5kZXgnIHdpdGggYHMnLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9pbmRleDogMSA8PSBzdGFydF9pbmRleFxuICAgICAgdmFsaWRfZW5kX2luZGV4OiBlbmRfaW5kZXggPD0gY291bnRcbiAgICAgIG1lYW5pbmdmdWxsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBkaWZmOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgc19jb3VudDogSU5URUdFUlxuICAgICAgb2xkX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHNfY291bnQgOj0gcy5jb3VudFxuICAgICAgb2xkX2NvdW50IDo9IGNvdW50XG4gICAgICBkaWZmIDo9IHNfY291bnQgLSAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgbmV3X3NpemUgOj0gZGlmZiArIG9sZF9jb3VudFxuICAgICAgaWYgZGlmZiA+IDAgdGhlblxuICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIHRoZSBzdHJpbmcuXG4gICAgICAgIGdyb3cgKG5ld19zaXplKVxuICAgICAgZW5kXG5cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIC0tfCBXZSBtb3ZlIHRoZSBlbmQgb2YgdGhlIHN0cmluZyBmb3J3YXJkIChpZiBkaWZmIGlzID4gMCksIGJhY2t3YXJkIChpZiBkaWZmIDwgMCksXG4gICAgICAgIC0tfCBhbmQgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICBpZiBkaWZmIC89IDAgdGhlblxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoZW5kX2luZGV4LCBlbmRfaW5kZXggKyBkaWZmLCBvbGRfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICBlbmRcbiAgICAgICAgLS18IFNldCBuZXcgY291bnRcbiAgICAgIHNldF9jb3VudCAobmV3X3NpemUpXG4gICAgICAgIC0tfCBXZSBjb3B5IHRoZSBzdWJzdHJpbmcuXG4gICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgc3RhcnRfaW5kZXggLSAxLCBzX2NvdW50KVxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50IC0gZW5kX2luZGV4ICsgc3RhcnRfaW5kZXggLSAxXG4gICAgICByZXBsYWNlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCAoc3Vic3RyaW5nICgxLCBzdGFydF9pbmRleCAtIDEpICtcbiAgICAgICAgICBzICsgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZ19hbGwgKG9yaWdpbmFsLCBuZXc6IFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgb2NjdXJyZW5jZSBvZiBgb3JpZ2luYWwnIHdpdGggYG5ldycuXG4gICAgcmVxdWlyZVxuICAgICAgb3JpZ2luYWxfZXhpc3RzOiBvcmlnaW5hbCAvPSBWb2lkXG4gICAgICBuZXdfZXhpc3RzOiBuZXcgLz0gVm9pZFxuICAgICAgb3JpZ2luYWxfbm90X2VtcHR5OiBub3Qgb3JpZ2luYWwuaXNfZW1wdHlcbiAgICBleHRlcm5cbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHJlcGxhY2VfYmxhbmtcbiAgICAgIC0tIFJlcGxhY2UgYWxsIGN1cnJlbnQgY2hhcmFjdGVycyB3aXRoIGJsYW5rcy5cbiAgICBkb1xuICAgICAgZmlsbF93aXRoICgnICcpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3NpemU6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGFsbF9ibGFuazogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzICgnICcpID0gY291bnRcbiAgICBlbmRcblxuICBmaWxsX2JsYW5rXG4gICAgICAtLSBGaWxsIHdpdGggYGNhcGFjaXR5JyBibGFuayBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBmaWxsX2NoYXJhY3RlciAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgZmlsbGVkOiBmdWxsXG4gICAgICBzYW1lX3NpemU6IChjb3VudCA9IGNhcGFjaXR5KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgLS0gYWxsX2JsYW5rOiBGb3IgZXZlcnkgYGknIGluIGBjb3VudCcuLmBjYXBhY2l0eScsIGBpdGVtJyAoYGknKSA9IGBCbGFuaydcbiAgICBlbmRcblxuICBmaWxsX3dpdGggKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGxfY291bnQgLz0gMCB0aGVuXG4gICAgICAgIGFyZWEuZmlsbF93aXRoIChjLCAwLCBsX2NvdW50IC0gMSlcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICByZXBsYWNlX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVwbGFjZSBldmVyeSBjaGFyYWN0ZXIgd2l0aCBgYycuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGZpbGxfd2l0aCcgaW5zdGVhZCdcIlxuICAgIGRvXG4gICAgICBmaWxsX3dpdGggKGMpXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBmaWxsZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoYykgPSBjb3VudFxuICAgIGVuZFxuXG4gIGtlZXBfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycyBleGNlcHQgZm9yIHRoZSBmaXJzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIGRvXG4gICAgICBpZiBuIDwgY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBrZWVwX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgbGFzdCBgbic7XG4gICAgICAtLSBkbyBub3RoaW5nIGlmIGBuJyA+PSBgY291bnQnLlxuICAgIGxvY2FsXG4gICAgICBuYjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgaWYgbiA8IG5iIHRoZW5cbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYiAtIG4sIDAsIG4pXG4gICAgICAgIGNvdW50IDo9IG5cbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGxlZnRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgIGxvY2FsXG4gICAgICBuYiwgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIHVudGlsXG4gICAgICAgIG5iX3NwYWNlID4gbmIgb3IgZWxzZSBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAobmJfc3BhY2UpKVxuICAgICAgbG9vcFxuICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQgdmFsdWUuXG4gICAgICAgIG5iIDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgICAgLS0gU2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdC5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKG5iX3NwYWNlLCAwLCBuYilcbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50LlxuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmlnaHRfYWRqdXN0XG4gICAgICAtLSBSZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgYzogQ0hBUkFDVEVSXzMyXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgcmlnaHQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50IC0gMVxuICAgICAgICBpIDo9IG5iXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpIDwgMFxuICAgICAgbG9vcFxuICAgICAgICBjIDo9IGxfYXJlYS5pdGVtIChpKVxuICAgICAgICBpZiBub3QgbF9wcm9wLmlzX3NwYWNlIChjKSB0aGVuXG4gICAgICAgICAgICAtLSBXZSBhcmUgZG9uZS5cbiAgICAgICAgICBpIDo9IC0xXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuYl9zcGFjZSA6PSBuYl9zcGFjZSArIDFcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5iX3NwYWNlID4gMCB0aGVuXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmIgKyAxIC0gbmJfc3BhY2VcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHNoYXJlIChvdGhlcjogU1RSSU5HXzMyKVxuICAgICAgLS0gTWFrZSBjdXJyZW50IHN0cmluZyBzaGFyZSB0aGUgdGV4dCBvZiBgb3RoZXInLlxuICAgICAgLS0gU3Vic2VxdWVudCBjaGFuZ2VzIHRvIHRoZSBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQgc3RyaW5nXG4gICAgICAtLSB3aWxsIGFsc28gYWZmZWN0IGBvdGhlcicsIGFuZCBjb252ZXJzZWx5LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgY291bnQgOj0gb3RoZXIuY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBzaGFyZWRfY291bnQ6IG90aGVyLmNvdW50ID0gY291bnRcbiAgICAgIHNoYXJlZF9hcmVhOiBvdGhlci5hcmVhID0gYXJlYVxuICAgIGVuZFxuXG4gIHB1dCAoYzogQ0hBUkFDVEVSXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gYGknIGJ5IGBjJy5cbiAgICBkb1xuICAgICAgYXJlYS5wdXQgKGMsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc3RhYmxlX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICBwdXRfY29kZSAodjogTkFUVVJBTF8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBjaGFyYWN0ZXIgb2YgY29kZSBgdicuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0ICh2LnRvX2NoYXJhY3Rlcl8zMiwgaSAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBsX3MzMiB0aGVuXG4gICAgICAgIHByZXBlbmQgKGxfczMyKVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHByZWNlZGUsIHByZXBlbmRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBBZGQgYGMnIGF0IGZyb250LlxuICAgIGxvY2FsXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBjb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgMSwgY291bnQpXG4gICAgICBsX2FyZWEucHV0IChjLCAwKVxuICAgICAgY291bnQgOj0gY291bnQgKyAxXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICBlbmRcblxuICBwcmVwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBkb1xuICAgICAgaW5zZXJ0X3N0cmluZyAocywgMSlcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAocyArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZnJvbnQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIG9mIGN1cnJlbnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlICgwLCBsX3NfY291bnQsIGNvdW50KVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGJlZ2lubmluZy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIDAsIGxfc19jb3VudClcblxuICAgICAgICBjb3VudCA6PSBuZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSArIEN1cnJlbnQpKVxuICAgIGVuZFxuXG4gIHByZXBlbmRfYm9vbGVhbiAoYjogQk9PTEVBTilcbiAgICAgIC0tIFByZXBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwgKGIub3V0KVxuICAgIGVuZFxuXG4gIHByZXBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChkLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2ludGVnZXIgKGk6IElOVEVHRVIpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChpLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3JlYWwgKHI6IFJFQUwpXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChyLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZyAoczogZGV0YWNoYWJsZSBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBQcmVwZW5kIGNoYXJhY3RlcnMgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIHMgLz0gVm9pZCB0aGVuXG4gICAgICAgIHByZXBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKHM6IFJFQURBQkxFX1NUUklOR19HRU5FUkFMKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgaWYgYXR0YWNoZWQge1JFQURBQkxFX1NUUklOR18zMn0gcyBhcyBsX3MzMiB0aGVuXG4gICAgICAgIGFwcGVuZCAobF9zMzIpXG4gICAgICBlbHNlXG4gICAgICAgIFByZWN1cnNvciB7U1RSSU5HX0dFTkVSQUx9IChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kIChzOiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBzLmNvdW50XG4gICAgICBpZiBsX3NfY291bnQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBsX25ld19zaXplIDo9IGxfc19jb3VudCArIGxfY291bnRcbiAgICAgICAgaWYgbF9uZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKGxfbmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcbiAgICAgICAgYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyLCBsX2NvdW50LCBsX3NfY291bnQpXG4gICAgICAgIGNvdW50IDo9IGxfbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIG9sZCBzLmNvdW50XG4gICAgICBhcHBlbmRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKEN1cnJlbnQgKyBzKSlcbiAgICBlbmRcblxuICBhcHBlbmRfc3Vic3RyaW5nIChzOiBSRUFEQUJMRV9TVFJJTkdfMzI7IHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBBcHBlbmQgY2hhcmFjdGVycyBvZiBgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpJyBhdCBlbmQuXG4gICAgcmVxdWlyZVxuICAgICAgYXJndW1lbnRfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgc3RhcnRfaW5kZXhfdmFsaWQ6IHN0YXJ0X2luZGV4ID49IDFcbiAgICAgIGVuZF9pbmRleF92YWxpZDogZW5kX2luZGV4IDw9IHMuY291bnRcbiAgICAgIHZhbGlkX2JvdW5kczogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBsX3NfY291bnQsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciArIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcy5zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXgpKSlcbiAgICBlbmRcblxuICBwbHVzIGFsaWFzIFwiK1wiIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTCk6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGNvdW50ICsgcy5jb3VudClcbiAgICAgIFJlc3VsdC5hcHBlbmQgKEN1cnJlbnQpXG4gICAgICBSZXN1bHQuYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gQXBwZW5kIGEgY29weSBvZiBgcycsIGlmIG5vdCB2b2lkLCBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIHMgLz0gVm9pZCB0aGVuXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgYXBwZW5kZWQ6IHMgLz0gVm9pZCBpbXBsaWVzXG4gICAgICAgIChlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgdHdpbiArIG9sZCBzLnR3aW4pKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSfS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl84IChpOiBJTlRFR0VSXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl84fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlcl8xNiAoaTogSU5URUdFUl8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUl8xNn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfNjQgKGk6IElOVEVHRVJfNjQpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzY0XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfNjR9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzggKGk6IE5BVFVSQUxfOClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfOFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzE2IChpOiBOQVRVUkFMXzE2KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF8xNlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzMyIChpOiBOQVRVUkFMXzMyKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF8zMlxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9uYXR1cmFsXzY0IChpOiBOQVRVUkFMXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogTkFUVVJBTF82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYHInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChyLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfZG91YmxlIChkOiBET1VCTEUpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgZCcgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKGQub3V0KVxuICAgIGVuZFxuXG4gIGFwcGVuZF9jaGFyYWN0ZXIsIGV4dGVuZCAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gQXBwZW5kIGBjJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGN1cnJlbnRfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3VycmVudF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgY3VycmVudF9jb3VudCA9IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChjdXJyZW50X2NvdW50ICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuICAgICAgYXJlYS5wdXQgKGMsIGN1cnJlbnRfY291bnQpXG4gICAgICBjb3VudCA6PSBjdXJyZW50X2NvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXRlbV9pbnNlcnRlZDogaXRlbSAoY291bnQpID0gY1xuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIHN0YWJsZV9iZWZvcmU6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKDEsIGNvdW50IC0gMSkgfiAob2xkIHR3aW4pXG4gICAgZW5kXG5cbiAgYXBwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgYicgYXQgZW5kLlxuICAgIGRvXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwgKGIub3V0KVxuICAgIGVuZFxuXG4gIGluc2VydCAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gQWRkIGBzJyB0byBsZWZ0IG9mIHBvc2l0aW9uIGBpJyBpbiBjdXJyZW50IHN0cmluZy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJFTEtTIDIwMDE6IHVzZSBgaW5zZXJ0X3N0cmluZycgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgICBpbmRleF9zbWFsbF9lbm91Z2g6IGkgPD0gY291bnQgKyAxXG4gICAgICBpbmRleF9sYXJnZV9lbm91Z2g6IGkgPiAwXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIGkpXG4gICAgZW5zdXJlXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzXG4gICAgICAgIChDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSArIG9sZCAocy50d2luKSArIG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSkpXG4gICAgZW5kXG5cbiAgaW5zZXJ0X3N0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBpOiBJTlRFR0VSKVxuICAgICAgLS0gSW5zZXJ0IGBzJyBhdCBpbmRleCBgaScsIHNoaWZ0aW5nIGNoYXJhY3RlcnMgYmV0d2VlbiByYW5rc1xuICAgICAgLS0gYGknIGFuZCBgY291bnQnIHJpZ2h0d2FyZHMuXG4gICAgcmVxdWlyZVxuICAgICAgc3RyaW5nX2V4aXN0czogcyAvPSBWb2lkXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9zX2NvdW50OiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIEluc2VydCBgcycgaWYgYHMnIGlzIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGlzIHVzZWxlc3MuXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50IC89IDAgdGhlblxuICAgICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgY291bnRcbiAgICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChuZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBwb3MgOj0gaSAtIDFcblxuICAgICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAocG9zLCBwb3MgKyBsX3NfY291bnQsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgICAgLS0gQ29weSBzdHJpbmcgYHMnIGF0IGluZGV4IGBwb3MnLlxuICAgICAgICBsX2FyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgcG9zLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkgKyBvbGQgKHMudHdpbikgKyBvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIGluc2VydF9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgYycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX2luc2VydGlvbl9pbmRleDogMSA8PSBpIGFuZCBpIDw9IGNvdW50ICsgMVxuICAgIGxvY2FsXG4gICAgICBwb3MsIG5ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICAgIC0tIFJlc2l6ZSBDdXJyZW50IGlmIG5lY2Vzc2FyeS5cbiAgICAgIG5ld19zaXplIDo9IDEgKyBjb3VudFxuICAgICAgaWYgbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gUGVyZm9ybSBhbGwgb3BlcmF0aW9ucyB1c2luZyBhIHplcm8gYmFzZWQgYXJyYXlzLlxuICAgICAgcG9zIDo9IGkgLSAxXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuXG4gICAgICAgIC0tIEZpcnN0IHNoaWZ0IGZyb20gYHMuY291bnQnIHBvc2l0aW9uIGFsbCBjaGFyYWN0ZXJzIHN0YXJ0aW5nIGF0IGluZGV4IGBwb3MnLlxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgMSwgY291bnQgLSBwb3MpXG5cbiAgICAgICAgLS0gSW5zZXJ0IG5ldyBjaGFyYWN0ZXJcbiAgICAgIGxfYXJlYS5wdXQgKGMsIHBvcylcblxuICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBvbmVfbW9yZV9jaGFyYWN0ZXI6IGNvdW50ID0gb2xkIGNvdW50ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGl0ZW0gKGkpID0gY1xuICAgICAgc3RhYmxlX2JlZm9yZV9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBpIC0gMSkgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpKVxuICAgICAgc3RhYmxlX2FmdGVyX2k6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkgfiAob2xkIHN1YnN0cmluZyAoaSwgY291bnQpKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlbW92YWxcblxuICByZW1vdmUgKGk6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYGknLXRoIGNoYXJhY3Rlci5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKGksIGkgLSAxLCBsX2NvdW50IC0gaSlcbiAgICAgICAgLS0gVXBkYXRlIGNvbnRlbnQuXG4gICAgICBjb3VudCA6PSBsX2NvdW50IC0gMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICByZW1vdmVfaGVhZCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBpZiBuID4gY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfdGFpbCAoY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nIChuLm1pbiAoY291bnQpICsgMSwgY291bnQpKVxuICAgIGVuZFxuXG4gIHJlbW92ZV9zdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZnJvbSBgc3RhcnRfaW5kZXgnXG4gICAgICAtLSB0byBgZW5kX2luZGV4JyBpbmNsdXNpdmUuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsX2ludGVydmFsOiBzdGFydF9pbmRleCA8PSBlbmRfaW5kZXggKyAxXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIG5iX3JlbW92ZWQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbmJfcmVtb3ZlZCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIG5iX3JlbW92ZWQgPiAwIHRoZW5cbiAgICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICBhcmVhLm92ZXJsYXBwaW5nX21vdmUgKHN0YXJ0X2luZGV4ICsgbmJfcmVtb3ZlZCAtIDEsIHN0YXJ0X2luZGV4IC0gMSwgbF9jb3VudCAtIGVuZF9pbmRleClcbiAgICAgICAgY291bnQgOj0gbF9jb3VudCAtIG5iX3JlbW92ZWRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArIG9sZCBzdWJzdHJpbmcgKGVuZF9pbmRleCArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfdGFpbCAobjogSU5URUdFUilcbiAgICAgIC0tIFJlbW92ZSBsYXN0IGBuJyBjaGFyYWN0ZXJzO1xuICAgICAgLS0gaWYgYG4nID4gYGNvdW50JywgcmVtb3ZlIGFsbC5cbiAgICByZXF1aXJlXG4gICAgICBuX25vbl9uZWdhdGl2ZTogbiA+PSAwXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgaWYgbiA+IGxfY291bnQgdGhlblxuICAgICAgICBjb3VudCA6PSAwXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbHNlXG4gICAgICAgIGtlZXBfaGVhZCAobF9jb3VudCAtIG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIGNvdW50IC0gbi5taW4gKGNvdW50KSkpXG4gICAgZW5kXG5cbiAgcHJ1bmUgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGBjJywgaWYgYW55LlxuICAgIHJlcXVpcmUgZWxzZVxuICAgICAgVHJ1ZVxuICAgIGxvY2FsXG4gICAgICBjb3VudGVyOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgICAgY291bnRlciA6PSAxXG4gICAgICB1bnRpbFxuICAgICAgICBjb3VudGVyID4gY291bnQgb3IgZWxzZSAoaXRlbSAoY291bnRlcikgPSBjKVxuICAgICAgbG9vcFxuICAgICAgICBjb3VudGVyIDo9IGNvdW50ZXIgKyAxXG4gICAgICBlbmRcbiAgICAgIGlmIGNvdW50ZXIgPD0gY291bnQgdGhlblxuICAgICAgICByZW1vdmUgKGNvdW50ZXIpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcnVuZV9hbGwgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlbW92ZSBhbGwgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIHJlcXVpcmUgZWxzZVxuICAgICAgVHJ1ZVxuICAgIGxvY2FsXG4gICAgICBpLCBqLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfY2hhcjogQ0hBUkFDVEVSXzMyXG4gICAgZG9cbiAgICAgICAgLS0gVHJhdmVyc2Ugc3RyaW5nIGFuZCBzaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0XG4gICAgICAgIC0tIGVhY2ggdGltZSB3ZSBmaW5kIGFuIG9jY3VycmVuY2Ugb2YgYGMnLlxuICAgICAgZnJvbVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IG5iXG4gICAgICBsb29wXG4gICAgICAgIGxfY2hhciA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbF9jaGFyIC89IGMgdGhlblxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfY2hhciwgailcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpIDo9IGkgKyAxXG4gICAgICBlbmRcbiAgICAgIGNvdW50IDo9IGpcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGNoYW5nZWRfY291bnQ6IGNvdW50ID0gKG9sZCBjb3VudCkgLSAob2xkIG9jY3VycmVuY2VzIChjKSlcbiAgICAgIC0tIHJlbW92ZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpIC89IGBjJ1xuICAgIGVuZFxuXG4gIHBydW5lX2FsbF9sZWFkaW5nIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGxlYWRpbmcgb2NjdXJyZW5jZXMgb2YgYGMnLlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICB1bnRpbFxuICAgICAgICBpc19lbXB0eSBvciBlbHNlIGl0ZW0gKDEpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlICgxKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsX3RyYWlsaW5nIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIHRyYWlsaW5nIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHkgb3IgZWxzZSBpdGVtIChjb3VudCkgLz0gY1xuICAgICAgbG9vcFxuICAgICAgICByZW1vdmUgKGNvdW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgd2lwZV9vdXRcbiAgICAgIC0tIFJlbW92ZSBhbGwgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmUgdGhlblxuICAgICAgaXNfZW1wdHk6IGNvdW50ID0gMFxuICAgICAgc2FtZV9jYXBhY2l0eTogY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHlcbiAgICBlbmRcblxuICBjbGVhcl9hbGxcbiAgICAgIC0tIFJlc2V0IGFsbCBjaGFyYWN0ZXJzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgd2lwZV9vdXQnIGluc3RlYWQuXCJcbiAgICBkb1xuICAgICAgY291bnQgOj0gMFxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gUmVzaXppbmdcblxuICBhZGFwdF9zaXplXG4gICAgICAtLSBBZGFwdCB0aGUgc2l6ZSB0byBhY2NvbW1vZGF0ZSBgY291bnQnIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIHJlc2l6ZSAoY291bnQpXG4gICAgZW5kXG5cbiAgcmVzaXplIChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gUmVhcnJhbmdlIHN0cmluZyBzbyB0aGF0IGl0IGNhbiBhY2NvbW1vZGF0ZVxuICAgICAgLS0gYXQgbGVhc3QgYG5ld3NpemUnIGNoYXJhY3RlcnMuXG4gICAgICAtLSBEbyBub3QgbG9zZSBhbnkgcHJldmlvdXNseSBlbnRlcmVkIGNoYXJhY3Rlci5cbiAgICBkb1xuICAgICAgYXJlYSA6PSBhcmVhLmFsaWFzZWRfcmVzaXplZF9hcmVhX3dpdGhfZGVmYXVsdCAoJyUvMDAwLycsIG5ld3NpemUgKyAxKVxuICAgIGVuZFxuXG4gIGdyb3cgKG5ld3NpemU6IElOVEVHRVIpXG4gICAgICAtLSBFbnN1cmUgdGhhdCB0aGUgY2FwYWNpdHkgaXMgYXQgbGVhc3QgYG5ld3NpemUnLlxuICAgIGRvXG4gICAgICBpZiBuZXdzaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld3NpemUpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0cmltXG4gICAgICAtLSA8UHJlY3Vyc29yPlxuICAgIGxvY2FsXG4gICAgICBuOiBsaWtlIGNvdW50XG4gICAgZG9cbiAgICAgIG4gOj0gY291bnRcbiAgICAgIGlmIG4gPCBjYXBhY2l0eSB0aGVuXG4gICAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYSAobilcbiAgICAgIGVuZFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBzYW1lX3N0cmluZzogc2FtZV9zdHJpbmcgKG9sZCB0d2luKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIENvbnZlcnNpb25cblxuICBhc19sb3dlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gbG93ZXIgY2FzZS5cbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHR3aW5cbiAgICAgIFJlc3VsdC50b19sb3dlclxuICAgIGVuZFxuXG4gIGFzX3VwcGVyOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBvYmplY3Qgd2l0aCBhbGwgbGV0dGVycyBpbiB1cHBlciBjYXNlXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fdXBwZXJcbiAgICBlbmRcblxuICBsZWZ0X2p1c3RpZnlcbiAgICAgIC0tIExlZnQganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2l0ZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZW1vdmUgbGVhZGluZyB3aGl0ZSBzcGFjZXMuXG4gICAgICBuYiA6PSBjb3VudFxuICAgICAgbGVmdF9hZGp1c3RcblxuICAgICAgICAtLSBHZXQgbmV3IGNvdW50XG4gICAgICBpIDo9IGNvdW50XG4gICAgICBpZiBpIDwgbmIgdGhlblxuICAgICAgICAgIC0tIGBsZWZ0X2FkanVzdCcgZGlkIHJlbW92ZSBzb21lIGNoYXJhY3RlcnMsIHNvIHdlIG5lZWQgdG8gYWRkXG4gICAgICAgICAgLS0gc29tZSB3aGl0ZSBzcGFjZXMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gbmJcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgaSlcbiAgICAgICAgICBpIDo9IGkgKyAxXG4gICAgICAgIGVuZFxuICAgICAgICAgIC0tIFJlc3RvcmUgYGNvdW50J1xuICAgICAgICBjb3VudCA6PSBuYlxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgY2VudGVyX2p1c3RpZnlcbiAgICAgIC0tIENlbnRlciBqdXN0aWZ5IEN1cnJlbnQgdXNpbmcgYGNvdW50JyBhcyB3aWR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmIsIGxfb2Zmc2V0OiBJTlRFR0VSXG4gICAgICBsZWZ0X25iX3NwYWNlLCByaWdodF9uYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGxfcHJvcDogbGlrZSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgIGRvXG4gICAgICBsX3Byb3AgOj0gY2hhcmFjdGVyX3Byb3BlcnRpZXNcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIGxlZnQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIG5iIDo9IGNvdW50XG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBsZWZ0X25iX3NwYWNlID0gbmIgb3IgZWxzZSBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAobGVmdF9uYl9zcGFjZSkpXG4gICAgICBsb29wXG4gICAgICAgIGxlZnRfbmJfc3BhY2UgOj0gbGVmdF9uYl9zcGFjZSArIDFcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgcmlnaHQgb2YgY3VycmVudCBzdHJpbmcuXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gbmIgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBpID0gLTEgb3IgZWxzZSBub3QgbF9wcm9wLmlzX3NwYWNlIChsX2FyZWEuaXRlbSAoaSkpXG4gICAgICBsb29wXG4gICAgICAgIHJpZ2h0X25iX3NwYWNlIDo9IHJpZ2h0X25iX3NwYWNlICsgMVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBXZSBlbmNvdXJhZ2UgdGhhdCBtb3JlIHNwYWNlcyB3aWxsIGJlIHB1dCB0byB0aGUgbGVmdCwgd2hlblxuICAgICAgICAtLSBudW1iZXIgb2Ygc3BhY2VzIGlzIG5vdCBldmVuLlxuICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSArIHJpZ2h0X25iX3NwYWNlXG4gICAgICBpZiBsX29mZnNldCBcXFxcIDIgPSAwIHRoZW5cbiAgICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC8vIDJcbiAgICAgIGVsc2VcbiAgICAgICAgbF9vZmZzZXQgOj0gbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC8vIDIgLSAxXG4gICAgICBlbmRcbiAgICAgIGlmIGxfb2Zmc2V0IC89IDAgdGhlblxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0IG9yIGxlZnQgKGRlcGVuZGluZyBvbiBzaWduIG9mXG4gICAgICAgICAgLS0gYGxfb2Zmc2V0JyBieSBgbF9vZmZzZXQnIHBvc2l0aW9uLlxuICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsZWZ0X25iX3NwYWNlLCBsZWZ0X25iX3NwYWNlIC0gbF9vZmZzZXQsXG4gICAgICAgICAgbmIgLSBsZWZ0X25iX3NwYWNlIC0gcmlnaHRfbmJfc3BhY2UpXG5cbiAgICAgICAgaWYgbF9vZmZzZXQgPCAwIHRoZW5cbiAgICAgICAgICAgIC0tIEZpbGwgbGVmdCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgbGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0IC0gMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgLS0gRmlsbCByaWdodCBwYXJ0IHdpdGggc3BhY2VzLlxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgbmIgLSByaWdodF9uYl9zcGFjZSAtIGxfb2Zmc2V0LCBuYiAtIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcmlnaHRfanVzdGlmeVxuICAgICAgLS0gUmlnaHQganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIHJpZ2h0X2FkanVzdFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgbmJfc3BhY2UgOj0gbmIgLSBpXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChpKSwgaSArIG5iX3NwYWNlKVxuICAgICAgICB2YXJpYW50XG4gICAgICAgICAgaSArIDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgZnJvbVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIG5iX3NwYWNlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgLSAxXG4gICAgICAgICAgbF9hcmVhLnB1dCAoJyAnLCBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIG5iX3NwYWNlICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICBlbmRcblxuICBjaGFyYWN0ZXJfanVzdGlmeSAocGl2b3Q6IENIQVJBQ1RFUl8zMjsgcG9zaXRpb246IElOVEVHRVIpXG4gICAgICAtLSBKdXN0aWZ5IGEgc3RyaW5nIGJhc2VkIG9uIGEgYHBpdm90J1xuICAgICAgLS0gYW5kIHRoZSBgcG9zaXRpb24nIGl0IG5lZWRzIHRvIGJlIGluXG4gICAgICAtLSB0aGUgZmluYWwgc3RyaW5nLlxuICAgICAgLS0gVGhpcyB3aWxsIGdyb3cgdGhlIHN0cmluZyBpZiBuZWNlc3NhcnlcbiAgICAgIC0tIHRvIGdldCB0aGUgcGl2b3QgaW4gdGhlIGNvcnJlY3QgcGxhY2UuXG4gICAgcmVxdWlyZVxuICAgICAgdmFsaWRfcG9zaXRpb246IHBvc2l0aW9uIDw9IGNhcGFjaXR5XG4gICAgICBwb3NpdGl2ZV9wb3NpdGlvbjogcG9zaXRpb24gPj0gMVxuICAgICAgcGl2b3Rfbm90X3NwYWNlOiBwaXZvdCAvPSAnICdcbiAgICAgIG5vdF9lbXB0eTogbm90IGlzX2VtcHR5XG4gICAgbG9jYWxcbiAgICAgIGxfaW5kZXhfb2ZfcGl2b3QsIGxfbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfaW5kZXhfb2ZfcGl2b3QgOj0gaW5kZXhfb2YgKHBpdm90LCAxKVxuICAgICAgaWYgbF9pbmRleF9vZl9waXZvdCAvPSAwIHRoZW5cbiAgICAgICAgaWYgbF9pbmRleF9vZl9waXZvdCA8IHBvc2l0aW9uIHRoZW5cbiAgICAgICAgICAgIC0tIFdlIG5lZWQgdG8gcmVzaXplIEN1cnJlbnQgc28gdGhhdCB3ZSBjYW4gc2hpZnQgQ3VycmVudCBieVxuICAgICAgICAgICAgLS0gYGxfaW5kZXhfb2ZfcGl2b3QgLSBwb3NpdGlvbicuXG4gICAgICAgICAgbF9uZXdfc2l6ZSA6PSBjb3VudCArIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdFxuICAgICAgICAgIGdyb3cgKGxfbmV3X3NpemUpXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhICgwLCBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3QsIGNvdW50KVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90IC0gMSlcbiAgICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIFNpbXBseSBzaGlmdCBjb250ZW50IHRvIHRoZSBsZWZ0IGFuZCByZXNldCB0cmFpbGluZyB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAgIGxfYXJlYS5tb3ZlX2RhdGEgKGxfaW5kZXhfb2ZfcGl2b3QgLSBwb3NpdGlvbiwgMCwgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24pXG4gICAgICAgICAgbF9hcmVhLmZpbGxfd2l0aCAoJyAnLCBjb3VudCAtIGxfaW5kZXhfb2ZfcGl2b3QgKyBwb3NpdGlvbiwgY291bnQgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHRvX2xvd2VyXG4gICAgICAtLSBDb252ZXJ0IHRvIGxvd2VyIGNhc2UuXG4gICAgZG9cbiAgICAgIHRvX2xvd2VyX2FyZWEgKGFyZWEsIDAsIGNvdW50IC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBsZW5ndGhfYW5kX2NvbnRlbnQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBhc19sb3dlcilcbiAgICBlbmRcblxuICB0b191cHBlclxuICAgICAgLS0gQ29udmVydCB0byB1cHBlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b191cHBlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfdXBwZXIpXG4gICAgZW5kXG5cbiAgbGluZWFyX3JlcHJlc2VudGF0aW9uOiBMSU5FQVIgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIC0tIFJlcHJlc2VudGF0aW9uIGFzIGEgbGluZWFyIHN0cnVjdHVyZVxuICAgIGxvY2FsXG4gICAgICB0ZW1wOiBBUlJBWUVEX0xJU1QgW0NIQVJBQ1RFUl8zMl1cbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgY3JlYXRlIHRlbXAubWFrZSAoY2FwYWNpdHkpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgaSA+IGNvdW50XG4gICAgICBsb29wXG4gICAgICAgIHRlbXAuZXh0ZW5kIChpdGVtIChpKSlcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBSZXN1bHQgOj0gdGVtcFxuICAgIGVuZFxuXG4gIGZyb3plbiB0b19jOiBBTllcbiAgICAgIC0tIEEgcmVmZXJlbmNlIHRvIGEgQyBmb3JtIG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgLS0gVXNlZnVsIG9ubHkgZm9yIGludGVyZmFjaW5nIHdpdGggQyBzb2Z0d2FyZS5cbiAgICByZXF1aXJlXG4gICAgICBub3RfaXNfZG90bmV0OiBub3Qge1BMQVRGT1JNfS5pc19kb3RuZXRcbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgIGxfYXJlYS5wdXQgKCclVScsIGNvdW50KVxuICAgICAgUmVzdWx0IDo9IGxfYXJlYVxuICAgIGVuZFxuXG4gIG1pcnJvcmVkOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE1pcnJvciBpbWFnZSBvZiBzdHJpbmc7XG4gICAgICAtLSBSZXN1bHQgZm9yIFwiSGVsbG8gd29ybGRcIiBpcyBcImRscm93IG9sbGVIXCIuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBSZXN1bHQubWlycm9yXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtaXJyb3JcbiAgICAgIC0tIFJldmVyc2UgdGhlIG9yZGVyIG9mIGNoYXJhY3RlcnMuXG4gICAgICAtLSBcIkhlbGxvIHdvcmxkXCIgLT4gXCJkbHJvdyBvbGxlSFwiLlxuICAgIGxvY2FsXG4gICAgICBhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgaSwgajogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBjb3VudCA+IDAgdGhlblxuICAgICAgICBmcm9tXG4gICAgICAgICAgaSA6PSBjb3VudCAtIDFcbiAgICAgICAgICBhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBpIDw9IGpcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGMgOj0gYS5pdGVtIChpKVxuICAgICAgICAgIGEucHV0IChhLml0ZW0gKGopLCBpKVxuICAgICAgICAgIGEucHV0IChjLCBqKVxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICBqIDo9IGogKyAxXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgLS0gcmV2ZXJzZWQ6IEZvciBldmVyeSBgaScgaW4gMS4uYGNvdW50JywgYGl0ZW0nIChgaScpID0gb2xkIGBpdGVtJyAoYGNvdW50JysxLWBpJylcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBEdXBsaWNhdGlvblxuXG4gIHN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleDogSU5URUdFUik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gQ29weSBvZiBzdWJzdHJpbmcgY29udGFpbmluZyBhbGwgY2hhcmFjdGVycyBhdCBpbmRpY2VzXG4gICAgICAtLSBiZXR3ZWVuIGBzdGFydF9pbmRleCcgYW5kIGBlbmRfaW5kZXgnXG4gICAgZG9cbiAgICAgIGlmICgxIDw9IHN0YXJ0X2luZGV4KSBhbmQgKHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCkgYW5kIChlbmRfaW5kZXggPD0gY291bnQpIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgICAgUmVzdWx0LmFyZWEuY29weV9kYXRhIChhcmVhLCBzdGFydF9pbmRleCAtIDEsIDAsIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgICAgUmVzdWx0LnNldF9jb3VudCAoZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxKVxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoMClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIG11bHRpcGx5IChuOiBJTlRFR0VSKVxuICAgICAgLS0gRHVwbGljYXRlIGEgc3RyaW5nIHdpdGhpbiBpdHNlbGZcbiAgICAgIC0tIChcImhlbGxvXCIpLm11bHRpcGx5KDMpID0+IFwiaGVsbG9oZWxsb2hlbGxvXCJcbiAgICByZXF1aXJlXG4gICAgICBtZWFuaW5nZnVsX211bHRpcGxpZXI6IG4gPj0gMVxuICAgIGxvY2FsXG4gICAgICBzOiBsaWtlIEN1cnJlbnRcbiAgICAgIGk6IElOVEVHRVJcbiAgICBkb1xuICAgICAgcyA6PSB0d2luXG4gICAgICBncm93IChuICogY291bnQpXG4gICAgICBmcm9tXG4gICAgICAgIGkgOj0gblxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IDFcbiAgICAgIGxvb3BcbiAgICAgICAgYXBwZW5kIChzKVxuICAgICAgICBpIDo9IGkgLSAxXG4gICAgICBlbmRcbiAgICBlbmRcblxuZmVhdHVyZSB7U1RSSU5HX0hBTkRMRVJ9IC0tIEltcGxlbWVudGF0aW9uXG5cbiAgZnJvemVuIHNldF9jb3VudCAobnVtYmVyOiBJTlRFR0VSKVxuICAgICAgLS0gU2V0IGBjb3VudCcgdG8gYG51bWJlcicgb2YgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY291bnQgOj0gbnVtYmVyXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuZFxuXG5mZWF0dXJlIHtOT05FfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIG5ld19zdHJpbmcgKG46IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIE5ldyBpbnN0YW5jZSBvZiBjdXJyZW50IHdpdGggc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICBjcmVhdGUgUmVzdWx0Lm1ha2UgKG4pXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gVHJhbnNmb3JtYXRpb25cblxuICBjb3JyZWN0X21pc21hdGNoXG4gICAgICAtLSBBdHRlbXB0IHRvIGNvcnJlY3Qgb2JqZWN0IG1pc21hdGNoIGR1cmluZyByZXRyaWV2ZSB1c2luZyBgbWlzbWF0Y2hfaW5mb3JtYXRpb24nLlxuICAgIGRvXG4gICAgICAgIC0tIE5vdGhpbmcgdG8gYmUgZG9uZSBiZWNhdXNlIHdlIG9ubHkgYWRkZWQgYGludGVybmFsX2hhc2hfY29kZScgdGhhdCB3aWxsXG4gICAgICAgIC0tIGJlIHJlY29tcHV0ZWQgbmV4dCB0aW1lIHdlIHF1ZXJ5IGBoYXNoX2NvZGUnLlxuXG4gICAgICAgIC0tIEluIC5ORVQsIHdlIGhhdmUgYSBtaXNtYXRjaCB0aGF0IGlzIHRyaWdnZXJlZCBkdWUgdG8gdGhlIGltcGxlbWVudGF0aW9uIG9mXG4gICAgICAgIC0tIFNQRUNJQUwgW0NIQVJBQ1RFUl8zMl0gYXMgYSAuTkVUIGFycmF5IG9mIFVJbnQxNi5cbiAgICAgIGlmIGFyZWEgPSBWb2lkIGFuZCB0aGVuIGF0dGFjaGVkIHtsaWtlIGFyZWF9IG1pc21hdGNoX2luZm9ybWF0aW9uLml0ZW0gKFwiYXJlYVwiKSBhcyBsX2FyZWEgdGhlblxuICAgICAgICBhcmVhIDo9IGxfYXJlYVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmludmFyaWFudFxuICBleHRlbmRpYmxlOiBleHRlbmRpYmxlXG4gIGNvbXBhcmVfY2hhcmFjdGVyOiBub3Qgb2JqZWN0X2NvbXBhcmlzb25cblxubm90ZVxuICBjb3B5cmlnaHQ6IFwiQ29weXJpZ2h0IChjKSAxOTg0LTIwMTQsIEVpZmZlbCBTb2Z0d2FyZSBhbmQgb3RoZXJzXCJcbiAgbGljZW5zZTogICBcIkVpZmZlbCBGb3J1bSBMaWNlbnNlIHYyIChzZWUgaHR0cDovL3d3dy5laWZmZWwuY29tL2xpY2Vuc2luZy9mb3J1bS50eHQpXCJcblxuZW5kXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=