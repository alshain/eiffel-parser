var __eiffel_builtin = [];
__eiffel_builtin.push({"filename":"any.e","content":"class\n  ANY\n\nfeature -- Status report\n\n  conforms_to (other: ANY): BOOLEAN\n      -- Does type of current object conform to type\n      -- of `other' (as per Eiffel: The Language, chapter 13)?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    end\n\n  same_type (other: ANY): BOOLEAN\n      -- Is type of current object identical to type of `other'?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      definition: Result = (conforms_to (other) and\n                    other.conforms_to (Current))\n    end\n\nfeature -- Comparison\n\n  is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object considered\n      -- equal to current object?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      symmetric: Result implies other ~ Current\n      consistent: standard_is_equal (other) implies Result\n    end\n\n  frozen standard_is_equal (other: like Current): BOOLEAN\n      -- Is `other' attached to an object of the same type\n      -- as current object, and field-by-field identical to it?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.standard_is_equal (Current)\n    end\n\n  frozen equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached\n      -- to objects considered equal?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.is_equal (b))\n    end\n\n  frozen standard_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void or attached to\n      -- field-by-field identical objects of the same type?\n      -- Always uses default object comparison criterion.\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then\n              a.standard_is_equal (b)\n      end\n    ensure\n      definition: Result = (a = Void and b = Void) or else\n            ((a /= Void and b /= Void) and then\n            a.standard_is_equal (b))\n    end\n\n  frozen is_deep_equal (other: like Current): BOOLEAN\n      -- Are `Current' and `other' attached to isomorphic object structures?\n    require\n      other_not_void: other /= Void\n    external\n      \"built_in\"\n    ensure\n      shallow_implies_deep: standard_is_equal (other) implies Result\n      same_type: Result implies same_type (other)\n      symmetric: Result implies other.is_deep_equal (Current)\n    end\n\n  frozen deep_equal (a: detachable ANY; b: like a): BOOLEAN\n      -- Are `a' and `b' either both void\n      -- or attached to isomorphic object structures?\n    do\n      if a = Void then\n        Result := b = Void\n      else\n        Result := b /= Void and then a.is_deep_equal (b)\n      end\n    ensure\n      shallow_implies_deep: standard_equal (a, b) implies Result\n      both_or_none_void: (a = Void) implies (Result = (b = Void))\n      same_type: (Result and (a /= Void)) implies (b /= Void and then a.same_type (b))\n      symmetric: Result implies deep_equal (b, a)\n    end\n\nfeature -- Output\n\n  io: STD_FILES\n      -- Handle to standard file setup\n    external\n      \"built_in\"\n    ensure\n      io_not_void: Result /= Void\n    end\n\n  out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    do\n      Result := tagged_out\n    ensure\n      out_not_void: Result /= Void\n    end\n\n  frozen tagged_out: STRING\n      -- New string containing terse printable representation\n      -- of current object\n    external\n      \"built_in\"\n    ensure\n      tagged_out_not_void: Result /= Void\n    end\n\n  print (o: detachable ANY)\n      -- Write terse external representation of `o'\n      -- on standard output.\n    do\n      if o /= Void then\n        io.put_string (o.out)\n      end\n    end\n\nfeature {NONE} -- Initialization\n\n  default_create\n      -- Process instances of classes with no creation clause.\n      -- (Default: do nothing.)\n    do\n    end\n\nfeature -- Basic operations\n  frozen dlo_nothing\n      -- Execute a null action.\n    do\n    end\n\ninvariant\n  reflexive_equality: standard_is_equal (Current)\n  reflexive_conformance: conforms_to (Current)\n\n\nend\n"});
__eiffel_builtin.push({"filename":"integer.e","content":"expanded class INTEGER_32 inherit\n\n  INTEGER_32_REF\n    redefine\n      is_less,\n      plus,\n      minus,\n      product,\n      quotient,\n      power,\n      integer_quotient,\n      integer_remainder,\n      opposite,\n      identity,\n      asa_natural_8,\n      as_natural_16,\n      as_natural_32,\n      as_natural_64,\n      as_integer_8,\n      as_integer_16,\n      as_integer_32,\n      as_integer_64,\n      to_real,\n      to_double,\n      to_character_8,\n      to_character_32,\n      bit_and,\n      bit_or,\n      bit_xor,\n      bit_not,\n      bit_shift_left,\n      bit_shift_right\n    end\n\ncreate\n  default_create,\n  make_from_reference\n\n-- convert\n--   make_from_reference ({INTEGER_32_REF}),\n--   to_real: {REAL_32},\n--   to_double: {REAL_64},\n--   to_integer_64: {INTEGER_64}\n\nfeature -- Comparison\n\n  is_less alias \"<\" (other: INTEGER_32): BOOLEAN\n      -- Is current integer less than `other'?\n    external\n      \"built_in\"\n    end\n\nfeature -- Basic operations\n\n  plus alias \"+\" (other: INTEGER_32): INTEGER_32\n      -- Sum with `other'\n    external\n      \"built_in\"\n    end\n\n  minus alias \"-\" (other: INTEGER_32): INTEGER_32\n      -- Result of subtracting `other'\n    external\n      \"built_in\"\n    end\n\n  product alias \"*\" (other: INTEGER_32): INTEGER_32\n      -- Product by `other'\n    external\n      \"built_in\"\n    end\n\n  quotient alias \"/\" (other: INTEGER_32): REAL_64\n      -- Division by `other'\n    external\n      \"built_in\"\n    end\n\n  identity alias \"+\": INTEGER_32\n      -- Unary plus\n    external\n      \"built_in\"\n    end\n\n  opposite alias \"-\": INTEGER_32\n      -- Unary minus\n    external\n      \"built_in\"\n    end\n\n  integer_quotient alias \"//\" (other: INTEGER_32): INTEGER_32\n      -- Integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  integer_remainder alias \"\\\\\" (other: INTEGER_32): INTEGER_32\n      -- Remainder of the integer division of Current by `other'\n    external\n      \"built_in\"\n    end\n\n  power alias \"^\" (other: REAL_64): REAL_64\n      -- Integer power of Current by `other'\n    external\n      \"built_in\"\n    end\n\nfeature -- Conversion\n\n  as_natural_8: NATURAL_8\n      -- Convert `item' into an NATURAL_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_16: NATURAL_16\n      -- Convert `item' into an NATURAL_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_32: NATURAL_32\n      -- Convert `item' into an NATURAL_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_natural_64: NATURAL_64\n      -- Convert `item' into an NATURAL_64 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_8: INTEGER_8\n      -- Convert `item' into an INTEGER_8 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_16: INTEGER_16\n      -- Convert `item' into an INTEGER_16 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_32: INTEGER_32\n      -- Convert `item' into an INTEGER_32 value.\n    external\n      \"built_in\"\n    end\n\n  as_integer_64: INTEGER_64\n      -- Convert `item' into an INTEGER_64 value.\n    external\n      \"built_in\"\n    end\n\n  to_real: REAL_32\n      -- Convert `item' into a REAL_32\n    external\n      \"built_in\"\n    end\n\n  to_double: REAL_64\n      -- Convert `item' into a REAL_64\n    external\n      \"built_in\"\n    end\n\n  to_character_8: CHARACTER_8\n      -- Associated character in 8 bit version.\n    external\n      \"built_in\"\n    end\n\n  to_character_32: CHARACTER_32\n      -- Associated character in 32 bit version.\n    external\n      \"built_in\"\n    end\n\nfeature -- Bit operations\n\n  bit_and alias \"&\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise and between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_or alias \"|\" (i: INTEGER_32): INTEGER_32\n      -- Bitwise or between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_xor (i: INTEGER_32): INTEGER_32\n      -- Bitwise xor between Current' and `i'.\n    external\n      \"built_in\"\n    end\n\n  bit_not: INTEGER_32\n      -- One's complement of Current.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_left alias \"|<<\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to left.\n    external\n      \"built_in\"\n    end\n\n  bit_shift_right alias \"|>>\" (n: INTEGER): INTEGER_32\n      -- Shift Current from `n' position to right.\n    external\n      \"built_in\"\n    end\n\nend\n"});
__eiffel_builtin.push({"filename":"string.e","content":"class\n  STRING\n\ninherit\n  READABLE_STRING_32\n    redefine\n      area\n    export\n      {ANY} make, make_empty, make_filled, make_from_c, make_from_string, fill_character\n    end\n\n  STRING_GENERAL\n    undefine\n      copy, is_equal, out, has, index_of, last_index_of, occurrences\n    redefine\n      append_string_general,\n      prepend_string_general\n    rename\n      append as append_string_general,\n      append_substring as append_substring_general,\n      prepend as prepend_string_general,\n      prepend_substring as prepend_substring_general,\n      same_string as same_string_general,\n      same_characters as same_characters_general,\n      same_caseless_characters as same_caseless_characters_general,\n      starts_with as starts_with_general,\n      ends_with as ends_with_general,\n      is_case_insensitive_equal as is_case_insensitive_equal_general\n    end\n\n  INDEXABLE [CHARACTER_32, INTEGER]\n    undefine\n      copy, is_equal, out\n    redefine\n      prune_all,\n      changeable_comparison_criterion\n    end\n\n  RESIZABLE [CHARACTER_32]\n    undefine\n      copy, is_equal, out\n    redefine\n      changeable_comparison_criterion\n    end\n\n  TO_SPECIAL [CHARACTER_32]\n    undefine\n      copy, is_equal, out, item, at, put, valid_index\n    redefine\n      area\n    end\n\n  MISMATCH_CORRECTOR\n    undefine\n      copy, is_equal, out\n    redefine\n      correct_mismatch\n    end\n\ncreate\n  make,\n  make_empty,\n  make_filled,\n  make_from_string,\n  make_from_string_general,\n  make_from_c,\n  make_from_c_pointer,\n  make_from_cil,\n  make_from_separate\n\nconvert\n  to_cil: {SYSTEM_STRING},\n  make_from_cil ({SYSTEM_STRING}),\n  as_string_8: {READABLE_STRING_8, STRING_8}\n\nfeature -- Initialization\n\n  make_from_string_general (s: READABLE_STRING_GENERAL)\n      -- Initialize from the characters of `s'.\n    do\n      if attached {READABLE_STRING_32} s as s32 then\n        make_from_string (s32)\n      else\n        make (s.count)\n        append_string_general (s)\n      end\n    end\n\n  make_from_cil (a_system_string: detachable SYSTEM_STRING)\n      -- Initialize Current with `a_system_string'.\n    local\n      l_count: INTEGER\n    do\n      if a_system_string /= Void then\n        l_count := a_system_string.length + dotnet_convertor.escape_count (a_system_string)\n      end\n      make (l_count)\n      if l_count > 0 and then a_system_string /= Void then\n        set_count (l_count)\n        dotnet_convertor.read_system_string_into (a_system_string, Current)\n      end\n    end\n\n  from_c (c_string: POINTER)\n      -- Reset contents of string from contents of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n    local\n      l_count: INTEGER\n    do\n      c_string_provider.set_shared_from_pointer (c_string)\n        -- Resize string in case it is not big enough\n      l_count := c_string_provider.count\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_string_into (Current)\n    ensure\n      no_zero_byte: not has ('%/0/')\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n      -- correct_count: the ASCII character at address c_string + count\n      --       is NULL\n    end\n\n  from_c_substring (c_string: POINTER; start_pos, end_pos: INTEGER)\n      -- Reset contents of string from substring of `c_string',\n      -- a string created by some C function.\n    require\n      c_string_exists: c_string /= default_pointer\n      start_position_big_enough: start_pos >= 1\n      end_position_big_enough: start_pos <= end_pos + 1\n    local\n      l_count: INTEGER\n    do\n      l_count := end_pos - start_pos + 1\n      c_string_provider.set_shared_from_pointer_and_count (c_string + (start_pos - 1), l_count)\n        -- Resize string in case it is not big enough\n      grow (l_count + 1)\n      count := l_count\n      internal_hash_code := 0\n      c_string_provider.read_substring_into (Current, 1, l_count)\n    ensure\n      valid_count: count = end_pos - start_pos + 1\n      -- characters: for all i in 1..count, item (i) equals\n      --       ASCII character at address c_string + (i - 1)\n    end\n\n  adapt (s: STRING_32): like Current\n      -- Object of a type conforming to the type of `s',\n      -- initialized with attributes from `s'\n    do\n      Result := new_string (0)\n      Result.share (s)\n    ensure\n      adapt_not_void: Result /= Void\n      shared_implementation: Result.shared_with (s)\n    end\n\n  remake (n: INTEGER)\n      -- Allocate space for at least `n' characters.\n    obsolete\n      \"Use `make' instead\"\n    require\n      non_negative_size: n >= 0\n    do\n      make (n)\n    ensure\n      empty_string: count = 0\n      area_allocated: capacity >= n\n    end\n\nfeature -- Access\n\n  item alias \"[]\", at alias \"@\" (i: INTEGER): CHARACTER_32 assign put\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1)\n    end\n\n  code (i: INTEGER): NATURAL_32\n      -- Character at position `i'\n    do\n      Result := area.item (i - 1).code.to_natural_32\n    end\n\n  item_code (i: INTEGER): INTEGER\n      -- Character at position `i'\n    obsolete\n      \"Due to potential truncation it is recommended to use `code (i)' instead.\"\n    do\n      Result := area.item (i - 1).natural_32_code.as_integer_32\n    end\n\n  area: SPECIAL [CHARACTER_32]\n      -- Storage for characters\n\nfeature -- Status report\n\n  extendible: BOOLEAN = True\n      -- May new items be added? (Answer: yes.)\n\n  prunable: BOOLEAN\n      -- May items be removed? (Answer: yes.)\n    do\n      Result := True\n    end\n\n  changeable_comparison_criterion: BOOLEAN = False\n\nfeature -- Element change\n\n  set (t: READABLE_STRING_32; n1, n2: INTEGER)\n      -- Set current string to substring of `t' from indices `n1'\n      -- to `n2', or to empty string if no such substring.\n    require\n      argument_not_void: t /= Void\n    local\n      s: READABLE_STRING_32\n    do\n      s := t.substring (n1, n2)\n      area := s.area\n      count := s.count\n      internal_hash_code := 0\n    ensure\n      is_substring: same_string (t.substring (n1, n2))\n    end\n\n  subcopy (other: READABLE_STRING_32; start_pos, end_pos, index_pos: INTEGER)\n      -- Copy characters of `other' within bounds `start_pos' and\n      -- `end_pos' to current string starting at index `index_pos'.\n    require\n      other_not_void: other /= Void\n      valid_start_pos: other.valid_index (start_pos)\n      valid_end_pos: other.valid_index (end_pos)\n      valid_bounds: (start_pos <= end_pos) or (start_pos = end_pos + 1)\n      valid_index_pos: valid_index (index_pos)\n      enough_space: (count - index_pos) >= (end_pos - start_pos)\n    local\n      l_other_area, l_area: like area\n    do\n      if end_pos >= start_pos then\n        l_other_area := other.area\n        l_area := area\n        if l_area /= l_other_area then\n          l_area.copy_data (l_other_area, start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        else\n          l_area.overlapping_move (start_pos - 1, index_pos - 1,\n            end_pos - start_pos + 1)\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      copied: elks_checking implies\n        (Current ~ (old substring (1, index_pos - 1) +\n        old other.substring (start_pos, end_pos) +\n        old substring (index_pos + (end_pos - start_pos + 1), count)))\n    end\n\n  replace_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Replace characters from `start_index' to `end_index' with `s'.\n    require\n      string_not_void: s /= Void\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningfull_interval: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      diff: INTEGER\n      l_area: like area\n      s_count: INTEGER\n      old_count: INTEGER\n    do\n      s_count := s.count\n      old_count := count\n      diff := s_count - (end_index - start_index + 1)\n      new_size := diff + old_count\n      if diff > 0 then\n          -- We need to resize the string.\n        grow (new_size)\n      end\n\n      l_area := area\n        --| We move the end of the string forward (if diff is > 0), backward (if diff < 0),\n        --| and nothing otherwise.\n      if diff /= 0 then\n        l_area.overlapping_move (end_index, end_index + diff, old_count - end_index)\n      end\n        --| Set new count\n      set_count (new_size)\n        --| We copy the substring.\n      l_area.copy_data (s.area, s.area_lower, start_index - 1, s_count)\n    ensure\n      new_count: count = old count + old s.count - end_index + start_index - 1\n      replaced: elks_checking implies\n        (Current ~ (old (substring (1, start_index - 1) +\n          s + substring (end_index + 1, count))))\n    end\n\n  replace_substring_all (original, new: READABLE_STRING_32)\n      -- Replace every occurrence of `original' with `new'.\n    require\n      original_exists: original /= Void\n      new_exists: new /= Void\n      original_not_empty: not original.is_empty\n    extern\n      \"built_in\"\n    end\n\n  replace_blank\n      -- Replace all current characters with blanks.\n    do\n      fill_with (' ')\n    ensure\n      same_size: (count = old count) and (capacity = old capacity)\n      all_blank: elks_checking implies occurrences (' ') = count\n    end\n\n  fill_blank\n      -- Fill with `capacity' blank characters.\n    do\n      fill_character (' ')\n    ensure\n      filled: full\n      same_size: (count = capacity) and (capacity = old capacity)\n      -- all_blank: For every `i' in `count'..`capacity', `item' (`i') = `Blank'\n    end\n\n  fill_with (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if l_count /= 0 then\n        area.fill_with (c, 0, l_count - 1)\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  replace_character (c: CHARACTER_32)\n      -- Replace every character with `c'.\n    obsolete\n      \"ELKS 2001: use `fill_with' instead'\"\n    do\n      fill_with (c)\n    ensure\n      same_count: (count = old count) and (capacity = old capacity)\n      filled: elks_checking implies occurrences (c) = count\n    end\n\n  keep_head (n: INTEGER)\n      -- Remove all characters except for the first `n';\n      -- do nothing if `n' >= `count'.\n    do\n      if n < count then\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  keep_tail (n: INTEGER)\n      -- Remove all characters except for the last `n';\n      -- do nothing if `n' >= `count'.\n    local\n      nb: like count\n    do\n      nb := count\n      if n < nb then\n        area.overlapping_move (nb - n, 0, n)\n        count := n\n        internal_hash_code := 0\n      end\n    end\n\n  left_adjust\n      -- Remove leading whitespace.\n    local\n      nb, nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count - 1\n        l_area := area\n      until\n        nb_space > nb or else not l_prop.is_space (l_area.item (nb_space))\n      loop\n        nb_space := nb_space + 1\n      end\n\n      if nb_space > 0 then\n          -- Set new count value.\n        nb := nb + 1 - nb_space\n          -- Shift characters to the left.\n        l_area.overlapping_move (nb_space, 0, nb)\n          -- Set new count.\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  right_adjust\n      -- Remove trailing whitespace.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n      c: CHARACTER_32\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n        -- Compute number of spaces at the right of current string.\n      from\n        nb := count - 1\n        i := nb\n        l_area := area\n      until\n        i < 0\n      loop\n        c := l_area.item (i)\n        if not l_prop.is_space (c) then\n            -- We are done.\n          i := -1\n        else\n          nb_space := nb_space + 1\n          i := i - 1\n        end\n      end\n\n      if nb_space > 0 then\n          -- Set new count.\n        count := nb + 1 - nb_space\n        internal_hash_code := 0\n      end\n    end\n\n  share (other: STRING_32)\n      -- Make current string share the text of `other'.\n      -- Subsequent changes to the characters of current string\n      -- will also affect `other', and conversely.\n    require\n      argument_not_void: other /= Void\n    do\n      area := other.area\n      count := other.count\n      internal_hash_code := 0\n    ensure\n      shared_count: other.count = count\n      shared_area: other.area = area\n    end\n\n  put (c: CHARACTER_32; i: INTEGER)\n      -- Replace character at position `i' by `c'.\n    do\n      area.put (c, i - 1)\n      internal_hash_code := 0\n    ensure then\n      stable_count: count = old count\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i + 1, count))\n    end\n\n  put_code (v: NATURAL_32; i: INTEGER)\n      -- Replace character at position `i' by character of code `v'.\n    do\n      area.put (v.to_character_32, i - 1)\n      internal_hash_code := 0\n    end\n\n  prepend_string_general (s: READABLE_STRING_GENERAL)\n      -- Prepend characters of `s' at front.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        prepend (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  precede, prepend_character (c: CHARACTER_32)\n      -- Add `c' at front.\n    local\n      l_area: like area\n    do\n      if count = capacity then\n        resize (count + additional_space)\n      end\n      l_area := area\n      l_area.overlapping_move (0, 1, count)\n      l_area.put (c, 0)\n      count := count + 1\n      internal_hash_code := 0\n    ensure\n      new_count: count = old count + 1\n    end\n\n  prepend (s: READABLE_STRING_32)\n      -- Prepend characters of `s' at front.\n    require\n      argument_not_void: s /= Void\n    do\n      insert_string (s, 1)\n    ensure\n      new_count: count = old (count + s.count)\n      inserted: elks_checking implies same_string (old (s + Current))\n    end\n\n  prepend_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Prepend characters of `s.substring (start_index, end_index)' at front.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n\n          -- First shift from `s.count' position all characters of current.\n        l_area.overlapping_move (0, l_s_count, count)\n\n          -- Copy string `s' at beginning.\n        l_area.copy_data (s.area, s.area_lower + start_index - 1, 0, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + end_index - start_index + 1\n      inserted: elks_checking implies same_string (old (s.substring (start_index, end_index) + Current))\n    end\n\n  prepend_boolean (b: BOOLEAN)\n      -- Prepend the string representation of `b' at front.\n    do\n      prepend_string_general (b.out)\n    end\n\n  prepend_double (d: DOUBLE)\n      -- Prepend the string representation of `d' at front.\n    do\n      prepend_string_general (d.out)\n    end\n\n  prepend_integer (i: INTEGER)\n      -- Prepend the string representation of `i' at front.\n    do\n      prepend_string_general (i.out)\n    end\n\n  prepend_real (r: REAL)\n      -- Prepend the string representation of `r' at front.\n    do\n      prepend_string_general (r.out)\n    end\n\n  prepend_string (s: detachable READABLE_STRING_32)\n      -- Prepend characters of `s', if not void, at front.\n    do\n      if s /= Void then\n        prepend (s)\n      end\n    end\n\n  append_string_general (s: READABLE_STRING_GENERAL)\n      -- Append characters of `s' at end.\n    do\n      if attached {READABLE_STRING_32} s as l_s32 then\n        append (l_s32)\n      else\n        Precursor {STRING_GENERAL} (s)\n      end\n    end\n\n  append (s: READABLE_STRING_32)\n      -- Append characters of `s' at end.\n    require\n      argument_not_void: s /= Void\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := s.count\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + old s.count\n      appended: elks_checking implies same_string (old (Current + s))\n    end\n\n  append_substring (s: READABLE_STRING_32; start_index, end_index: INTEGER)\n      -- Append characters of `s.substring (start_index, end_index)' at end.\n    require\n      argument_not_void: s /= Void\n      start_index_valid: start_index >= 1\n      end_index_valid: end_index <= s.count\n      valid_bounds: start_index <= end_index + 1\n    local\n      l_count, l_s_count, l_new_size: INTEGER\n    do\n      l_s_count := end_index - start_index + 1\n      if l_s_count > 0 then\n        l_count := count\n        l_new_size := l_s_count + l_count\n        if l_new_size > capacity then\n          resize (l_new_size + additional_space)\n        end\n        area.copy_data (s.area, s.area_lower + start_index - 1, l_count, l_s_count)\n        count := l_new_size\n        internal_hash_code := 0\n      end\n    ensure\n      new_count: count = old count + (end_index - start_index + 1)\n      appended: elks_checking implies same_string (old (Current + s.substring (start_index, end_index)))\n    end\n\n  plus alias \"+\" (s: READABLE_STRING_GENERAL): like Current\n      -- <Precursor>\n    do\n      Result := new_string (count + s.count)\n      Result.append (Current)\n      Result.append_string_general (s)\n    end\n\n  append_string (s: detachable READABLE_STRING_32)\n      -- Append a copy of `s', if not void, at end.\n    do\n      if s /= Void then\n        append (s)\n      end\n    ensure\n      appended: s /= Void implies\n        (elks_checking implies Current ~ (old twin + old s.twin))\n    end\n\n  append_integer (i: INTEGER)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_8 (i: INTEGER_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_8}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_16 (i: INTEGER_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_16}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_integer_64 (i: INTEGER_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: INTEGER_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          if i < 0 then\n            append_character ('-')\n            l_starting_index := l_starting_index + 1\n              -- Special case for minimum integer value as negating it\n              -- as no effect.\n            if i = {INTEGER_64}.Min_value then\n              append_character ('8')\n              l_value := -(i // 10)\n            else\n              l_value := -i\n            end\n          else\n            l_value := i\n          end\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_8 (i: NATURAL_8)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_8\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_16 (i: NATURAL_16)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_16\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_32 (i: NATURAL_32)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_32\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_natural_64 (i: NATURAL_64)\n      -- Append the string representation of `i' at end.\n    local\n      l_value: NATURAL_64\n      l_starting_index, l_ending_index: INTEGER\n      l_temp: CHARACTER_32\n      l_area: like area\n    do\n      if i = 0 then\n        append_character ('0')\n      else\n          -- Extract integer value digit by digit from right to left.\n        from\n          l_starting_index := count\n          l_value := i\n        until\n          l_value = 0\n        loop\n          append_character (((l_value \\\\ 10)+ 48).to_character_32)\n          l_value := l_value // 10\n        end\n\n          -- Now put digits in correct order from left to right.\n        from\n          l_ending_index := count - 1\n          l_area := area\n        until\n          l_starting_index >= l_ending_index\n        loop\n          l_temp := l_area.item (l_starting_index)\n          l_area.put (l_area.item (l_ending_index), l_starting_index)\n          l_area.put (l_temp, l_ending_index)\n          l_ending_index := l_ending_index - 1\n          l_starting_index := l_starting_index + 1\n        end\n      end\n    end\n\n  append_real (r: REAL)\n      -- Append the string representation of `r' at end.\n    do\n      append_string_general (r.out)\n    end\n\n  append_double (d: DOUBLE)\n      -- Append the string representation of `d' at end.\n    do\n      append_string_general (d.out)\n    end\n\n  append_character, extend (c: CHARACTER_32)\n      -- Append `c' at end.\n    local\n      current_count: INTEGER\n    do\n      current_count := count\n      if current_count = capacity then\n        resize (current_count + additional_space)\n      end\n      area.put (c, current_count)\n      count := current_count + 1\n      internal_hash_code := 0\n    ensure then\n      item_inserted: item (count) = c\n      new_count: count = old count + 1\n      stable_before: elks_checking implies substring (1, count - 1) ~ (old twin)\n    end\n\n  append_boolean (b: BOOLEAN)\n      -- Append the string representation of `b' at end.\n    do\n      append_string_general (b.out)\n    end\n\n  insert (s: READABLE_STRING_32; i: INTEGER)\n      -- Add `s' to left of position `i' in current string.\n    obsolete\n      \"ELKS 2001: use `insert_string' instead\"\n    require\n      string_exists: s /= Void\n      index_small_enough: i <= count + 1\n      index_large_enough: i > 0\n    do\n      insert_string (s, i)\n    ensure\n      inserted: elks_checking implies\n        (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_string (s: READABLE_STRING_32; i: INTEGER)\n      -- Insert `s' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      string_exists: s /= Void\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_s_count: INTEGER\n      l_area: like area\n    do\n        -- Insert `s' if `s' is not empty, otherwise is useless.\n      l_s_count := s.count\n      if l_s_count /= 0 then\n          -- Resize Current if necessary.\n        new_size := l_s_count + count\n        if new_size > capacity then\n          resize (new_size + additional_space)\n        end\n\n          -- Perform all operations using a zero based arrays.\n        l_area := area\n        pos := i - 1\n\n          -- First shift from `s.count' position all characters starting at index `pos'.\n        l_area.overlapping_move (pos, pos + l_s_count, count - pos)\n\n          -- Copy string `s' at index `pos'.\n        l_area.copy_data (s.area, s.area_lower, pos, l_s_count)\n\n        count := new_size\n        internal_hash_code := 0\n      end\n    ensure\n      inserted: elks_checking implies (Current ~ (old substring (1, i - 1) + old (s.twin) + old substring (i, count)))\n    end\n\n  insert_character (c: CHARACTER_32; i: INTEGER)\n      -- Insert `c' at index `i', shifting characters between ranks\n      -- `i' and `count' rightwards.\n    require\n      valid_insertion_index: 1 <= i and i <= count + 1\n    local\n      pos, new_size: INTEGER\n      l_area: like area\n    do\n        -- Resize Current if necessary.\n      new_size := 1 + count\n      if new_size > capacity then\n        resize (new_size + additional_space)\n      end\n\n        -- Perform all operations using a zero based arrays.\n      pos := i - 1\n      l_area := area\n\n        -- First shift from `s.count' position all characters starting at index `pos'.\n      l_area.overlapping_move (pos, pos + 1, count - pos)\n\n        -- Insert new character\n      l_area.put (c, pos)\n\n      count := new_size\n      internal_hash_code := 0\n    ensure\n      one_more_character: count = old count + 1\n      inserted: item (i) = c\n      stable_before_i: elks_checking implies substring (1, i - 1) ~ (old substring (1, i - 1))\n      stable_after_i: elks_checking implies substring (i + 1, count) ~ (old substring (i, count))\n    end\n\nfeature -- Removal\n\n  remove (i: INTEGER)\n      -- Remove `i'-th character.\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n        -- Shift characters to the left.\n      area.overlapping_move (i, i - 1, l_count - i)\n        -- Update content.\n      count := l_count - 1\n      internal_hash_code := 0\n    end\n\n  remove_head (n: INTEGER)\n      -- Remove first `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    do\n      if n > count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_tail (count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (n.min (count) + 1, count))\n    end\n\n  remove_substring (start_index, end_index: INTEGER)\n      -- Remove all characters from `start_index'\n      -- to `end_index' inclusive.\n    require\n      valid_start_index: 1 <= start_index\n      valid_end_index: end_index <= count\n      meaningful_interval: start_index <= end_index + 1\n    local\n      l_count, nb_removed: INTEGER\n    do\n      nb_removed := end_index - start_index + 1\n      if nb_removed > 0 then\n        l_count := count\n        area.overlapping_move (start_index + nb_removed - 1, start_index - 1, l_count - end_index)\n        count := l_count - nb_removed\n        internal_hash_code := 0\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, start_index - 1) + old substring (end_index + 1, count))\n    end\n\n  remove_tail (n: INTEGER)\n      -- Remove last `n' characters;\n      -- if `n' > `count', remove all.\n    require\n      n_non_negative: n >= 0\n    local\n      l_count: INTEGER\n    do\n      l_count := count\n      if n > l_count then\n        count := 0\n        internal_hash_code := 0\n      else\n        keep_head (l_count - n)\n      end\n    ensure\n      removed: elks_checking implies Current ~ (old substring (1, count - n.min (count)))\n    end\n\n  prune (c: CHARACTER_32)\n      -- Remove first occurrence of `c', if any.\n    require else\n      True\n    local\n      counter: INTEGER\n    do\n      from\n        counter := 1\n      until\n        counter > count or else (item (counter) = c)\n      loop\n        counter := counter + 1\n      end\n      if counter <= count then\n        remove (counter)\n      end\n    end\n\n  prune_all (c: CHARACTER_32)\n      -- Remove all occurrences of `c'.\n    require else\n      True\n    local\n      i, j, nb: INTEGER\n      l_area: like area\n      l_char: CHARACTER_32\n    do\n        -- Traverse string and shift characters to the left\n        -- each time we find an occurrence of `c'.\n      from\n        l_area := area\n        nb := count\n      until\n        i = nb\n      loop\n        l_char := l_area.item (i)\n        if l_char /= c then\n          l_area.put (l_char, j)\n          j := j + 1\n        end\n        i := i + 1\n      end\n      count := j\n      internal_hash_code := 0\n    ensure then\n      changed_count: count = (old count) - (old occurrences (c))\n      -- removed: For every `i' in 1..`count', `item' (`i') /= `c'\n    end\n\n  prune_all_leading (c: CHARACTER_32)\n      -- Remove all leading occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (1) /= c\n      loop\n        remove (1)\n      end\n    end\n\n  prune_all_trailing (c: CHARACTER_32)\n      -- Remove all trailing occurrences of `c'.\n    do\n      from\n      until\n        is_empty or else item (count) /= c\n      loop\n        remove (count)\n      end\n    end\n\n  wipe_out\n      -- Remove all characters.\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure then\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\n  clear_all\n      -- Reset all characters.\n    obsolete\n      \"Use `wipe_out' instead.\"\n    do\n      count := 0\n      internal_hash_code := 0\n    ensure\n      is_empty: count = 0\n      same_capacity: capacity = old capacity\n    end\n\nfeature -- Resizing\n\n  adapt_size\n      -- Adapt the size to accommodate `count' characters.\n    do\n      resize (count)\n    end\n\n  resize (newsize: INTEGER)\n      -- Rearrange string so that it can accommodate\n      -- at least `newsize' characters.\n      -- Do not lose any previously entered character.\n    do\n      area := area.aliased_resized_area_with_default ('%/000/', newsize + 1)\n    end\n\n  grow (newsize: INTEGER)\n      -- Ensure that the capacity is at least `newsize'.\n    do\n      if newsize > capacity then\n        resize (newsize)\n      end\n    end\n\n  trim\n      -- <Precursor>\n    local\n      n: like count\n    do\n      n := count\n      if n < capacity then\n        area := area.aliased_resized_area (n)\n      end\n    ensure then\n      same_string: same_string (old twin)\n    end\n\nfeature -- Conversion\n\n  as_lower: like Current\n      -- New object with all letters in lower case.\n    do\n      Result := twin\n      Result.to_lower\n    end\n\n  as_upper: like Current\n      -- New object with all letters in upper case\n    do\n      Result := twin\n      Result.to_upper\n    end\n\n  left_justify\n      -- Left justify Current using `count' as witdth.\n    local\n      i, nb: INTEGER\n      l_area: like area\n    do\n        -- Remove leading white spaces.\n      nb := count\n      left_adjust\n\n        -- Get new count\n      i := count\n      if i < nb then\n          -- `left_adjust' did remove some characters, so we need to add\n          -- some white spaces at the end of the string.\n        from\n          l_area := area\n        until\n          i = nb\n        loop\n          l_area.put (' ', i)\n          i := i + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    end\n\n  center_justify\n      -- Center justify Current using `count' as width.\n    local\n      i, nb, l_offset: INTEGER\n      left_nb_space, right_nb_space: INTEGER\n      l_area: like area\n      l_prop: like character_properties\n    do\n      l_prop := character_properties\n\n        -- Compute number of spaces at the left of current string.\n      from\n        nb := count\n        l_area := area\n      until\n        left_nb_space = nb or else not l_prop.is_space (l_area.item (left_nb_space))\n      loop\n        left_nb_space := left_nb_space + 1\n      end\n\n        -- Compute number of spaces at the right of current string.\n      from\n        i := nb - 1\n        l_area := area\n      until\n        i = -1 or else not l_prop.is_space (l_area.item (i))\n      loop\n        right_nb_space := right_nb_space + 1\n        i := i - 1\n      end\n\n        -- We encourage that more spaces will be put to the left, when\n        -- number of spaces is not even.\n      l_offset := left_nb_space + right_nb_space\n      if l_offset \\\\ 2 = 0 then\n        l_offset := left_nb_space - l_offset // 2\n      else\n        l_offset := left_nb_space - l_offset // 2 - 1\n      end\n      if l_offset /= 0 then\n          -- Shift characters to the right or left (depending on sign of\n          -- `l_offset' by `l_offset' position.\n        l_area.move_data (left_nb_space, left_nb_space - l_offset,\n          nb - left_nb_space - right_nb_space)\n\n        if l_offset < 0 then\n            -- Fill left part with spaces.\n          l_area.fill_with (' ', left_nb_space, left_nb_space - l_offset - 1)\n        else\n            -- Fill right part with spaces.\n          l_area.fill_with (' ', nb - right_nb_space - l_offset, nb - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  right_justify\n      -- Right justify Current using `count' as width.\n    local\n      i, nb: INTEGER\n      nb_space: INTEGER\n      l_area: like area\n    do\n      nb := count\n      right_adjust\n      i := count\n      nb_space := nb - i\n      if nb_space > 0 then\n          -- Shift characters to the right.\n        from\n          l_area := area\n        until\n          i = 0\n        loop\n          i := i - 1\n          l_area.put (l_area.item (i), i + nb_space)\n        variant\n          i + 1\n        end\n\n          -- Fill left part with spaces.\n        from\n        until\n          nb_space = 0\n        loop\n          nb_space := nb_space - 1\n          l_area.put (' ', nb_space)\n        variant\n          nb_space + 1\n        end\n          -- Restore `count'\n        count := nb\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n    end\n\n  character_justify (pivot: CHARACTER_32; position: INTEGER)\n      -- Justify a string based on a `pivot'\n      -- and the `position' it needs to be in\n      -- the final string.\n      -- This will grow the string if necessary\n      -- to get the pivot in the correct place.\n    require\n      valid_position: position <= capacity\n      positive_position: position >= 1\n      pivot_not_space: pivot /= ' '\n      not_empty: not is_empty\n    local\n      l_index_of_pivot, l_new_size: INTEGER\n      l_area: like area\n    do\n      l_index_of_pivot := index_of (pivot, 1)\n      if l_index_of_pivot /= 0 then\n        if l_index_of_pivot < position then\n            -- We need to resize Current so that we can shift Current by\n            -- `l_index_of_pivot - position'.\n          l_new_size := count + position - l_index_of_pivot\n          grow (l_new_size)\n          l_area := area\n          l_area.move_data (0, position - l_index_of_pivot, count)\n          l_area.fill_with (' ', 0, position - l_index_of_pivot - 1)\n          count := l_new_size\n        else\n            -- Simply shift content to the left and reset trailing with spaces.\n          l_area := area\n          l_area.move_data (l_index_of_pivot - position, 0, count - l_index_of_pivot + position)\n          l_area.fill_with (' ', count - l_index_of_pivot + position, count - 1)\n        end\n        internal_hash_code := 0\n      end\n    end\n\n  to_lower\n      -- Convert to lower case.\n    do\n      to_lower_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_lower)\n    end\n\n  to_upper\n      -- Convert to upper case.\n    do\n      to_upper_area (area, 0, count - 1)\n      internal_hash_code := 0\n    ensure\n      length_and_content: elks_checking implies Current ~ (old as_upper)\n    end\n\n  linear_representation: LINEAR [CHARACTER_32]\n      -- Representation as a linear structure\n    local\n      temp: ARRAYED_LIST [CHARACTER_32]\n      i: INTEGER\n    do\n      create temp.make (capacity)\n      from\n        i := 1\n      until\n        i > count\n      loop\n        temp.extend (item (i))\n        i := i + 1\n      end\n      Result := temp\n    end\n\n  frozen to_c: ANY\n      -- A reference to a C form of current string.\n      -- Useful only for interfacing with C software.\n    require\n      not_is_dotnet: not {PLATFORM}.is_dotnet\n    local\n      l_area: like area\n    do\n      l_area := area\n      l_area.put ('%U', count)\n      Result := l_area\n    end\n\n  mirrored: like Current\n      -- Mirror image of string;\n      -- Result for \"Hello world\" is \"dlrow olleH\".\n    do\n      Result := twin\n      if count > 0 then\n        Result.mirror\n      end\n    end\n\n  mirror\n      -- Reverse the order of characters.\n      -- \"Hello world\" -> \"dlrow olleH\".\n    local\n      a: like area\n      c: CHARACTER_32\n      i, j: INTEGER\n    do\n      if count > 0 then\n        from\n          i := count - 1\n          a := area\n        until\n          i <= j\n        loop\n          c := a.item (i)\n          a.put (a.item (j), i)\n          a.put (c, j)\n          i := i - 1\n          j := j + 1\n        end\n        internal_hash_code := 0\n      end\n    ensure\n      same_count: count = old count\n      -- reversed: For every `i' in 1..`count', `item' (`i') = old `item' (`count'+1-`i')\n    end\n\nfeature -- Duplication\n\n  substring (start_index, end_index: INTEGER): like Current\n      -- Copy of substring containing all characters at indices\n      -- between `start_index' and `end_index'\n    do\n      if (1 <= start_index) and (start_index <= end_index) and (end_index <= count) then\n        Result := new_string (end_index - start_index + 1)\n        Result.area.copy_data (area, start_index - 1, 0, end_index - start_index + 1)\n        Result.set_count (end_index - start_index + 1)\n      else\n        Result := new_string (0)\n      end\n    end\n\n  multiply (n: INTEGER)\n      -- Duplicate a string within itself\n      -- (\"hello\").multiply(3) => \"hellohellohello\"\n    require\n      meaningful_multiplier: n >= 1\n    local\n      s: like Current\n      i: INTEGER\n    do\n      s := twin\n      grow (n * count)\n      from\n        i := n\n      until\n        i = 1\n      loop\n        append (s)\n        i := i - 1\n      end\n    end\n\nfeature {STRING_HANDLER} -- Implementation\n\n  frozen set_count (number: INTEGER)\n      -- Set `count' to `number' of characters.\n    do\n      count := number\n      internal_hash_code := 0\n    end\n\nfeature {NONE} -- Implementation\n\n  new_string (n: INTEGER): like Current\n      -- New instance of current with space for at least `n' characters.\n    do\n      create Result.make (n)\n    end\n\nfeature -- Transformation\n\n  correct_mismatch\n      -- Attempt to correct object mismatch during retrieve using `mismatch_information'.\n    do\n        -- Nothing to be done because we only added `internal_hash_code' that will\n        -- be recomputed next time we query `hash_code'.\n\n        -- In .NET, we have a mismatch that is triggered due to the implementation of\n        -- SPECIAL [CHARACTER_32] as a .NET array of UInt16.\n      if area = Void and then attached {like area} mismatch_information.item (\"area\") as l_area then\n        area := l_area\n      end\n    end\n\ninvariant\n  extendible: extendible\n  compare_character: not object_comparison\n\nnote\n  copyright: \"Copyright (c) 1984-2014, Eiffel Software and others\"\n  license:   \"Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)\"\n  source: \"[\n      Eiffel Software\n      5949 Hollister Ave., Goleta, CA 93117 USA\n      Telephone 805-685-1006, Fax 805-685-6869\n      Website http://www.eiffel.com\n      Customer support http://support.eiffel.com\n    ]\"\n\nend\n"});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFueS5lIiwiaW50ZWdlci5lIiwic3RyaW5nLmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQ0RBO0FDQUEiLCJmaWxlIjoiYnVpbHRpbi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzXG4gIEFOWVxuXG5mZWF0dXJlIC0tIFN0YXR1cyByZXBvcnRcblxuICBjb25mb3Jtc190byAob3RoZXI6IEFOWSk6IEJPT0xFQU5cbiAgICAgIC0tIERvZXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBjb25mb3JtIHRvIHR5cGVcbiAgICAgIC0tIG9mIGBvdGhlcicgKGFzIHBlciBFaWZmZWw6IFRoZSBMYW5ndWFnZSwgY2hhcHRlciAxMyk/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgc2FtZV90eXBlIChvdGhlcjogQU5ZKTogQk9PTEVBTlxuICAgICAgLS0gSXMgdHlwZSBvZiBjdXJyZW50IG9iamVjdCBpZGVudGljYWwgdG8gdHlwZSBvZiBgb3RoZXInP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGNvbmZvcm1zX3RvIChvdGhlcikgYW5kXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLmNvbmZvcm1zX3RvIChDdXJyZW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb21wYXJpc29uXG5cbiAgaXNfZXF1YWwgKG90aGVyOiBsaWtlIEN1cnJlbnQpOiBCT09MRUFOXG4gICAgICAtLSBJcyBgb3RoZXInIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBjb25zaWRlcmVkXG4gICAgICAtLSBlcXVhbCB0byBjdXJyZW50IG9iamVjdD9cbiAgICByZXF1aXJlXG4gICAgICBvdGhlcl9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIgfiBDdXJyZW50XG4gICAgICBjb25zaXN0ZW50OiBzdGFuZGFyZF9pc19lcXVhbCAob3RoZXIpIGltcGxpZXMgUmVzdWx0XG4gICAgZW5kXG5cbiAgZnJvemVuIHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gSXMgYG90aGVyJyBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgLS0gYXMgY3VycmVudCBvYmplY3QsIGFuZCBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgdG8gaXQ/XG4gICAgcmVxdWlyZVxuICAgICAgb3RoZXJfbm90X3ZvaWQ6IG90aGVyIC89IFZvaWRcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX3R5cGU6IFJlc3VsdCBpbXBsaWVzIHNhbWVfdHlwZSAob3RoZXIpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIG90aGVyLnN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICAgIGVuZFxuXG4gIGZyb3plbiBlcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkXG4gICAgICAtLSB0byBvYmplY3RzIGNvbnNpZGVyZWQgZXF1YWw/XG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBzdGFuZGFyZF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkIG9yIGF0dGFjaGVkIHRvXG4gICAgICAtLSBmaWVsZC1ieS1maWVsZCBpZGVudGljYWwgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlP1xuICAgICAgLS0gQWx3YXlzIHVzZXMgZGVmYXVsdCBvYmplY3QgY29tcGFyaXNvbiBjcml0ZXJpb24uXG4gICAgZG9cbiAgICAgIGlmIGEgPSBWb2lkIHRoZW5cbiAgICAgICAgUmVzdWx0IDo9IGIgPSBWb2lkXG4gICAgICBlbHNlXG4gICAgICAgIFJlc3VsdCA6PSBiIC89IFZvaWQgYW5kIHRoZW5cbiAgICAgICAgICAgICAgYS5zdGFuZGFyZF9pc19lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgZGVmaW5pdGlvbjogUmVzdWx0ID0gKGEgPSBWb2lkIGFuZCBiID0gVm9pZCkgb3IgZWxzZVxuICAgICAgICAgICAgKChhIC89IFZvaWQgYW5kIGIgLz0gVm9pZCkgYW5kIHRoZW5cbiAgICAgICAgICAgIGEuc3RhbmRhcmRfaXNfZXF1YWwgKGIpKVxuICAgIGVuZFxuXG4gIGZyb3plbiBpc19kZWVwX2VxdWFsIChvdGhlcjogbGlrZSBDdXJyZW50KTogQk9PTEVBTlxuICAgICAgLS0gQXJlIGBDdXJyZW50JyBhbmQgYG90aGVyJyBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2lzX2VxdWFsIChvdGhlcikgaW1wbGllcyBSZXN1bHRcbiAgICAgIHNhbWVfdHlwZTogUmVzdWx0IGltcGxpZXMgc2FtZV90eXBlIChvdGhlcilcbiAgICAgIHN5bW1ldHJpYzogUmVzdWx0IGltcGxpZXMgb3RoZXIuaXNfZGVlcF9lcXVhbCAoQ3VycmVudClcbiAgICBlbmRcblxuICBmcm96ZW4gZGVlcF9lcXVhbCAoYTogZGV0YWNoYWJsZSBBTlk7IGI6IGxpa2UgYSk6IEJPT0xFQU5cbiAgICAgIC0tIEFyZSBgYScgYW5kIGBiJyBlaXRoZXIgYm90aCB2b2lkXG4gICAgICAtLSBvciBhdHRhY2hlZCB0byBpc29tb3JwaGljIG9iamVjdCBzdHJ1Y3R1cmVzP1xuICAgIGRvXG4gICAgICBpZiBhID0gVm9pZCB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBiID0gVm9pZFxuICAgICAgZWxzZVxuICAgICAgICBSZXN1bHQgOj0gYiAvPSBWb2lkIGFuZCB0aGVuIGEuaXNfZGVlcF9lcXVhbCAoYilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2hhbGxvd19pbXBsaWVzX2RlZXA6IHN0YW5kYXJkX2VxdWFsIChhLCBiKSBpbXBsaWVzIFJlc3VsdFxuICAgICAgYm90aF9vcl9ub25lX3ZvaWQ6IChhID0gVm9pZCkgaW1wbGllcyAoUmVzdWx0ID0gKGIgPSBWb2lkKSlcbiAgICAgIHNhbWVfdHlwZTogKFJlc3VsdCBhbmQgKGEgLz0gVm9pZCkpIGltcGxpZXMgKGIgLz0gVm9pZCBhbmQgdGhlbiBhLnNhbWVfdHlwZSAoYikpXG4gICAgICBzeW1tZXRyaWM6IFJlc3VsdCBpbXBsaWVzIGRlZXBfZXF1YWwgKGIsIGEpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gT3V0cHV0XG5cbiAgaW86IFNURF9GSUxFU1xuICAgICAgLS0gSGFuZGxlIHRvIHN0YW5kYXJkIGZpbGUgc2V0dXBcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5zdXJlXG4gICAgICBpb19ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBvdXQ6IFNUUklOR1xuICAgICAgLS0gTmV3IHN0cmluZyBjb250YWluaW5nIHRlcnNlIHByaW50YWJsZSByZXByZXNlbnRhdGlvblxuICAgICAgLS0gb2YgY3VycmVudCBvYmplY3RcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IHRhZ2dlZF9vdXRcbiAgICBlbnN1cmVcbiAgICAgIG91dF9ub3Rfdm9pZDogUmVzdWx0IC89IFZvaWRcbiAgICBlbmRcblxuICBmcm96ZW4gdGFnZ2VkX291dDogU1RSSU5HXG4gICAgICAtLSBOZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGVyc2UgcHJpbnRhYmxlIHJlcHJlc2VudGF0aW9uXG4gICAgICAtLSBvZiBjdXJyZW50IG9iamVjdFxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbnN1cmVcbiAgICAgIHRhZ2dlZF9vdXRfbm90X3ZvaWQ6IFJlc3VsdCAvPSBWb2lkXG4gICAgZW5kXG5cbiAgcHJpbnQgKG86IGRldGFjaGFibGUgQU5ZKVxuICAgICAgLS0gV3JpdGUgdGVyc2UgZXh0ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYG8nXG4gICAgICAtLSBvbiBzdGFuZGFyZCBvdXRwdXQuXG4gICAgZG9cbiAgICAgIGlmIG8gLz0gVm9pZCB0aGVuXG4gICAgICAgIGlvLnB1dF9zdHJpbmcgKG8ub3V0KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge05PTkV9IC0tIEluaXRpYWxpemF0aW9uXG5cbiAgZGVmYXVsdF9jcmVhdGVcbiAgICAgIC0tIFByb2Nlc3MgaW5zdGFuY2VzIG9mIGNsYXNzZXMgd2l0aCBubyBjcmVhdGlvbiBjbGF1c2UuXG4gICAgICAtLSAoRGVmYXVsdDogZG8gbm90aGluZy4pXG4gICAgZG9cbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG4gIGZyb3plbiBkbG9fbm90aGluZ1xuICAgICAgLS0gRXhlY3V0ZSBhIG51bGwgYWN0aW9uLlxuICAgIGRvXG4gICAgZW5kXG5cbmludmFyaWFudFxuICByZWZsZXhpdmVfZXF1YWxpdHk6IHN0YW5kYXJkX2lzX2VxdWFsIChDdXJyZW50KVxuICByZWZsZXhpdmVfY29uZm9ybWFuY2U6IGNvbmZvcm1zX3RvIChDdXJyZW50KVxuXG5cbmVuZFxuIiwiZXhwYW5kZWQgY2xhc3MgSU5URUdFUl8zMiBpbmhlcml0XG5cbiAgSU5URUdFUl8zMl9SRUZcbiAgICByZWRlZmluZVxuICAgICAgaXNfbGVzcyxcbiAgICAgIHBsdXMsXG4gICAgICBtaW51cyxcbiAgICAgIHByb2R1Y3QsXG4gICAgICBxdW90aWVudCxcbiAgICAgIHBvd2VyLFxuICAgICAgaW50ZWdlcl9xdW90aWVudCxcbiAgICAgIGludGVnZXJfcmVtYWluZGVyLFxuICAgICAgb3Bwb3NpdGUsXG4gICAgICBpZGVudGl0eSxcbiAgICAgIGFzYV9uYXR1cmFsXzgsXG4gICAgICBhc19uYXR1cmFsXzE2LFxuICAgICAgYXNfbmF0dXJhbF8zMixcbiAgICAgIGFzX25hdHVyYWxfNjQsXG4gICAgICBhc19pbnRlZ2VyXzgsXG4gICAgICBhc19pbnRlZ2VyXzE2LFxuICAgICAgYXNfaW50ZWdlcl8zMixcbiAgICAgIGFzX2ludGVnZXJfNjQsXG4gICAgICB0b19yZWFsLFxuICAgICAgdG9fZG91YmxlLFxuICAgICAgdG9fY2hhcmFjdGVyXzgsXG4gICAgICB0b19jaGFyYWN0ZXJfMzIsXG4gICAgICBiaXRfYW5kLFxuICAgICAgYml0X29yLFxuICAgICAgYml0X3hvcixcbiAgICAgIGJpdF9ub3QsXG4gICAgICBiaXRfc2hpZnRfbGVmdCxcbiAgICAgIGJpdF9zaGlmdF9yaWdodFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgZGVmYXVsdF9jcmVhdGUsXG4gIG1ha2VfZnJvbV9yZWZlcmVuY2VcblxuLS0gY29udmVydFxuLS0gICBtYWtlX2Zyb21fcmVmZXJlbmNlICh7SU5URUdFUl8zMl9SRUZ9KSxcbi0tICAgdG9fcmVhbDoge1JFQUxfMzJ9LFxuLS0gICB0b19kb3VibGU6IHtSRUFMXzY0fSxcbi0tICAgdG9faW50ZWdlcl82NDoge0lOVEVHRVJfNjR9XG5cbmZlYXR1cmUgLS0gQ29tcGFyaXNvblxuXG4gIGlzX2xlc3MgYWxpYXMgXCI8XCIgKG90aGVyOiBJTlRFR0VSXzMyKTogQk9PTEVBTlxuICAgICAgLS0gSXMgY3VycmVudCBpbnRlZ2VyIGxlc3MgdGhhbiBgb3RoZXInP1xuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCYXNpYyBvcGVyYXRpb25zXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAob3RoZXI6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTdW0gd2l0aCBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIG1pbnVzIGFsaWFzIFwiLVwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlc3VsdCBvZiBzdWJ0cmFjdGluZyBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHByb2R1Y3QgYWxpYXMgXCIqXCIgKG90aGVyOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gUHJvZHVjdCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHF1b3RpZW50IGFsaWFzIFwiL1wiIChvdGhlcjogSU5URUdFUl8zMik6IFJFQUxfNjRcbiAgICAgIC0tIERpdmlzaW9uIGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgaWRlbnRpdHkgYWxpYXMgXCIrXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IHBsdXNcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgb3Bwb3NpdGUgYWxpYXMgXCItXCI6IElOVEVHRVJfMzJcbiAgICAgIC0tIFVuYXJ5IG1pbnVzXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcXVvdGllbnQgYWxpYXMgXCIvL1wiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEludGVnZXIgZGl2aXNpb24gb2YgQ3VycmVudCBieSBgb3RoZXInXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGludGVnZXJfcmVtYWluZGVyIGFsaWFzIFwiXFxcXFwiIChvdGhlcjogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIFJlbWFpbmRlciBvZiB0aGUgaW50ZWdlciBkaXZpc2lvbiBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgcG93ZXIgYWxpYXMgXCJeXCIgKG90aGVyOiBSRUFMXzY0KTogUkVBTF82NFxuICAgICAgLS0gSW50ZWdlciBwb3dlciBvZiBDdXJyZW50IGJ5IGBvdGhlcidcbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQ29udmVyc2lvblxuXG4gIGFzX25hdHVyYWxfODogTkFUVVJBTF84XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfOCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfbmF0dXJhbF8xNjogTkFUVVJBTF8xNlxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBOQVRVUkFMXzE2IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19uYXR1cmFsXzMyOiBOQVRVUkFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIE5BVFVSQUxfMzIgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX25hdHVyYWxfNjQ6IE5BVFVSQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gTkFUVVJBTF82NCB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl84OiBJTlRFR0VSXzhcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl84IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBhc19pbnRlZ2VyXzE2OiBJTlRFR0VSXzE2XG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGFuIElOVEVHRVJfMTYgdmFsdWUuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGFzX2ludGVnZXJfMzI6IElOVEVHRVJfMzJcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYW4gSU5URUdFUl8zMiB2YWx1ZS5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgYXNfaW50ZWdlcl82NDogSU5URUdFUl82NFxuICAgICAgLS0gQ29udmVydCBgaXRlbScgaW50byBhbiBJTlRFR0VSXzY0IHZhbHVlLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19yZWFsOiBSRUFMXzMyXG4gICAgICAtLSBDb252ZXJ0IGBpdGVtJyBpbnRvIGEgUkVBTF8zMlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICB0b19kb3VibGU6IFJFQUxfNjRcbiAgICAgIC0tIENvbnZlcnQgYGl0ZW0nIGludG8gYSBSRUFMXzY0XG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIHRvX2NoYXJhY3Rlcl84OiBDSEFSQUNURVJfOFxuICAgICAgLS0gQXNzb2NpYXRlZCBjaGFyYWN0ZXIgaW4gOCBiaXQgdmVyc2lvbi5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbiAgdG9fY2hhcmFjdGVyXzMyOiBDSEFSQUNURVJfMzJcbiAgICAgIC0tIEFzc29jaWF0ZWQgY2hhcmFjdGVyIGluIDMyIGJpdCB2ZXJzaW9uLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBCaXQgb3BlcmF0aW9uc1xuXG4gIGJpdF9hbmQgYWxpYXMgXCImXCIgKGk6IElOVEVHRVJfMzIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBCaXR3aXNlIGFuZCBiZXR3ZWVuIEN1cnJlbnQnIGFuZCBgaScuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9vciBhbGlhcyBcInxcIiAoaTogSU5URUdFUl8zMik6IElOVEVHRVJfMzJcbiAgICAgIC0tIEJpdHdpc2Ugb3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfeG9yIChpOiBJTlRFR0VSXzMyKTogSU5URUdFUl8zMlxuICAgICAgLS0gQml0d2lzZSB4b3IgYmV0d2VlbiBDdXJyZW50JyBhbmQgYGknLlxuICAgIGV4dGVybmFsXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICBiaXRfbm90OiBJTlRFR0VSXzMyXG4gICAgICAtLSBPbmUncyBjb21wbGVtZW50IG9mIEN1cnJlbnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9sZWZ0IGFsaWFzIFwifDw8XCIgKG46IElOVEVHRVIpOiBJTlRFR0VSXzMyXG4gICAgICAtLSBTaGlmdCBDdXJyZW50IGZyb20gYG4nIHBvc2l0aW9uIHRvIGxlZnQuXG4gICAgZXh0ZXJuYWxcbiAgICAgIFwiYnVpbHRfaW5cIlxuICAgIGVuZFxuXG4gIGJpdF9zaGlmdF9yaWdodCBhbGlhcyBcInw+PlwiIChuOiBJTlRFR0VSKTogSU5URUdFUl8zMlxuICAgICAgLS0gU2hpZnQgQ3VycmVudCBmcm9tIGBuJyBwb3NpdGlvbiB0byByaWdodC5cbiAgICBleHRlcm5hbFxuICAgICAgXCJidWlsdF9pblwiXG4gICAgZW5kXG5cbmVuZFxuIiwiY2xhc3NcbiAgU1RSSU5HXG5cbmluaGVyaXRcbiAgUkVBREFCTEVfU1RSSU5HXzMyXG4gICAgcmVkZWZpbmVcbiAgICAgIGFyZWFcbiAgICBleHBvcnRcbiAgICAgIHtBTll9IG1ha2UsIG1ha2VfZW1wdHksIG1ha2VfZmlsbGVkLCBtYWtlX2Zyb21fYywgbWFrZV9mcm9tX3N0cmluZywgZmlsbF9jaGFyYWN0ZXJcbiAgICBlbmRcblxuICBTVFJJTkdfR0VORVJBTFxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBoYXMsIGluZGV4X29mLCBsYXN0X2luZGV4X29mLCBvY2N1cnJlbmNlc1xuICAgIHJlZGVmaW5lXG4gICAgICBhcHBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsXG4gICAgcmVuYW1lXG4gICAgICBhcHBlbmQgYXMgYXBwZW5kX3N0cmluZ19nZW5lcmFsLFxuICAgICAgYXBwZW5kX3N1YnN0cmluZyBhcyBhcHBlbmRfc3Vic3RyaW5nX2dlbmVyYWwsXG4gICAgICBwcmVwZW5kIGFzIHByZXBlbmRfc3RyaW5nX2dlbmVyYWwsXG4gICAgICBwcmVwZW5kX3N1YnN0cmluZyBhcyBwcmVwZW5kX3N1YnN0cmluZ19nZW5lcmFsLFxuICAgICAgc2FtZV9zdHJpbmcgYXMgc2FtZV9zdHJpbmdfZ2VuZXJhbCxcbiAgICAgIHNhbWVfY2hhcmFjdGVycyBhcyBzYW1lX2NoYXJhY3RlcnNfZ2VuZXJhbCxcbiAgICAgIHNhbWVfY2FzZWxlc3NfY2hhcmFjdGVycyBhcyBzYW1lX2Nhc2VsZXNzX2NoYXJhY3RlcnNfZ2VuZXJhbCxcbiAgICAgIHN0YXJ0c193aXRoIGFzIHN0YXJ0c193aXRoX2dlbmVyYWwsXG4gICAgICBlbmRzX3dpdGggYXMgZW5kc193aXRoX2dlbmVyYWwsXG4gICAgICBpc19jYXNlX2luc2Vuc2l0aXZlX2VxdWFsIGFzIGlzX2Nhc2VfaW5zZW5zaXRpdmVfZXF1YWxfZ2VuZXJhbFxuICAgIGVuZFxuXG4gIElOREVYQUJMRSBbQ0hBUkFDVEVSXzMyLCBJTlRFR0VSXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0XG4gICAgcmVkZWZpbmVcbiAgICAgIHBydW5lX2FsbCxcbiAgICAgIGNoYW5nZWFibGVfY29tcGFyaXNvbl9jcml0ZXJpb25cbiAgICBlbmRcblxuICBSRVNJWkFCTEUgW0NIQVJBQ1RFUl8zMl1cbiAgICB1bmRlZmluZVxuICAgICAgY29weSwgaXNfZXF1YWwsIG91dFxuICAgIHJlZGVmaW5lXG4gICAgICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uXG4gICAgZW5kXG5cbiAgVE9fU1BFQ0lBTCBbQ0hBUkFDVEVSXzMyXVxuICAgIHVuZGVmaW5lXG4gICAgICBjb3B5LCBpc19lcXVhbCwgb3V0LCBpdGVtLCBhdCwgcHV0LCB2YWxpZF9pbmRleFxuICAgIHJlZGVmaW5lXG4gICAgICBhcmVhXG4gICAgZW5kXG5cbiAgTUlTTUFUQ0hfQ09SUkVDVE9SXG4gICAgdW5kZWZpbmVcbiAgICAgIGNvcHksIGlzX2VxdWFsLCBvdXRcbiAgICByZWRlZmluZVxuICAgICAgY29ycmVjdF9taXNtYXRjaFxuICAgIGVuZFxuXG5jcmVhdGVcbiAgbWFrZSxcbiAgbWFrZV9lbXB0eSxcbiAgbWFrZV9maWxsZWQsXG4gIG1ha2VfZnJvbV9zdHJpbmcsXG4gIG1ha2VfZnJvbV9zdHJpbmdfZ2VuZXJhbCxcbiAgbWFrZV9mcm9tX2MsXG4gIG1ha2VfZnJvbV9jX3BvaW50ZXIsXG4gIG1ha2VfZnJvbV9jaWwsXG4gIG1ha2VfZnJvbV9zZXBhcmF0ZVxuXG5jb252ZXJ0XG4gIHRvX2NpbDoge1NZU1RFTV9TVFJJTkd9LFxuICBtYWtlX2Zyb21fY2lsICh7U1lTVEVNX1NUUklOR30pLFxuICBhc19zdHJpbmdfODoge1JFQURBQkxFX1NUUklOR184LCBTVFJJTkdfOH1cblxuZmVhdHVyZSAtLSBJbml0aWFsaXphdGlvblxuXG4gIG1ha2VfZnJvbV9zdHJpbmdfZ2VuZXJhbCAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpXG4gICAgICAtLSBJbml0aWFsaXplIGZyb20gdGhlIGNoYXJhY3RlcnMgb2YgYHMnLlxuICAgIGRvXG4gICAgICBpZiBhdHRhY2hlZCB7UkVBREFCTEVfU1RSSU5HXzMyfSBzIGFzIHMzMiB0aGVuXG4gICAgICAgIG1ha2VfZnJvbV9zdHJpbmcgKHMzMilcbiAgICAgIGVsc2VcbiAgICAgICAgbWFrZSAocy5jb3VudClcbiAgICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWFrZV9mcm9tX2NpbCAoYV9zeXN0ZW1fc3RyaW5nOiBkZXRhY2hhYmxlIFNZU1RFTV9TVFJJTkcpXG4gICAgICAtLSBJbml0aWFsaXplIEN1cnJlbnQgd2l0aCBgYV9zeXN0ZW1fc3RyaW5nJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBpZiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gYV9zeXN0ZW1fc3RyaW5nLmxlbmd0aCArIGRvdG5ldF9jb252ZXJ0b3IuZXNjYXBlX2NvdW50IChhX3N5c3RlbV9zdHJpbmcpXG4gICAgICBlbmRcbiAgICAgIG1ha2UgKGxfY291bnQpXG4gICAgICBpZiBsX2NvdW50ID4gMCBhbmQgdGhlbiBhX3N5c3RlbV9zdHJpbmcgLz0gVm9pZCB0aGVuXG4gICAgICAgIHNldF9jb3VudCAobF9jb3VudClcbiAgICAgICAgZG90bmV0X2NvbnZlcnRvci5yZWFkX3N5c3RlbV9zdHJpbmdfaW50byAoYV9zeXN0ZW1fc3RyaW5nLCBDdXJyZW50KVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgZnJvbV9jIChjX3N0cmluZzogUE9JTlRFUilcbiAgICAgIC0tIFJlc2V0IGNvbnRlbnRzIG9mIHN0cmluZyBmcm9tIGNvbnRlbnRzIG9mIGBjX3N0cmluZycsXG4gICAgICAtLSBhIHN0cmluZyBjcmVhdGVkIGJ5IHNvbWUgQyBmdW5jdGlvbi5cbiAgICByZXF1aXJlXG4gICAgICBjX3N0cmluZ19leGlzdHM6IGNfc3RyaW5nIC89IGRlZmF1bHRfcG9pbnRlclxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyIChjX3N0cmluZylcbiAgICAgICAgLS0gUmVzaXplIHN0cmluZyBpbiBjYXNlIGl0IGlzIG5vdCBiaWcgZW5vdWdoXG4gICAgICBsX2NvdW50IDo9IGNfc3RyaW5nX3Byb3ZpZGVyLmNvdW50XG4gICAgICBncm93IChsX2NvdW50ICsgMSlcbiAgICAgIGNvdW50IDo9IGxfY291bnRcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBjX3N0cmluZ19wcm92aWRlci5yZWFkX3N0cmluZ19pbnRvIChDdXJyZW50KVxuICAgIGVuc3VyZVxuICAgICAgbm9femVyb19ieXRlOiBub3QgaGFzICgnJS8wLycpXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgICAtLSBjb3JyZWN0X2NvdW50OiB0aGUgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyBjb3VudFxuICAgICAgLS0gICAgICAgaXMgTlVMTFxuICAgIGVuZFxuXG4gIGZyb21fY19zdWJzdHJpbmcgKGNfc3RyaW5nOiBQT0lOVEVSOyBzdGFydF9wb3MsIGVuZF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBSZXNldCBjb250ZW50cyBvZiBzdHJpbmcgZnJvbSBzdWJzdHJpbmcgb2YgYGNfc3RyaW5nJyxcbiAgICAgIC0tIGEgc3RyaW5nIGNyZWF0ZWQgYnkgc29tZSBDIGZ1bmN0aW9uLlxuICAgIHJlcXVpcmVcbiAgICAgIGNfc3RyaW5nX2V4aXN0czogY19zdHJpbmcgLz0gZGVmYXVsdF9wb2ludGVyXG4gICAgICBzdGFydF9wb3NpdGlvbl9iaWdfZW5vdWdoOiBzdGFydF9wb3MgPj0gMVxuICAgICAgZW5kX3Bvc2l0aW9uX2JpZ19lbm91Z2g6IHN0YXJ0X3BvcyA8PSBlbmRfcG9zICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDFcbiAgICAgIGNfc3RyaW5nX3Byb3ZpZGVyLnNldF9zaGFyZWRfZnJvbV9wb2ludGVyX2FuZF9jb3VudCAoY19zdHJpbmcgKyAoc3RhcnRfcG9zIC0gMSksIGxfY291bnQpXG4gICAgICAgIC0tIFJlc2l6ZSBzdHJpbmcgaW4gY2FzZSBpdCBpcyBub3QgYmlnIGVub3VnaFxuICAgICAgZ3JvdyAobF9jb3VudCArIDEpXG4gICAgICBjb3VudCA6PSBsX2NvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgY19zdHJpbmdfcHJvdmlkZXIucmVhZF9zdWJzdHJpbmdfaW50byAoQ3VycmVudCwgMSwgbF9jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIHZhbGlkX2NvdW50OiBjb3VudCA9IGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxXG4gICAgICAtLSBjaGFyYWN0ZXJzOiBmb3IgYWxsIGkgaW4gMS4uY291bnQsIGl0ZW0gKGkpIGVxdWFsc1xuICAgICAgLS0gICAgICAgQVNDSUkgY2hhcmFjdGVyIGF0IGFkZHJlc3MgY19zdHJpbmcgKyAoaSAtIDEpXG4gICAgZW5kXG5cbiAgYWRhcHQgKHM6IFNUUklOR18zMik6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gT2JqZWN0IG9mIGEgdHlwZSBjb25mb3JtaW5nIHRvIHRoZSB0eXBlIG9mIGBzJyxcbiAgICAgIC0tIGluaXRpYWxpemVkIHdpdGggYXR0cmlidXRlcyBmcm9tIGBzJ1xuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gbmV3X3N0cmluZyAoMClcbiAgICAgIFJlc3VsdC5zaGFyZSAocylcbiAgICBlbnN1cmVcbiAgICAgIGFkYXB0X25vdF92b2lkOiBSZXN1bHQgLz0gVm9pZFxuICAgICAgc2hhcmVkX2ltcGxlbWVudGF0aW9uOiBSZXN1bHQuc2hhcmVkX3dpdGggKHMpXG4gICAgZW5kXG5cbiAgcmVtYWtlIChuOiBJTlRFR0VSKVxuICAgICAgLS0gQWxsb2NhdGUgc3BhY2UgZm9yIGF0IGxlYXN0IGBuJyBjaGFyYWN0ZXJzLlxuICAgIG9ic29sZXRlXG4gICAgICBcIlVzZSBgbWFrZScgaW5zdGVhZFwiXG4gICAgcmVxdWlyZVxuICAgICAgbm9uX25lZ2F0aXZlX3NpemU6IG4gPj0gMFxuICAgIGRvXG4gICAgICBtYWtlIChuKVxuICAgIGVuc3VyZVxuICAgICAgZW1wdHlfc3RyaW5nOiBjb3VudCA9IDBcbiAgICAgIGFyZWFfYWxsb2NhdGVkOiBjYXBhY2l0eSA+PSBuXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gQWNjZXNzXG5cbiAgaXRlbSBhbGlhcyBcIltdXCIsIGF0IGFsaWFzIFwiQFwiIChpOiBJTlRFR0VSKTogQ0hBUkFDVEVSXzMyIGFzc2lnbiBwdXRcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpXG4gICAgZW5kXG5cbiAgY29kZSAoaTogSU5URUdFUik6IE5BVFVSQUxfMzJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IGFyZWEuaXRlbSAoaSAtIDEpLmNvZGUudG9fbmF0dXJhbF8zMlxuICAgIGVuZFxuXG4gIGl0ZW1fY29kZSAoaTogSU5URUdFUik6IElOVEVHRVJcbiAgICAgIC0tIENoYXJhY3RlciBhdCBwb3NpdGlvbiBgaSdcbiAgICBvYnNvbGV0ZVxuICAgICAgXCJEdWUgdG8gcG90ZW50aWFsIHRydW5jYXRpb24gaXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlIGBjb2RlIChpKScgaW5zdGVhZC5cIlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gYXJlYS5pdGVtIChpIC0gMSkubmF0dXJhbF8zMl9jb2RlLmFzX2ludGVnZXJfMzJcbiAgICBlbmRcblxuICBhcmVhOiBTUEVDSUFMIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBTdG9yYWdlIGZvciBjaGFyYWN0ZXJzXG5cbmZlYXR1cmUgLS0gU3RhdHVzIHJlcG9ydFxuXG4gIGV4dGVuZGlibGU6IEJPT0xFQU4gPSBUcnVlXG4gICAgICAtLSBNYXkgbmV3IGl0ZW1zIGJlIGFkZGVkPyAoQW5zd2VyOiB5ZXMuKVxuXG4gIHBydW5hYmxlOiBCT09MRUFOXG4gICAgICAtLSBNYXkgaXRlbXMgYmUgcmVtb3ZlZD8gKEFuc3dlcjogeWVzLilcbiAgICBkb1xuICAgICAgUmVzdWx0IDo9IFRydWVcbiAgICBlbmRcblxuICBjaGFuZ2VhYmxlX2NvbXBhcmlzb25fY3JpdGVyaW9uOiBCT09MRUFOID0gRmFsc2VcblxuZmVhdHVyZSAtLSBFbGVtZW50IGNoYW5nZVxuXG4gIHNldCAodDogUkVBREFCTEVfU1RSSU5HXzMyOyBuMSwgbjI6IElOVEVHRVIpXG4gICAgICAtLSBTZXQgY3VycmVudCBzdHJpbmcgdG8gc3Vic3RyaW5nIG9mIGB0JyBmcm9tIGluZGljZXMgYG4xJ1xuICAgICAgLS0gdG8gYG4yJywgb3IgdG8gZW1wdHkgc3RyaW5nIGlmIG5vIHN1Y2ggc3Vic3RyaW5nLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiB0IC89IFZvaWRcbiAgICBsb2NhbFxuICAgICAgczogUkVBREFCTEVfU1RSSU5HXzMyXG4gICAgZG9cbiAgICAgIHMgOj0gdC5zdWJzdHJpbmcgKG4xLCBuMilcbiAgICAgIGFyZWEgOj0gcy5hcmVhXG4gICAgICBjb3VudCA6PSBzLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgaXNfc3Vic3RyaW5nOiBzYW1lX3N0cmluZyAodC5zdWJzdHJpbmcgKG4xLCBuMikpXG4gICAgZW5kXG5cbiAgc3ViY29weSAob3RoZXI6IFJFQURBQkxFX1NUUklOR18zMjsgc3RhcnRfcG9zLCBlbmRfcG9zLCBpbmRleF9wb3M6IElOVEVHRVIpXG4gICAgICAtLSBDb3B5IGNoYXJhY3RlcnMgb2YgYG90aGVyJyB3aXRoaW4gYm91bmRzIGBzdGFydF9wb3MnIGFuZFxuICAgICAgLS0gYGVuZF9wb3MnIHRvIGN1cnJlbnQgc3RyaW5nIHN0YXJ0aW5nIGF0IGluZGV4IGBpbmRleF9wb3MnLlxuICAgIHJlcXVpcmVcbiAgICAgIG90aGVyX25vdF92b2lkOiBvdGhlciAvPSBWb2lkXG4gICAgICB2YWxpZF9zdGFydF9wb3M6IG90aGVyLnZhbGlkX2luZGV4IChzdGFydF9wb3MpXG4gICAgICB2YWxpZF9lbmRfcG9zOiBvdGhlci52YWxpZF9pbmRleCAoZW5kX3BvcylcbiAgICAgIHZhbGlkX2JvdW5kczogKHN0YXJ0X3BvcyA8PSBlbmRfcG9zKSBvciAoc3RhcnRfcG9zID0gZW5kX3BvcyArIDEpXG4gICAgICB2YWxpZF9pbmRleF9wb3M6IHZhbGlkX2luZGV4IChpbmRleF9wb3MpXG4gICAgICBlbm91Z2hfc3BhY2U6IChjb3VudCAtIGluZGV4X3BvcykgPj0gKGVuZF9wb3MgLSBzdGFydF9wb3MpXG4gICAgbG9jYWxcbiAgICAgIGxfb3RoZXJfYXJlYSwgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgZW5kX3BvcyA+PSBzdGFydF9wb3MgdGhlblxuICAgICAgICBsX290aGVyX2FyZWEgOj0gb3RoZXIuYXJlYVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICBpZiBsX2FyZWEgLz0gbF9vdGhlcl9hcmVhIHRoZW5cbiAgICAgICAgICBsX2FyZWEuY29weV9kYXRhIChsX290aGVyX2FyZWEsIHN0YXJ0X3BvcyAtIDEsIGluZGV4X3BvcyAtIDEsXG4gICAgICAgICAgICBlbmRfcG9zIC0gc3RhcnRfcG9zICsgMSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9wb3MgLSAxLCBpbmRleF9wb3MgLSAxLFxuICAgICAgICAgICAgZW5kX3BvcyAtIHN0YXJ0X3BvcyArIDEpXG4gICAgICAgIGVuZFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBzYW1lX2NvdW50OiBjb3VudCA9IG9sZCBjb3VudFxuICAgICAgY29waWVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXNcbiAgICAgICAgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaW5kZXhfcG9zIC0gMSkgK1xuICAgICAgICBvbGQgb3RoZXIuc3Vic3RyaW5nIChzdGFydF9wb3MsIGVuZF9wb3MpICtcbiAgICAgICAgb2xkIHN1YnN0cmluZyAoaW5kZXhfcG9zICsgKGVuZF9wb3MgLSBzdGFydF9wb3MgKyAxKSwgY291bnQpKSlcbiAgICBlbmRcblxuICByZXBsYWNlX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVwbGFjZSBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4JyB0byBgZW5kX2luZGV4JyB3aXRoIGBzJy5cbiAgICByZXF1aXJlXG4gICAgICBzdHJpbmdfbm90X3ZvaWQ6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfc3RhcnRfaW5kZXg6IDEgPD0gc3RhcnRfaW5kZXhcbiAgICAgIHZhbGlkX2VuZF9pbmRleDogZW5kX2luZGV4IDw9IGNvdW50XG4gICAgICBtZWFuaW5nZnVsbF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgZGlmZjogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIHNfY291bnQ6IElOVEVHRVJcbiAgICAgIG9sZF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBzX2NvdW50IDo9IHMuY291bnRcbiAgICAgIG9sZF9jb3VudCA6PSBjb3VudFxuICAgICAgZGlmZiA6PSBzX2NvdW50IC0gKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIG5ld19zaXplIDo9IGRpZmYgKyBvbGRfY291bnRcbiAgICAgIGlmIGRpZmYgPiAwIHRoZW5cbiAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSB0aGUgc3RyaW5nLlxuICAgICAgICBncm93IChuZXdfc2l6ZSlcbiAgICAgIGVuZFxuXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICAtLXwgV2UgbW92ZSB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgZm9yd2FyZCAoaWYgZGlmZiBpcyA+IDApLCBiYWNrd2FyZCAoaWYgZGlmZiA8IDApLFxuICAgICAgICAtLXwgYW5kIG5vdGhpbmcgb3RoZXJ3aXNlLlxuICAgICAgaWYgZGlmZiAvPSAwIHRoZW5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKGVuZF9pbmRleCwgZW5kX2luZGV4ICsgZGlmZiwgb2xkX2NvdW50IC0gZW5kX2luZGV4KVxuICAgICAgZW5kXG4gICAgICAgIC0tfCBTZXQgbmV3IGNvdW50XG4gICAgICBzZXRfY291bnQgKG5ld19zaXplKVxuICAgICAgICAtLXwgV2UgY29weSB0aGUgc3Vic3RyaW5nLlxuICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHN0YXJ0X2luZGV4IC0gMSwgc19jb3VudClcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudCAtIGVuZF9pbmRleCArIHN0YXJ0X2luZGV4IC0gMVxuICAgICAgcmVwbGFjZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgKHN1YnN0cmluZyAoMSwgc3RhcnRfaW5kZXggLSAxKSArXG4gICAgICAgICAgcyArIHN1YnN0cmluZyAoZW5kX2luZGV4ICsgMSwgY291bnQpKSkpXG4gICAgZW5kXG5cbiAgcmVwbGFjZV9zdWJzdHJpbmdfYWxsIChvcmlnaW5hbCwgbmV3OiBSRUFEQUJMRV9TVFJJTkdfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IG9jY3VycmVuY2Ugb2YgYG9yaWdpbmFsJyB3aXRoIGBuZXcnLlxuICAgIHJlcXVpcmVcbiAgICAgIG9yaWdpbmFsX2V4aXN0czogb3JpZ2luYWwgLz0gVm9pZFxuICAgICAgbmV3X2V4aXN0czogbmV3IC89IFZvaWRcbiAgICAgIG9yaWdpbmFsX25vdF9lbXB0eTogbm90IG9yaWdpbmFsLmlzX2VtcHR5XG4gICAgZXh0ZXJuXG4gICAgICBcImJ1aWx0X2luXCJcbiAgICBlbmRcblxuICByZXBsYWNlX2JsYW5rXG4gICAgICAtLSBSZXBsYWNlIGFsbCBjdXJyZW50IGNoYXJhY3RlcnMgd2l0aCBibGFua3MuXG4gICAgZG9cbiAgICAgIGZpbGxfd2l0aCAoJyAnKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBvbGQgY291bnQpIGFuZCAoY2FwYWNpdHkgPSBvbGQgY2FwYWNpdHkpXG4gICAgICBhbGxfYmxhbms6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBvY2N1cnJlbmNlcyAoJyAnKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgZmlsbF9ibGFua1xuICAgICAgLS0gRmlsbCB3aXRoIGBjYXBhY2l0eScgYmxhbmsgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgZmlsbF9jaGFyYWN0ZXIgKCcgJylcbiAgICBlbnN1cmVcbiAgICAgIGZpbGxlZDogZnVsbFxuICAgICAgc2FtZV9zaXplOiAoY291bnQgPSBjYXBhY2l0eSkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIC0tIGFsbF9ibGFuazogRm9yIGV2ZXJ5IGBpJyBpbiBgY291bnQnLi5gY2FwYWNpdHknLCBgaXRlbScgKGBpJykgPSBgQmxhbmsnXG4gICAgZW5kXG5cbiAgZmlsbF93aXRoIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZXBsYWNlIGV2ZXJ5IGNoYXJhY3RlciB3aXRoIGBjJy5cbiAgICBsb2NhbFxuICAgICAgbF9jb3VudDogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICBpZiBsX2NvdW50IC89IDAgdGhlblxuICAgICAgICBhcmVhLmZpbGxfd2l0aCAoYywgMCwgbF9jb3VudCAtIDEpXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IChjb3VudCA9IG9sZCBjb3VudCkgYW5kIChjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eSlcbiAgICAgIGZpbGxlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIG9jY3VycmVuY2VzIChjKSA9IGNvdW50XG4gICAgZW5kXG5cbiAgcmVwbGFjZV9jaGFyYWN0ZXIgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIFJlcGxhY2UgZXZlcnkgY2hhcmFjdGVyIHdpdGggYGMnLlxuICAgIG9ic29sZXRlXG4gICAgICBcIkVMS1MgMjAwMTogdXNlIGBmaWxsX3dpdGgnIGluc3RlYWQnXCJcbiAgICBkb1xuICAgICAgZmlsbF93aXRoIChjKVxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogKGNvdW50ID0gb2xkIGNvdW50KSBhbmQgKGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5KVxuICAgICAgZmlsbGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgb2NjdXJyZW5jZXMgKGMpID0gY291bnRcbiAgICBlbmRcblxuICBrZWVwX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMgZXhjZXB0IGZvciB0aGUgZmlyc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBkb1xuICAgICAgaWYgbiA8IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gblxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAga2VlcF90YWlsIChuOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGV4Y2VwdCBmb3IgdGhlIGxhc3QgYG4nO1xuICAgICAgLS0gZG8gbm90aGluZyBpZiBgbicgPj0gYGNvdW50Jy5cbiAgICBsb2NhbFxuICAgICAgbmI6IGxpa2UgY291bnRcbiAgICBkb1xuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGlmIG4gPCBuYiB0aGVuXG4gICAgICAgIGFyZWEub3ZlcmxhcHBpbmdfbW92ZSAobmIgLSBuLCAwLCBuKVxuICAgICAgICBjb3VudCA6PSBuXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBsZWZ0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICBsb2NhbFxuICAgICAgbmIsIG5iX3NwYWNlOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuXG4gICAgICAgIC0tIENvbXB1dGUgbnVtYmVyIG9mIHNwYWNlcyBhdCB0aGUgbGVmdCBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIGZyb21cbiAgICAgICAgbmIgOj0gY291bnQgLSAxXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICB1bnRpbFxuICAgICAgICBuYl9zcGFjZSA+IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKG5iX3NwYWNlKSlcbiAgICAgIGxvb3BcbiAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTZXQgbmV3IGNvdW50IHZhbHVlLlxuICAgICAgICBuYiA6PSBuYiArIDEgLSBuYl9zcGFjZVxuICAgICAgICAgIC0tIFNoaWZ0IGNoYXJhY3RlcnMgdG8gdGhlIGxlZnQuXG4gICAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChuYl9zcGFjZSwgMCwgbmIpXG4gICAgICAgICAgLS0gU2V0IG5ldyBjb3VudC5cbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2FkanVzdFxuICAgICAgLS0gUmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gICAgbG9jYWxcbiAgICAgIGksIG5iOiBJTlRFR0VSXG4gICAgICBuYl9zcGFjZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICAgIGM6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9wcm9wOiBsaWtlIGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG4gICAgZG9cbiAgICAgIGxfcHJvcCA6PSBjaGFyYWN0ZXJfcHJvcGVydGllc1xuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudCAtIDFcbiAgICAgICAgaSA6PSBuYlxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA8IDBcbiAgICAgIGxvb3BcbiAgICAgICAgYyA6PSBsX2FyZWEuaXRlbSAoaSlcbiAgICAgICAgaWYgbm90IGxfcHJvcC5pc19zcGFjZSAoYykgdGhlblxuICAgICAgICAgICAgLS0gV2UgYXJlIGRvbmUuXG4gICAgICAgICAgaSA6PSAtMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbmJfc3BhY2UgOj0gbmJfc3BhY2UgKyAxXG4gICAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuXG4gICAgICBpZiBuYl9zcGFjZSA+IDAgdGhlblxuICAgICAgICAgIC0tIFNldCBuZXcgY291bnQuXG4gICAgICAgIGNvdW50IDo9IG5iICsgMSAtIG5iX3NwYWNlXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBzaGFyZSAob3RoZXI6IFNUUklOR18zMilcbiAgICAgIC0tIE1ha2UgY3VycmVudCBzdHJpbmcgc2hhcmUgdGhlIHRleHQgb2YgYG90aGVyJy5cbiAgICAgIC0tIFN1YnNlcXVlbnQgY2hhbmdlcyB0byB0aGUgY2hhcmFjdGVycyBvZiBjdXJyZW50IHN0cmluZ1xuICAgICAgLS0gd2lsbCBhbHNvIGFmZmVjdCBgb3RoZXInLCBhbmQgY29udmVyc2VseS5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogb3RoZXIgLz0gVm9pZFxuICAgIGRvXG4gICAgICBhcmVhIDo9IG90aGVyLmFyZWFcbiAgICAgIGNvdW50IDo9IG90aGVyLmNvdW50XG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgc2hhcmVkX2NvdW50OiBvdGhlci5jb3VudCA9IGNvdW50XG4gICAgICBzaGFyZWRfYXJlYTogb3RoZXIuYXJlYSA9IGFyZWFcbiAgICBlbmRcblxuICBwdXQgKGM6IENIQVJBQ1RFUl8zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIFJlcGxhY2UgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIGBpJyBieSBgYycuXG4gICAgZG9cbiAgICAgIGFyZWEucHV0IChjLCBpIC0gMSlcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIHN0YWJsZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGkgKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcHV0X2NvZGUgKHY6IE5BVFVSQUxfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBSZXBsYWNlIGNoYXJhY3RlciBhdCBwb3NpdGlvbiBgaScgYnkgY2hhcmFjdGVyIG9mIGNvZGUgYHYnLlxuICAgIGRvXG4gICAgICBhcmVhLnB1dCAodi50b19jaGFyYWN0ZXJfMzIsIGkgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIFByZXBlbmQgY2hhcmFjdGVycyBvZiBgcycgYXQgZnJvbnQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBwcmVwZW5kIChsX3MzMilcbiAgICAgIGVsc2VcbiAgICAgICAgUHJlY3Vyc29yIHtTVFJJTkdfR0VORVJBTH0gKHMpXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBwcmVjZWRlLCBwcmVwZW5kX2NoYXJhY3RlciAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gQWRkIGBjJyBhdCBmcm9udC5cbiAgICBsb2NhbFxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY291bnQgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgZW5kXG4gICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKDAsIDEsIGNvdW50KVxuICAgICAgbF9hcmVhLnB1dCAoYywgMClcbiAgICAgIGNvdW50IDo9IGNvdW50ICsgMVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgZW5kXG5cbiAgcHJlcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBmcm9udC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgZG9cbiAgICAgIGluc2VydF9zdHJpbmcgKHMsIDEpXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIChjb3VudCArIHMuY291bnQpXG4gICAgICBpbnNlcnRlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIHNhbWVfc3RyaW5nIChvbGQgKHMgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCknIGF0IGZyb250LlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgICAgLS0gUmVzaXplIEN1cnJlbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBuZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBjb3VudFxuICAgICAgICBpZiBuZXdfc2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBQZXJmb3JtIGFsbCBvcGVyYXRpb25zIHVzaW5nIGEgemVybyBiYXNlZCBhcnJheXMuXG4gICAgICAgIGxfYXJlYSA6PSBhcmVhXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBvZiBjdXJyZW50LlxuICAgICAgICBsX2FyZWEub3ZlcmxhcHBpbmdfbW92ZSAoMCwgbF9zX2NvdW50LCBjb3VudClcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBiZWdpbm5pbmcuXG4gICAgICAgIGxfYXJlYS5jb3B5X2RhdGEgKHMuYXJlYSwgcy5hcmVhX2xvd2VyICsgc3RhcnRfaW5kZXggLSAxLCAwLCBsX3NfY291bnQpXG5cbiAgICAgICAgY291bnQgOj0gbmV3X3NpemVcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgbmV3X2NvdW50OiBjb3VudCA9IG9sZCBjb3VudCArIGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChzLnN1YnN0cmluZyAoc3RhcnRfaW5kZXgsIGVuZF9pbmRleCkgKyBDdXJyZW50KSlcbiAgICBlbmRcblxuICBwcmVwZW5kX2Jvb2xlYW4gKGI6IEJPT0xFQU4pXG4gICAgICAtLSBQcmVwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBwcmVwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBwcmVwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBkJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoZC5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9pbnRlZ2VyIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoaS5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9yZWFsIChyOiBSRUFMKVxuICAgICAgLS0gUHJlcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBmcm9udC5cbiAgICBkb1xuICAgICAgcHJlcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgcHJlcGVuZF9zdHJpbmcgKHM6IGRldGFjaGFibGUgUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gUHJlcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJywgaWYgbm90IHZvaWQsIGF0IGZyb250LlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBwcmVwZW5kIChzKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChzOiBSRUFEQUJMRV9TVFJJTkdfR0VORVJBTClcbiAgICAgIC0tIEFwcGVuZCBjaGFyYWN0ZXJzIG9mIGBzJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGlmIGF0dGFjaGVkIHtSRUFEQUJMRV9TVFJJTkdfMzJ9IHMgYXMgbF9zMzIgdGhlblxuICAgICAgICBhcHBlbmQgKGxfczMyKVxuICAgICAgZWxzZVxuICAgICAgICBQcmVjdXJzb3Ige1NUUklOR19HRU5FUkFMfSAocylcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZCAoczogUkVBREFCTEVfU1RSSU5HXzMyKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMnIGF0IGVuZC5cbiAgICByZXF1aXJlXG4gICAgICBhcmd1bWVudF9ub3Rfdm9pZDogcyAvPSBWb2lkXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQsIGxfc19jb3VudCwgbF9uZXdfc2l6ZTogSU5URUdFUlxuICAgIGRvXG4gICAgICBsX3NfY291bnQgOj0gcy5jb3VudFxuICAgICAgaWYgbF9zX2NvdW50ID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgbF9uZXdfc2l6ZSA6PSBsX3NfY291bnQgKyBsX2NvdW50XG4gICAgICAgIGlmIGxfbmV3X3NpemUgPiBjYXBhY2l0eSB0aGVuXG4gICAgICAgICAgcmVzaXplIChsX25ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgICAgZW5kXG4gICAgICAgIGFyZWEuY29weV9kYXRhIChzLmFyZWEsIHMuYXJlYV9sb3dlciwgbF9jb3VudCwgbF9zX2NvdW50KVxuICAgICAgICBjb3VudCA6PSBsX25ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyBvbGQgcy5jb3VudFxuICAgICAgYXBwZW5kZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBzYW1lX3N0cmluZyAob2xkIChDdXJyZW50ICsgcykpXG4gICAgZW5kXG5cbiAgYXBwZW5kX3N1YnN0cmluZyAoczogUkVBREFCTEVfU1RSSU5HXzMyOyBzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gQXBwZW5kIGNoYXJhY3RlcnMgb2YgYHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KScgYXQgZW5kLlxuICAgIHJlcXVpcmVcbiAgICAgIGFyZ3VtZW50X25vdF92b2lkOiBzIC89IFZvaWRcbiAgICAgIHN0YXJ0X2luZGV4X3ZhbGlkOiBzdGFydF9pbmRleCA+PSAxXG4gICAgICBlbmRfaW5kZXhfdmFsaWQ6IGVuZF9pbmRleCA8PSBzLmNvdW50XG4gICAgICB2YWxpZF9ib3VuZHM6IHN0YXJ0X2luZGV4IDw9IGVuZF9pbmRleCArIDFcbiAgICBsb2NhbFxuICAgICAgbF9jb3VudCwgbF9zX2NvdW50LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfc19jb3VudCA6PSBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDFcbiAgICAgIGlmIGxfc19jb3VudCA+IDAgdGhlblxuICAgICAgICBsX2NvdW50IDo9IGNvdW50XG4gICAgICAgIGxfbmV3X3NpemUgOj0gbF9zX2NvdW50ICsgbF9jb3VudFxuICAgICAgICBpZiBsX25ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobF9uZXdfc2l6ZSArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICAgIGVuZFxuICAgICAgICBhcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIgKyBzdGFydF9pbmRleCAtIDEsIGxfY291bnQsIGxfc19jb3VudClcbiAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICBuZXdfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50ICsgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGFwcGVuZGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc2FtZV9zdHJpbmcgKG9sZCAoQ3VycmVudCArIHMuc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4KSkpXG4gICAgZW5kXG5cbiAgcGx1cyBhbGlhcyBcIitcIiAoczogUkVBREFCTEVfU1RSSU5HX0dFTkVSQUwpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIDxQcmVjdXJzb3I+XG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChjb3VudCArIHMuY291bnQpXG4gICAgICBSZXN1bHQuYXBwZW5kIChDdXJyZW50KVxuICAgICAgUmVzdWx0LmFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAocylcbiAgICBlbmRcblxuICBhcHBlbmRfc3RyaW5nIChzOiBkZXRhY2hhYmxlIFJFQURBQkxFX1NUUklOR18zMilcbiAgICAgIC0tIEFwcGVuZCBhIGNvcHkgb2YgYHMnLCBpZiBub3Qgdm9pZCwgYXQgZW5kLlxuICAgIGRvXG4gICAgICBpZiBzIC89IFZvaWQgdGhlblxuICAgICAgICBhcHBlbmQgKHMpXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGFwcGVuZGVkOiBzIC89IFZvaWQgaW1wbGllc1xuICAgICAgICAoZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHR3aW4gKyBvbGQgcy50d2luKSlcbiAgICBlbmRcblxuICBhcHBlbmRfaW50ZWdlciAoaTogSU5URUdFUilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IElOVEVHRVJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnLScpXG4gICAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgICAgICAgIC0tIFNwZWNpYWwgY2FzZSBmb3IgbWluaW11bSBpbnRlZ2VyIHZhbHVlIGFzIG5lZ2F0aW5nIGl0XG4gICAgICAgICAgICAgIC0tIGFzIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIGlmIGkgPSB7SU5URUdFUn0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfOCAoaTogSU5URUdFUl84KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl84XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfOH0uTWluX3ZhbHVlIHRoZW5cbiAgICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzgnKVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC0oaSAvLyAxMClcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtaVxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgbF92YWx1ZSA6PSBpXG4gICAgICAgICAgZW5kXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF92YWx1ZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCgobF92YWx1ZSBcXFxcIDEwKSsgNDgpLnRvX2NoYXJhY3Rlcl8zMilcbiAgICAgICAgICBsX3ZhbHVlIDo9IGxfdmFsdWUgLy8gMTBcbiAgICAgICAgZW5kXG5cbiAgICAgICAgICAtLSBOb3cgcHV0IGRpZ2l0cyBpbiBjb3JyZWN0IG9yZGVyIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGNvdW50IC0gMVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA+PSBsX2VuZGluZ19pbmRleFxuICAgICAgICBsb29wXG4gICAgICAgICAgbF90ZW1wIDo9IGxfYXJlYS5pdGVtIChsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfYXJlYS5pdGVtIChsX2VuZGluZ19pbmRleCksIGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF90ZW1wLCBsX2VuZGluZ19pbmRleClcbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBsX2VuZGluZ19pbmRleCAtIDFcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGxfc3RhcnRpbmdfaW5kZXggKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgYXBwZW5kX2ludGVnZXJfMTYgKGk6IElOVEVHRVJfMTYpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBJTlRFR0VSXzE2XG4gICAgICBsX3N0YXJ0aW5nX2luZGV4LCBsX2VuZGluZ19pbmRleDogSU5URUdFUlxuICAgICAgbF90ZW1wOiBDSEFSQUNURVJfMzJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGlmIGkgPSAwIHRoZW5cbiAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJzAnKVxuICAgICAgZWxzZVxuICAgICAgICAgIC0tIEV4dHJhY3QgaW50ZWdlciB2YWx1ZSBkaWdpdCBieSBkaWdpdCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4IDo9IGNvdW50XG4gICAgICAgICAgaWYgaSA8IDAgdGhlblxuICAgICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoJy0nKVxuICAgICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICAgICAgICAtLSBTcGVjaWFsIGNhc2UgZm9yIG1pbmltdW0gaW50ZWdlciB2YWx1ZSBhcyBuZWdhdGluZyBpdFxuICAgICAgICAgICAgICAtLSBhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICBpZiBpID0ge0lOVEVHRVJfMTZ9Lk1pbl92YWx1ZSB0aGVuXG4gICAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCc4JylcbiAgICAgICAgICAgICAgbF92YWx1ZSA6PSAtKGkgLy8gMTApXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLWlcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxfdmFsdWUgOj0gaVxuICAgICAgICAgIGVuZFxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfdmFsdWUgPSAwXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgoKGxfdmFsdWUgXFxcXCAxMCkrIDQ4KS50b19jaGFyYWN0ZXJfMzIpXG4gICAgICAgICAgbF92YWx1ZSA6PSBsX3ZhbHVlIC8vIDEwXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gTm93IHB1dCBkaWdpdHMgaW4gY29ycmVjdCBvcmRlciBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICAgIGZyb21cbiAgICAgICAgICBsX2VuZGluZ19pbmRleCA6PSBjb3VudCAtIDFcbiAgICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgICB1bnRpbFxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggPj0gbF9lbmRpbmdfaW5kZXhcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGxfdGVtcCA6PSBsX2FyZWEuaXRlbSAobF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAobF9lbmRpbmdfaW5kZXgpLCBsX3N0YXJ0aW5nX2luZGV4KVxuICAgICAgICAgIGxfYXJlYS5wdXQgKGxfdGVtcCwgbF9lbmRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gbF9lbmRpbmdfaW5kZXggLSAxXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBsX3N0YXJ0aW5nX2luZGV4ICsgMVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGFwcGVuZF9pbnRlZ2VyXzY0IChpOiBJTlRFR0VSXzY0KVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGknIGF0IGVuZC5cbiAgICBsb2NhbFxuICAgICAgbF92YWx1ZTogSU5URUdFUl82NFxuICAgICAgbF9zdGFydGluZ19pbmRleCwgbF9lbmRpbmdfaW5kZXg6IElOVEVHRVJcbiAgICAgIGxfdGVtcDogQ0hBUkFDVEVSXzMyXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBpZiBpID0gMCB0aGVuXG4gICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCcwJylcbiAgICAgIGVsc2VcbiAgICAgICAgICAtLSBFeHRyYWN0IGludGVnZXIgdmFsdWUgZGlnaXQgYnkgZGlnaXQgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9zdGFydGluZ19pbmRleCA6PSBjb3VudFxuICAgICAgICAgIGlmIGkgPCAwIHRoZW5cbiAgICAgICAgICAgIGFwcGVuZF9jaGFyYWN0ZXIgKCctJylcbiAgICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgICAgICAgLS0gU3BlY2lhbCBjYXNlIGZvciBtaW5pbXVtIGludGVnZXIgdmFsdWUgYXMgbmVnYXRpbmcgaXRcbiAgICAgICAgICAgICAgLS0gYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgaWYgaSA9IHtJTlRFR0VSXzY0fS5NaW5fdmFsdWUgdGhlblxuICAgICAgICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnOCcpXG4gICAgICAgICAgICAgIGxfdmFsdWUgOj0gLShpIC8vIDEwKVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBsX3ZhbHVlIDo9IC1pXG4gICAgICAgICAgICBlbmRcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgICBlbmRcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF84IChpOiBOQVRVUkFMXzgpXG4gICAgICAtLSBBcHBlbmQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBgaScgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBsX3ZhbHVlOiBOQVRVUkFMXzhcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8xNiAoaTogTkFUVVJBTF8xNilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMTZcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF8zMiAoaTogTkFUVVJBTF8zMilcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfMzJcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfbmF0dXJhbF82NCAoaTogTkFUVVJBTF82NClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBpJyBhdCBlbmQuXG4gICAgbG9jYWxcbiAgICAgIGxfdmFsdWU6IE5BVFVSQUxfNjRcbiAgICAgIGxfc3RhcnRpbmdfaW5kZXgsIGxfZW5kaW5nX2luZGV4OiBJTlRFR0VSXG4gICAgICBsX3RlbXA6IENIQVJBQ1RFUl8zMlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgaWYgaSA9IDAgdGhlblxuICAgICAgICBhcHBlbmRfY2hhcmFjdGVyICgnMCcpXG4gICAgICBlbHNlXG4gICAgICAgICAgLS0gRXh0cmFjdCBpbnRlZ2VyIHZhbHVlIGRpZ2l0IGJ5IGRpZ2l0IGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gY291bnRcbiAgICAgICAgICBsX3ZhbHVlIDo9IGlcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3ZhbHVlID0gMFxuICAgICAgICBsb29wXG4gICAgICAgICAgYXBwZW5kX2NoYXJhY3RlciAoKChsX3ZhbHVlIFxcXFwgMTApKyA0OCkudG9fY2hhcmFjdGVyXzMyKVxuICAgICAgICAgIGxfdmFsdWUgOj0gbF92YWx1ZSAvLyAxMFxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIE5vdyBwdXQgZGlnaXRzIGluIGNvcnJlY3Qgb3JkZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAgICBmcm9tXG4gICAgICAgICAgbF9lbmRpbmdfaW5kZXggOj0gY291bnQgLSAxXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgdW50aWxcbiAgICAgICAgICBsX3N0YXJ0aW5nX2luZGV4ID49IGxfZW5kaW5nX2luZGV4XG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX3RlbXAgOj0gbF9hcmVhLml0ZW0gKGxfc3RhcnRpbmdfaW5kZXgpXG4gICAgICAgICAgbF9hcmVhLnB1dCAobF9hcmVhLml0ZW0gKGxfZW5kaW5nX2luZGV4KSwgbF9zdGFydGluZ19pbmRleClcbiAgICAgICAgICBsX2FyZWEucHV0IChsX3RlbXAsIGxfZW5kaW5nX2luZGV4KVxuICAgICAgICAgIGxfZW5kaW5nX2luZGV4IDo9IGxfZW5kaW5nX2luZGV4IC0gMVxuICAgICAgICAgIGxfc3RhcnRpbmdfaW5kZXggOj0gbF9zdGFydGluZ19pbmRleCArIDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBhcHBlbmRfcmVhbCAocjogUkVBTClcbiAgICAgIC0tIEFwcGVuZCB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGByJyBhdCBlbmQuXG4gICAgZG9cbiAgICAgIGFwcGVuZF9zdHJpbmdfZ2VuZXJhbCAoci5vdXQpXG4gICAgZW5kXG5cbiAgYXBwZW5kX2RvdWJsZSAoZDogRE9VQkxFKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGQnIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChkLm91dClcbiAgICBlbmRcblxuICBhcHBlbmRfY2hhcmFjdGVyLCBleHRlbmQgKGM6IENIQVJBQ1RFUl8zMilcbiAgICAgIC0tIEFwcGVuZCBgYycgYXQgZW5kLlxuICAgIGxvY2FsXG4gICAgICBjdXJyZW50X2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGN1cnJlbnRfY291bnQgOj0gY291bnRcbiAgICAgIGlmIGN1cnJlbnRfY291bnQgPSBjYXBhY2l0eSB0aGVuXG4gICAgICAgIHJlc2l6ZSAoY3VycmVudF9jb3VudCArIGFkZGl0aW9uYWxfc3BhY2UpXG4gICAgICBlbmRcbiAgICAgIGFyZWEucHV0IChjLCBjdXJyZW50X2NvdW50KVxuICAgICAgY291bnQgOj0gY3VycmVudF9jb3VudCArIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGl0ZW1faW5zZXJ0ZWQ6IGl0ZW0gKGNvdW50KSA9IGNcbiAgICAgIG5ld19jb3VudDogY291bnQgPSBvbGQgY291bnQgKyAxXG4gICAgICBzdGFibGVfYmVmb3JlOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nICgxLCBjb3VudCAtIDEpIH4gKG9sZCB0d2luKVxuICAgIGVuZFxuXG4gIGFwcGVuZF9ib29sZWFuIChiOiBCT09MRUFOKVxuICAgICAgLS0gQXBwZW5kIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYGInIGF0IGVuZC5cbiAgICBkb1xuICAgICAgYXBwZW5kX3N0cmluZ19nZW5lcmFsIChiLm91dClcbiAgICBlbmRcblxuICBpbnNlcnQgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEFkZCBgcycgdG8gbGVmdCBvZiBwb3NpdGlvbiBgaScgaW4gY3VycmVudCBzdHJpbmcuXG4gICAgb2Jzb2xldGVcbiAgICAgIFwiRUxLUyAyMDAxOiB1c2UgYGluc2VydF9zdHJpbmcnIGluc3RlYWRcIlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgaW5kZXhfc21hbGxfZW5vdWdoOiBpIDw9IGNvdW50ICsgMVxuICAgICAgaW5kZXhfbGFyZ2VfZW5vdWdoOiBpID4gMFxuICAgIGRvXG4gICAgICBpbnNlcnRfc3RyaW5nIChzLCBpKVxuICAgIGVuc3VyZVxuICAgICAgaW5zZXJ0ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllc1xuICAgICAgICAoQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBpIC0gMSkgKyBvbGQgKHMudHdpbikgKyBvbGQgc3Vic3RyaW5nIChpLCBjb3VudCkpKVxuICAgIGVuZFxuXG4gIGluc2VydF9zdHJpbmcgKHM6IFJFQURBQkxFX1NUUklOR18zMjsgaTogSU5URUdFUilcbiAgICAgIC0tIEluc2VydCBgcycgYXQgaW5kZXggYGknLCBzaGlmdGluZyBjaGFyYWN0ZXJzIGJldHdlZW4gcmFua3NcbiAgICAgIC0tIGBpJyBhbmQgYGNvdW50JyByaWdodHdhcmRzLlxuICAgIHJlcXVpcmVcbiAgICAgIHN0cmluZ19leGlzdHM6IHMgLz0gVm9pZFxuICAgICAgdmFsaWRfaW5zZXJ0aW9uX2luZGV4OiAxIDw9IGkgYW5kIGkgPD0gY291bnQgKyAxXG4gICAgbG9jYWxcbiAgICAgIHBvcywgbmV3X3NpemU6IElOVEVHRVJcbiAgICAgIGxfc19jb3VudDogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBJbnNlcnQgYHMnIGlmIGBzJyBpcyBub3QgZW1wdHksIG90aGVyd2lzZSBpcyB1c2VsZXNzLlxuICAgICAgbF9zX2NvdW50IDo9IHMuY291bnRcbiAgICAgIGlmIGxfc19jb3VudCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIG5ld19zaXplIDo9IGxfc19jb3VudCArIGNvdW50XG4gICAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICAgIHJlc2l6ZSAobmV3X3NpemUgKyBhZGRpdGlvbmFsX3NwYWNlKVxuICAgICAgICBlbmRcblxuICAgICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgcG9zIDo9IGkgLSAxXG5cbiAgICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLm92ZXJsYXBwaW5nX21vdmUgKHBvcywgcG9zICsgbF9zX2NvdW50LCBjb3VudCAtIHBvcylcblxuICAgICAgICAgIC0tIENvcHkgc3RyaW5nIGBzJyBhdCBpbmRleCBgcG9zJy5cbiAgICAgICAgbF9hcmVhLmNvcHlfZGF0YSAocy5hcmVhLCBzLmFyZWFfbG93ZXIsIHBvcywgbF9zX2NvdW50KVxuXG4gICAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIGluc2VydGVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgKEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAoMSwgaSAtIDEpICsgb2xkIChzLnR3aW4pICsgb2xkIHN1YnN0cmluZyAoaSwgY291bnQpKSlcbiAgICBlbmRcblxuICBpbnNlcnRfY2hhcmFjdGVyIChjOiBDSEFSQUNURVJfMzI7IGk6IElOVEVHRVIpXG4gICAgICAtLSBJbnNlcnQgYGMnIGF0IGluZGV4IGBpJywgc2hpZnRpbmcgY2hhcmFjdGVycyBiZXR3ZWVuIHJhbmtzXG4gICAgICAtLSBgaScgYW5kIGBjb3VudCcgcmlnaHR3YXJkcy5cbiAgICByZXF1aXJlXG4gICAgICB2YWxpZF9pbnNlcnRpb25faW5kZXg6IDEgPD0gaSBhbmQgaSA8PSBjb3VudCArIDFcbiAgICBsb2NhbFxuICAgICAgcG9zLCBuZXdfc2l6ZTogSU5URUdFUlxuICAgICAgbF9hcmVhOiBsaWtlIGFyZWFcbiAgICBkb1xuICAgICAgICAtLSBSZXNpemUgQ3VycmVudCBpZiBuZWNlc3NhcnkuXG4gICAgICBuZXdfc2l6ZSA6PSAxICsgY291bnRcbiAgICAgIGlmIG5ld19zaXplID4gY2FwYWNpdHkgdGhlblxuICAgICAgICByZXNpemUgKG5ld19zaXplICsgYWRkaXRpb25hbF9zcGFjZSlcbiAgICAgIGVuZFxuXG4gICAgICAgIC0tIFBlcmZvcm0gYWxsIG9wZXJhdGlvbnMgdXNpbmcgYSB6ZXJvIGJhc2VkIGFycmF5cy5cbiAgICAgIHBvcyA6PSBpIC0gMVxuICAgICAgbF9hcmVhIDo9IGFyZWFcblxuICAgICAgICAtLSBGaXJzdCBzaGlmdCBmcm9tIGBzLmNvdW50JyBwb3NpdGlvbiBhbGwgY2hhcmFjdGVycyBzdGFydGluZyBhdCBpbmRleCBgcG9zJy5cbiAgICAgIGxfYXJlYS5vdmVybGFwcGluZ19tb3ZlIChwb3MsIHBvcyArIDEsIGNvdW50IC0gcG9zKVxuXG4gICAgICAgIC0tIEluc2VydCBuZXcgY2hhcmFjdGVyXG4gICAgICBsX2FyZWEucHV0IChjLCBwb3MpXG5cbiAgICAgIGNvdW50IDo9IG5ld19zaXplXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgb25lX21vcmVfY2hhcmFjdGVyOiBjb3VudCA9IG9sZCBjb3VudCArIDFcbiAgICAgIGluc2VydGVkOiBpdGVtIChpKSA9IGNcbiAgICAgIHN0YWJsZV9iZWZvcmVfaTogZWxrc19jaGVja2luZyBpbXBsaWVzIHN1YnN0cmluZyAoMSwgaSAtIDEpIH4gKG9sZCBzdWJzdHJpbmcgKDEsIGkgLSAxKSlcbiAgICAgIHN0YWJsZV9hZnRlcl9pOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgc3Vic3RyaW5nIChpICsgMSwgY291bnQpIH4gKG9sZCBzdWJzdHJpbmcgKGksIGNvdW50KSlcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBSZW1vdmFsXG5cbiAgcmVtb3ZlIChpOiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGBpJy10aCBjaGFyYWN0ZXIuXG4gICAgbG9jYWxcbiAgICAgIGxfY291bnQ6IElOVEVHRVJcbiAgICBkb1xuICAgICAgbF9jb3VudCA6PSBjb3VudFxuICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSBsZWZ0LlxuICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChpLCBpIC0gMSwgbF9jb3VudCAtIGkpXG4gICAgICAgIC0tIFVwZGF0ZSBjb250ZW50LlxuICAgICAgY291bnQgOj0gbF9jb3VudCAtIDFcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5kXG5cbiAgcmVtb3ZlX2hlYWQgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3QgYG4nIGNoYXJhY3RlcnM7XG4gICAgICAtLSBpZiBgbicgPiBgY291bnQnLCByZW1vdmUgYWxsLlxuICAgIHJlcXVpcmVcbiAgICAgIG5fbm9uX25lZ2F0aXZlOiBuID49IDBcbiAgICBkb1xuICAgICAgaWYgbiA+IGNvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX3RhaWwgKGNvdW50IC0gbilcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgcmVtb3ZlZDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIHN1YnN0cmluZyAobi5taW4gKGNvdW50KSArIDEsIGNvdW50KSlcbiAgICBlbmRcblxuICByZW1vdmVfc3Vic3RyaW5nIChzdGFydF9pbmRleCwgZW5kX2luZGV4OiBJTlRFR0VSKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBjaGFyYWN0ZXJzIGZyb20gYHN0YXJ0X2luZGV4J1xuICAgICAgLS0gdG8gYGVuZF9pbmRleCcgaW5jbHVzaXZlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3N0YXJ0X2luZGV4OiAxIDw9IHN0YXJ0X2luZGV4XG4gICAgICB2YWxpZF9lbmRfaW5kZXg6IGVuZF9pbmRleCA8PSBjb3VudFxuICAgICAgbWVhbmluZ2Z1bF9pbnRlcnZhbDogc3RhcnRfaW5kZXggPD0gZW5kX2luZGV4ICsgMVxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50LCBuYl9yZW1vdmVkOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIG5iX3JlbW92ZWQgOj0gZW5kX2luZGV4IC0gc3RhcnRfaW5kZXggKyAxXG4gICAgICBpZiBuYl9yZW1vdmVkID4gMCB0aGVuXG4gICAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgICAgYXJlYS5vdmVybGFwcGluZ19tb3ZlIChzdGFydF9pbmRleCArIG5iX3JlbW92ZWQgLSAxLCBzdGFydF9pbmRleCAtIDEsIGxfY291bnQgLSBlbmRfaW5kZXgpXG4gICAgICAgIGNvdW50IDo9IGxfY291bnQgLSBuYl9yZW1vdmVkXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHJlbW92ZWQ6IGVsa3NfY2hlY2tpbmcgaW1wbGllcyBDdXJyZW50IH4gKG9sZCBzdWJzdHJpbmcgKDEsIHN0YXJ0X2luZGV4IC0gMSkgKyBvbGQgc3Vic3RyaW5nIChlbmRfaW5kZXggKyAxLCBjb3VudCkpXG4gICAgZW5kXG5cbiAgcmVtb3ZlX3RhaWwgKG46IElOVEVHRVIpXG4gICAgICAtLSBSZW1vdmUgbGFzdCBgbicgY2hhcmFjdGVycztcbiAgICAgIC0tIGlmIGBuJyA+IGBjb3VudCcsIHJlbW92ZSBhbGwuXG4gICAgcmVxdWlyZVxuICAgICAgbl9ub25fbmVnYXRpdmU6IG4gPj0gMFxuICAgIGxvY2FsXG4gICAgICBsX2NvdW50OiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGxfY291bnQgOj0gY291bnRcbiAgICAgIGlmIG4gPiBsX2NvdW50IHRoZW5cbiAgICAgICAgY291bnQgOj0gMFxuICAgICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgICAgZWxzZVxuICAgICAgICBrZWVwX2hlYWQgKGxfY291bnQgLSBuKVxuICAgICAgZW5kXG4gICAgZW5zdXJlXG4gICAgICByZW1vdmVkOiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgc3Vic3RyaW5nICgxLCBjb3VudCAtIG4ubWluIChjb3VudCkpKVxuICAgIGVuZFxuXG4gIHBydW5lIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgYycsIGlmIGFueS5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgY291bnRlcjogSU5URUdFUlxuICAgIGRvXG4gICAgICBmcm9tXG4gICAgICAgIGNvdW50ZXIgOj0gMVxuICAgICAgdW50aWxcbiAgICAgICAgY291bnRlciA+IGNvdW50IG9yIGVsc2UgKGl0ZW0gKGNvdW50ZXIpID0gYylcbiAgICAgIGxvb3BcbiAgICAgICAgY291bnRlciA6PSBjb3VudGVyICsgMVxuICAgICAgZW5kXG4gICAgICBpZiBjb3VudGVyIDw9IGNvdW50IHRoZW5cbiAgICAgICAgcmVtb3ZlIChjb3VudGVyKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgcHJ1bmVfYWxsIChjOiBDSEFSQUNURVJfMzIpXG4gICAgICAtLSBSZW1vdmUgYWxsIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICByZXF1aXJlIGVsc2VcbiAgICAgIFRydWVcbiAgICBsb2NhbFxuICAgICAgaSwgaiwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX2NoYXI6IENIQVJBQ1RFUl8zMlxuICAgIGRvXG4gICAgICAgIC0tIFRyYXZlcnNlIHN0cmluZyBhbmQgc2hpZnQgY2hhcmFjdGVycyB0byB0aGUgbGVmdFxuICAgICAgICAtLSBlYWNoIHRpbWUgd2UgZmluZCBhbiBvY2N1cnJlbmNlIG9mIGBjJy5cbiAgICAgIGZyb21cbiAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgbmIgOj0gY291bnRcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSBuYlxuICAgICAgbG9vcFxuICAgICAgICBsX2NoYXIgOj0gbF9hcmVhLml0ZW0gKGkpXG4gICAgICAgIGlmIGxfY2hhciAvPSBjIHRoZW5cbiAgICAgICAgICBsX2FyZWEucHV0IChsX2NoYXIsIGopXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaSA6PSBpICsgMVxuICAgICAgZW5kXG4gICAgICBjb3VudCA6PSBqXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZSB0aGVuXG4gICAgICBjaGFuZ2VkX2NvdW50OiBjb3VudCA9IChvbGQgY291bnQpIC0gKG9sZCBvY2N1cnJlbmNlcyAoYykpXG4gICAgICAtLSByZW1vdmVkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSAvPSBgYydcbiAgICBlbmRcblxuICBwcnVuZV9hbGxfbGVhZGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCBsZWFkaW5nIG9jY3VycmVuY2VzIG9mIGBjJy5cbiAgICBkb1xuICAgICAgZnJvbVxuICAgICAgdW50aWxcbiAgICAgICAgaXNfZW1wdHkgb3IgZWxzZSBpdGVtICgxKSAvPSBjXG4gICAgICBsb29wXG4gICAgICAgIHJlbW92ZSAoMSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHBydW5lX2FsbF90cmFpbGluZyAoYzogQ0hBUkFDVEVSXzMyKVxuICAgICAgLS0gUmVtb3ZlIGFsbCB0cmFpbGluZyBvY2N1cnJlbmNlcyBvZiBgYycuXG4gICAgZG9cbiAgICAgIGZyb21cbiAgICAgIHVudGlsXG4gICAgICAgIGlzX2VtcHR5IG9yIGVsc2UgaXRlbSAoY291bnQpIC89IGNcbiAgICAgIGxvb3BcbiAgICAgICAgcmVtb3ZlIChjb3VudClcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHdpcGVfb3V0XG4gICAgICAtLSBSZW1vdmUgYWxsIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlIHRoZW5cbiAgICAgIGlzX2VtcHR5OiBjb3VudCA9IDBcbiAgICAgIHNhbWVfY2FwYWNpdHk6IGNhcGFjaXR5ID0gb2xkIGNhcGFjaXR5XG4gICAgZW5kXG5cbiAgY2xlYXJfYWxsXG4gICAgICAtLSBSZXNldCBhbGwgY2hhcmFjdGVycy5cbiAgICBvYnNvbGV0ZVxuICAgICAgXCJVc2UgYHdpcGVfb3V0JyBpbnN0ZWFkLlwiXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IDBcbiAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgZW5zdXJlXG4gICAgICBpc19lbXB0eTogY291bnQgPSAwXG4gICAgICBzYW1lX2NhcGFjaXR5OiBjYXBhY2l0eSA9IG9sZCBjYXBhY2l0eVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFJlc2l6aW5nXG5cbiAgYWRhcHRfc2l6ZVxuICAgICAgLS0gQWRhcHQgdGhlIHNpemUgdG8gYWNjb21tb2RhdGUgYGNvdW50JyBjaGFyYWN0ZXJzLlxuICAgIGRvXG4gICAgICByZXNpemUgKGNvdW50KVxuICAgIGVuZFxuXG4gIHJlc2l6ZSAobmV3c2l6ZTogSU5URUdFUilcbiAgICAgIC0tIFJlYXJyYW5nZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYWNjb21tb2RhdGVcbiAgICAgIC0tIGF0IGxlYXN0IGBuZXdzaXplJyBjaGFyYWN0ZXJzLlxuICAgICAgLS0gRG8gbm90IGxvc2UgYW55IHByZXZpb3VzbHkgZW50ZXJlZCBjaGFyYWN0ZXIuXG4gICAgZG9cbiAgICAgIGFyZWEgOj0gYXJlYS5hbGlhc2VkX3Jlc2l6ZWRfYXJlYV93aXRoX2RlZmF1bHQgKCclLzAwMC8nLCBuZXdzaXplICsgMSlcbiAgICBlbmRcblxuICBncm93IChuZXdzaXplOiBJTlRFR0VSKVxuICAgICAgLS0gRW5zdXJlIHRoYXQgdGhlIGNhcGFjaXR5IGlzIGF0IGxlYXN0IGBuZXdzaXplJy5cbiAgICBkb1xuICAgICAgaWYgbmV3c2l6ZSA+IGNhcGFjaXR5IHRoZW5cbiAgICAgICAgcmVzaXplIChuZXdzaXplKVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgdHJpbVxuICAgICAgLS0gPFByZWN1cnNvcj5cbiAgICBsb2NhbFxuICAgICAgbjogbGlrZSBjb3VudFxuICAgIGRvXG4gICAgICBuIDo9IGNvdW50XG4gICAgICBpZiBuIDwgY2FwYWNpdHkgdGhlblxuICAgICAgICBhcmVhIDo9IGFyZWEuYWxpYXNlZF9yZXNpemVkX2FyZWEgKG4pXG4gICAgICBlbmRcbiAgICBlbnN1cmUgdGhlblxuICAgICAgc2FtZV9zdHJpbmc6IHNhbWVfc3RyaW5nIChvbGQgdHdpbilcbiAgICBlbmRcblxuZmVhdHVyZSAtLSBDb252ZXJzaW9uXG5cbiAgYXNfbG93ZXI6IGxpa2UgQ3VycmVudFxuICAgICAgLS0gTmV3IG9iamVjdCB3aXRoIGFsbCBsZXR0ZXJzIGluIGxvd2VyIGNhc2UuXG4gICAgZG9cbiAgICAgIFJlc3VsdCA6PSB0d2luXG4gICAgICBSZXN1bHQudG9fbG93ZXJcbiAgICBlbmRcblxuICBhc191cHBlcjogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgb2JqZWN0IHdpdGggYWxsIGxldHRlcnMgaW4gdXBwZXIgY2FzZVxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgUmVzdWx0LnRvX3VwcGVyXG4gICAgZW5kXG5cbiAgbGVmdF9qdXN0aWZ5XG4gICAgICAtLSBMZWZ0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpdGR0aC5cbiAgICBsb2NhbFxuICAgICAgaSwgbmI6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgICAgLS0gUmVtb3ZlIGxlYWRpbmcgd2hpdGUgc3BhY2VzLlxuICAgICAgbmIgOj0gY291bnRcbiAgICAgIGxlZnRfYWRqdXN0XG5cbiAgICAgICAgLS0gR2V0IG5ldyBjb3VudFxuICAgICAgaSA6PSBjb3VudFxuICAgICAgaWYgaSA8IG5iIHRoZW5cbiAgICAgICAgICAtLSBgbGVmdF9hZGp1c3QnIGRpZCByZW1vdmUgc29tZSBjaGFyYWN0ZXJzLCBzbyB3ZSBuZWVkIHRvIGFkZFxuICAgICAgICAgIC0tIHNvbWUgd2hpdGUgc3BhY2VzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IG5iXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBsX2FyZWEucHV0ICgnICcsIGkpXG4gICAgICAgICAgaSA6PSBpICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgICAtLSBSZXN0b3JlIGBjb3VudCdcbiAgICAgICAgY291bnQgOj0gbmJcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIGNlbnRlcl9qdXN0aWZ5XG4gICAgICAtLSBDZW50ZXIganVzdGlmeSBDdXJyZW50IHVzaW5nIGBjb3VudCcgYXMgd2lkdGguXG4gICAgbG9jYWxcbiAgICAgIGksIG5iLCBsX29mZnNldDogSU5URUdFUlxuICAgICAgbGVmdF9uYl9zcGFjZSwgcmlnaHRfbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgICBsX3Byb3A6IGxpa2UgY2hhcmFjdGVyX3Byb3BlcnRpZXNcbiAgICBkb1xuICAgICAgbF9wcm9wIDo9IGNoYXJhY3Rlcl9wcm9wZXJ0aWVzXG5cbiAgICAgICAgLS0gQ29tcHV0ZSBudW1iZXIgb2Ygc3BhY2VzIGF0IHRoZSBsZWZ0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBuYiA6PSBjb3VudFxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgbGVmdF9uYl9zcGFjZSA9IG5iIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGxlZnRfbmJfc3BhY2UpKVxuICAgICAgbG9vcFxuICAgICAgICBsZWZ0X25iX3NwYWNlIDo9IGxlZnRfbmJfc3BhY2UgKyAxXG4gICAgICBlbmRcblxuICAgICAgICAtLSBDb21wdXRlIG51bWJlciBvZiBzcGFjZXMgYXQgdGhlIHJpZ2h0IG9mIGN1cnJlbnQgc3RyaW5nLlxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5iIC0gMVxuICAgICAgICBsX2FyZWEgOj0gYXJlYVxuICAgICAgdW50aWxcbiAgICAgICAgaSA9IC0xIG9yIGVsc2Ugbm90IGxfcHJvcC5pc19zcGFjZSAobF9hcmVhLml0ZW0gKGkpKVxuICAgICAgbG9vcFxuICAgICAgICByaWdodF9uYl9zcGFjZSA6PSByaWdodF9uYl9zcGFjZSArIDFcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG5cbiAgICAgICAgLS0gV2UgZW5jb3VyYWdlIHRoYXQgbW9yZSBzcGFjZXMgd2lsbCBiZSBwdXQgdG8gdGhlIGxlZnQsIHdoZW5cbiAgICAgICAgLS0gbnVtYmVyIG9mIHNwYWNlcyBpcyBub3QgZXZlbi5cbiAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgKyByaWdodF9uYl9zcGFjZVxuICAgICAgaWYgbF9vZmZzZXQgXFxcXCAyID0gMCB0aGVuXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyXG4gICAgICBlbHNlXG4gICAgICAgIGxfb2Zmc2V0IDo9IGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAvLyAyIC0gMVxuICAgICAgZW5kXG4gICAgICBpZiBsX29mZnNldCAvPSAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodCBvciBsZWZ0IChkZXBlbmRpbmcgb24gc2lnbiBvZlxuICAgICAgICAgIC0tIGBsX29mZnNldCcgYnkgYGxfb2Zmc2V0JyBwb3NpdGlvbi5cbiAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAobGVmdF9uYl9zcGFjZSwgbGVmdF9uYl9zcGFjZSAtIGxfb2Zmc2V0LFxuICAgICAgICAgIG5iIC0gbGVmdF9uYl9zcGFjZSAtIHJpZ2h0X25iX3NwYWNlKVxuXG4gICAgICAgIGlmIGxfb2Zmc2V0IDwgMCB0aGVuXG4gICAgICAgICAgICAtLSBGaWxsIGxlZnQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIGxlZnRfbmJfc3BhY2UsIGxlZnRfbmJfc3BhY2UgLSBsX29mZnNldCAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIC0tIEZpbGwgcmlnaHQgcGFydCB3aXRoIHNwYWNlcy5cbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIG5iIC0gcmlnaHRfbmJfc3BhY2UgLSBsX29mZnNldCwgbmIgLSAxKVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gIHJpZ2h0X2p1c3RpZnlcbiAgICAgIC0tIFJpZ2h0IGp1c3RpZnkgQ3VycmVudCB1c2luZyBgY291bnQnIGFzIHdpZHRoLlxuICAgIGxvY2FsXG4gICAgICBpLCBuYjogSU5URUdFUlxuICAgICAgbmJfc3BhY2U6IElOVEVHRVJcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIG5iIDo9IGNvdW50XG4gICAgICByaWdodF9hZGp1c3RcbiAgICAgIGkgOj0gY291bnRcbiAgICAgIG5iX3NwYWNlIDo9IG5iIC0gaVxuICAgICAgaWYgbmJfc3BhY2UgPiAwIHRoZW5cbiAgICAgICAgICAtLSBTaGlmdCBjaGFyYWN0ZXJzIHRvIHRoZSByaWdodC5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIGkgOj0gaSAtIDFcbiAgICAgICAgICBsX2FyZWEucHV0IChsX2FyZWEuaXRlbSAoaSksIGkgKyBuYl9zcGFjZSlcbiAgICAgICAgdmFyaWFudFxuICAgICAgICAgIGkgKyAxXG4gICAgICAgIGVuZFxuXG4gICAgICAgICAgLS0gRmlsbCBsZWZ0IHBhcnQgd2l0aCBzcGFjZXMuXG4gICAgICAgIGZyb21cbiAgICAgICAgdW50aWxcbiAgICAgICAgICBuYl9zcGFjZSA9IDBcbiAgICAgICAgbG9vcFxuICAgICAgICAgIG5iX3NwYWNlIDo9IG5iX3NwYWNlIC0gMVxuICAgICAgICAgIGxfYXJlYS5wdXQgKCcgJywgbmJfc3BhY2UpXG4gICAgICAgIHZhcmlhbnRcbiAgICAgICAgICBuYl9zcGFjZSArIDFcbiAgICAgICAgZW5kXG4gICAgICAgICAgLS0gUmVzdG9yZSBgY291bnQnXG4gICAgICAgIGNvdW50IDo9IG5iXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbnN1cmVcbiAgICAgIHNhbWVfY291bnQ6IGNvdW50ID0gb2xkIGNvdW50XG4gICAgZW5kXG5cbiAgY2hhcmFjdGVyX2p1c3RpZnkgKHBpdm90OiBDSEFSQUNURVJfMzI7IHBvc2l0aW9uOiBJTlRFR0VSKVxuICAgICAgLS0gSnVzdGlmeSBhIHN0cmluZyBiYXNlZCBvbiBhIGBwaXZvdCdcbiAgICAgIC0tIGFuZCB0aGUgYHBvc2l0aW9uJyBpdCBuZWVkcyB0byBiZSBpblxuICAgICAgLS0gdGhlIGZpbmFsIHN0cmluZy5cbiAgICAgIC0tIFRoaXMgd2lsbCBncm93IHRoZSBzdHJpbmcgaWYgbmVjZXNzYXJ5XG4gICAgICAtLSB0byBnZXQgdGhlIHBpdm90IGluIHRoZSBjb3JyZWN0IHBsYWNlLlxuICAgIHJlcXVpcmVcbiAgICAgIHZhbGlkX3Bvc2l0aW9uOiBwb3NpdGlvbiA8PSBjYXBhY2l0eVxuICAgICAgcG9zaXRpdmVfcG9zaXRpb246IHBvc2l0aW9uID49IDFcbiAgICAgIHBpdm90X25vdF9zcGFjZTogcGl2b3QgLz0gJyAnXG4gICAgICBub3RfZW1wdHk6IG5vdCBpc19lbXB0eVxuICAgIGxvY2FsXG4gICAgICBsX2luZGV4X29mX3Bpdm90LCBsX25ld19zaXplOiBJTlRFR0VSXG4gICAgICBsX2FyZWE6IGxpa2UgYXJlYVxuICAgIGRvXG4gICAgICBsX2luZGV4X29mX3Bpdm90IDo9IGluZGV4X29mIChwaXZvdCwgMSlcbiAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgLz0gMCB0aGVuXG4gICAgICAgIGlmIGxfaW5kZXhfb2ZfcGl2b3QgPCBwb3NpdGlvbiB0aGVuXG4gICAgICAgICAgICAtLSBXZSBuZWVkIHRvIHJlc2l6ZSBDdXJyZW50IHNvIHRoYXQgd2UgY2FuIHNoaWZ0IEN1cnJlbnQgYnlcbiAgICAgICAgICAgIC0tIGBsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24nLlxuICAgICAgICAgIGxfbmV3X3NpemUgOj0gY291bnQgKyBwb3NpdGlvbiAtIGxfaW5kZXhfb2ZfcGl2b3RcbiAgICAgICAgICBncm93IChsX25ld19zaXplKVxuICAgICAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICAgICAgbF9hcmVhLm1vdmVfZGF0YSAoMCwgcG9zaXRpb24gLSBsX2luZGV4X29mX3Bpdm90LCBjb3VudClcbiAgICAgICAgICBsX2FyZWEuZmlsbF93aXRoICgnICcsIDAsIHBvc2l0aW9uIC0gbF9pbmRleF9vZl9waXZvdCAtIDEpXG4gICAgICAgICAgY291bnQgOj0gbF9uZXdfc2l6ZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICAtLSBTaW1wbHkgc2hpZnQgY29udGVudCB0byB0aGUgbGVmdCBhbmQgcmVzZXQgdHJhaWxpbmcgd2l0aCBzcGFjZXMuXG4gICAgICAgICAgbF9hcmVhIDo9IGFyZWFcbiAgICAgICAgICBsX2FyZWEubW92ZV9kYXRhIChsX2luZGV4X29mX3Bpdm90IC0gcG9zaXRpb24sIDAsIGNvdW50IC0gbF9pbmRleF9vZl9waXZvdCArIHBvc2l0aW9uKVxuICAgICAgICAgIGxfYXJlYS5maWxsX3dpdGggKCcgJywgY291bnQgLSBsX2luZGV4X29mX3Bpdm90ICsgcG9zaXRpb24sIGNvdW50IC0gMSlcbiAgICAgICAgZW5kXG4gICAgICAgIGludGVybmFsX2hhc2hfY29kZSA6PSAwXG4gICAgICBlbmRcbiAgICBlbmRcblxuICB0b19sb3dlclxuICAgICAgLS0gQ29udmVydCB0byBsb3dlciBjYXNlLlxuICAgIGRvXG4gICAgICB0b19sb3dlcl9hcmVhIChhcmVhLCAwLCBjb3VudCAtIDEpXG4gICAgICBpbnRlcm5hbF9oYXNoX2NvZGUgOj0gMFxuICAgIGVuc3VyZVxuICAgICAgbGVuZ3RoX2FuZF9jb250ZW50OiBlbGtzX2NoZWNraW5nIGltcGxpZXMgQ3VycmVudCB+IChvbGQgYXNfbG93ZXIpXG4gICAgZW5kXG5cbiAgdG9fdXBwZXJcbiAgICAgIC0tIENvbnZlcnQgdG8gdXBwZXIgY2FzZS5cbiAgICBkb1xuICAgICAgdG9fdXBwZXJfYXJlYSAoYXJlYSwgMCwgY291bnQgLSAxKVxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbnN1cmVcbiAgICAgIGxlbmd0aF9hbmRfY29udGVudDogZWxrc19jaGVja2luZyBpbXBsaWVzIEN1cnJlbnQgfiAob2xkIGFzX3VwcGVyKVxuICAgIGVuZFxuXG4gIGxpbmVhcl9yZXByZXNlbnRhdGlvbjogTElORUFSIFtDSEFSQUNURVJfMzJdXG4gICAgICAtLSBSZXByZXNlbnRhdGlvbiBhcyBhIGxpbmVhciBzdHJ1Y3R1cmVcbiAgICBsb2NhbFxuICAgICAgdGVtcDogQVJSQVlFRF9MSVNUIFtDSEFSQUNURVJfMzJdXG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIGNyZWF0ZSB0ZW1wLm1ha2UgKGNhcGFjaXR5KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IDFcbiAgICAgIHVudGlsXG4gICAgICAgIGkgPiBjb3VudFxuICAgICAgbG9vcFxuICAgICAgICB0ZW1wLmV4dGVuZCAoaXRlbSAoaSkpXG4gICAgICAgIGkgOj0gaSArIDFcbiAgICAgIGVuZFxuICAgICAgUmVzdWx0IDo9IHRlbXBcbiAgICBlbmRcblxuICBmcm96ZW4gdG9fYzogQU5ZXG4gICAgICAtLSBBIHJlZmVyZW5jZSB0byBhIEMgZm9ybSBvZiBjdXJyZW50IHN0cmluZy5cbiAgICAgIC0tIFVzZWZ1bCBvbmx5IGZvciBpbnRlcmZhY2luZyB3aXRoIEMgc29mdHdhcmUuXG4gICAgcmVxdWlyZVxuICAgICAgbm90X2lzX2RvdG5ldDogbm90IHtQTEFURk9STX0uaXNfZG90bmV0XG4gICAgbG9jYWxcbiAgICAgIGxfYXJlYTogbGlrZSBhcmVhXG4gICAgZG9cbiAgICAgIGxfYXJlYSA6PSBhcmVhXG4gICAgICBsX2FyZWEucHV0ICgnJVUnLCBjb3VudClcbiAgICAgIFJlc3VsdCA6PSBsX2FyZWFcbiAgICBlbmRcblxuICBtaXJyb3JlZDogbGlrZSBDdXJyZW50XG4gICAgICAtLSBNaXJyb3IgaW1hZ2Ugb2Ygc3RyaW5nO1xuICAgICAgLS0gUmVzdWx0IGZvciBcIkhlbGxvIHdvcmxkXCIgaXMgXCJkbHJvdyBvbGxlSFwiLlxuICAgIGRvXG4gICAgICBSZXN1bHQgOj0gdHdpblxuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgUmVzdWx0Lm1pcnJvclxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgbWlycm9yXG4gICAgICAtLSBSZXZlcnNlIHRoZSBvcmRlciBvZiBjaGFyYWN0ZXJzLlxuICAgICAgLS0gXCJIZWxsbyB3b3JsZFwiIC0+IFwiZGxyb3cgb2xsZUhcIi5cbiAgICBsb2NhbFxuICAgICAgYTogbGlrZSBhcmVhXG4gICAgICBjOiBDSEFSQUNURVJfMzJcbiAgICAgIGksIGo6IElOVEVHRVJcbiAgICBkb1xuICAgICAgaWYgY291bnQgPiAwIHRoZW5cbiAgICAgICAgZnJvbVxuICAgICAgICAgIGkgOj0gY291bnQgLSAxXG4gICAgICAgICAgYSA6PSBhcmVhXG4gICAgICAgIHVudGlsXG4gICAgICAgICAgaSA8PSBqXG4gICAgICAgIGxvb3BcbiAgICAgICAgICBjIDo9IGEuaXRlbSAoaSlcbiAgICAgICAgICBhLnB1dCAoYS5pdGVtIChqKSwgaSlcbiAgICAgICAgICBhLnB1dCAoYywgailcbiAgICAgICAgICBpIDo9IGkgLSAxXG4gICAgICAgICAgaiA6PSBqICsgMVxuICAgICAgICBlbmRcbiAgICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICAgIGVuZFxuICAgIGVuc3VyZVxuICAgICAgc2FtZV9jb3VudDogY291bnQgPSBvbGQgY291bnRcbiAgICAgIC0tIHJldmVyc2VkOiBGb3IgZXZlcnkgYGknIGluIDEuLmBjb3VudCcsIGBpdGVtJyAoYGknKSA9IG9sZCBgaXRlbScgKGBjb3VudCcrMS1gaScpXG4gICAgZW5kXG5cbmZlYXR1cmUgLS0gRHVwbGljYXRpb25cblxuICBzdWJzdHJpbmcgKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXg6IElOVEVHRVIpOiBsaWtlIEN1cnJlbnRcbiAgICAgIC0tIENvcHkgb2Ygc3Vic3RyaW5nIGNvbnRhaW5pbmcgYWxsIGNoYXJhY3RlcnMgYXQgaW5kaWNlc1xuICAgICAgLS0gYmV0d2VlbiBgc3RhcnRfaW5kZXgnIGFuZCBgZW5kX2luZGV4J1xuICAgIGRvXG4gICAgICBpZiAoMSA8PSBzdGFydF9pbmRleCkgYW5kIChzdGFydF9pbmRleCA8PSBlbmRfaW5kZXgpIGFuZCAoZW5kX2luZGV4IDw9IGNvdW50KSB0aGVuXG4gICAgICAgIFJlc3VsdCA6PSBuZXdfc3RyaW5nIChlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5hcmVhLmNvcHlfZGF0YSAoYXJlYSwgc3RhcnRfaW5kZXggLSAxLCAwLCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpXG4gICAgICAgIFJlc3VsdC5zZXRfY291bnQgKGVuZF9pbmRleCAtIHN0YXJ0X2luZGV4ICsgMSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmVzdWx0IDo9IG5ld19zdHJpbmcgKDApXG4gICAgICBlbmRcbiAgICBlbmRcblxuICBtdWx0aXBseSAobjogSU5URUdFUilcbiAgICAgIC0tIER1cGxpY2F0ZSBhIHN0cmluZyB3aXRoaW4gaXRzZWxmXG4gICAgICAtLSAoXCJoZWxsb1wiKS5tdWx0aXBseSgzKSA9PiBcImhlbGxvaGVsbG9oZWxsb1wiXG4gICAgcmVxdWlyZVxuICAgICAgbWVhbmluZ2Z1bF9tdWx0aXBsaWVyOiBuID49IDFcbiAgICBsb2NhbFxuICAgICAgczogbGlrZSBDdXJyZW50XG4gICAgICBpOiBJTlRFR0VSXG4gICAgZG9cbiAgICAgIHMgOj0gdHdpblxuICAgICAgZ3JvdyAobiAqIGNvdW50KVxuICAgICAgZnJvbVxuICAgICAgICBpIDo9IG5cbiAgICAgIHVudGlsXG4gICAgICAgIGkgPSAxXG4gICAgICBsb29wXG4gICAgICAgIGFwcGVuZCAocylcbiAgICAgICAgaSA6PSBpIC0gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbmZlYXR1cmUge1NUUklOR19IQU5ETEVSfSAtLSBJbXBsZW1lbnRhdGlvblxuXG4gIGZyb3plbiBzZXRfY291bnQgKG51bWJlcjogSU5URUdFUilcbiAgICAgIC0tIFNldCBgY291bnQnIHRvIGBudW1iZXInIG9mIGNoYXJhY3RlcnMuXG4gICAgZG9cbiAgICAgIGNvdW50IDo9IG51bWJlclxuICAgICAgaW50ZXJuYWxfaGFzaF9jb2RlIDo9IDBcbiAgICBlbmRcblxuZmVhdHVyZSB7Tk9ORX0gLS0gSW1wbGVtZW50YXRpb25cblxuICBuZXdfc3RyaW5nIChuOiBJTlRFR0VSKTogbGlrZSBDdXJyZW50XG4gICAgICAtLSBOZXcgaW5zdGFuY2Ugb2YgY3VycmVudCB3aXRoIHNwYWNlIGZvciBhdCBsZWFzdCBgbicgY2hhcmFjdGVycy5cbiAgICBkb1xuICAgICAgY3JlYXRlIFJlc3VsdC5tYWtlIChuKVxuICAgIGVuZFxuXG5mZWF0dXJlIC0tIFRyYW5zZm9ybWF0aW9uXG5cbiAgY29ycmVjdF9taXNtYXRjaFxuICAgICAgLS0gQXR0ZW1wdCB0byBjb3JyZWN0IG9iamVjdCBtaXNtYXRjaCBkdXJpbmcgcmV0cmlldmUgdXNpbmcgYG1pc21hdGNoX2luZm9ybWF0aW9uJy5cbiAgICBkb1xuICAgICAgICAtLSBOb3RoaW5nIHRvIGJlIGRvbmUgYmVjYXVzZSB3ZSBvbmx5IGFkZGVkIGBpbnRlcm5hbF9oYXNoX2NvZGUnIHRoYXQgd2lsbFxuICAgICAgICAtLSBiZSByZWNvbXB1dGVkIG5leHQgdGltZSB3ZSBxdWVyeSBgaGFzaF9jb2RlJy5cblxuICAgICAgICAtLSBJbiAuTkVULCB3ZSBoYXZlIGEgbWlzbWF0Y2ggdGhhdCBpcyB0cmlnZ2VyZWQgZHVlIHRvIHRoZSBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAgICAtLSBTUEVDSUFMIFtDSEFSQUNURVJfMzJdIGFzIGEgLk5FVCBhcnJheSBvZiBVSW50MTYuXG4gICAgICBpZiBhcmVhID0gVm9pZCBhbmQgdGhlbiBhdHRhY2hlZCB7bGlrZSBhcmVhfSBtaXNtYXRjaF9pbmZvcm1hdGlvbi5pdGVtIChcImFyZWFcIikgYXMgbF9hcmVhIHRoZW5cbiAgICAgICAgYXJlYSA6PSBsX2FyZWFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG5pbnZhcmlhbnRcbiAgZXh0ZW5kaWJsZTogZXh0ZW5kaWJsZVxuICBjb21wYXJlX2NoYXJhY3Rlcjogbm90IG9iamVjdF9jb21wYXJpc29uXG5cbm5vdGVcbiAgY29weXJpZ2h0OiBcIkNvcHlyaWdodCAoYykgMTk4NC0yMDE0LCBFaWZmZWwgU29mdHdhcmUgYW5kIG90aGVyc1wiXG4gIGxpY2Vuc2U6ICAgXCJFaWZmZWwgRm9ydW0gTGljZW5zZSB2MiAoc2VlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbS9saWNlbnNpbmcvZm9ydW0udHh0KVwiXG4gIHNvdXJjZTogXCJbXG4gICAgICBFaWZmZWwgU29mdHdhcmVcbiAgICAgIDU5NDkgSG9sbGlzdGVyIEF2ZS4sIEdvbGV0YSwgQ0EgOTMxMTcgVVNBXG4gICAgICBUZWxlcGhvbmUgODA1LTY4NS0xMDA2LCBGYXggODA1LTY4NS02ODY5XG4gICAgICBXZWJzaXRlIGh0dHA6Ly93d3cuZWlmZmVsLmNvbVxuICAgICAgQ3VzdG9tZXIgc3VwcG9ydCBodHRwOi8vc3VwcG9ydC5laWZmZWwuY29tXG4gICAgXVwiXG5cbmVuZFxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9